/** this is an amalgamated file. do not edit.
 */

/* Handy pixel/color and texture/image classes. zlib/libpng licensed.
 * - rlyeh ~~ listening to Twilightning - Painting the blue eyes

 *   Hue - Think of a color wheel. Around 0 and 255 are reds 85 are greens, 170 are blues. Use anything in between 0-255. Values above and below will be modulus 255.
 *   Saturation - 0 is completely denatured (grayscale). 255 is fully saturated (full color).
 *   Lightness - 0 is completely dark (black). 255 is completely light (white). 127 is average lightness.
 *   alpha - Opacity/Transparency value. 0 is fully transparent. 255 is fully opaque. 127 is 50% transparent.

 *   enum hue
 *   {
 *       hred1 = 0,
 *       hgreen = 85,
 *       hblue = 170,
 *       hred2 = 255,

 *       hpurple =  ( ( hblue + hred2 ) / 2 ) % 255,
 *       hcyan =  ( ( hgreen + hblue ) / 2 ) % 255,
 *       hyellow = ( ( hred1 + hgreen ) / 2 ) % 255
 *   };

 *   unsigned char make_hue( float reds, float greens, float blues )
 *   {
 *       return (unsigned char)( int( reds * 255 + greens * 85 + blues * 170 ) % 255 );
 *   }

 * valid color components in range [0..1]
 * components can handle higher values (useful for color algebra), but their values will be clamped when displayed

 * image = array of pixels[] in RGBA or HSLA format
 * texture = strict subset of an image { squared, rgba only }
 * so, image > texture

 * image @todo
 * vg {
 * image.glow( 1px, pixel::black )
 * image.glow( 2px, pixel::red )
 * image.mask(white);
 * image.mask(white).glow( 2x, pixel::blue ).replace(white,transp) --> L4D2 style
 * image.aabb(); -> return aabb for this frame
 * }
 * composition {
 * image.append( img[], align09 = 6 )
 * image.crop( columns/rows to remove, align09 = 2, method = fast/carving )
 * image.shrink( w, h )
 * }
 * image.noisex()
 * image.perlin()
 * image.mipmap()
 * image.upload()/unload()
 * image.download()/capture()
 * image.rotate(deg, bgcolor/transparent?)
 * image.premultiply()/unpremultiply()
 * image.gamma(1.22)
 * image.atlas( image[] )/combine(other)
 * image.blur()/sharpen()
 * image.scale(marquee_scale,content_scale,scale_method)
 * @todo: also image1 * / *= / + / += image2

 * pixel @Todo:
 *  replace float with float8 (microfloat 0.4.4 ; good idea?)
 *  to_rg() // computer vision: r = r/r+g+b, g = g/r+g+b
 *  munsell 5 hues: red, yellow, green, blue, purple
 *  hsl 6 hues: red, yellow, green, cyan, blue, purple
 *  rgy
 *  http://en.wikipedia.org/wiki/HSL_color_space#Disadvantages
 *  https://github.com/aras-p/miniexr/blob/master/miniexr.cpp
 *  http://cgit.haiku-os.org/haiku/plain/src/add-ons/translators/exr/openexr/half/half.h
 *  ftp://www.fox-toolkit.org/pub/fasthalffloatconversion.pdf
 *  std::string str() const { return std::string(); } //#ffffffff

*/

#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <algorithm>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <vector>

#include "spot.hpp"

#define NANOSVG_ALL_COLOR_KEYWORDS  // Include full list of color keywords.
#define NANOSVG_IMPLEMENTATION      // Expands implementation
#define NANOSVGRAST_IMPLEMENTATION  // Expands implementation


//#line 1 "nanosvg.h"
#ifndef NANOSVG_H
#define NANOSVG_H

#ifdef __cplusplus
extern "C" {
#endif

// NanoSVG is a simple stupid single-header-file SVG parse. The output of the parser is a list of cubic bezier shapes.
//
// The library suits well for anything from rendering scalable icons in your editor application to prototyping a game.
//
// NanoSVG supports a wide range of SVG features, but something may be missing, feel free to create a pull request!
//
// The shapes in the SVG images are transformed by the viewBox and converted to specified units.
// That is, you should get the same looking data as your designed in your favorite app.
//
// NanoSVG can return the paths in few different units. For example if you want to render an image, you may choose
// to get the paths in pixels, or if you are feeding the data into a CNC-cutter, you may want to use millimeters.
//
// The units passed to NanoVG should be one of: 'px', 'pt', 'pc' 'mm', 'cm', or 'in'.
// DPI (dots-per-inch) controls how the unit conversion is done.
//
// If you don't know or care about the units stuff, "px" and 96 should get you going.

/* Example Usage:
	// Load
	SNVGImage* image;
	image = nsvgParseFromFile("test.svg", "px", 96);
	printf("size: %f x %f\n", image->width, image->height);
	// Use...
	for (shape = image->shapes; shape != NULL; shape = shape->next) {
		for (path = shape->paths; path != NULL; path = path->next) {
			for (i = 0; i < path->npts-1; i += 3) {
				float* p = &path->pts[i*2];
				drawCubicBez(p[0],p[1], p[2],p[3], p[4],p[5], p[6],p[7]);
			}
		}
	}
	// Delete
	nsvgDelete(image);
*/

enum NSVGpaintType {
	NSVG_PAINT_NONE = 0,
	NSVG_PAINT_COLOR = 1,
	NSVG_PAINT_LINEAR_GRADIENT = 2,
	NSVG_PAINT_RADIAL_GRADIENT = 3,
};

enum NSVGspreadType {
	NSVG_SPREAD_PAD = 0,
	NSVG_SPREAD_REFLECT = 1,
	NSVG_SPREAD_REPEAT = 2,
};

enum NSVGlineJoin {
	NSVG_JOIN_MITER = 0,
	NSVG_JOIN_ROUND = 1,
	NSVG_JOIN_BEVEL = 2,
};

enum NSVGlineCap {
	NSVG_CAP_BUTT = 0,
	NSVG_CAP_ROUND = 1,
	NSVG_CAP_SQUARE = 2,
};

typedef struct NSVGgradientStop {
	unsigned int color;
	float offset;
} NSVGgradientStop;

typedef struct NSVGgradient {
	float xform[6];
	char spread;
	float fx, fy;
	int nstops;
	NSVGgradientStop stops[1];
} NSVGgradient;

typedef struct NSVGpaint {
	char type;
	union {
		unsigned int color;
		NSVGgradient* gradient;
	};
} NSVGpaint;

typedef struct NSVGpath
{
	float* pts;					// Cubic bezier points: x0,y0, [cpx1,cpx1,cpx2,cpy2,x1,y1], ...
	int npts;					// Total number of bezier points.
	char closed;				// Flag indicating if shapes should be treated as closed.
	float bounds[4];			// Tight bounding box of the shape [minx,miny,maxx,maxy].
	struct NSVGpath* next;		// Pointer to next path, or NULL if last element.
} NSVGpath;

typedef struct NSVGshape
{
	char id[64];				// Optional 'id' attr of the shape or its group
	NSVGpaint fill;				// Fill paint
	NSVGpaint stroke;			// Stroke paint
	float opacity;				// Opacity of the shape.
	float strokeWidth;			// Stroke width (scaled).
	char strokeLineJoin;		// Stroke join type.
	char strokeLineCap;			// Stroke cap type.
	float bounds[4];			// Tight bounding box of the shape [minx,miny,maxx,maxy].
	NSVGpath* paths;			// Linked list of paths in the image.
	struct NSVGshape* next;		// Pointer to next shape, or NULL if last element.
} NSVGshape;

typedef struct NSVGimage
{
	float width;				// Width of the image.
	float height;				// Height of the image.
	NSVGshape* shapes;			// Linked list of shapes in the image.
} NSVGimage;

// Parses SVG file from a file, returns SVG image as paths.
NSVGimage* nsvgParseFromFile(const char* filename, const char* units, float dpi);

// Parses SVG file from a null terminated string, returns SVG image as paths.
NSVGimage* nsvgParse(char* input, const char* units, float dpi);

// Deletes list of paths.
void nsvgDelete(NSVGimage* image);

#ifdef __cplusplus
};
#endif

#endif // NANOSVG_H

#ifdef NANOSVG_IMPLEMENTATION

#include <string.h>
#include <stdlib.h>
#include <math.h>

#define NSVG_PI (3.14159265358979323846264338327f)
#define NSVG_KAPPA90 (0.5522847493f)	// Lenght proportional to radius of a cubic bezier handle for 90deg arcs.

#define NSVG_ALIGN_MIN 0
#define NSVG_ALIGN_MID 1
#define NSVG_ALIGN_MAX 2
#define NSVG_ALIGN_NONE 0
#define NSVG_ALIGN_MEET 1
#define NSVG_ALIGN_SLICE 2

#define NSVG_NOTUSED(v) do { (void)(1 ? (void)0 : ( (void)(v) ) ); } while(0)
#define NSVG_RGB(r, g, b) (((unsigned int)r) | ((unsigned int)g << 8) | ((unsigned int)b << 16))

#ifdef _MSC_VER
	#pragma warning (disable: 4996) // Switch off security warnings
	#pragma warning (disable: 4100) // Switch off unreferenced formal parameter warnings
	#ifdef __cplusplus
	#define NSVG_INLINE inline
	#else
	#define NSVG_INLINE
	#endif
#else
	#define NSVG_INLINE inline
#endif

static int nsvg__isspace(char c)
{
	return strchr(" \t\n\v\f\r", c) != 0;
}

static int nsvg__isdigit(char c)
{
	return strchr("0123456789", c) != 0;
}

static int nsvg__isnum(char c)
{
	return strchr("0123456789+-.eE", c) != 0;
}

static NSVG_INLINE float nsvg__minf(float a, float b) { return a < b ? a : b; }
static NSVG_INLINE float nsvg__maxf(float a, float b) { return a > b ? a : b; }

// Simple XML parser

#define NSVG_XML_TAG 1
#define NSVG_XML_CONTENT 2
#define NSVG_XML_MAX_ATTRIBS 256

static void nsvg__parseContent(char* s,
							   void (*contentCb)(void* ud, const char* s),
							   void* ud)
{
	// Trim start white spaces
	while (*s && nsvg__isspace(*s)) s++;
	if (!*s) return;

	if (contentCb)
		(*contentCb)(ud, s);
}

static void nsvg__parseElement(char* s,
							   void (*startelCb)(void* ud, const char* el, const char** attr),
							   void (*endelCb)(void* ud, const char* el),
							   void* ud)
{
	const char* attr[NSVG_XML_MAX_ATTRIBS];
	int nattr = 0;
	char* name;
	int start = 0;
	int end = 0;
	char quote;

	// Skip white space after the '<'
	while (*s && nsvg__isspace(*s)) s++;

	// Check if the tag is end tag
	if (*s == '/') {
		s++;
		end = 1;
	} else {
		start = 1;
	}

	// Skip comments, data and preprocessor stuff.
	if (!*s || *s == '?' || *s == '!')
		return;

	// Get tag name
	name = s;
	while (*s && !nsvg__isspace(*s)) s++;
	if (*s) { *s++ = '\0'; }

	// Get attribs
	while (!end && *s && nattr < NSVG_XML_MAX_ATTRIBS-3) {
		// Skip white space before the attrib name
		while (*s && nsvg__isspace(*s)) s++;
		if (!*s) break;
		if (*s == '/') {
			end = 1;
			break;
		}
		attr[nattr++] = s;
		// Find end of the attrib name.
		while (*s && !nsvg__isspace(*s) && *s != '=') s++;
		if (*s) { *s++ = '\0'; }
		// Skip until the beginning of the value.
		while (*s && *s != '\"' && *s != '\'') s++;
		if (!*s) break;
		quote = *s;
		s++;
		// Store value and find the end of it.
		attr[nattr++] = s;
		while (*s && *s != quote) s++;
		if (*s) { *s++ = '\0'; }
	}

	// List terminator
	attr[nattr++] = 0;
	attr[nattr++] = 0;

	// Call callbacks.
	if (start && startelCb)
		(*startelCb)(ud, name, attr);
	if (end && endelCb)
		(*endelCb)(ud, name);
}

int nsvg__parseXML(char* input,
				   void (*startelCb)(void* ud, const char* el, const char** attr),
				   void (*endelCb)(void* ud, const char* el),
				   void (*contentCb)(void* ud, const char* s),
				   void* ud)
{
	char* s = input;
	char* mark = s;
	int state = NSVG_XML_CONTENT;
	while (*s) {
		if (*s == '<' && state == NSVG_XML_CONTENT) {
			// Start of a tag
			*s++ = '\0';
			nsvg__parseContent(mark, contentCb, ud);
			mark = s;
			state = NSVG_XML_TAG;
		} else if (*s == '>' && state == NSVG_XML_TAG) {
			// Start of a content or new tag.
			*s++ = '\0';
			nsvg__parseElement(mark, startelCb, endelCb, ud);
			mark = s;
			state = NSVG_XML_CONTENT;
		} else {
			s++;
		}
	}

	return 1;
}

/* Simple SVG parser. */

#define NSVG_MAX_ATTR 128

#define NSVG_USER_SPACE 0
#define NSVG_OBJECT_SPACE 1

typedef struct NSVGlinearData {
	float x1, y1, x2, y2;
} NSVGlinearData;

typedef struct NSVGradialData {
	float cx, cy, r, fx, fy;
} NSVGradialData;

typedef struct NSVGgradientData
{
	char id[64];
	char ref[64];
	char type;
	union {
		NSVGlinearData linear;
		NSVGradialData radial;
	};
	char spread;
	char units;
	float xform[6];
	int nstops;
	NSVGgradientStop* stops;
	struct NSVGgradientData* next;
} NSVGgradientData;

typedef struct NSVGattrib
{
	char id[64];
	float xform[6];
	unsigned int fillColor;
	unsigned int strokeColor;
	float opacity;
	float fillOpacity;
	float strokeOpacity;
	char fillGradient[64];
	char strokeGradient[64];
	float strokeWidth;
	char strokeLineJoin;
	char strokeLineCap;
	float fontSize;
	unsigned int stopColor;
	float stopOpacity;
	float stopOffset;
	char hasFill;
	char hasStroke;
	char visible;
} NSVGattrib;

typedef struct NSVGparser
{
	NSVGattrib attr[NSVG_MAX_ATTR];
	int attrHead;
	float* pts;
	int npts;
	int cpts;
	NSVGpath* plist;
	NSVGimage* image;
	NSVGgradientData* gradients;
	float viewMinx, viewMiny, viewWidth, viewHeight;
	int alignX, alignY, alignType;
	float dpi;
	char pathFlag;
	char defsFlag;
} NSVGparser;

static void nsvg__xformIdentity(float* t)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetTranslation(float* t, float tx, float ty)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = tx; t[5] = ty;
}

static void nsvg__xformSetScale(float* t, float sx, float sy)
{
	t[0] = sx; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = sy;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetSkewX(float* t, float a)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = tanf(a); t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetSkewY(float* t, float a)
{
	t[0] = 1.0f; t[1] = tanf(a);
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetRotation(float* t, float a)
{
	float cs = cosf(a), sn = sinf(a);
	t[0] = cs; t[1] = sn;
	t[2] = -sn; t[3] = cs;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformMultiply(float* t, float* s)
{
	float t0 = t[0] * s[0] + t[1] * s[2];
	float t2 = t[2] * s[0] + t[3] * s[2];
	float t4 = t[4] * s[0] + t[5] * s[2] + s[4];
	t[1] = t[0] * s[1] + t[1] * s[3];
	t[3] = t[2] * s[1] + t[3] * s[3];
	t[5] = t[4] * s[1] + t[5] * s[3] + s[5];
	t[0] = t0;
	t[2] = t2;
	t[4] = t4;
}

static void nsvg__xformInverse(float* inv, float* t)
{
	double det = (double)t[0] * t[3] - (double)t[2] * t[1];
	double invdet = 1.0 / det;
	if (det > -1e-6 && det < -1e-6) {
		nsvg__xformIdentity(t);
		return;
	}
	inv[0] = (float)(t[3] * invdet);
	inv[2] = (float)(-t[2] * invdet);
	inv[4] = (float)(((double)t[2] * t[5] - (double)t[3] * t[4]) * invdet);
	inv[1] = (float)(-t[1] * invdet);
	inv[3] = (float)(t[0] * invdet);
	inv[5] = (float)(((double)t[1] * t[4] - (double)t[0] * t[5]) * invdet);
}

static void nsvg__xformPremultiply(float* t, float* s)
{
	float s2[6];
	memcpy(s2, s, sizeof(float)*6);
	nsvg__xformMultiply(s2, t);
	memcpy(t, s2, sizeof(float)*6);
}

static void nsvg__xformPoint(float* dx, float* dy, float x, float y, float* t)
{
	*dx = x*t[0] + y*t[2] + t[4];
	*dy = x*t[1] + y*t[3] + t[5];
}

static void nsvg__xformVec(float* dx, float* dy, float x, float y, float* t)
{
	*dx = x*t[0] + y*t[2];
	*dy = x*t[1] + y*t[3];
}

#define NSVG_EPSILON (1e-12)

static int nsvg__ptInBounds(float* pt, float* bounds)
{
	return pt[0] >= bounds[0] && pt[0] <= bounds[2] && pt[1] >= bounds[1] && pt[1] <= bounds[3];
}

static double nsvg__evalBezier(double t, double p0, double p1, double p2, double p3)
{
	double it = 1.0-t;
	return it*it*it*p0 + 3.0*it*it*t*p1 + 3.0*it*t*t*p2 + t*t*t*p3;
}

static void nsvg__curveBounds(float* bounds, float* curve)
{
	int i, j, count;
	double roots[2], a, b, c, b2ac, t, v;
	float* v0 = &curve[0];
	float* v1 = &curve[2];
	float* v2 = &curve[4];
	float* v3 = &curve[6];

	// Start the bounding box by end points
	bounds[0] = nsvg__minf(v0[0], v3[0]);
	bounds[1] = nsvg__minf(v0[1], v3[1]);
	bounds[2] = nsvg__maxf(v0[0], v3[0]);
	bounds[3] = nsvg__maxf(v0[1], v3[1]);

	// Bezier curve fits inside the convex hull of it's control points.
	// If control points are inside the bounds, we're done.
	if (nsvg__ptInBounds(v1, bounds) && nsvg__ptInBounds(v2, bounds))
		return;

	// Add bezier curve inflection points in X and Y.
	for (i = 0; i < 2; i++) {
		a = -3.0 * v0[i] + 9.0 * v1[i] - 9.0 * v2[i] + 3.0 * v3[i];
		b = 6.0 * v0[i] - 12.0 * v1[i] + 6.0 * v2[i];
		c = 3.0 * v1[i] - 3.0 * v0[i];
		count = 0;
		if (fabs(a) < NSVG_EPSILON) {
			if (fabs(b) > NSVG_EPSILON) {
				t = -c / b;
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
			}
		} else {
			b2ac = b*b - 4.0*c*a;
			if (b2ac > NSVG_EPSILON) {
				t = (-b + sqrt(b2ac)) / (2.0 * a);
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
				t = (-b - sqrt(b2ac)) / (2.0 * a);
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
			}
		}
		for (j = 0; j < count; j++) {
			v = nsvg__evalBezier(roots[j], v0[i], v1[i], v2[i], v3[i]);
			bounds[0+i] = nsvg__minf(bounds[0+i], (float)v);
			bounds[2+i] = nsvg__maxf(bounds[2+i], (float)v);
		}
	}
}

static NSVGparser* nsvg__createParser()
{
	NSVGparser* p;
	p = (NSVGparser*)malloc(sizeof(NSVGparser));
	if (p == NULL) goto error;
	memset(p, 0, sizeof(NSVGparser));

	p->image = (NSVGimage*)malloc(sizeof(NSVGimage));
	if (p->image == NULL) goto error;
	memset(p->image, 0, sizeof(NSVGimage));

	// Init style
	nsvg__xformIdentity(p->attr[0].xform);
	memset(p->attr[0].id, 0, sizeof p->attr[0].id);
	p->attr[0].fillColor = NSVG_RGB(0,0,0);
	p->attr[0].strokeColor = NSVG_RGB(0,0,0);
	p->attr[0].opacity = 1;
	p->attr[0].fillOpacity = 1;
	p->attr[0].strokeOpacity = 1;
	p->attr[0].stopOpacity = 1;
	p->attr[0].strokeWidth = 1;
	p->attr[0].strokeLineJoin = NSVG_JOIN_MITER;
	p->attr[0].strokeLineCap = NSVG_CAP_BUTT;
	p->attr[0].hasFill = 1;
	p->attr[0].hasStroke = 0;
	p->attr[0].visible = 1;

	return p;

error:
	if (p) {
		if (p->image) free(p->image);
		free(p);
	}
	return NULL;
}

static void nsvg__deletePaths(NSVGpath* path)
{
	while (path) {
		NSVGpath *next = path->next;
		if (path->pts != NULL)
			free(path->pts);
		free(path);
		path = next;
	}
}

static void nsvg__deletePaint(NSVGpaint* paint)
{
	if (paint->type == NSVG_PAINT_LINEAR_GRADIENT || paint->type == NSVG_PAINT_LINEAR_GRADIENT)
		free(paint->gradient);
}

static void nsvg__deleteGradientData(NSVGgradientData* grad)
{
	NSVGgradientData* next;
	while (grad != NULL) {
		next = grad->next;
		free(grad->stops);
		free(grad);
		grad = next;
	}
}

static void nsvg__deleteParser(NSVGparser* p)
{
	if (p != NULL) {
		nsvg__deletePaths(p->plist);
		nsvg__deleteGradientData(p->gradients);
		nsvgDelete(p->image);
		free(p->pts);
		free(p);
	}
}

static void nsvg__resetPath(NSVGparser* p)
{
	p->npts = 0;
}

static void nsvg__addPoint(NSVGparser* p, float x, float y)
{
	if (p->npts+1 > p->cpts) {
		p->cpts = p->cpts ? p->cpts*2 : 8;
		p->pts = (float*)realloc(p->pts, p->cpts*2*sizeof(float));
		if (!p->pts) return;
	}
	p->pts[p->npts*2+0] = x;
	p->pts[p->npts*2+1] = y;
	p->npts++;
}

static void nsvg__moveTo(NSVGparser* p, float x, float y)
{
	if (p->npts > 0) {
		p->pts[(p->npts-1)*2+0] = x;
		p->pts[(p->npts-1)*2+1] = y;
	} else {
		nsvg__addPoint(p, x, y);
	}
}

static void nsvg__lineTo(NSVGparser* p, float x, float y)
{
	float px,py, dx,dy;
	if (p->npts > 0) {
		px = p->pts[(p->npts-1)*2+0];
		py = p->pts[(p->npts-1)*2+1];
		dx = x - px;
		dy = y - py;
		nsvg__addPoint(p, px + dx/3.0f, py + dy/3.0f);
		nsvg__addPoint(p, x - dx/3.0f, y - dy/3.0f);
		nsvg__addPoint(p, x, y);
	}
}

static void nsvg__cubicBezTo(NSVGparser* p, float cpx1, float cpy1, float cpx2, float cpy2, float x, float y)
{
	nsvg__addPoint(p, cpx1, cpy1);
	nsvg__addPoint(p, cpx2, cpy2);
	nsvg__addPoint(p, x, y);
}

static NSVGattrib* nsvg__getAttr(NSVGparser* p)
{
	return &p->attr[p->attrHead];
}

static void nsvg__pushAttr(NSVGparser* p)
{
	if (p->attrHead < NSVG_MAX_ATTR-1) {
		p->attrHead++;
		memcpy(&p->attr[p->attrHead], &p->attr[p->attrHead-1], sizeof(NSVGattrib));
	}
}

static void nsvg__popAttr(NSVGparser* p)
{
	if (p->attrHead > 0)
		p->attrHead--;
}

static NSVGgradientData* nsvg__findGradientData(NSVGparser* p, const char* id)
{
	NSVGgradientData* grad = p->gradients;
	while (grad) {
		if (strcmp(grad->id, id) == 0)
			return grad;
		grad = grad->next;
	}
	return NULL;
}

static NSVGgradient* nsvg__createGradient(NSVGparser* p, const char* id, const float* bounds, char* paintType)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	NSVGgradientData* data = NULL;
	NSVGgradientData* ref = NULL;
	NSVGgradientStop* stops = NULL;
	NSVGgradient* grad;
	float dx, dy, d;
	int nstops = 0;
	NSVG_NOTUSED(bounds);

	data = nsvg__findGradientData(p, id);
	if (data == NULL) return NULL;

	// TODO: use ref to fill in all unset values too.
	ref = data;
	while (ref != NULL) {
		if (ref->stops != NULL) {
			stops = ref->stops;
			nstops = ref->nstops;
			break;
		}
		ref = nsvg__findGradientData(p, ref->ref);
	}
	if (stops == NULL) return NULL;

	grad = (NSVGgradient*)malloc(sizeof(NSVGgradient) + sizeof(NSVGgradientStop)*(nstops-1));
	if (grad == NULL) return NULL;

	// TODO: handle data->units == NSVG_OBJECT_SPACE.

	if (data->type == NSVG_PAINT_LINEAR_GRADIENT) {
		// Calculate transform aligned to the line
		dx = data->linear.x2 - data->linear.x1;
		dy = data->linear.y2 - data->linear.y1;
		d = sqrtf(dx*dx + dy*dy);
		grad->xform[0] = dy; grad->xform[1] = -dx;
		grad->xform[2] = dx; grad->xform[3] = dy;
		grad->xform[4] = data->linear.x1; grad->xform[5] = data->linear.y1;
	} else {
		// Calculate transform aligned to the circle
		grad->xform[0] = data->radial.r; grad->xform[1] = 0;
		grad->xform[2] = 0; grad->xform[3] = data->radial.r;
		grad->xform[4] = data->radial.cx; grad->xform[5] = data->radial.cy;
		grad->fx = data->radial.fx / data->radial.r;
		grad->fy = data->radial.fy / data->radial.r;
	}

	nsvg__xformMultiply(grad->xform, attr->xform);
	nsvg__xformMultiply(grad->xform, data->xform);

	grad->spread = data->spread;
	memcpy(grad->stops, stops, nstops*sizeof(NSVGgradientStop));
	grad->nstops = nstops;

	*paintType = data->type;

	return grad;
}

static float nsvg__getAverageScale(float* t)
{
	float sx = sqrtf(t[0]*t[0] + t[2]*t[2]);
	float sy = sqrtf(t[1]*t[1] + t[3]*t[3]);
	return (sx + sy) * 0.5f;
}

static void nsvg__addShape(NSVGparser* p)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	float scale = 1.0f;
	NSVGshape *shape, *cur, *prev;
	NSVGpath* path;

	if (p->plist == NULL)
		return;

	shape = (NSVGshape*)malloc(sizeof(NSVGshape));
	if (shape == NULL) goto error;
	memset(shape, 0, sizeof(NSVGshape));

	memcpy(shape->id, attr->id, sizeof shape->id);
	scale = nsvg__getAverageScale(attr->xform);
	shape->strokeWidth = attr->strokeWidth * scale;
	shape->strokeLineJoin = attr->strokeLineJoin;
	shape->strokeLineCap = attr->strokeLineCap;
	shape->opacity = attr->opacity;

	shape->paths = p->plist;
	p->plist = NULL;

	// Calculate shape bounds
	shape->bounds[0] = shape->paths->bounds[0];
	shape->bounds[1] = shape->paths->bounds[1];
	shape->bounds[2] = shape->paths->bounds[2];
	shape->bounds[3] = shape->paths->bounds[3];
	for (path = shape->paths->next; path != NULL; path = path->next) {
		shape->bounds[0] = nsvg__minf(shape->bounds[0], path->bounds[0]);
		shape->bounds[1] = nsvg__minf(shape->bounds[1], path->bounds[1]);
		shape->bounds[2] = nsvg__maxf(shape->bounds[2], path->bounds[2]);
		shape->bounds[3] = nsvg__maxf(shape->bounds[3], path->bounds[3]);
	}

	// Set fill
	if (attr->hasFill == 0) {
		shape->fill.type = NSVG_PAINT_NONE;
	} else if (attr->hasFill == 1) {
		shape->fill.type = NSVG_PAINT_COLOR;
		shape->fill.color = attr->fillColor;
		shape->fill.color |= (unsigned int)(attr->fillOpacity*255) << 24;
	} else if (attr->hasFill == 2) {
		shape->fill.gradient = nsvg__createGradient(p, attr->fillGradient, shape->bounds, &shape->fill.type);
		if (shape->fill.gradient == NULL) {
			shape->fill.type = NSVG_PAINT_NONE;
		}
	}

	// Set stroke
	if (attr->hasStroke == 0) {
		shape->stroke.type = NSVG_PAINT_NONE;
	} else if (attr->hasStroke == 1) {
		shape->stroke.type = NSVG_PAINT_COLOR;
		shape->stroke.color = attr->strokeColor;
		shape->stroke.color |= (unsigned int)(attr->strokeOpacity*255) << 24;
	} else if (attr->hasStroke == 2) {
		shape->stroke.gradient = nsvg__createGradient(p, attr->strokeGradient, shape->bounds, &shape->stroke.type);
		if (shape->stroke.gradient == NULL)
			shape->stroke.type = NSVG_PAINT_NONE;
	}

	// Add to tail
	prev = NULL;
	cur = p->image->shapes;
	while (cur != NULL) {
		prev = cur;
		cur = cur->next;
	}
	if (prev == NULL)
		p->image->shapes = shape;
	else
		prev->next = shape;

	return;

error:
	if (shape) free(shape);
}

static void nsvg__addPath(NSVGparser* p, char closed)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	NSVGpath* path = NULL;
	float bounds[4];
	float* curve;
	int i;

	if (p->npts < 4)
		return;

	if (closed)
		nsvg__lineTo(p, p->pts[0], p->pts[1]);

	path = (NSVGpath*)malloc(sizeof(NSVGpath));
	if (path == NULL) goto error;
	memset(path, 0, sizeof(NSVGpath));

	path->pts = (float*)malloc(p->npts*2*sizeof(float));
	if (path->pts == NULL) goto error;
	path->closed = closed;
	path->npts = p->npts;

	// Transform path.
	for (i = 0; i < p->npts; ++i)
		nsvg__xformPoint(&path->pts[i*2], &path->pts[i*2+1], p->pts[i*2], p->pts[i*2+1], attr->xform);

	// Find bounds
	for (i = 0; i < path->npts-1; i += 3) {
		curve = &path->pts[i*2];
		nsvg__curveBounds(bounds, curve);
		if (i == 0) {
			path->bounds[0] = bounds[0];
			path->bounds[1] = bounds[1];
			path->bounds[2] = bounds[2];
			path->bounds[3] = bounds[3];
		} else {
			path->bounds[0] = nsvg__minf(path->bounds[0], bounds[0]);
			path->bounds[1] = nsvg__minf(path->bounds[1], bounds[1]);
			path->bounds[2] = nsvg__maxf(path->bounds[2], bounds[2]);
			path->bounds[3] = nsvg__maxf(path->bounds[3], bounds[3]);
		}
	}

	path->next = p->plist;
	p->plist = path;

	return;

error:
	if (path != NULL) {
		if (path->pts != NULL) free(path->pts);
		free(path);
	}
}

static const char* nsvg__parseNumber(const char* s, char* it, const int size)
{
	const int last = size-1;
	int i = 0;

	// sign
	if (*s == '-' || *s == '+') {
		if (i < last) it[i++] = *s;
		s++;
	}
	// integer part
	while (*s && nsvg__isdigit(*s)) {
		if (i < last) it[i++] = *s;
		s++;
	}
	if (*s == '.') {
		// decimal point
		if (i < last) it[i++] = *s;
		s++;
		// fraction part
		while (*s && nsvg__isdigit(*s)) {
			if (i < last) it[i++] = *s;
			s++;
		}
	}
	// exponent
	if (*s == 'e' || *s == 'E') {
		if (i < last) it[i++] = *s;
		s++;
		if (*s == '-' || *s == '+') {
			if (i < last) it[i++] = *s;
			s++;
		}
		while (*s && nsvg__isdigit(*s)) {
			if (i < last) it[i++] = *s;
			s++;
		}
	}
	it[i] = '\0';

	return s;
}

static const char* nsvg__getNextPathItem(const char* s, char* it)
{
	it[0] = '\0';
	// Skip white spaces and commas
	while (*s && (nsvg__isspace(*s) || *s == ',')) s++;
	if (!*s) return s;
	if (*s == '-' || *s == '+' || *s == '.' || nsvg__isdigit(*s)) {
		s = nsvg__parseNumber(s, it, 64);
	} else {
		// Parse command
		it[0] = *s++;
		it[1] = '\0';
		return s;
	}

	return s;
}

static float nsvg__actualWidth(NSVGparser* p)
{
	return p->viewWidth;
}

static float nsvg__actualHeight(NSVGparser* p)
{
	return p->viewHeight;
}

static float nsvg__actualLength(NSVGparser* p)
{
	float w = nsvg__actualWidth(p), h = nsvg__actualHeight(p);
	return sqrtf(w*w + h*h) / sqrtf(2.0f);
}

static unsigned int nsvg__parseColorHex(const char* str)
{
	unsigned int c = 0, r = 0, g = 0, b = 0;
	int n = 0;
	str++; // skip #
	// Calculate number of characters.
	while(str[n] && !nsvg__isspace(str[n]))
		n++;
	if (n == 6) {
		sscanf(str, "%x", &c);
	} else if (n == 3) {
		sscanf(str, "%x", &c);
		c = (c&0xf) | ((c&0xf0) << 4) | ((c&0xf00) << 8);
		c |= c<<4;
	}
	r = (c >> 16) & 0xff;
	g = (c >> 8) & 0xff;
	b = c & 0xff;
	return NSVG_RGB(r,g,b);
}

static unsigned int nsvg__parseColorRGB(const char* str)
{
	int r = -1, g = -1, b = -1;
	char s1[32]="", s2[32]="";
	sscanf(str + 4, "%d%[%%, \t]%d%[%%, \t]%d", &r, s1, &g, s2, &b);
	if (strchr(s1, '%')) {
		return NSVG_RGB((r*255)/100,(g*255)/100,(b*255)/100);
	} else {
		return NSVG_RGB(r,g,b);
	}
}

typedef struct NSVGNamedColor {
	const char* name;
	unsigned int color;
} NSVGNamedColor;

NSVGNamedColor nsvg__colors[] = {

	{ "red", NSVG_RGB(255, 0, 0) },
	{ "green", NSVG_RGB( 0, 128, 0) },
	{ "blue", NSVG_RGB( 0, 0, 255) },
	{ "yellow", NSVG_RGB(255, 255, 0) },
	{ "cyan", NSVG_RGB( 0, 255, 255) },
	{ "magenta", NSVG_RGB(255, 0, 255) },
	{ "black", NSVG_RGB( 0, 0, 0) },
	{ "grey", NSVG_RGB(128, 128, 128) },
	{ "gray", NSVG_RGB(128, 128, 128) },
	{ "white", NSVG_RGB(255, 255, 255) },

#ifdef NANOSVG_ALL_COLOR_KEYWORDS
	{ "aliceblue", NSVG_RGB(240, 248, 255) },
	{ "antiquewhite", NSVG_RGB(250, 235, 215) },
	{ "aqua", NSVG_RGB( 0, 255, 255) },
	{ "aquamarine", NSVG_RGB(127, 255, 212) },
	{ "azure", NSVG_RGB(240, 255, 255) },
	{ "beige", NSVG_RGB(245, 245, 220) },
	{ "bisque", NSVG_RGB(255, 228, 196) },
	{ "blanchedalmond", NSVG_RGB(255, 235, 205) },
	{ "blueviolet", NSVG_RGB(138, 43, 226) },
	{ "brown", NSVG_RGB(165, 42, 42) },
	{ "burlywood", NSVG_RGB(222, 184, 135) },
	{ "cadetblue", NSVG_RGB( 95, 158, 160) },
	{ "chartreuse", NSVG_RGB(127, 255, 0) },
	{ "chocolate", NSVG_RGB(210, 105, 30) },
	{ "coral", NSVG_RGB(255, 127, 80) },
	{ "cornflowerblue", NSVG_RGB(100, 149, 237) },
	{ "cornsilk", NSVG_RGB(255, 248, 220) },
	{ "crimson", NSVG_RGB(220, 20, 60) },
	{ "darkblue", NSVG_RGB( 0, 0, 139) },
	{ "darkcyan", NSVG_RGB( 0, 139, 139) },
	{ "darkgoldenrod", NSVG_RGB(184, 134, 11) },
	{ "darkgray", NSVG_RGB(169, 169, 169) },
	{ "darkgreen", NSVG_RGB( 0, 100, 0) },
	{ "darkgrey", NSVG_RGB(169, 169, 169) },
	{ "darkkhaki", NSVG_RGB(189, 183, 107) },
	{ "darkmagenta", NSVG_RGB(139, 0, 139) },
	{ "darkolivegreen", NSVG_RGB( 85, 107, 47) },
	{ "darkorange", NSVG_RGB(255, 140, 0) },
	{ "darkorchid", NSVG_RGB(153, 50, 204) },
	{ "darkred", NSVG_RGB(139, 0, 0) },
	{ "darksalmon", NSVG_RGB(233, 150, 122) },
	{ "darkseagreen", NSVG_RGB(143, 188, 143) },
	{ "darkslateblue", NSVG_RGB( 72, 61, 139) },
	{ "darkslategray", NSVG_RGB( 47, 79, 79) },
	{ "darkslategrey", NSVG_RGB( 47, 79, 79) },
	{ "darkturquoise", NSVG_RGB( 0, 206, 209) },
	{ "darkviolet", NSVG_RGB(148, 0, 211) },
	{ "deeppink", NSVG_RGB(255, 20, 147) },
	{ "deepskyblue", NSVG_RGB( 0, 191, 255) },
	{ "dimgray", NSVG_RGB(105, 105, 105) },
	{ "dimgrey", NSVG_RGB(105, 105, 105) },
	{ "dodgerblue", NSVG_RGB( 30, 144, 255) },
	{ "firebrick", NSVG_RGB(178, 34, 34) },
	{ "floralwhite", NSVG_RGB(255, 250, 240) },
	{ "forestgreen", NSVG_RGB( 34, 139, 34) },
	{ "fuchsia", NSVG_RGB(255, 0, 255) },
	{ "gainsboro", NSVG_RGB(220, 220, 220) },
	{ "ghostwhite", NSVG_RGB(248, 248, 255) },
	{ "gold", NSVG_RGB(255, 215, 0) },
	{ "goldenrod", NSVG_RGB(218, 165, 32) },
	{ "greenyellow", NSVG_RGB(173, 255, 47) },
	{ "honeydew", NSVG_RGB(240, 255, 240) },
	{ "hotpink", NSVG_RGB(255, 105, 180) },
	{ "indianred", NSVG_RGB(205, 92, 92) },
	{ "indigo", NSVG_RGB( 75, 0, 130) },
	{ "ivory", NSVG_RGB(255, 255, 240) },
	{ "khaki", NSVG_RGB(240, 230, 140) },
	{ "lavender", NSVG_RGB(230, 230, 250) },
	{ "lavenderblush", NSVG_RGB(255, 240, 245) },
	{ "lawngreen", NSVG_RGB(124, 252, 0) },
	{ "lemonchiffon", NSVG_RGB(255, 250, 205) },
	{ "lightblue", NSVG_RGB(173, 216, 230) },
	{ "lightcoral", NSVG_RGB(240, 128, 128) },
	{ "lightcyan", NSVG_RGB(224, 255, 255) },
	{ "lightgoldenrodyellow", NSVG_RGB(250, 250, 210) },
	{ "lightgray", NSVG_RGB(211, 211, 211) },
	{ "lightgreen", NSVG_RGB(144, 238, 144) },
	{ "lightgrey", NSVG_RGB(211, 211, 211) },
	{ "lightpink", NSVG_RGB(255, 182, 193) },
	{ "lightsalmon", NSVG_RGB(255, 160, 122) },
	{ "lightseagreen", NSVG_RGB( 32, 178, 170) },
	{ "lightskyblue", NSVG_RGB(135, 206, 250) },
	{ "lightslategray", NSVG_RGB(119, 136, 153) },
	{ "lightslategrey", NSVG_RGB(119, 136, 153) },
	{ "lightsteelblue", NSVG_RGB(176, 196, 222) },
	{ "lightyellow", NSVG_RGB(255, 255, 224) },
	{ "lime", NSVG_RGB( 0, 255, 0) },
	{ "limegreen", NSVG_RGB( 50, 205, 50) },
	{ "linen", NSVG_RGB(250, 240, 230) },
	{ "maroon", NSVG_RGB(128, 0, 0) },
	{ "mediumaquamarine", NSVG_RGB(102, 205, 170) },
	{ "mediumblue", NSVG_RGB( 0, 0, 205) },
	{ "mediumorchid", NSVG_RGB(186, 85, 211) },
	{ "mediumpurple", NSVG_RGB(147, 112, 219) },
	{ "mediumseagreen", NSVG_RGB( 60, 179, 113) },
	{ "mediumslateblue", NSVG_RGB(123, 104, 238) },
	{ "mediumspringgreen", NSVG_RGB( 0, 250, 154) },
	{ "mediumturquoise", NSVG_RGB( 72, 209, 204) },
	{ "mediumvioletred", NSVG_RGB(199, 21, 133) },
	{ "midnightblue", NSVG_RGB( 25, 25, 112) },
	{ "mintcream", NSVG_RGB(245, 255, 250) },
	{ "mistyrose", NSVG_RGB(255, 228, 225) },
	{ "moccasin", NSVG_RGB(255, 228, 181) },
	{ "navajowhite", NSVG_RGB(255, 222, 173) },
	{ "navy", NSVG_RGB( 0, 0, 128) },
	{ "oldlace", NSVG_RGB(253, 245, 230) },
	{ "olive", NSVG_RGB(128, 128, 0) },
	{ "olivedrab", NSVG_RGB(107, 142, 35) },
	{ "orange", NSVG_RGB(255, 165, 0) },
	{ "orangered", NSVG_RGB(255, 69, 0) },
	{ "orchid", NSVG_RGB(218, 112, 214) },
	{ "palegoldenrod", NSVG_RGB(238, 232, 170) },
	{ "palegreen", NSVG_RGB(152, 251, 152) },
	{ "paleturquoise", NSVG_RGB(175, 238, 238) },
	{ "palevioletred", NSVG_RGB(219, 112, 147) },
	{ "papayawhip", NSVG_RGB(255, 239, 213) },
	{ "peachpuff", NSVG_RGB(255, 218, 185) },
	{ "peru", NSVG_RGB(205, 133, 63) },
	{ "pink", NSVG_RGB(255, 192, 203) },
	{ "plum", NSVG_RGB(221, 160, 221) },
	{ "powderblue", NSVG_RGB(176, 224, 230) },
	{ "purple", NSVG_RGB(128, 0, 128) },
	{ "rosybrown", NSVG_RGB(188, 143, 143) },
	{ "royalblue", NSVG_RGB( 65, 105, 225) },
	{ "saddlebrown", NSVG_RGB(139, 69, 19) },
	{ "salmon", NSVG_RGB(250, 128, 114) },
	{ "sandybrown", NSVG_RGB(244, 164, 96) },
	{ "seagreen", NSVG_RGB( 46, 139, 87) },
	{ "seashell", NSVG_RGB(255, 245, 238) },
	{ "sienna", NSVG_RGB(160, 82, 45) },
	{ "silver", NSVG_RGB(192, 192, 192) },
	{ "skyblue", NSVG_RGB(135, 206, 235) },
	{ "slateblue", NSVG_RGB(106, 90, 205) },
	{ "slategray", NSVG_RGB(112, 128, 144) },
	{ "slategrey", NSVG_RGB(112, 128, 144) },
	{ "snow", NSVG_RGB(255, 250, 250) },
	{ "springgreen", NSVG_RGB( 0, 255, 127) },
	{ "steelblue", NSVG_RGB( 70, 130, 180) },
	{ "tan", NSVG_RGB(210, 180, 140) },
	{ "teal", NSVG_RGB( 0, 128, 128) },
	{ "thistle", NSVG_RGB(216, 191, 216) },
	{ "tomato", NSVG_RGB(255, 99, 71) },
	{ "turquoise", NSVG_RGB( 64, 224, 208) },
	{ "violet", NSVG_RGB(238, 130, 238) },
	{ "wheat", NSVG_RGB(245, 222, 179) },
	{ "whitesmoke", NSVG_RGB(245, 245, 245) },
	{ "yellowgreen", NSVG_RGB(154, 205, 50) },
#endif
};

static unsigned int nsvg__parseColorName(const char* str)
{
	int i, ncolors = sizeof(nsvg__colors) / sizeof(NSVGNamedColor);

	for (i = 0; i < ncolors; i++) {
		if (strcmp(nsvg__colors[i].name, str) == 0) {
			return nsvg__colors[i].color;
		}
	}

	return NSVG_RGB(128, 128, 128);
}

static unsigned int nsvg__parseColor(const char* str)
{
	size_t len = 0;
	while(*str == ' ') ++str;
	len = strlen(str);
	if (len >= 1 && *str == '#')
		return nsvg__parseColorHex(str);
	else if (len >= 4 && str[0] == 'r' && str[1] == 'g' && str[2] == 'b' && str[3] == '(')
		return nsvg__parseColorRGB(str);
	return nsvg__parseColorName(str);
}

static float nsvg__convertToPixels(NSVGparser* p, float val, const char* units, int dir)
{
	NSVGattrib* attr;

	if (p != NULL) {
		// Convert units to pixels.
		if (units[0] == '\0') {
			return val;
		} else if (units[0] == 'p' && units[1] == 'x') {
			return val;
		} else if (units[0] == 'p' && units[1] == 't') {
			return val / 72.0f * p->dpi;
		} else if (units[0] == 'p' && units[1] == 'c') {
			return val / 6.0f * p->dpi;
		} else if (units[0] == 'm' && units[1] == 'm') {
			return val / 25.4f * p->dpi;
		} else if (units[0] == 'c' && units[1] == 'm') {
			return val / 2.54f * p->dpi;
		} else if (units[0] == 'i' && units[1] == 'n') {
			return val * p->dpi;
		} else if (units[0] == '%') {
			if (p != NULL) {
				attr = nsvg__getAttr(p);
				if (dir == 0)
					return (val/100.0f) * nsvg__actualWidth(p);
				else if (dir == 1)
					return (val/100.0f) * nsvg__actualHeight(p);
				else if (dir == 2)
					return (val/100.0f) * nsvg__actualLength(p);
			} else {
				return (val/100.0f);
			}
		} else if (units[0] == 'e' && units[1] == 'm') {
			if (p != NULL) {
				attr = nsvg__getAttr(p);
				return val * attr->fontSize;
			}
		} else if (units[0] == 'e' && units[1] == 'x') {
			if (p != NULL) {
				attr = nsvg__getAttr(p);
				return val * attr->fontSize * 0.52f; // x-height of Helvetica.
			}
		}
	} else {
		// Convert units to pixels.
		if (units[0] == '\0') {
			return val;
		} else if (units[0] == 'p' && units[1] == 'x') {
			return val;
		} else if (units[0] == '%') {
			return (val/100.0f);
		}
	}
	return val;
}

static float nsvg__parseFloat(NSVGparser* p, const char* str, int dir)
{
	float val = 0;
	char units[32]="";
	sscanf(str, "%f%s", &val, units);
	return nsvg__convertToPixels(p, val, units, dir);
}

static int nsvg__parseTransformArgs(const char* str, float* args, int maxNa, int* na)
{
	const char* end;
	const char* ptr;
	char it[64];

	*na = 0;
	ptr = str;
	while (*ptr && *ptr != '(') ++ptr;
	if (*ptr == 0)
		return 1;
	end = ptr;
	while (*end && *end != ')') ++end;
	if (*end == 0)
		return 1;

	while (ptr < end) {
		if (*ptr == '-' || *ptr == '+' || *ptr == '.' || nsvg__isdigit(*ptr)) {
			if (*na >= maxNa) return 0;
			ptr = nsvg__parseNumber(ptr, it, 64);
			args[(*na)++] = (float)atof(it);
		} else {
			++ptr;
		}
	}
	return (int)(end - str);
}

static int nsvg__parseMatrix(float* xform, const char* str)
{
	float t[6];
	int na = 0;
	int len = nsvg__parseTransformArgs(str, t, 6, &na);
	if (na != 6) return len;
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseTranslate(float* xform, const char* str)
{
	float args[2];
	float t[6];
	int na = 0;
	int len = nsvg__parseTransformArgs(str, args, 2, &na);
	if (na == 1) args[1] = 0.0;

	nsvg__xformSetTranslation(t, args[0], args[1]);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseScale(float* xform, const char* str)
{
	float args[2];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 2, &na);
	if (na == 1) args[1] = args[0];
	nsvg__xformSetScale(t, args[0], args[1]);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseSkewX(float* xform, const char* str)
{
	float args[1];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 1, &na);
	nsvg__xformSetSkewX(t, args[0]/180.0f*NSVG_PI);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseSkewY(float* xform, const char* str)
{
	float args[1];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 1, &na);
	nsvg__xformSetSkewY(t, args[0]/180.0f*NSVG_PI);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseRotate(float* xform, const char* str)
{
	float args[3];
	int na = 0;
	float m[6];
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 3, &na);
	if (na == 1)
		args[1] = args[2] = 0.0f;
	nsvg__xformIdentity(m);

	if (na > 1) {
		nsvg__xformSetTranslation(t, -args[1], -args[2]);
		nsvg__xformMultiply(m, t);
	}

	nsvg__xformSetRotation(t, args[0]/180.0f*NSVG_PI);
	nsvg__xformMultiply(m, t);

	if (na > 1) {
		nsvg__xformSetTranslation(t, args[1], args[2]);
		nsvg__xformMultiply(m, t);
	}

	memcpy(xform, m, sizeof(float)*6);

	return len;
}

static void nsvg__parseTransform(float* xform, const char* str)
{
	float t[6];
	nsvg__xformIdentity(xform);
	while (*str)
	{
		if (strncmp(str, "matrix", 6) == 0)
			str += nsvg__parseMatrix(t, str);
		else if (strncmp(str, "translate", 9) == 0)
			str += nsvg__parseTranslate(t, str);
		else if (strncmp(str, "scale", 5) == 0)
			str += nsvg__parseScale(t, str);
		else if (strncmp(str, "rotate", 6) == 0)
			str += nsvg__parseRotate(t, str);
		else if (strncmp(str, "skewX", 5) == 0)
			str += nsvg__parseSkewX(t, str);
		else if (strncmp(str, "skewY", 5) == 0)
			str += nsvg__parseSkewY(t, str);
		else{
			++str;
			continue;
		}

		nsvg__xformPremultiply(xform, t);
	}
}

static void nsvg__parseUrl(char* id, const char* str)
{
	int i = 0;
	str += 4; // "url(";
	if (*str == '#')
		str++;
	while (i < 63 && *str != ')') {
		id[i] = *str++;
		i++;
	}
	id[i] = '\0';
}

static char nsvg__parseLineCap(const char* str)
{
	if (strcmp(str, "butt") == 0)
		return NSVG_CAP_BUTT;
	else if (strcmp(str, "round") == 0)
		return NSVG_CAP_ROUND;
	else if (strcmp(str, "square") == 0)
		return NSVG_CAP_SQUARE;
	// TODO: handle inherit.
	return NSVG_CAP_BUTT;
}

static char nsvg__parseLineJoin(const char* str)
{
	if (strcmp(str, "miter") == 0)
		return NSVG_JOIN_MITER;
	else if (strcmp(str, "round") == 0)
		return NSVG_JOIN_ROUND;
	else if (strcmp(str, "bevel") == 0)
		return NSVG_JOIN_BEVEL;
	// TODO: handle inherit.
	return NSVG_CAP_BUTT;
}

static void nsvg__parseStyle(NSVGparser* p, const char* str);

static int nsvg__parseAttr(NSVGparser* p, const char* name, const char* value)
{
	float xform[6];
	NSVGattrib* attr = nsvg__getAttr(p);
	if (!attr) return 0;

	if (strcmp(name, "style") == 0) {
		nsvg__parseStyle(p, value);
	} else if (strcmp(name, "display") == 0) {
		if (strcmp(value, "none") == 0)
			attr->visible = 0;
		else
			attr->visible = 1;
	} else if (strcmp(name, "fill") == 0) {
		if (strcmp(value, "none") == 0) {
			attr->hasFill = 0;
		} else if (strncmp(value, "url(", 4) == 0) {
			attr->hasFill = 2;
			nsvg__parseUrl(attr->fillGradient, value);
		} else {
			attr->hasFill = 1;
			attr->fillColor = nsvg__parseColor(value);
		}
	} else if (strcmp(name, "opacity") == 0) {
		attr->opacity = nsvg__parseFloat(p, value, 2);
	} else if (strcmp(name, "fill-opacity") == 0) {
		attr->fillOpacity = nsvg__parseFloat(p, value, 2);
	} else if (strcmp(name, "stroke") == 0) {
		if (strcmp(value, "none") == 0) {
			attr->hasStroke = 0;
		} else if (strncmp(value, "url(", 4) == 0) {
			attr->hasStroke = 2;
			nsvg__parseUrl(attr->strokeGradient, value);
		} else {
			attr->hasStroke = 1;
			attr->strokeColor = nsvg__parseColor(value);
		}
	} else if (strcmp(name, "stroke-width") == 0) {
		attr->strokeWidth = nsvg__parseFloat(p, value, 2);
	} else if (strcmp(name, "stroke-opacity") == 0) {
		attr->strokeOpacity = nsvg__parseFloat(NULL, value, 2);
	} else if (strcmp(name, "stroke-linecap") == 0) {
		attr->strokeLineCap = nsvg__parseLineCap(value);
	} else if (strcmp(name, "stroke-linejoin") == 0) {
		attr->strokeLineJoin = nsvg__parseLineJoin(value);
	} else if (strcmp(name, "font-size") == 0) {
		attr->fontSize = nsvg__parseFloat(p, value, 2);
	} else if (strcmp(name, "transform") == 0) {
		nsvg__parseTransform(xform, value);
		nsvg__xformPremultiply(attr->xform, xform);
	} else if (strcmp(name, "stop-color") == 0) {
		attr->stopColor = nsvg__parseColor(value);
	} else if (strcmp(name, "stop-opacity") == 0) {
		attr->stopOpacity = nsvg__parseFloat(NULL, value, 2);
	} else if (strcmp(name, "offset") == 0) {
		attr->stopOffset = nsvg__parseFloat(NULL, value, 2);
	} else if (strcmp(name, "id") == 0) {
		strncpy(attr->id, value, 63);
		attr->id[63] = '\0';
	} else {
		return 0;
	}
	return 1;
}

static int nsvg__parseNameValue(NSVGparser* p, const char* start, const char* end)
{
	const char* str;
	const char* val;
	char name[512];
	char value[512];
	int n;

	str = start;
	while (str < end && *str != ':') ++str;

	val = str;

	// Right Trim
	while (str > start &&  (*str == ':' || nsvg__isspace(*str))) --str;
	++str;

	n = (int)(str - start);
	if (n > 511) n = 511;
	if (n) memcpy(name, start, n);
	name[n] = 0;

	while (val < end && (*val == ':' || nsvg__isspace(*val))) ++val;

	n = (int)(end - val);
	if (n > 511) n = 511;
	if (n) memcpy(value, val, n);
	value[n] = 0;

	return nsvg__parseAttr(p, name, value);
}

static void nsvg__parseStyle(NSVGparser* p, const char* str)
{
	const char* start;
	const char* end;

	while (*str) {
		// Left Trim
		while(*str && nsvg__isspace(*str)) ++str;
		start = str;
		while(*str && *str != ';') ++str;
		end = str;

		// Right Trim
		while (end > start &&  (*end == ';' || nsvg__isspace(*end))) --end;
		++end;

		nsvg__parseNameValue(p, start, end);
		if (*str) ++str;
	}
}

static void nsvg__parseAttribs(NSVGparser* p, const char** attr)
{
	int i;
	for (i = 0; attr[i]; i += 2)
	{
		if (strcmp(attr[i], "style") == 0)
			nsvg__parseStyle(p, attr[i + 1]);
		else
			nsvg__parseAttr(p, attr[i], attr[i + 1]);
	}
}

static int nsvg__getArgsPerElement(char cmd)
{
	switch (cmd) {
		case 'v':
		case 'V':
		case 'h':
		case 'H':
			return 1;
		case 'm':
		case 'M':
		case 'l':
		case 'L':
		case 't':
		case 'T':
			return 2;
		case 'q':
		case 'Q':
		case 's':
		case 'S':
			return 4;
		case 'c':
		case 'C':
			return 6;
		case 'a':
		case 'A':
			return 7;
	}
	return 0;
}

static void nsvg__pathMoveTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel) {
		*cpx += args[0];
		*cpy += args[1];
	} else {
		*cpx = args[0];
		*cpy = args[1];
	}
	nsvg__moveTo(p, *cpx, *cpy);
}

static void nsvg__pathLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel) {
		*cpx += args[0];
		*cpy += args[1];
	} else {
		*cpx = args[0];
		*cpy = args[1];
	}
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathHLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel)
		*cpx += args[0];
	else
		*cpx = args[0];
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathVLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel)
		*cpy += args[0];
	else
		*cpy = args[0];
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathCubicBezTo(NSVGparser* p, float* cpx, float* cpy,
								 float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		cx1 = *cpx + args[0];
		cy1 = *cpy + args[1];
		cx2 = *cpx + args[2];
		cy2 = *cpy + args[3];
		x2 = *cpx + args[4];
		y2 = *cpy + args[5];
	} else {
		cx1 = args[0];
		cy1 = args[1];
		cx2 = args[2];
		cy2 = args[3];
		x2 = args[4];
		y2 = args[5];
	}

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx2;
	*cpy2 = cy2;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathCubicBezShortTo(NSVGparser* p, float* cpx, float* cpy,
									  float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		cx2 = *cpx + args[0];
		cy2 = *cpy + args[1];
		x2 = *cpx + args[2];
		y2 = *cpy + args[3];
	} else {
		cx2 = args[0];
		cy2 = args[1];
		x2 = args[2];
		y2 = args[3];
	}

	cx1 = 2*x1 - *cpx2;
	cy1 = 2*y1 - *cpy2;

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx2;
	*cpy2 = cy2;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathQuadBezTo(NSVGparser* p, float* cpx, float* cpy,
								float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx, cy;
	float cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		cx = *cpx + args[0];
		cy = *cpy + args[1];
		x2 = *cpx + args[2];
		y2 = *cpy + args[3];
	} else {
		cx = args[0];
		cy = args[1];
		x2 = args[2];
		y2 = args[3];
	}

	// Convert to cubic bezier
	cx1 = x1 + 2.0f/3.0f*(cx - x1);
	cy1 = y1 + 2.0f/3.0f*(cy - y1);
	cx2 = x2 + 2.0f/3.0f*(cx - x2);
	cy2 = y2 + 2.0f/3.0f*(cy - y2);

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx;
	*cpy2 = cy;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathQuadBezShortTo(NSVGparser* p, float* cpx, float* cpy,
									 float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx, cy;
	float cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		x2 = *cpx + args[0];
		y2 = *cpy + args[1];
	} else {
		x2 = args[0];
		y2 = args[1];
	}

	cx = 2*x1 - *cpx2;
	cy = 2*y1 - *cpy2;

	// Convert to cubix bezier
	cx1 = x1 + 2.0f/3.0f*(cx - x1);
	cy1 = y1 + 2.0f/3.0f*(cy - y1);
	cx2 = x2 + 2.0f/3.0f*(cx - x2);
	cy2 = y2 + 2.0f/3.0f*(cy - y2);

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx;
	*cpy2 = cy;
	*cpx = x2;
	*cpy = y2;
}

static float nsvg__sqr(float x) { return x*x; }
static float nsvg__vmag(float x, float y) { return sqrtf(x*x + y*y); }

static float nsvg__vecrat(float ux, float uy, float vx, float vy)
{
	return (ux*vx + uy*vy) / (nsvg__vmag(ux,uy) * nsvg__vmag(vx,vy));
}

static float nsvg__vecang(float ux, float uy, float vx, float vy)
{
	float r = nsvg__vecrat(ux,uy, vx,vy);
	if (r < -1.0f) r = -1.0f;
	if (r > 1.0f) r = 1.0f;
	return ((ux*vy < uy*vx) ? -1.0f : 1.0f) * acosf(r);
}

static void nsvg__pathArcTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	// Ported from canvg (https://code.google.com/p/canvg/)
	float rx, ry, rotx;
	float x1, y1, x2, y2, cx, cy, dx, dy, d;
	float x1p, y1p, cxp, cyp, s, sa, sb;
	float ux, uy, vx, vy, a1, da;
	float x, y, tanx, tany, a, px = 0, py = 0, ptanx = 0, ptany = 0, t[6];
	float sinrx, cosrx;
	int fa, fs;
	int i, ndivs;
	float hda, kappa;

	rx = fabsf(args[0]);				// y radius
	ry = fabsf(args[1]);				// x radius
	rotx = args[2] / 180.0f * NSVG_PI;		// x rotation engle
	fa = fabsf(args[3]) > 1e-6 ? 1 : 0;	// Large arc
	fs = fabsf(args[4]) > 1e-6 ? 1 : 0;	// Sweep direction
	x1 = *cpx;							// start point
	y1 = *cpy;
	if (rel) {							// end point
		x2 = *cpx + args[5];
		y2 = *cpy + args[6];
	} else {
		x2 = args[5];
		y2 = args[6];
	}

	dx = x1 - x2;
	dy = y1 - y2;
	d = sqrtf(dx*dx + dy*dy);
	if (d < 1e-6f || rx < 1e-6f || ry < 1e-6f) {
		// The arc degenerates to a line
		nsvg__lineTo(p, x2, y2);
		*cpx = x2;
		*cpy = y2;
		return;
	}

	sinrx = sinf(rotx);
	cosrx = cosf(rotx);

	// Convert to center point parameterization.
	// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	// 1) Compute x1', y1'
	x1p = cosrx * dx / 2.0f + sinrx * dy / 2.0f;
	y1p = -sinrx * dx / 2.0f + cosrx * dy / 2.0f;
	d = nsvg__sqr(x1p)/nsvg__sqr(rx) + nsvg__sqr(y1p)/nsvg__sqr(ry);
	if (d > 1) {
		d = sqrtf(d);
		rx *= d;
		ry *= d;
	}
	// 2) Compute cx', cy'
	s = 0.0f;
	sa = nsvg__sqr(rx)*nsvg__sqr(ry) - nsvg__sqr(rx)*nsvg__sqr(y1p) - nsvg__sqr(ry)*nsvg__sqr(x1p);
	sb = nsvg__sqr(rx)*nsvg__sqr(y1p) + nsvg__sqr(ry)*nsvg__sqr(x1p);
	if (sa < 0.0f) sa = 0.0f;
	if (sb > 0.0f)
		s = sqrtf(sa / sb);
	if (fa == fs)
		s = -s;
	cxp = s * rx * y1p / ry;
	cyp = s * -ry * x1p / rx;

	// 3) Compute cx,cy from cx',cy'
	cx = (x1 + x2)/2.0f + cosrx*cxp - sinrx*cyp;
	cy = (y1 + y2)/2.0f + sinrx*cxp + cosrx*cyp;

	// 4) Calculate theta1, and delta theta.
	ux = (x1p - cxp) / rx;
	uy = (y1p - cyp) / ry;
	vx = (-x1p - cxp) / rx;
	vy = (-y1p - cyp) / ry;
	a1 = nsvg__vecang(1.0f,0.0f, ux,uy);	// Initial angle
	da = nsvg__vecang(ux,uy, vx,vy);		// Delta angle

//	if (vecrat(ux,uy,vx,vy) <= -1.0f) da = NSVG_PI;
//	if (vecrat(ux,uy,vx,vy) >= 1.0f) da = 0;

	if (fa) {
		// Choose large arc
		if (da > 0.0f)
			da = da - 2*NSVG_PI;
		else
			da = 2*NSVG_PI + da;
	}

	// Approximate the arc using cubic spline segments.
	t[0] = cosrx; t[1] = sinrx;
	t[2] = -sinrx; t[3] = cosrx;
	t[4] = cx; t[5] = cy;

	// Split arc into max 90 degree segments.
	// The loop assumes an iteration per end point (including start and end), this +1.
	ndivs = (int)(fabsf(da) / (NSVG_PI*0.5f) + 1.0f);
	hda = (da / (float)ndivs) / 2.0f;
	kappa = fabsf(4.0f / 3.0f * (1.0f - cosf(hda)) / sinf(hda));
	if (da < 0.0f)
		kappa = -kappa;

	for (i = 0; i <= ndivs; i++) {
		a = a1 + da * (i/(float)ndivs);
		dx = cosf(a);
		dy = sinf(a);
		nsvg__xformPoint(&x, &y, dx*rx, dy*ry, t); // position
		nsvg__xformVec(&tanx, &tany, -dy*rx * kappa, dx*ry * kappa, t); // tangent
		if (i > 0)
			nsvg__cubicBezTo(p, px+ptanx,py+ptany, x-tanx, y-tany, x, y);
		px = x;
		py = y;
		ptanx = tanx;
		ptany = tany;
	}

	*cpx = x2;
	*cpy = y2;
}

static void nsvg__parsePath(NSVGparser* p, const char** attr)
{
	const char* s = NULL;
	char cmd = '\0';
	float args[10];
	int nargs;
	int rargs = 0;
	float cpx, cpy, cpx2, cpy2;
	const char* tmp[4];
	char closedFlag;
	int i;
	char item[64];

	for (i = 0; attr[i]; i += 2) {
		if (strcmp(attr[i], "d") == 0) {
			s = attr[i + 1];
		} else {
			tmp[0] = attr[i];
			tmp[1] = attr[i + 1];
			tmp[2] = 0;
			tmp[3] = 0;
			nsvg__parseAttribs(p, tmp);
		}
	}

	if (s) {
		nsvg__resetPath(p);
		cpx = 0; cpy = 0;
		closedFlag = 0;
		nargs = 0;

		while (*s) {
			s = nsvg__getNextPathItem(s, item);
			if (!*item) break;
			if (nsvg__isnum(item[0])) {
				if (nargs < 10)
					args[nargs++] = (float)atof(item);
				if (nargs >= rargs) {
					switch (cmd) {
						case 'm':
						case 'M':
							nsvg__pathMoveTo(p, &cpx, &cpy, args, cmd == 'm' ? 1 : 0);
							// Moveto can be followed by multiple coordinate pairs,
							// which should be treated as linetos.
							cmd = (cmd == 'm') ? 'l' : 'L';
							rargs = nsvg__getArgsPerElement(cmd);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'l':
						case 'L':
							nsvg__pathLineTo(p, &cpx, &cpy, args, cmd == 'l' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'H':
						case 'h':
							nsvg__pathHLineTo(p, &cpx, &cpy, args, cmd == 'h' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'V':
						case 'v':
							nsvg__pathVLineTo(p, &cpx, &cpy, args, cmd == 'v' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'C':
						case 'c':
							nsvg__pathCubicBezTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 'c' ? 1 : 0);
							break;
						case 'S':
						case 's':
							nsvg__pathCubicBezShortTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 's' ? 1 : 0);
							break;
						case 'Q':
						case 'q':
							nsvg__pathQuadBezTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 'q' ? 1 : 0);
							break;
						case 'T':
						case 't':
							nsvg__pathQuadBezShortTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 's' ? 1 : 0);
							break;
						case 'A':
						case 'a':
							nsvg__pathArcTo(p, &cpx, &cpy, args, cmd == 'a' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						default:
							if (nargs >= 2) {
								cpx = args[nargs-2];
								cpy = args[nargs-1];
	                            cpx2 = cpx; cpy2 = cpy;
							}
							break;
					}
					nargs = 0;
				}
			} else {
				cmd = item[0];
				rargs = nsvg__getArgsPerElement(cmd);
				if (cmd == 'M' || cmd == 'm') {
					// Commit path.
					if (p->npts > 0)
						nsvg__addPath(p, closedFlag);
					// Start new subpath.
					nsvg__resetPath(p);
					closedFlag = 0;
					nargs = 0;
				} else if (cmd == 'Z' || cmd == 'z') {
					closedFlag = 1;
					// Commit path.
					if (p->npts > 0) {
						// Move current point to first point
						cpx = p->pts[0];
						cpy = p->pts[1];
						cpx2 = cpx; cpy2 = cpy;
						nsvg__addPath(p, closedFlag);
					}
					// Start new subpath.
					nsvg__resetPath(p);
					nsvg__moveTo(p, cpx, cpy);
					closedFlag = 0;
					nargs = 0;
				}
			}
		}
		// Commit path.
		if (p->npts)
			nsvg__addPath(p, closedFlag);
	}

	nsvg__addShape(p);
}

static void nsvg__parseRect(NSVGparser* p, const char** attr)
{
	float x = 0.0f;
	float y = 0.0f;
	float w = 0.0f;
	float h = 0.0f;
	float rx = -1.0f; // marks not set
	float ry = -1.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "x") == 0) x = nsvg__parseFloat(p, attr[i+1], 0);
			if (strcmp(attr[i], "y") == 0) y = nsvg__parseFloat(p, attr[i+1], 1);
			if (strcmp(attr[i], "width") == 0) w = nsvg__parseFloat(p, attr[i+1], 0);
			if (strcmp(attr[i], "height") == 0) h = nsvg__parseFloat(p, attr[i+1], 1);
			if (strcmp(attr[i], "rx") == 0) rx = fabsf(nsvg__parseFloat(p, attr[i+1], 0));
			if (strcmp(attr[i], "ry") == 0) ry = fabsf(nsvg__parseFloat(p, attr[i+1], 1));
		}
	}

	if (rx < 0.0f && ry > 0.0f) rx = ry;
	if (ry < 0.0f && rx > 0.0f) ry = rx;
	if (rx < 0.0f) rx = 0.0f;
	if (ry < 0.0f) ry = 0.0f;
	if (rx > w/2.0f) rx = w/2.0f;
	if (ry > h/2.0f) ry = h/2.0f;

	if (w != 0.0f && h != 0.0f) {
		nsvg__resetPath(p);

		if (rx < 0.00001f || ry < 0.0001f) {
			nsvg__moveTo(p, x, y);
			nsvg__lineTo(p, x+w, y);
			nsvg__lineTo(p, x+w, y+h);
			nsvg__lineTo(p, x, y+h);
		} else {
			// Rounded rectangle
			nsvg__moveTo(p, x+rx, y);
			nsvg__lineTo(p, x+w-rx, y);
			nsvg__cubicBezTo(p, x+w-rx*(1-NSVG_KAPPA90), y, x+w, y+ry*(1-NSVG_KAPPA90), x+w, y+ry);
			nsvg__lineTo(p, x+w, y+h-ry);
			nsvg__cubicBezTo(p, x+w, y+h-ry*(1-NSVG_KAPPA90), x+w-rx*(1-NSVG_KAPPA90), y+h, x+w-rx, y+h);
			nsvg__lineTo(p, x+rx, y+h);
			nsvg__cubicBezTo(p, x+rx*(1-NSVG_KAPPA90), y+h, x, y+h-ry*(1-NSVG_KAPPA90), x, y+h-ry);
			nsvg__lineTo(p, x, y+ry);
			nsvg__cubicBezTo(p, x, y+ry*(1-NSVG_KAPPA90), x+rx*(1-NSVG_KAPPA90), y, x+rx, y);
		}

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseCircle(NSVGparser* p, const char** attr)
{
	float cx = 0.0f;
	float cy = 0.0f;
	float r = 0.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "cx") == 0) cx = nsvg__parseFloat(p, attr[i+1], 0);
			if (strcmp(attr[i], "cy") == 0) cy = nsvg__parseFloat(p, attr[i+1], 1);
			if (strcmp(attr[i], "r") == 0) r = fabsf(nsvg__parseFloat(p, attr[i+1], 2));
		}
	}

	if (r > 0.0f) {
		nsvg__resetPath(p);

		nsvg__moveTo(p, cx+r, cy);
		nsvg__cubicBezTo(p, cx+r, cy+r*NSVG_KAPPA90, cx+r*NSVG_KAPPA90, cy+r, cx, cy+r);
		nsvg__cubicBezTo(p, cx-r*NSVG_KAPPA90, cy+r, cx-r, cy+r*NSVG_KAPPA90, cx-r, cy);
		nsvg__cubicBezTo(p, cx-r, cy-r*NSVG_KAPPA90, cx-r*NSVG_KAPPA90, cy-r, cx, cy-r);
		nsvg__cubicBezTo(p, cx+r*NSVG_KAPPA90, cy-r, cx+r, cy-r*NSVG_KAPPA90, cx+r, cy);

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseEllipse(NSVGparser* p, const char** attr)
{
	float cx = 0.0f;
	float cy = 0.0f;
	float rx = 0.0f;
	float ry = 0.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "cx") == 0) cx = nsvg__parseFloat(p, attr[i+1], 0);
			if (strcmp(attr[i], "cy") == 0) cy = nsvg__parseFloat(p, attr[i+1], 1);
			if (strcmp(attr[i], "rx") == 0) rx = fabsf(nsvg__parseFloat(p, attr[i+1], 0));
			if (strcmp(attr[i], "ry") == 0) ry = fabsf(nsvg__parseFloat(p, attr[i+1], 1));
		}
	}

	if (rx > 0.0f && ry > 0.0f) {

		nsvg__resetPath(p);

		nsvg__moveTo(p, cx+rx, cy);
		nsvg__cubicBezTo(p, cx+rx, cy+ry*NSVG_KAPPA90, cx+rx*NSVG_KAPPA90, cy+ry, cx, cy+ry);
		nsvg__cubicBezTo(p, cx-rx*NSVG_KAPPA90, cy+ry, cx-rx, cy+ry*NSVG_KAPPA90, cx-rx, cy);
		nsvg__cubicBezTo(p, cx-rx, cy-ry*NSVG_KAPPA90, cx-rx*NSVG_KAPPA90, cy-ry, cx, cy-ry);
		nsvg__cubicBezTo(p, cx+rx*NSVG_KAPPA90, cy-ry, cx+rx, cy-ry*NSVG_KAPPA90, cx+rx, cy);

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseLine(NSVGparser* p, const char** attr)
{
	float x1 = 0.0;
	float y1 = 0.0;
	float x2 = 0.0;
	float y2 = 0.0;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "x1") == 0) x1 = nsvg__parseFloat(p, attr[i + 1], 0);
			if (strcmp(attr[i], "y1") == 0) y1 = nsvg__parseFloat(p, attr[i + 1], 1);
			if (strcmp(attr[i], "x2") == 0) x2 = nsvg__parseFloat(p, attr[i + 1], 0);
			if (strcmp(attr[i], "y2") == 0) y2 = nsvg__parseFloat(p, attr[i + 1], 1);
		}
	}

	nsvg__resetPath(p);

	nsvg__moveTo(p, x1, y1);
	nsvg__lineTo(p, x2, y2);

	nsvg__addPath(p, 0);

	nsvg__addShape(p);
}

static void nsvg__parsePoly(NSVGparser* p, const char** attr, int closeFlag)
{
	int i;
	const char* s;
	float args[2];
	int nargs, npts = 0;
	char item[64];

	nsvg__resetPath(p);

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "points") == 0) {
				s = attr[i + 1];
				nargs = 0;
				while (*s) {
					s = nsvg__getNextPathItem(s, item);
					args[nargs++] = (float)atof(item);
					if (nargs >= 2) {
						if (npts == 0)
							nsvg__moveTo(p, args[0], args[1]);
						else
							nsvg__lineTo(p, args[0], args[1]);
						nargs = 0;
						npts++;
					}
				}
			}
		}
	}

	nsvg__addPath(p, (char)closeFlag);

	nsvg__addShape(p);
}

static void nsvg__parseSVG(NSVGparser* p, const char** attr)
{
	int i;
	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "width") == 0) {
				p->image->width = nsvg__parseFloat(p, attr[i + 1], 0);
			} else if (strcmp(attr[i], "height") == 0) {
				p->image->height = nsvg__parseFloat(p, attr[i + 1], 1);
			} else if (strcmp(attr[i], "viewBox") == 0) {
				sscanf(attr[i + 1], "%f%*[%%, \t]%f%*[%%, \t]%f%*[%%, \t]%f", &p->viewMinx, &p->viewMiny, &p->viewWidth, &p->viewHeight);
			} else if (strcmp(attr[i], "preserveAspectRatio") == 0) {
				if (strstr(attr[i + 1], "none") != 0) {
					// No uniform scaling
					p->alignType = NSVG_ALIGN_NONE;
				} else {
					// Parse X align
					if (strstr(attr[i + 1], "xMin") != 0)
						p->alignX = NSVG_ALIGN_MIN;
					else if (strstr(attr[i + 1], "xMid") != 0)
						p->alignX = NSVG_ALIGN_MID;
					else if (strstr(attr[i + 1], "xMax") != 0)
						p->alignX = NSVG_ALIGN_MAX;
					// Parse X align
					if (strstr(attr[i + 1], "yMin") != 0)
						p->alignY = NSVG_ALIGN_MIN;
					else if (strstr(attr[i + 1], "yMid") != 0)
						p->alignY = NSVG_ALIGN_MID;
					else if (strstr(attr[i + 1], "yMax") != 0)
						p->alignY = NSVG_ALIGN_MAX;
					// Parse meet/slice
					p->alignType = NSVG_ALIGN_MEET;
					if (strstr(attr[i + 1], "slice") != 0)
						p->alignType = NSVG_ALIGN_SLICE;
				}
			}
		}
	}
}

static void nsvg__parseGradient(NSVGparser* p, const char** attr, char type)
{
	int i;
	NSVGgradientData* grad = (NSVGgradientData*)malloc(sizeof(NSVGgradientData));
	if (grad == NULL) return;
	memset(grad, 0, sizeof(NSVGgradientData));

	grad->type = type;
	nsvg__xformIdentity(grad->xform);

	// TODO: does not handle percent and objectBoundingBox correctly yet.
	for (i = 0; attr[i]; i += 2) {
		if (strcmp(attr[i], "id") == 0) {
			strncpy(grad->id, attr[i+1], 63);
			grad->id[63] = '\0';
		} else if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "gradientUnits") == 0) {
				if (strcmp(attr[i+1], "objectBoundingBox") == 0)
					grad->units = NSVG_OBJECT_SPACE;
				else
					grad->units = NSVG_USER_SPACE;
			} else if (strcmp(attr[i], "gradientTransform") == 0) {
				nsvg__parseTransform(grad->xform, attr[i + 1]);
			} else if (strcmp(attr[i], "cx") == 0) {
				grad->radial.cx = nsvg__parseFloat(p, attr[i + 1], 0);
			} else if (strcmp(attr[i], "cy") == 0) {
				grad->radial.cy = nsvg__parseFloat(p, attr[i + 1], 1);
			} else if (strcmp(attr[i], "r") == 0) {
				grad->radial.r = nsvg__parseFloat(p, attr[i + 1], 2);
			} else if (strcmp(attr[i], "fx") == 0) {
				grad->radial.fx = nsvg__parseFloat(p, attr[i + 1], 0);
			} else if (strcmp(attr[i], "fy") == 0) {
				grad->radial.fy = nsvg__parseFloat(p, attr[i + 1], 1);
			} else if (strcmp(attr[i], "x1") == 0) {
				grad->linear.x1 = nsvg__parseFloat(p, attr[i + 1], 0);
			} else if (strcmp(attr[i], "y1") == 0) {
				grad->linear.y1 = nsvg__parseFloat(p, attr[i + 1], 1);
			} else if (strcmp(attr[i], "x2") == 0) {
				grad->linear.x2 = nsvg__parseFloat(p, attr[i + 1], 0);
			} else if (strcmp(attr[i], "y2") == 0) {
				grad->linear.y2 = nsvg__parseFloat(p, attr[i + 1], 1);
			} else if (strcmp(attr[i], "spreadMethod") == 0) {
				if (strcmp(attr[i+1], "pad") == 0)
					grad->spread = NSVG_SPREAD_PAD;
				else if (strcmp(attr[i+1], "reflect") == 0)
					grad->spread = NSVG_SPREAD_REFLECT;
				else if (strcmp(attr[i+1], "repeat") == 0)
					grad->spread = NSVG_SPREAD_REPEAT;
			} else if (strcmp(attr[i], "xlink:href") == 0) {
				strncpy(grad->ref, attr[i+1], 63);
				grad->ref[63] = '\0';
			}
		}
	}

	grad->next = p->gradients;
	p->gradients = grad;
}

static void nsvg__parseGradientStop(NSVGparser* p, const char** attr)
{
	NSVGattrib* curAttr = nsvg__getAttr(p);
	NSVGgradientData* grad;
	NSVGgradientStop* stop;
	int i, idx;

	curAttr->stopOffset = 0;
	curAttr->stopColor = 0;
	curAttr->stopOpacity = 1.0f;

	for (i = 0; attr[i]; i += 2) {
		nsvg__parseAttr(p, attr[i], attr[i + 1]);
	}

	// Add stop to the last gradient.
	grad = p->gradients;
	if (grad == NULL) return;

	grad->nstops++;
	grad->stops = (NSVGgradientStop*)realloc(grad->stops, sizeof(NSVGgradientStop)*grad->nstops);
	if (grad->stops == NULL) return;

	// Insert
	idx = grad->nstops-1;
	for (i = 0; i < grad->nstops-1; i++) {
		if (curAttr->stopOffset < grad->stops[i].offset) {
			idx = i;
			break;
		}
	}
	if (idx != grad->nstops-1) {
		for (i = grad->nstops-1; i > idx; i--)
			grad->stops[i] = grad->stops[i-1];
	}

	stop = &grad->stops[idx];
	stop->color = curAttr->stopColor;
	stop->color |= (unsigned int)(curAttr->stopOpacity*255) << 24;
	stop->offset = curAttr->stopOffset;
}

static void nsvg__startElement(void* ud, const char* el, const char** attr)
{
	NSVGparser* p = (NSVGparser*)ud;

	if (p->defsFlag) {
		// Skip everything but gradients in defs
		if (strcmp(el, "linearGradient") == 0) {
			nsvg__parseGradient(p, attr, NSVG_PAINT_LINEAR_GRADIENT);
		} else if (strcmp(el, "radialGradient") == 0) {
			nsvg__parseGradient(p, attr, NSVG_PAINT_RADIAL_GRADIENT);
		} else if (strcmp(el, "stop") == 0) {
			nsvg__parseGradientStop(p, attr);
		}
		return;
	}

	if (strcmp(el, "g") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseAttribs(p, attr);
	} else if (strcmp(el, "path") == 0) {
		if (p->pathFlag)	// Do not allow nested paths.
			return;
		nsvg__pushAttr(p);
		nsvg__parsePath(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "rect") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseRect(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "circle") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseCircle(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "ellipse") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseEllipse(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "line") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parseLine(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "polyline") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parsePoly(p, attr, 0);
		nsvg__popAttr(p);
	} else if (strcmp(el, "polygon") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parsePoly(p, attr, 1);
		nsvg__popAttr(p);
	} else  if (strcmp(el, "linearGradient") == 0) {
		nsvg__parseGradient(p, attr, NSVG_PAINT_LINEAR_GRADIENT);
	} else if (strcmp(el, "radialGradient") == 0) {
		nsvg__parseGradient(p, attr, NSVG_PAINT_RADIAL_GRADIENT);
	} else if (strcmp(el, "stop") == 0) {
		nsvg__parseGradientStop(p, attr);
	} else if (strcmp(el, "defs") == 0) {
		p->defsFlag = 1;
	} else if (strcmp(el, "svg") == 0) {
		nsvg__parseSVG(p, attr);
	}
}

static void nsvg__endElement(void* ud, const char* el)
{
	NSVGparser* p = (NSVGparser*)ud;

	if (strcmp(el, "g") == 0) {
		nsvg__popAttr(p);
	} else if (strcmp(el, "path") == 0) {
		p->pathFlag = 0;
	} else if (strcmp(el, "defs") == 0) {
		p->defsFlag = 0;
	}
}

static void nsvg__content(void* ud, const char* s)
{
	NSVG_NOTUSED(ud);
	NSVG_NOTUSED(s);
	// empty
}

static void nsvg__imageBounds(NSVGparser* p, float* bounds)
{
	NSVGshape* shape;
	shape = p->image->shapes;
	if (shape == NULL) return;
	bounds[0] = shape->bounds[0];
	bounds[1] = shape->bounds[1];
	bounds[2] = shape->bounds[2];
	bounds[3] = shape->bounds[3];
	for (shape = shape->next; shape != NULL; shape = shape->next) {
		bounds[0] = nsvg__minf(bounds[0], shape->bounds[0]);
		bounds[1] = nsvg__minf(bounds[1], shape->bounds[1]);
		bounds[2] = nsvg__maxf(bounds[2], shape->bounds[2]);
		bounds[3] = nsvg__maxf(bounds[3], shape->bounds[3]);
	}
}

static float nsvg__viewAlign(float content, float container, int type)
{
	if (type == NSVG_ALIGN_MIN)
		return 0;
	else if (type == NSVG_ALIGN_MAX)
		return container - content;
	// mid
	return (container - content) * 0.5f;
}

static void nsvg__scaleGradient(NSVGgradient* grad, float tx, float ty, float sx, float sy)
{
	grad->xform[0] *= sx;
	grad->xform[1] *= sx;
	grad->xform[2] *= sy;
	grad->xform[3] *= sy;
	grad->xform[4] += tx*sx;
	grad->xform[5] += ty*sx;
}

static void nsvg__scaleToViewbox(NSVGparser* p, const char* units)
{
	NSVGshape* shape;
	NSVGpath* path;
	float tx, ty, sx, sy, us, bounds[4], t[6];
	int i;
	float* pt;

	// Guess image size if not set completely.
	nsvg__imageBounds(p, bounds);
	if (p->viewWidth == 0) {
		if (p->image->width > 0)
			p->viewWidth = p->image->width;
		else
			p->viewWidth = bounds[2];
	}
	if (p->viewHeight == 0) {
		if (p->image->height > 0)
			p->viewHeight = p->image->height;
		else
			p->viewHeight = bounds[3];
	}
	if (p->image->width == 0)
		p->image->width = p->viewWidth;
	if (p->image->height == 0)
		p->image->height = p->viewHeight;

	tx = -p->viewMinx;
	ty = -p->viewMiny;
	sx = p->viewWidth > 0 ? p->image->width / p->viewWidth : 0;
	sy = p->viewHeight > 0 ? p->image->height / p->viewHeight : 0;
	us = 1.0f / nsvg__convertToPixels(p, 1.0f, units, 0);

	// Fix aspect ratio
	if (p->alignType == NSVG_ALIGN_MEET) {
		// fit whole image into viewbox
		sx = sy = nsvg__minf(sx, sy);
		tx += nsvg__viewAlign(p->viewWidth*sx, p->image->width, p->alignX) / sx;
		ty += nsvg__viewAlign(p->viewHeight*sy, p->image->height, p->alignY) / sy;
	} else if (p->alignType == NSVG_ALIGN_SLICE) {
		// fill whole viewbox with image
		sx = sy = nsvg__maxf(sx, sy);
		tx += nsvg__viewAlign(p->viewWidth*sx, p->image->width, p->alignX) / sx;
		ty += nsvg__viewAlign(p->viewHeight*sy, p->image->height, p->alignY) / sy;
	}

	// Transform
	sx *= us;
	sy *= us;
	for (shape = p->image->shapes; shape != NULL; shape = shape->next) {
		shape->bounds[0] = (shape->bounds[0] + tx) * sx;
		shape->bounds[1] = (shape->bounds[1] + ty) * sy;
		shape->bounds[2] = (shape->bounds[2] + tx) * sx;
		shape->bounds[3] = (shape->bounds[3] + ty) * sy;
		for (path = shape->paths; path != NULL; path = path->next) {
			path->bounds[0] = (path->bounds[0] + tx) * sx;
			path->bounds[1] = (path->bounds[1] + ty) * sy;
			path->bounds[2] = (path->bounds[2] + tx) * sx;
			path->bounds[3] = (path->bounds[3] + ty) * sy;
			for (i =0; i < path->npts; i++) {
				pt = &path->pts[i*2];
				pt[0] = (pt[0] + tx) * sx;
				pt[1] = (pt[1] + ty) * sy;
			}
		}

		if (shape->fill.type == NSVG_PAINT_LINEAR_GRADIENT || shape->fill.type == NSVG_PAINT_RADIAL_GRADIENT) {
			nsvg__scaleGradient(shape->fill.gradient, tx,ty, sx,sy);
			memcpy(t, shape->fill.gradient->xform, sizeof(float)*6);
			nsvg__xformInverse(shape->fill.gradient->xform, t);
		}
		if (shape->stroke.type == NSVG_PAINT_LINEAR_GRADIENT || shape->stroke.type == NSVG_PAINT_RADIAL_GRADIENT) {
			nsvg__scaleGradient(shape->stroke.gradient, tx,ty, sx,sy);
			memcpy(t, shape->stroke.gradient->xform, sizeof(float)*6);
			nsvg__xformInverse(shape->stroke.gradient->xform, t);
		}

	}

	sx *= us;
	sy *= us;
}

NSVGimage* nsvgParse(char* input, const char* units, float dpi)
{
	NSVGparser* p;
	NSVGimage* ret = 0;

	p = nsvg__createParser();
	if (p == NULL) {
		return NULL;
	}
	p->dpi = dpi;

	nsvg__parseXML(input, nsvg__startElement, nsvg__endElement, nsvg__content, p);

	// Scale to viewBox
	nsvg__scaleToViewbox(p, units);

	ret = p->image;
	p->image = NULL;

	nsvg__deleteParser(p);

	return ret;
}

NSVGimage* nsvgParseFromFile(const char* filename, const char* units, float dpi)
{
	FILE* fp = NULL;
	size_t size;
	char* data = NULL;
	NSVGimage* image = NULL;

	fp = fopen(filename, "rb");
	if (!fp) goto error;
	fseek(fp, 0, SEEK_END);
	size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	data = (char*)malloc(size+1);
	if (data == NULL) goto error;
	size = fread(data, size, 1, fp);
	data[size] = '\0';	// Must be null terminated.
	fclose(fp);
	image = nsvgParse(data, units, dpi);
	free(data);

	return image;

error:
	if (fp) fclose(fp);
	if (data) free(data);
	if (image) nsvgDelete(image);
	return NULL;
}

void nsvgDelete(NSVGimage* image)
{
	NSVGshape *snext, *shape;
	if (image == NULL) return;
	shape = image->shapes;
	while (shape != NULL) {
		snext = shape->next;
		nsvg__deletePaths(shape->paths);
		nsvg__deletePaint(&shape->fill);
		nsvg__deletePaint(&shape->stroke);
		free(shape);
		shape = snext;
	}
	free(image);
}

#endif


//#line 1 "nanosvgrast.h"
#ifndef NANOSVGRAST_H
#define NANOSVGRAST_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct NSVGrasterizer NSVGrasterizer;

/* Example Usage:
	// Load SVG
	struct SNVGImage* image = nsvgParseFromFile("test.svg.");

	// Create rasterizer (can be used to render multiple images).
	struct NSVGrasterizer* rast = nsvgCreateRasterizer();
	// Allocate memory for image
	unsigned char* img = malloc(w*h*4);
	// Rasterize
	nsvgRasterize(rast, image, 0,0,1, img, w, h, w*4);
*/

// Allocated rasterizer context.
NSVGrasterizer* nsvgCreateRasterizer();

// Rasterizes SVG image, returns RGBA image (non-premultiplied alpha)
//   r - pointer to rasterizer context
//   image - pointer to image to rasterize
//   tx,ty - image offset (applied after scaling)
//   scale - image scale
//   dst - pointer to destination image data, 4 bytes per pixel (RGBA)
//   w - width of the image to render
//   h - height of the image to render
//   stride - number of bytes per scaleline in the destination buffer
void nsvgRasterize(NSVGrasterizer* r,
				   NSVGimage* image, float tx, float ty, float scale,
				   unsigned char* dst, int w, int h, int stride);

// Deletes rasterizer context.
void nsvgDeleteRasterizer(NSVGrasterizer*);

#ifdef __cplusplus
};
#endif

#endif // NANOSVGRAST_H

#ifdef NANOSVGRAST_IMPLEMENTATION

#include <math.h>

#define NSVG__SUBSAMPLES	5
#define NSVG__FIXSHIFT		10
#define NSVG__FIX			(1 << NSVG__FIXSHIFT)
#define NSVG__FIXMASK		(NSVG__FIX-1)
#define NSVG__MEMPAGE_SIZE	1024

typedef struct NSVGedge {
	float x0,y0, x1,y1;
	int dir;
	struct NSVGedge* next;
} NSVGedge;

typedef struct NSVGpoint {
	float x, y;
	float dx, dy;
	float len;
	float dmx, dmy;
	unsigned char flags;
} NSVGpoint;

typedef struct NSVGactiveEdge {
	int x,dx;
	float ey;
	int dir;
	struct NSVGactiveEdge *next;
} NSVGactiveEdge;

typedef struct NSVGmemPage {
	unsigned char mem[NSVG__MEMPAGE_SIZE];
	int size;
	struct NSVGmemPage* next;
} NSVGmemPage;

typedef struct NSVGcachedPaint {
	char type;
	char spread;
	float xform[6];
	unsigned int colors[256];
} NSVGcachedPaint;

struct NSVGrasterizer
{
	float px, py;

	float tessTol;
	float distTol;

	NSVGedge* edges;
	int nedges;
	int cedges;

	NSVGpoint* points;
	int npoints;
	int cpoints;

	NSVGactiveEdge* freelist;
	NSVGmemPage* pages;
	NSVGmemPage* curpage;

	unsigned char* scanline;
	int cscanline;

	unsigned char* bitmap;
	int width, height, stride;
};

NSVGrasterizer* nsvgCreateRasterizer()
{
	NSVGrasterizer* r = (NSVGrasterizer*)malloc(sizeof(NSVGrasterizer));
	if (r == NULL) goto error;
	memset(r, 0, sizeof(NSVGrasterizer));

	r->tessTol = 0.25f;
	r->distTol = 0.01f;

	return r;

error:
	nsvgDeleteRasterizer(r);
	return NULL;
}

void nsvgDeleteRasterizer(NSVGrasterizer* r)
{
	NSVGmemPage* p;

	if (r == NULL) return;

	p = r->pages;
	while (p != NULL) {
		NSVGmemPage* next = p->next;
		free(p);
		p = next;
	}

	if (r->edges) free(r->edges);
	if (r->points) free(r->points);
	if (r->scanline) free(r->scanline);

	free(r);
}

static NSVGmemPage* nsvg__nextPage(NSVGrasterizer* r, NSVGmemPage* cur)
{
	NSVGmemPage *newp;

	// If using existing chain, return the next page in chain
	if (cur != NULL && cur->next != NULL) {
		return cur->next;
	}

	// Alloc new page
	newp = (NSVGmemPage*)malloc(sizeof(NSVGmemPage));
	if (newp == NULL) return NULL;
	memset(newp, 0, sizeof(NSVGmemPage));

	// Add to linked list
	if (cur != NULL)
		cur->next = newp;
	else
		r->pages = newp;

	return newp;
}

static void nsvg__resetPool(NSVGrasterizer* r)
{
	NSVGmemPage* p = r->pages;
	while (p != NULL) {
		p->size = 0;
		p = p->next;
	}
	r->curpage = r->pages;
}

static unsigned char* nsvg__alloc(NSVGrasterizer* r, int size)
{
	unsigned char* buf;
	if (size > NSVG__MEMPAGE_SIZE) return NULL;
	if (r->curpage == NULL || r->curpage->size+size > NSVG__MEMPAGE_SIZE) {
		r->curpage = nsvg__nextPage(r, r->curpage);
	}
	buf = &r->curpage->mem[r->curpage->size];
	r->curpage->size += size;
	return buf;
}

static int nsvg__ptEquals(float x1, float y1, float x2, float y2, float tol)
{
	float dx = x2 - x1;
	float dy = y2 - y1;
	return dx*dx + dy*dy < tol*tol;
}

static void nsvg__addPathPoint(NSVGrasterizer* r, float x, float y, int flags)
{
	NSVGpoint* pt;

	if (r->npoints > 0) {
		pt = &r->points[r->npoints-1];
		if (nsvg__ptEquals(pt->x,pt->y, x,y, r->distTol)) {
			pt->flags |= flags;
			return;
		}
	}

	if (r->npoints+1 > r->cpoints) {
		r->cpoints = r->cpoints > 0 ? r->cpoints * 2 : 64;
		r->points = (NSVGpoint*)realloc(r->points, sizeof(NSVGpoint) * r->cpoints);
		if (r->points == NULL) return;
	}

	pt = &r->points[r->npoints];
	pt->x = x;
	pt->y = y;
	pt->flags = flags;
	r->npoints++;
}

static void nsvg__addEdge(NSVGrasterizer* r, float x0, float y0, float x1, float y1)
{
	NSVGedge* e;

	// Skip horizontal edges
	if (y0 == y1)
		return;

	if (r->nedges+1 > r->cedges) {
		r->cedges = r->cedges > 0 ? r->cedges * 2 : 64;
		r->edges = (NSVGedge*)realloc(r->edges, sizeof(NSVGedge) * r->cedges);
		if (r->edges == NULL) return;
	}

	e = &r->edges[r->nedges];
	r->nedges++;

	if (y0 < y1) {
		e->x0 = x0;
		e->y0 = y0;
		e->x1 = x1;
		e->y1 = y1;
		e->dir = 1;
	} else {
		e->x0 = x1;
		e->y0 = y1;
		e->x1 = x0;
		e->y1 = y0;
		e->dir = -1;
	}
}

static float nsvg__normalize(float *x, float* y)
{
	float d = sqrtf((*x)*(*x) + (*y)*(*y));
	if (d > 1e-6f) {
		float id = 1.0f / d;
		*x *= id;
		*y *= id;
	}
	return d;
}

static float nsvg__absf(float x) { return x < 0 ? -x : x; }

static void nsvg__flattenCubicBez(NSVGrasterizer* r,
								  float x1, float y1, float x2, float y2,
								  float x3, float y3, float x4, float y4,
								  int level, int type)
{
	float x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234;
	float dx,dy,d2,d3;

	if (level > 10) return;

	x12 = (x1+x2)*0.5f;
	y12 = (y1+y2)*0.5f;
	x23 = (x2+x3)*0.5f;
	y23 = (y2+y3)*0.5f;
	x34 = (x3+x4)*0.5f;
	y34 = (y3+y4)*0.5f;
	x123 = (x12+x23)*0.5f;
	y123 = (y12+y23)*0.5f;

	dx = x4 - x1;
	dy = y4 - y1;
	d2 = nsvg__absf(((x2 - x4) * dy - (y2 - y4) * dx));
	d3 = nsvg__absf(((x3 - x4) * dy - (y3 - y4) * dx));

	if ((d2 + d3)*(d2 + d3) < r->tessTol * (dx*dx + dy*dy)) {
		nsvg__addPathPoint(r, x4, y4, type);
		return;
	}

	x234 = (x23+x34)*0.5f;
	y234 = (y23+y34)*0.5f;
	x1234 = (x123+x234)*0.5f;
	y1234 = (y123+y234)*0.5f;

	nsvg__flattenCubicBez(r, x1,y1, x12,y12, x123,y123, x1234,y1234, level+1, 0);
	nsvg__flattenCubicBez(r, x1234,y1234, x234,y234, x34,y34, x4,y4, level+1, type);
}

static void nsvg__flattenShape(NSVGrasterizer* r, NSVGshape* shape, float scale)
{
	int i, j;
	NSVGpath* path;

	for (path = shape->paths; path != NULL; path = path->next) {
		r->npoints = 0;
		// Flatten path
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, 0);
		for (i = 0; i < path->npts-1; i += 3) {
			float* p = &path->pts[i*2];
			nsvg__flattenCubicBez(r, p[0]*scale,p[1]*scale, p[2]*scale,p[3]*scale, p[4]*scale,p[5]*scale, p[6]*scale,p[7]*scale, 0, 0);
		}
		// Close path
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, 0);
		// Build edges
		for (i = 0, j = r->npoints-1; i < r->npoints; j = i++)
			nsvg__addEdge(r, r->points[j].x, r->points[j].y, r->points[i].x, r->points[i].y);
	}
}

enum NSVGpointFlags
{
	NSVG_PT_CORNER = 0x01,
	NSVG_PT_BEVEL = 0x02,
	NSVG_PT_LEFT = 0x04,
};

static void nsvg__initClosed(NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dx = p1->x - p0->x;
	float dy = p1->y - p0->y;
	float len = nsvg__normalize(&dx, &dy);
	float px = p0->x + dx*len*0.5f, py = p0->y + dy*len*0.5f;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__buttCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)
{
	float w = lineWidth * 0.5f;
	float px = p->x, py = p->y;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;

	nsvg__addEdge(r, lx, ly, rx, ry);

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__squareCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)
{
	float w = lineWidth * 0.5f;
	float px = p->x - dx*w, py = p->y - dy*w;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;

	nsvg__addEdge(r, lx, ly, rx, ry);

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

#ifndef NSVG_PI
#define NSVG_PI (3.14159265358979323846264338327f)
#endif

static void nsvg__roundCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int ncap, int connect)
{
	int i;
	float w = lineWidth * 0.5f;
	float px = p->x, py = p->y;
	float dlx = dy, dly = -dx;
	float lx, ly, rx, ry, prevx, prevy;

	for (i = 0; i < ncap; i++) {
		float a = i/(float)(ncap-1)*NSVG_PI;
		float ax = cosf(a) * w, ay = sinf(a) * w;
		float x = px - dlx*ax - dx*ay;
		float y = py - dly*ax - dy*ay;

		if (i > 0)
			nsvg__addEdge(r, prevx, prevy, x, y);

		prevx = x;
		prevy = y;

		if (i == 0) {
			lx = x; ly = y;
		} else if (i == ncap-1) {
			rx = x; ry = y;
		}
	}

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__bevelJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float lx0 = p1->x - (dlx0 * w), ly0 = p1->y - (dly0 * w);
	float rx0 = p1->x + (dlx0 * w), ry0 = p1->y + (dly0 * w);
	float lx1 = p1->x - (dlx1 * w), ly1 = p1->y - (dly1 * w);
	float rx1 = p1->x + (dlx1 * w), ry1 = p1->y + (dly1 * w);

	nsvg__addEdge(r, lx0, ly0, left->x, left->y);
	nsvg__addEdge(r, lx1, ly1, lx0, ly0);

	nsvg__addEdge(r, right->x, right->y, rx0, ry0);
	nsvg__addEdge(r, rx0, ry0, rx1, ry1);

	left->x = lx1; left->y = ly1;
	right->x = rx1; right->y = ry1;
}

static void nsvg__miterJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float lx0, rx0, lx1, rx1;
	float ly0, ry0, ly1, ry1;

	if (p1->flags & NSVG_PT_LEFT) {
		lx0 = lx1 = p1->x - p1->dmx * w;
		ly0 = ly1 = p1->y - p1->dmy * w;
		nsvg__addEdge(r, lx1, ly1, left->x, left->y);

		rx0 = p1->x + (dlx0 * w);
		ry0 = p1->y + (dly0 * w);
		rx1 = p1->x + (dlx1 * w);
		ry1 = p1->y + (dly1 * w);
		nsvg__addEdge(r, right->x, right->y, rx0, ry0);
		nsvg__addEdge(r, rx0, ry0, rx1, ry1);
	} else {
		lx0 = p1->x - (dlx0 * w);
		ly0 = p1->y - (dly0 * w);
		lx1 = p1->x - (dlx1 * w);
		ly1 = p1->y - (dly1 * w);
		nsvg__addEdge(r, lx0, ly0, left->x, left->y);
		nsvg__addEdge(r, lx1, ly1, lx0, ly0);

		rx0 = rx1 = p1->x + p1->dmx * w;
		ry0 = ry1 = p1->y + p1->dmy * w;
		nsvg__addEdge(r, right->x, right->y, rx1, ry1);
	}

	left->x = lx1; left->y = ly1;
	right->x = rx1; right->y = ry1;
}

static void nsvg__roundJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth, int ncap)
{
	int i, n;
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float a0 = atan2f(dly0, dlx0);
	float a1 = atan2f(dly1, dlx1);
	float da = a1 - a0;
	float lx, ly, rx, ry;

	if (da < NSVG_PI) da += NSVG_PI*2;
	if (da > NSVG_PI) da -= NSVG_PI*2;

	n = (int)ceilf((nsvg__absf(da) / NSVG_PI) * ncap);
	if (n < 2) n = 2;
	if (n > ncap) n = ncap;

	lx = left->x;
	ly = left->y;
	rx = right->x;
	ry = right->y;

	for (i = 0; i < n; i++) {
		float u = i/(float)(n-1);
		float a = a0 + u*da;
		float ax = cosf(a) * w, ay = sinf(a) * w;
		float lx1 = p1->x - ax, ly1 = p1->y - ay;
		float rx1 = p1->x + ax, ry1 = p1->y + ay;

		nsvg__addEdge(r, lx1, ly1, lx, ly);
		nsvg__addEdge(r, rx, ry, rx1, ry1);

		lx = lx1; ly = ly1;
		rx = rx1; ry = ry1;
	}

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__straightJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float lx = p1->x - (p1->dmx * w), ly = p1->y - (p1->dmy * w);
	float rx = p1->x + (p1->dmx * w), ry = p1->y + (p1->dmy * w);

	nsvg__addEdge(r, lx, ly, left->x, left->y);
	nsvg__addEdge(r, right->x, right->y, rx, ry);

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static int nsvg__curveDivs(float r, float arc, float tol)
{
	float da = acosf(r / (r + tol)) * 2.0f;
	int divs = (int)ceilf(arc / da);
	if (divs < 2) divs = 2;
	return divs;
}

static void nsvg__flattenShapeStroke(NSVGrasterizer* r, NSVGshape* shape, float scale)
{
	int i, j, closed;
	int s, e;
	NSVGpath* path;
	NSVGpoint* p0, *p1;
	float miterLimit = 4;
	int lineJoin = shape->strokeLineJoin;
	int lineCap = shape->strokeLineCap;
	float lineWidth = shape->strokeWidth * scale;
	int ncap = nsvg__curveDivs(lineWidth*0.5f, NSVG_PI, r->tessTol);	// Calculate divisions per half circle.
	NSVGpoint left, right, firstLeft, firstRight;

	for (path = shape->paths; path != NULL; path = path->next) {
		r->npoints = 0;
		// Flatten path
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, NSVG_PT_CORNER);
		for (i = 0; i < path->npts-1; i += 3) {
			float* p = &path->pts[i*2];
			nsvg__flattenCubicBez(r, p[0]*scale,p[1]*scale, p[2]*scale,p[3]*scale, p[4]*scale,p[5]*scale, p[6]*scale,p[7]*scale, 0, NSVG_PT_CORNER);
		}
		if (r->npoints < 2)
			continue;

		closed = path->closed;

		// If the first and last points are the same, remove the last, mark as closed path.
		p0 = &r->points[r->npoints-1];
		p1 = &r->points[0];
		if (nsvg__ptEquals(p0->x,p0->y, p1->x,p1->y, r->distTol)) {
			r->npoints--;
			p0 = &r->points[r->npoints-1];
			closed = 1;
		}

		for (i = 0; i < r->npoints; i++) {
			// Calculate segment direction and length
			p0->dx = p1->x - p0->x;
			p0->dy = p1->y - p0->y;
			p0->len = nsvg__normalize(&p0->dx, &p0->dy);
			// Advance
			p0 = p1++;
		}

		// calculate joins
		p0 = &r->points[r->npoints-1];
		p1 = &r->points[0];
		for (j = 0; j < r->npoints; j++) {
			float dlx0, dly0, dlx1, dly1, dmr2, cross;
			dlx0 = p0->dy;
			dly0 = -p0->dx;
			dlx1 = p1->dy;
			dly1 = -p1->dx;
			// Calculate extrusions
			p1->dmx = (dlx0 + dlx1) * 0.5f;
			p1->dmy = (dly0 + dly1) * 0.5f;
			dmr2 = p1->dmx*p1->dmx + p1->dmy*p1->dmy;
			if (dmr2 > 0.000001f) {
				float s = 1.0f / dmr2;
				if (s > 600.0f) {
					s = 600.0f;
				}
				p1->dmx *= s;
				p1->dmy *= s;
			}

			// Clear flags, but keep the corner.
			p1->flags = (p1->flags & NSVG_PT_CORNER) ? NSVG_PT_CORNER : 0;

			// Keep track of left turns.
			cross = p1->dx * p0->dy - p0->dx * p1->dy;
			if (cross > 0.0f)
				p1->flags |= NSVG_PT_LEFT;

			// Check to see if the corner needs to be beveled.
			if (p1->flags & NSVG_PT_CORNER) {
				if ((dmr2 * miterLimit*miterLimit) < 1.0f || lineJoin == NSVG_JOIN_BEVEL || lineJoin == NSVG_JOIN_ROUND) {
					p1->flags |= NSVG_PT_BEVEL;
				}
			}

			p0 = p1++;
		}

		// Build stroke edges
		if (closed) {
			// Looping
			p0 = &r->points[r->npoints-1];
			p1 = &r->points[0];
			s = 0;
			e = r->npoints;
		} else {
			// Add cap
			p0 = &r->points[0];
			p1 = &r->points[1];
			s = 1;
			e = r->npoints-1;
		}

		if (closed) {
			nsvg__initClosed(&left, &right, p0, p1, lineWidth);
			firstLeft = left;
			firstRight = right;
		} else {
			// Add cap
			float dx = p1->x - p0->x;
			float dy = p1->y - p0->y;
			nsvg__normalize(&dx, &dy);
			if (lineCap == NSVG_CAP_BUTT)
				nsvg__buttCap(r, &left, &right, p0, dx, dy, lineWidth, 0);
			else if (lineCap == NSVG_CAP_SQUARE)
				nsvg__squareCap(r, &left, &right, p0, dx, dy, lineWidth, 0);
			else if (lineCap == NSVG_CAP_ROUND)
				nsvg__roundCap(r, &left, &right, p0, dx, dy, lineWidth, ncap, 0);
		}

		for (j = s; j < e; ++j) {
//			if (p1->flags & NSVG_PT_BEVEL) {
			if (p1->flags & NSVG_PT_CORNER) {
				if (lineJoin == NSVG_JOIN_ROUND)
					nsvg__roundJoin(r, &left, &right, p0, p1, lineWidth, ncap);
				else if (lineJoin == NSVG_JOIN_BEVEL || (p1->flags & NSVG_PT_BEVEL))
					nsvg__bevelJoin(r, &left, &right, p0, p1, lineWidth);
				else
					nsvg__miterJoin(r, &left, &right, p0, p1, lineWidth);
			} else {
				nsvg__straightJoin(r, &left, &right, p1, lineWidth);
			}
			p0 = p1++;
		}

		if (closed) {
			// Loop it
			nsvg__addEdge(r, firstLeft.x, firstLeft.y, left.x, left.y);
			nsvg__addEdge(r, right.x, right.y, firstRight.x, firstRight.y);
		} else {
			// Add cap
			float dx = p1->x - p0->x;
			float dy = p1->y - p0->y;
			nsvg__normalize(&dx, &dy);
			if (lineCap == NSVG_CAP_BUTT)
				nsvg__buttCap(r, &right, &left, p1, -dx, -dy, lineWidth, 1);
			else if (lineCap == NSVG_CAP_SQUARE)
				nsvg__squareCap(r, &right, &left, p1, -dx, -dy, lineWidth, 1);
			else if (lineCap == NSVG_CAP_ROUND)
				nsvg__roundCap(r, &right, &left, p1, -dx, -dy, lineWidth, ncap, 1);
		}
	}
}

static int nsvg__cmpEdge(const void *p, const void *q)
{
	NSVGedge* a = (NSVGedge*)p;
	NSVGedge* b = (NSVGedge*)q;

	if (a->y0 < b->y0) return -1;
	if (a->y0 > b->y0) return  1;
	return 0;
}

static NSVGactiveEdge* nsvg__addActive(NSVGrasterizer* r, NSVGedge* e, float startPoint)
{
	 NSVGactiveEdge* z;

	if (r->freelist != NULL) {
		// Restore from freelist.
		z = r->freelist;
		r->freelist = z->next;
	} else {
		// Alloc new edge.
		z = (NSVGactiveEdge*)nsvg__alloc(r, sizeof(NSVGactiveEdge));
		if (z == NULL) return NULL;
	}

	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
//	STBTT_assert(e->y0 <= start_point);
	// round dx down to avoid going too far
	if (dxdy < 0)
		z->dx = -floorf(NSVG__FIX * -dxdy);
	else
		z->dx = floorf(NSVG__FIX * dxdy);
	z->x = floorf(NSVG__FIX * (e->x0 + dxdy * (startPoint - e->y0)));
//	z->x -= off_x * FIX;
	z->ey = e->y1;
	z->next = 0;
	z->dir = e->dir;

	return z;
}

static void nsvg__freeActive(NSVGrasterizer* r, NSVGactiveEdge* z)
{
	z->next = r->freelist;
	r->freelist = z;
}

// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void nsvg__fillActiveEdges(unsigned char* scanline, int len, NSVGactiveEdge* e, int maxWeight, int* xmin, int* xmax)
{
	// non-zero winding fill
	int x0 = 0, w = 0;

	while (e != NULL) {
		if (w == 0) {
			// if we're currently at zero, we need to record the edge start point
			x0 = e->x; w += e->dir;
		} else {
			int x1 = e->x; w += e->dir;
			// if we went to zero, we need to draw
			if (w == 0) {
				int i = x0 >> NSVG__FIXSHIFT;
				int j = x1 >> NSVG__FIXSHIFT;
				if (i < *xmin) *xmin = i;
				if (j > *xmax) *xmax = j;
				if (i < len && j >= 0) {
					if (i == j) {
						// x0,x1 are the same pixel, so compute combined coverage
						scanline[i] += (unsigned char)((x1 - x0) * maxWeight >> NSVG__FIXSHIFT);
					} else {
						if (i >= 0) // add antialiasing for x0
							scanline[i] += (unsigned char)(((NSVG__FIX - (x0 & NSVG__FIXMASK)) * maxWeight) >> NSVG__FIXSHIFT);
						else
							i = -1; // clip

						if (j < len) // add antialiasing for x1
							scanline[j] += (unsigned char)(((x1 & NSVG__FIXMASK) * maxWeight) >> NSVG__FIXSHIFT);
						else
							j = len; // clip

						for (++i; i < j; ++i) // fill pixels between x0 and x1
							scanline[i] += (unsigned char)maxWeight;
					}
				}
			}
		}
		e = e->next;
	}
}

static float nsvg__clampf(float a, float mn, float mx) { return a < mn ? mn : (a > mx ? mx : a); }

static unsigned int nsvg__RGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
	return (r) | (g << 8) | (b << 16) | (a << 24);
}

static unsigned int nsvg__lerpRGBA(unsigned int c0, unsigned int c1, float u)
{
	int iu = (float)(nsvg__clampf(u, 0.0f, 1.0f) * 256.0f);
	int r = (((c0) & 0xff)*(256-iu) + (((c1) & 0xff)*iu)) >> 8;
	int g = (((c0>>8) & 0xff)*(256-iu) + (((c1>>8) & 0xff)*iu)) >> 8;
	int b = (((c0>>16) & 0xff)*(256-iu) + (((c1>>16) & 0xff)*iu)) >> 8;
	int a = (((c0>>24) & 0xff)*(256-iu) + (((c1>>24) & 0xff)*iu)) >> 8;
	return nsvg__RGBA(r,g,b,a);
}

static unsigned int nsvg__applyOpacity(unsigned int c, float u)
{
	int iu = (float)(nsvg__clampf(u, 0.0f, 1.0f) * 256.0f);
	int r = (c) & 0xff;
	int g = (c>>8) & 0xff;
	int b = (c>>16) & 0xff;
	int a = (((c>>24) & 0xff)*iu) >> 8;
	return nsvg__RGBA(r,g,b,a);
}

static void nsvg__scanlineSolid(unsigned char* dst, int count, unsigned char* cover, int x, int y,
								float tx, float ty, float scale, NSVGcachedPaint* cache)
{

	if (cache->type == NSVG_PAINT_COLOR) {
		int i, cr, cg, cb, ca;
		cr = cache->colors[0] & 0xff;
		cg = (cache->colors[0] >> 8) & 0xff;
		cb = (cache->colors[0] >> 16) & 0xff;
		ca = (cache->colors[0] >> 24) & 0xff;

		for (i = 0; i < count; i++) {
			int r,g,b;
			int a = ((int)cover[0] * ca) >> 8;
			int ia = 255 - a;
			// Premultiply
			r = (cr * a) >> 8;
			g = (cg * a) >> 8;
			b = (cb * a) >> 8;

			// Blend over
			r += ((ia * (int)dst[0]) >> 8);
			g += ((ia * (int)dst[1]) >> 8);
			b += ((ia * (int)dst[2]) >> 8);
			a += ((ia * (int)dst[3]) >> 8);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
		}
	} else if (cache->type == NSVG_PAINT_LINEAR_GRADIENT) {
		// TODO: spread modes.
		// TODO: plenty of opportunities to optimize.
		float fx, fy, dx, gy;
		float* t = cache->xform;
		int i, cr, cg, cb, ca;
		unsigned int c;

		fx = (x - tx) / scale;
		fy = (y - ty) / scale;
		dx = 1.0f / scale;

		for (i = 0; i < count; i++) {
			int r,g,b,a,ia;
			gy = fx*t[1] + fy*t[3] + t[5];
			c = cache->colors[(int)nsvg__clampf(gy*255.0f, 0, 255.0f)];
			cr = (c) & 0xff;
			cg = (c >> 8) & 0xff;
			cb = (c >> 16) & 0xff;
			ca = (c >> 24) & 0xff;

			a = ((int)cover[0] * ca) >> 8;
			ia = 255 - a;

			// Premultiply
			r = (cr * a) >> 8;
			g = (cg * a) >> 8;
			b = (cb * a) >> 8;

			// Blend over
			r += ((ia * (int)dst[0]) >> 8);
			g += ((ia * (int)dst[1]) >> 8);
			b += ((ia * (int)dst[2]) >> 8);
			a += ((ia * (int)dst[3]) >> 8);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
			fx += dx;
		}
	} else if (cache->type == NSVG_PAINT_RADIAL_GRADIENT) {
		// TODO: spread modes.
		// TODO: plenty of opportunities to optimize.
		// TODO: focus (fx,fy)
		float fx, fy, dx, gx, gy, gd;
		float* t = cache->xform;
		int i, cr, cg, cb, ca;
		unsigned int c;

		fx = (x - tx) / scale;
		fy = (y - ty) / scale;
		dx = 1.0f / scale;

		for (i = 0; i < count; i++) {
			int r,g,b,a,ia;
			gx = fx*t[0] + fy*t[2] + t[4];
			gy = fx*t[1] + fy*t[3] + t[5];
			gd = sqrtf(gx*gx + gy*gy);
			c = cache->colors[(int)nsvg__clampf(gd*255.0f, 0, 255.0f)];
			cr = (c) & 0xff;
			cg = (c >> 8) & 0xff;
			cb = (c >> 16) & 0xff;
			ca = (c >> 24) & 0xff;

			a = ((int)cover[0] * ca) >> 8;
			ia = 255 - a;

			// Premultiply
			r = (cr * a) >> 8;
			g = (cg * a) >> 8;
			b = (cb * a) >> 8;

			// Blend over
			r += ((ia * (int)dst[0]) >> 8);
			g += ((ia * (int)dst[1]) >> 8);
			b += ((ia * (int)dst[2]) >> 8);
			a += ((ia * (int)dst[3]) >> 8);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
			fx += dx;
		}
	}
}

static void nsvg__rasterizeSortedEdges(NSVGrasterizer *r, float tx, float ty, float scale, NSVGcachedPaint* cache)
{
	NSVGactiveEdge *active = NULL;
	int y, s;
	int e = 0;
	int maxWeight = (255 / NSVG__SUBSAMPLES);  // weight per vertical scanline
	int xmin, xmax;

	for (y = 0; y < r->height; y++) {
		memset(r->scanline, 0, r->width);
		xmin = r->width;
		xmax = 0;
		for (s = 0; s < NSVG__SUBSAMPLES; ++s) {
			// find center of pixel for this scanline
			float scany = y*NSVG__SUBSAMPLES + s + 0.5f;
			NSVGactiveEdge **step = &active;

			// update all active edges;
			// remove all active edges that terminate before the center of this scanline
			while (*step) {
				NSVGactiveEdge *z = *step;
				if (z->ey <= scany) {
					*step = z->next; // delete from list
//					NSVG__assert(z->valid);
					nsvg__freeActive(r, z);
				} else {
					z->x += z->dx; // advance to position for current scanline
					step = &((*step)->next); // advance through list
				}
			}

			// resort the list if needed
			for (;;) {
				int changed = 0;
				step = &active;
				while (*step && (*step)->next) {
					if ((*step)->x > (*step)->next->x) {
						NSVGactiveEdge* t = *step;
						NSVGactiveEdge* q = t->next;
						t->next = q->next;
						q->next = t;
						*step = q;
						changed = 1;
					}
					step = &(*step)->next;
				}
				if (!changed) break;
			}

			// insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
			while (e < r->nedges && r->edges[e].y0 <= scany) {
				if (r->edges[e].y1 > scany) {
					NSVGactiveEdge* z = nsvg__addActive(r, &r->edges[e], scany);
					if (z == NULL) break;
					// find insertion point
					if (active == NULL) {
						active = z;
					} else if (z->x < active->x) {
						// insert at front
						z->next = active;
						active = z;
					} else {
						// find thing to insert AFTER
						NSVGactiveEdge* p = active;
						while (p->next && p->next->x < z->x)
							p = p->next;
						// at this point, p->next->x is NOT < z->x
						z->next = p->next;
						p->next = z;
					}
				}
				e++;
			}

			// now process all active edges in non-zero fashion
			if (active != NULL)
				nsvg__fillActiveEdges(r->scanline, r->width, active, maxWeight, &xmin, &xmax);
		}
		// Blit
		if (xmin < 0) xmin = 0;
		if (xmax > r->width-1) xmax = r->width-1;
		if (xmin <= xmax) {
			nsvg__scanlineSolid(&r->bitmap[y * r->stride] + xmin*4, xmax-xmin+1, &r->scanline[xmin], xmin, y, tx,ty,scale,cache);
		}
	}

}

static void nsvg__unpremultiplyAlpha(unsigned char* image, int w, int h, int stride)
{
	int x,y;

	// Unpremultiply
	for (y = 0; y < h; y++) {
		unsigned char *row = &image[y*stride];
		for (x = 0; x < w; x++) {
			int r = row[0], g = row[1], b = row[2], a = row[3];
			if (a != 0) {
				row[0] = (int)(r*255/a);
				row[1] = (int)(g*255/a);
				row[2] = (int)(b*255/a);
			}
			row += 4;
		}
	}

	// Defringe
	for (y = 0; y < h; y++) {
		unsigned char *row = &image[y*stride];
		for (x = 0; x < w; x++) {
			int r = 0, g = 0, b = 0, a = row[3], n = 0;
			if (a == 0) {
				if (x-1 > 0 && row[-1] != 0) {
					r += row[-4];
					g += row[-3];
					b += row[-2];
					n++;
				}
				if (x+1 < w && row[7] != 0) {
					r += row[4];
					g += row[5];
					b += row[6];
					n++;
				}
				if (y-1 > 0 && row[-stride+3] != 0) {
					r += row[-stride];
					g += row[-stride+1];
					b += row[-stride+2];
					n++;
				}
				if (y+1 < h && row[stride+3] != 0) {
					r += row[stride];
					g += row[stride+1];
					b += row[stride+2];
					n++;
				}
				if (n > 0) {
					row[0] = r/n;
					row[1] = g/n;
					row[2] = b/n;
				}
			}
			row += 4;
		}
	}
}

static void nsvg__initPaint(NSVGcachedPaint* cache, NSVGpaint* paint, float opacity)
{
	int i, j;
	NSVGgradient* grad;

	cache->type = paint->type;

	if (paint->type == NSVG_PAINT_COLOR) {
		cache->colors[0] = nsvg__applyOpacity(paint->color, opacity);
		return;
	}

	grad = paint->gradient;

	cache->spread = grad->spread;
	memcpy(cache->xform, grad->xform, sizeof(float)*6);

	if (grad->nstops == 0) {
		for (i = 0; i < 256; i++)
			cache->colors[i] = 0;
	} if (grad->nstops == 1) {
		for (i = 0; i < 256; i++)
			cache->colors[i] = nsvg__applyOpacity(grad->stops[i].color, opacity);
	} else {
		unsigned int ca, cb;
		float ua, ub, du, u;
		int ia, ib, count;

		ca = nsvg__applyOpacity(grad->stops[0].color, opacity);
		ua = nsvg__clampf(grad->stops[0].offset, 0, 1);
		ub = nsvg__clampf(grad->stops[grad->nstops-1].offset, ua, 1);
		ia = ua * 255.0f;
		ib = ub * 255.0f;
		for (i = 0; i < ia; i++) {
			cache->colors[i] = ca;
		}

		for (i = 0; i < grad->nstops-1; i++) {
			ca = nsvg__applyOpacity(grad->stops[i].color, opacity);
			cb = nsvg__applyOpacity(grad->stops[i+1].color, opacity);
			ua = nsvg__clampf(grad->stops[i].offset, 0, 1);
			ub = nsvg__clampf(grad->stops[i+1].offset, 0, 1);
			ia = ua * 255.0f;
			ib = ub * 255.0f;
			count = ib - ia;
			if (count <= 0) continue;
			u = 0;
			du = 1.0f / (float)count;
			for (j = 0; j < count; j++) {
				cache->colors[ia+j] = nsvg__lerpRGBA(ca,cb,u);
				u += du;
			}
		}

		for (i = ib; i < 256; i++)
			cache->colors[i] = cb;
	}

}

/*
static void dumpEdges(NSVGrasterizer* r, const char* name)
{
	float xmin = 0, xmax = 0, ymin = 0, ymax = 0;
	NSVGedge *e = NULL;
	int i;
	if (r->nedges == 0) return;
	FILE* fp = fopen(name, "w");
	if (fp == NULL) return;

	xmin = xmax = r->edges[0].x0;
	ymin = ymax = r->edges[0].y0;
	for (i = 0; i < r->nedges; i++) {
		e = &r->edges[i];
		xmin = nsvg__minf(xmin, e->x0);
		xmin = nsvg__minf(xmin, e->x1);
		xmax = nsvg__maxf(xmax, e->x0);
		xmax = nsvg__maxf(xmax, e->x1);
		ymin = nsvg__minf(ymin, e->y0);
		ymin = nsvg__minf(ymin, e->y1);
		ymax = nsvg__maxf(ymax, e->y0);
		ymax = nsvg__maxf(ymax, e->y1);
	}

	fprintf(fp, "<svg viewBox=\"%f %f %f %f\" xmlns=\"http://www.w3.org/2000/svg\">", xmin, ymin, (xmax - xmin), (ymax - ymin));

	for (i = 0; i < r->nedges; i++) {
		e = &r->edges[i];
		fprintf(fp ,"<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:#000;\" />", e->x0,e->y0, e->x1,e->y1);
	}

	for (i = 0; i < r->npoints; i++) {
		if (i+1 < r->npoints)
			fprintf(fp ,"<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:#f00;\" />", r->points[i].x, r->points[i].y, r->points[i+1].x, r->points[i+1].y);
		fprintf(fp ,"<circle cx=\"%f\" cy=\"%f\" r=\"1\" style=\"fill:%s;\" />", r->points[i].x, r->points[i].y, r->points[i].flags == 0 ? "#f00" : "#0f0");
	}

	fprintf(fp, "</svg>");
	fclose(fp);
}
*/

void nsvgRasterize(NSVGrasterizer* r,
				   NSVGimage* image, float tx, float ty, float scale,
				   unsigned char* dst, int w, int h, int stride)
{
	NSVGshape *shape = NULL;
	NSVGedge *e = NULL;
	NSVGcachedPaint cache;
	int i;

	r->bitmap = dst;
	r->width = w;
	r->height = h;
	r->stride = stride;

	if (w > r->cscanline) {
		r->cscanline = w;
		r->scanline = (unsigned char*)realloc(r->scanline, w);
		if (r->scanline == NULL) return;
	}

	for (i = 0; i < h; i++)
		memset(&dst[i*stride], 0, w*4);

	for (shape = image->shapes; shape != NULL; shape = shape->next) {
		if (shape->fill.type != NSVG_PAINT_NONE) {
			nsvg__resetPool(r);
			r->freelist = NULL;
			r->nedges = 0;

			nsvg__flattenShape(r, shape, scale);

			// Scale and translate edges
			for (i = 0; i < r->nedges; i++) {
				e = &r->edges[i];
				e->x0 = tx + e->x0;
				e->y0 = (ty + e->y0) * NSVG__SUBSAMPLES;
				e->x1 = tx + e->x1;
				e->y1 = (ty + e->y1) * NSVG__SUBSAMPLES;
			}

			// Rasterize edges
			qsort(r->edges, r->nedges, sizeof(NSVGedge), nsvg__cmpEdge);

			// now, traverse the scanlines and find the intersections on each scanline, use non-zero rule
			nsvg__initPaint(&cache, &shape->fill, shape->opacity);

			nsvg__rasterizeSortedEdges(r, tx,ty,scale, &cache);
		}
		if (shape->stroke.type != NSVG_PAINT_NONE && (shape->strokeWidth * scale) > 0.01f) {
			nsvg__resetPool(r);
			r->freelist = NULL;
			r->nedges = 0;

			nsvg__flattenShapeStroke(r, shape, scale);

//			dumpEdges(r, "edge.svg");

			// Scale and translate edges
			for (i = 0; i < r->nedges; i++) {
				e = &r->edges[i];
				e->x0 = tx + e->x0;
				e->y0 = (ty + e->y0) * NSVG__SUBSAMPLES;
				e->x1 = tx + e->x1;
				e->y1 = (ty + e->y1) * NSVG__SUBSAMPLES;
			}

			// Rasterize edges
			qsort(r->edges, r->nedges, sizeof(NSVGedge), nsvg__cmpEdge);

			// now, traverse the scanlines and find the intersections on each scanline, use non-zero rule
			nsvg__initPaint(&cache, &shape->stroke, shape->opacity);

			nsvg__rasterizeSortedEdges(r, tx,ty,scale, &cache);
		}
	}

	nsvg__unpremultiplyAlpha(dst, w, h, stride);

	r->bitmap = NULL;
	r->width = 0;
	r->height = 0;
	r->stride = 0;
}

#endif

/*
#define STBI_MALLOC(x)    spot_malloc(x)
#define STBI_FREE(p)      spot_free(p)
#define STBI_REALLOC(p,x) spot_realloc(p,x)
*/
#define STB_IMAGE_STATIC
#define STBI_NO_STDIO

//#line 1 "stb_image.c"

//#line 1 "stb_image.h"
#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 16-bit-per-channel PNG
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - no 1-bit BMP
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x       -- outputs image width in pixels
//    int *y       -- outputs image height in pixels
//    int *comp    -- outputs # of image components in image file
//    int req_comp -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
// If req_comp is non-zero, *comp has the number of components that _would_
// have been output otherwise. E.g. if you set req_comp to 4, you will always
// get RGBA output, but you can check *comp to see if it's trivially opaque
// because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
// can be queried for an extremely brief, end-user unfriendly explanation
// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy to use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries do not emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// make more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// The output of the JPEG decoder is slightly different from versions where
// SIMD support was introduced (that is, for versions before 1.49). The
// difference is only +-1 in the 8-bit RGB channels, and only on a small
// fraction of pixels. You can force the pre-1.49 behavior by defining
// STBI_JPEG_OLD, but this will disable some of the SIMD decoding path
// and hence cost some performance.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image now supports loading HDR images in general, and currently
// the Radiance .HDR file format, although the support is provided
// generically. You can still load any file through the existing interface;
// if you attempt to load an HDR file, it will be automatically remapped to
// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB, even though
// they are internally encoded differently. You can disable this conversion
// by by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through (which
// is BGR stored in RGB).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for req_comp

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

typedef unsigned char stbi_uc;

#ifdef __cplusplus
extern "C" {
#endif

#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

STBIDEF stbi_uc *stbi_load               (char              const *filename,           int *x, int *y, int *comp, int req_comp);
STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *comp, int req_comp);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load_from_file  (FILE *f,                  int *x, int *y, int *comp, int req_comp);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf                 (char const *filename,           int *x, int *y, int *comp, int req_comp);
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf_from_file  (FILE *f,                int *x, int *y, int *comp, int req_comp);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_HDR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO

// get a VERY brief reason for failure
// NOT THREADSAFE
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);

#endif

// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

#ifndef STBI_NO_DDS

//#line 1 "stbi_DDS.h"
#ifndef HEADER_STB_IMAGE_DDS_AUGMENTATION
#define HEADER_STB_IMAGE_DDS_AUGMENTATION

/*	is it a DDS file? */
extern int      stbi__dds_test_memory      (stbi_uc const *buffer, int len);
extern int      stbi__dds_test_callbacks   (stbi_io_callbacks const *clbk, void *user);

extern stbi_uc *stbi__dds_load_from_path   (const char *filename,           int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi__dds_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi__dds_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern int      stbi__dds_test_filename    (char const *filename);
extern int      stbi__dds_test_file        (FILE *f);
extern stbi_uc *stbi__dds_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

extern int      stbi__dds_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__dds_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int *iscompressed);

#ifndef STBI_NO_STDIO
extern int      stbi__dds_info_from_path   (char const *filename,     int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__dds_info_from_file   (FILE *f,                  int *x, int *y, int *comp, int *iscompressed);
#endif

/*
//
////   end header file   /////////////////////////////////////////////////////*/
#endif /* HEADER_STB_IMAGE_DDS_AUGMENTATION */


#endif

#ifndef STBI_NO_PVR

//#line 1 "stbi_pvr.h"
#ifndef HEADER_STB_IMAGE_PVR_AUGMENTATION
#define HEADER_STB_IMAGE_PVR_AUGMENTATION

/*	is it a PVR file? */
extern int      stbi__pvr_test_memory      (stbi_uc const *buffer, int len);
extern int      stbi__pvr_test_callbacks   (stbi_io_callbacks const *clbk, void *user);

extern stbi_uc *stbi__pvr_load_from_path   (char const *filename,           int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi__pvr_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi__pvr_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern int      stbi__pvr_test_filename    (char const *filename);
extern int      stbi__pvr_test_file        (FILE *f);
extern stbi_uc *stbi__pvr_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

extern int      stbi__pvr_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__pvr_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int *iscompressed);

#ifndef STBI_NO_STDIO
extern int      stbi__pvr_info_from_path   (char const *filename,     int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__pvr_info_from_file   (FILE *f,                  int *x, int *y, int *comp, int *iscompressed);
#endif

/*
//
////   end header file   /////////////////////////////////////////////////////*/
#endif /* HEADER_STB_IMAGE_PVR_AUGMENTATION */


#endif

#ifndef STBI_NO_PKM

//#line 1 "stbi_pkm.h"
#ifndef HEADER_STB_IMAGE_PKM_AUGMENTATION
#define HEADER_STB_IMAGE_PKM_AUGMENTATION

/*	is it a PKM file? */
extern int      stbi__pkm_test_memory      (stbi_uc const *buffer, int len);
extern int      stbi__pkm_test_callbacks   (stbi_io_callbacks const *clbk, void *user);

extern stbi_uc *stbi__pkm_load_from_path   (char const *filename,           int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi__pkm_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern stbi_uc *stbi__pkm_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern int      stbi__pkm_test_filename    (char const *filename);
extern int      stbi__pkm_test_file        (FILE *f);
extern stbi_uc *stbi__pkm_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

extern int      stbi__pkm_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp);
extern int      stbi__pkm_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
extern int      stbi__pkm_info_from_path   (char const *filename,     int *x, int *y, int *comp);
extern int      stbi__pkm_info_from_file   (FILE *f,                  int *x, int *y, int *comp);
#endif

/*
//
////   end header file   /////////////////////////////////////////////////////*/
#endif /* HEADER_STB_IMAGE_PKM_AUGMENTATION */


#endif

#ifndef STBI_NO_EXT

//#line 1 "stbi_ext.h"
#ifndef HEADER_STB_IMAGE_EXT
#define HEADER_STB_IMAGE_EXT

enum {
	STBI_unknown= 0,
	STBI_jpeg	= 1,
	STBI_png	= 2,
	STBI_bmp	= 3,
	STBI_gif	= 4,
	STBI_tga	= 5,
	STBI_psd	= 6,
	STBI_pic	= 7,
	STBI_pnm	= 8,
	STBI_dds	= 9,
	STBI_pvr	= 10,
	STBI_pkm	= 11,
	STBI_hdr	= 12
};

extern int      stbi_test_from_memory      (stbi_uc const *buffer, int len);
extern int      stbi_test_from_callbacks   (stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
extern int      stbi_test					(char const *filename);
extern int      stbi_test_from_file        (FILE *f);
#endif

#endif /* HEADER_STB_IMAGE_EXT */


#endif

#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

/*
   revision history:
	  2.02  (2015-01-19) fix incorrect assert, fix warning
	  2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
	  2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
	  2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
						 progressive JPEG (stb)
						 PGM/PPM support (Ken Miller)
						 STBI_MALLOC,STBI_REALLOC,STBI_FREE
						 GIF bugfix -- seemingly never worked
						 STBI_NO_*, STBI_ONLY_*
	  1.48  (2014-12-14) fix incorrectly-named assert()
	  1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
						 optimize PNG (ryg)
						 fix bug in interlaced PNG with user-specified channel count (stb)
	  1.46  (2014-08-26)
			  fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
	  1.45  (2014-08-16)
			  fix MSVC-ARM internal compiler error by wrapping malloc
	  1.44  (2014-08-07)
			  various warning fixes from Ronny Chevalier
	  1.43  (2014-07-15)
			  fix MSVC-only compiler problem in code changed in 1.42
	  1.42  (2014-07-09)
			  don't define _CRT_SECURE_NO_WARNINGS (affects user code)
			  fixes to stbi__cleanup_jpeg path
			  added STBI_ASSERT to avoid requiring assert.h
	  1.41  (2014-06-25)
			  fix search&replace from 1.36 that messed up comments/error messages
	  1.40  (2014-06-22)
			  fix gcc struct-initialization warning
	  1.39  (2014-06-15)
			  fix to TGA optimization when req_comp != number of components in TGA;
			  fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
			  add support for BMP version 5 (more ignored fields)
	  1.38  (2014-06-06)
			  suppress MSVC warnings on integer casts truncating values
			  fix accidental rename of 'skip' field of I/O
	  1.37  (2014-06-04)
			  remove duplicate typedef
	  1.36  (2014-06-03)
			  convert to header file single-file library
			  if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
	  1.35  (2014-05-27)
			  various warnings
			  fix broken STBI_SIMD path
			  fix bug where stbi_load_from_file no longer left file pointer in correct place
			  fix broken non-easy path for 32-bit BMP (possibly never used)
			  TGA optimization by Arseny Kapoulkine
	  1.34  (unknown)
			  use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
	  1.33  (2011-07-14)
			  make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
	  1.32  (2011-07-13)
			  support for "info" function for all supported filetypes (SpartanJ)
	  1.31  (2011-06-20)
			  a few more leak fixes, bug in PNG handling (SpartanJ)
	  1.30  (2011-06-11)
			  added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
			  removed deprecated format-specific test/load functions
			  removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
			  error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
			  fix inefficiency in decoding 32-bit BMP (David Woo)
	  1.29  (2010-08-16)
			  various warning fixes from Aurelien Pocheville
	  1.28  (2010-08-01)
			  fix bug in GIF palette transparency (SpartanJ)
	  1.27  (2010-08-01)
			  cast-to-stbi_uc to fix warnings
	  1.26  (2010-07-24)
			  fix bug in file buffering for PNG reported by SpartanJ
	  1.25  (2010-07-17)
			  refix trans_data warning (Won Chun)
	  1.24  (2010-07-12)
			  perf improvements reading from files on platforms with lock-heavy fgetc()
			  minor perf improvements for jpeg
			  deprecated type-specific functions so we'll get feedback if they're needed
			  attempt to fix trans_data warning (Won Chun)
	  1.23    fixed bug in iPhone support
	  1.22  (2010-07-10)
			  removed image *writing* support
			  stbi_info support from Jetro Lauha
			  GIF support from Jean-Marc Lienher
			  iPhone PNG-extensions from James Brown
			  warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
	  1.21    fix use of 'stbi_uc' in header (reported by jon blow)
	  1.20    added support for Softimage PIC, by Tom Seddon
	  1.19    bug in interlaced PNG corruption check (found by ryg)
	  1.18 2008-08-02
			  fix a threading bug (local mutable static)
	  1.17    support interlaced PNG
	  1.16    major bugfix - stbi__convert_format converted one too many pixels
	  1.15    initialize some fields for thread safety
	  1.14    fix threadsafe conversion bug
			  header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
	  1.13    threadsafe
	  1.12    const qualifiers in the API
	  1.11    Support installable IDCT, colorspace conversion routines
	  1.10    Fixes for 64-bit (don't use "unsigned long")
			  optimized upsampling by Fabian "ryg" Giesen
	  1.09    Fix format-conversion for PSD code (bad global variables!)
	  1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
	  1.07    attempt to fix C++ warning/errors again
	  1.06    attempt to fix C++ warning/errors again
	  1.05    fix TGA loading to return correct *comp and use good luminance calc
	  1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
	  1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
	  1.02    support for (subset of) HDR files, float interface for preferred access to them
	  1.01    fix bug: possible bug in handling right-side up bmps... not sure
			  fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
	  1.00    interface to zlib that skips zlib header
	  0.99    correct handling of alpha in palette
	  0.98    TGA loader by lonesock; dynamically add loaders (untested)
	  0.97    jpeg errors on too large a file; also catch another malloc failure
	  0.96    fix detection of invalid v value - particleman@mollyrocket forum
	  0.95    during header scan, seek to markers in case of padding
	  0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
	  0.93    handle jpegtran output; verbose errors
	  0.92    read 4,8,16,24,32-bit BMP files of several formats
	  0.91    output 24-bit Windows 3.0 BMP files
	  0.90    fix a few more warnings; bump version number to approach 1.0
	  0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
	  0.60    fix compiling as c++
	  0.59    fix warnings: merge Dave Moore's -Wall fixes
	  0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
	  0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
	  0.56    fix bug: zlib uncompressed mode len vs. nlen
	  0.55    fix bug: restart_interval not initialized to 0
	  0.54    allow NULL for 'int *comp'
	  0.53    fix bug in png 3->4; speedup png decoding
	  0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
	  0.51    obey req_comp requests, 1-component jpegs return as 1-component,
			  on 'test' only check type, not whether we support this variant
	  0.50    first released version
*/

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif

#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && defined(STBI_REALLOC)
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)    malloc(sz)
#define STBI_REALLOC(p,sz) realloc(p,sz)
#define STBI_FREE(p)       free(p)
#endif

#if defined(__GNUC__) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// (but compiling with -msse2 allows the compiler to use SSE2 everywhere;
// this is just broken and gcc are jerks for not fixing it properly
// http://www.virtualdub.org/blog/pivot/entry.php?id=363 )
#define STBI_NO_SIMD
#endif

#if !defined(STBI_NO_SIMD) && (defined(__x86_64__) || defined(_M_X64) || defined(__i386) || defined(_M_IX86))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
	  mov  eax,1
	  cpuid
	  mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

static int stbi__sse2_available()
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

static int stbi__sse2_available()
{
#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) >= 408 // GCC 4.8 or later
   // GCC 4.8+ has a nice way to do this
   return __builtin_cpu_supports("sse2");
#else
   // portable way to do this, preferably without using GCC inline ASM?
   // just bail for now.
   return 0;
#endif
}
#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
// assume GCC or Clang on ARM targets
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original;
} stbi__context;

static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   fseek((FILE*) user, n, SEEK_CUR);
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
}

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static stbi_uc *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static stbi_uc *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static stbi_uc *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static stbi_uc *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_DDS

static int      stbi__dds_test(stbi__context *s);
static stbi_uc *stbi__dds_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
#endif

#ifndef STBI_NO_PVR

static int      stbi__pvr_test(stbi__context *s);
static stbi_uc *stbi__pvr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
#endif

#ifndef STBI_NO_PKM

static int      stbi__pkm_test(stbi__context *s);
static stbi_uc *stbi__pkm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
#endif

// this is not threadsafe
static const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}

static void *stbi__malloc(size_t size)
{
	return STBI_MALLOC(size);
}

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static unsigned char *stbi_load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   /* textures first, as they need to be done (often) quickly */
   #ifndef STBI_NO_DDS
   if (stbi__dds_test(s))  return stbi__dds_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_PVR
   if (stbi__pvr_test(s))  return stbi__pvr_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_PKM
   if (stbi__pkm_test(s))  return stbi__pkm_load(s,x,y,comp,req_comp);
   #endif
   /* common image formats first */
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp);
   #endif
   /* others */
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
	  float *hdr = stbi__hdr_load(s, x,y,comp,req_comp);
	  return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp);
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
	  return stbi__tga_load(s,x,y,comp,req_comp);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

#ifndef STBI_NO_STDIO

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
	  f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}

STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi_load_main(&s,x,y,comp,req_comp);
   if (result) {
	  // need to 'unget' all the characters in the IO buffer
	  fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}
#endif //!STBI_NO_STDIO

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi_load_main(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi_load_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_LINEAR
static float *stbi_loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s))
	  return stbi__hdr_load(s,x,y,comp,req_comp);
   #endif
   data = stbi_load_main(s, x, y, comp, req_comp);
   if (data)
	  return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi_loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi_loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi_loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
	  result = stbi_is_hdr_from_file(f);
	  fclose(f);
   }
   return result;
}

STBIDEF int      stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__hdr_test(&s);
   #else
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   return 0;
   #endif
}

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

#ifndef STBI_NO_LINEAR
STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }

//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   if (n == 0) {
	  // at end of file, treat same as if from memory, but need to handle case
	  // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
	  s->read_from_callbacks = 0;
	  s->img_buffer = s->buffer_start;
	  s->img_buffer_end = s->buffer_start+1;
	  *s->img_buffer = 0;
   } else {
	  s->img_buffer = s->buffer_start;
	  s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
	  return *s->img_buffer++;
   if (s->read_from_callbacks) {
	  stbi__refill_buffer(s);
	  return *s->img_buffer++;
   }
   return 0;
}

stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
	  if (!(s->io.eof)(s->io_user_data)) return 0;
	  // if feof() is true, check if buffer = end
	  // special case: we've only got the special 0 character at the end
	  if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}

static void stbi__skip(stbi__context *s, int n)
{
   if (s->io.read) {
	  int blen = (int) (s->img_buffer_end - s->img_buffer);
	  if (blen < n) {
		 s->img_buffer = s->img_buffer_end;
		 (s->io.skip)(s->io_user_data, n - blen);
		 return;
	  }
   }
   s->img_buffer += n;
}

static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
	  int blen = (int) (s->img_buffer_end - s->img_buffer);
	  if (blen < n) {
		 int res, count;

		 memcpy(buffer, s->img_buffer, blen);

		 count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
		 res = (count == (n-blen));
		 s->img_buffer = s->img_buffer_end;
		 return res;
	  }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
	  memcpy(buffer, s->img_buffer, n);
	  s->img_buffer += n;
	  return 1;
   } else
	  return 0;
}

static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}

static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}

static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}

static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   return z + (stbi__get16le(s) << 16);
}

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}

static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc(req_comp * x * y);
   if (good == NULL) {
	  STBI_FREE(data);
	  return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
	  unsigned char *src  = data + j * x * img_n   ;
	  unsigned char *dest = good + j * x * req_comp;

	  #define COMBO(a,b)  ((a)*8+(b))
	  #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
	  // convert source image with img_n components to one with req_comp components;
	  // avoid switch per pixel, so use switch per scanline and massive macros
	  switch (COMBO(img_n, req_comp)) {
		 CASE(1,2) dest[0]=src[0], dest[1]=255; break;
		 CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;
		 CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;
		 CASE(2,1) dest[0]=src[0]; break;
		 CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;
		 CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;
		 CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;
		 CASE(3,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
		 CASE(3,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255; break;
		 CASE(4,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
		 CASE(4,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;
		 CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;
		 default: STBI_ASSERT(0);
	  }
	  #undef CASE
   }

   STBI_FREE(data);
   return good;
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output = (float *) stbi__malloc(x * y * comp * sizeof(float));
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
	  for (k=0; k < n; ++k) {
		 output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
	  }
	  if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output = (stbi_uc *) stbi__malloc(x * y * comp);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
	  for (k=0; k < n; ++k) {
		 float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
		 if (z < 0) z = 0;
		 if (z > 255) z = 255;
		 output[i*comp + k] = (stbi_uc) stbi__float2int(z);
	  }
	  if (k < comp) {
		 float z = data[i*comp+k] * 255 + 0.5f;
		 if (z < 0) z = 0;
		 if (z > 255) z = 255;
		 output[i*comp + k] = (stbi_uc) stbi__float2int(z);
	  }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi_uc dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
	  int id;
	  int h,v;
	  int tq;
	  int hd,ha;
	  int dc_pred;

	  int x,y,w2,h2;
	  stbi_uc *data;
	  void *raw_data, *raw_coeff;
	  stbi_uc *linebuf;
	  short   *coeff;   // progressive only
	  int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0,code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
	  for (j=0; j < count[i]; ++j)
		 h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
	  // compute delta to add to code to compute symbol id
	  h->delta[j] = k - code;
	  if (h->size[k] == j) {
		 while (h->size[k] == j)
			h->code[k++] = (stbi__uint16) (code++);
		 if (code-1 >= (1 << j)) return stbi__err("bad code lengths","Corrupt JPEG");
	  }
	  // compute largest code + 1 for this size, preshifted as needed later
	  h->maxcode[j] = code << (16-j);
	  code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
	  int s = h->size[i];
	  if (s <= FAST_BITS) {
		 int c = h->code[i] << (FAST_BITS-s);
		 int m = 1 << (FAST_BITS-s);
		 for (j=0; j < m; ++j) {
			h->fast[c+j] = (stbi_uc) i;
		 }
	  }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
	  stbi_uc fast = h->fast[i];
	  fast_ac[i] = 0;
	  if (fast < 255) {
		 int rs = h->values[fast];
		 int run = (rs >> 4) & 15;
		 int magbits = rs & 15;
		 int len = h->size[fast];

		 if (magbits && len + magbits <= FAST_BITS) {
			// magnitude code followed by receive_extend code
			int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
			int m = 1 << (magbits - 1);
			if (k < m) k += (-1 << magbits) + 1;
			// if the result is small enough, we can fit it in fast_ac table
			if (k >= -128 && k <= 127)
			   fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));
		 }
	  }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
	  int b = j->nomore ? 0 : stbi__get8(j->s);
	  if (b == 0xff) {
		 int c = stbi__get8(j->s);
		 if (c != 0) {
			j->marker = (unsigned char) c;
			j->nomore = 1;
			return;
		 }
	  }
	  j->code_buffer |= b << (24 - j->code_bits);
	  j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
	  int s = h->size[k];
	  if (s > j->code_bits)
		 return -1;
	  j->code_buffer <<= s;
	  j->code_bits -= s;
	  return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
	  if (temp < h->maxcode[k])
		 break;
   if (k == 17) {
	  // error! code not found
	  j->code_bits -= 16;
	  return -1;
   }

   if (k > j->code_bits)
	  return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static int const stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & ~sgn);
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static stbi_uc stbi__jpeg_dezigzag[64+15] =
{
	0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi_uc *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
	  unsigned int zig;
	  int c,r,s;
	  if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
	  c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
	  r = fac[c];
	  if (r) { // fast-AC path
		 k += (r >> 4) & 15; // run
		 s = r & 15; // combined length
		 j->code_buffer <<= s;
		 j->code_bits -= s;
		 // decode into unzigzag'd location
		 zig = stbi__jpeg_dezigzag[k++];
		 data[zig] = (short) ((r >> 8) * dequant[zig]);
	  } else {
		 int rs = stbi__jpeg_huff_decode(j, hac);
		 if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
		 s = rs & 15;
		 r = rs >> 4;
		 if (s == 0) {
			if (rs != 0xf0) break; // end block
			k += 16;
		 } else {
			k += r;
			// decode into unzigzag'd location
			zig = stbi__jpeg_dezigzag[k++];
			data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
		 }
	  }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
	  // first scan for DC coefficient, must be first
	  memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
	  t = stbi__jpeg_huff_decode(j, hdc);
	  diff = t ? stbi__extend_receive(j, t) : 0;

	  dc = j->img_comp[b].dc_pred + diff;
	  j->img_comp[b].dc_pred = dc;
	  data[0] = (short) (dc << j->succ_low);
   } else {
	  // refinement scan for DC coefficient
	  if (stbi__jpeg_get_bit(j))
		 data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
	  int shift = j->succ_low;

	  if (j->eob_run) {
		 --j->eob_run;
		 return 1;
	  }

	  k = j->spec_start;
	  do {
		 unsigned int zig;
		 int c,r,s;
		 if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
		 c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
		 r = fac[c];
		 if (r) { // fast-AC path
			k += (r >> 4) & 15; // run
			s = r & 15; // combined length
			j->code_buffer <<= s;
			j->code_bits -= s;
			zig = stbi__jpeg_dezigzag[k++];
			data[zig] = (short) ((r >> 8) << shift);
		 } else {
			int rs = stbi__jpeg_huff_decode(j, hac);
			if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
			s = rs & 15;
			r = rs >> 4;
			if (s == 0) {
			   if (r < 15) {
				  j->eob_run = (1 << r);
				  if (r)
					 j->eob_run += stbi__jpeg_get_bits(j, r);
				  --j->eob_run;
				  break;
			   }
			   k += 16;
			} else {
			   k += r;
			   zig = stbi__jpeg_dezigzag[k++];
			   data[zig] = (short) (stbi__extend_receive(j,s) << shift);
			}
		 }
	  } while (k <= j->spec_end);
   } else {
	  // refinement scan for these AC coefficients

	  short bit = (short) (1 << j->succ_low);

	  if (j->eob_run) {
		 --j->eob_run;
		 for (k = j->spec_start; k <= j->spec_end; ++k) {
			short *p = &data[stbi__jpeg_dezigzag[k]];
			if (*p != 0)
			   if (stbi__jpeg_get_bit(j))
				  if ((*p & bit)==0){
					 if (*p > 0)
						*p += bit;
					 else
						*p -= bit;
				  }
		 }
	  } else {
		 k = j->spec_start;
		 do {
			int r,s;
			int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
			if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
			s = rs & 15;
			r = rs >> 4;
			if (s == 0) {
			   if (r < 15) {
				  j->eob_run = (1 << r) - 1;
				  if (r)
					 j->eob_run += stbi__jpeg_get_bits(j, r);
				  r = 64; // force end of block
			   } else
				  r = 16; // r=15 is the code for 16 0s
			} else {
			   if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
			   // sign bit
			   if (stbi__jpeg_get_bit(j))
				  s = bit;
			   else
				  s = -bit;
			}

			// advance by r
			while (k <= j->spec_end) {
			   short *p = &data[stbi__jpeg_dezigzag[k]];
			   if (*p != 0) {
				  if (stbi__jpeg_get_bit(j))
					 if ((*p & bit)==0){
						if (*p > 0)
						   *p += bit;
						else
						   *p -= bit;
					 }
				  ++k;
			   } else {
				  if (r == 0) {
					 if (s)
						data[stbi__jpeg_dezigzag[k++]] = (short) s;
					 break;
				  }
				  --r;
				  ++k;
			   }
			}
		 } while (k <= j->spec_end);
	  }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
	  if (x < 0) return 0;
	  if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) << 12)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
	  // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
	  if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
		   && d[40]==0 && d[48]==0 && d[56]==0) {
		 //    no shortcut                 0     seconds
		 //    (1|2|3|4|5|6|7)==0          0     seconds
		 //    all separate               -0.047 seconds
		 //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
		 int dcterm = d[0] << 2;
		 v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
	  } else {
		 STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
		 // constants scaled things up by 1<<12; let's bring them back
		 // down, but keep 2 extra bits of precision
		 x0 += 512; x1 += 512; x2 += 512; x3 += 512;
		 v[ 0] = (x0+t3) >> 10;
		 v[56] = (x0-t3) >> 10;
		 v[ 8] = (x1+t2) >> 10;
		 v[48] = (x1-t2) >> 10;
		 v[16] = (x2+t1) >> 10;
		 v[40] = (x2-t1) >> 10;
		 v[24] = (x3+t0) >> 10;
		 v[32] = (x3-t0) >> 10;
	  }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
	  // no fast case since the first 1D IDCT spread components out
	  STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
	  // constants scaled things up by 1<<12, plus we had 1<<2 from first
	  // loop, plus horizontal and vertical each scale by sqrt(8) so together
	  // we've got an extra 1<<3, so 1<<17 total we need to remove.
	  // so we want to round that, which means adding 0.5 * 1<<17,
	  // aka 65536. Also, we'll end up with -128 to 127 that we want
	  // to encode as 0..255 by adding 128, so we'll add that before the shift
	  x0 += 65536 + (128<<17);
	  x1 += 65536 + (128<<17);
	  x2 += 65536 + (128<<17);
	  x3 += 65536 + (128<<17);
	  // tried computing the shifts into temps, or'ing the temps to see
	  // if any were out of range, but that was slower
	  o[0] = stbi__clamp((x0+t3) >> 17);
	  o[7] = stbi__clamp((x0-t3) >> 17);
	  o[1] = stbi__clamp((x1+t2) >> 17);
	  o[6] = stbi__clamp((x1-t2) >> 17);
	  o[2] = stbi__clamp((x2+t1) >> 17);
	  o[5] = stbi__clamp((x2-t1) >> 17);
	  o[3] = stbi__clamp((x3+t0) >> 17);
	  o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
	  __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
	  __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
	  __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
	  __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
	  __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
	  __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
	  __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
	  __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
	  __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
	  __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
	  __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
	  __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
	  { \
		 __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
		 __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
		 dct_wadd(sum, abiased, b); \
		 dct_wsub(dif, abiased, b); \
		 out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
		 out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
	  }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
	  tmp = a; \
	  a = _mm_unpacklo_epi8(a, b); \
	  b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
	  tmp = a; \
	  a = _mm_unpacklo_epi16(a, b); \
	  b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
	  { \
		 /* even part */ \
		 dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
		 __m128i sum04 = _mm_add_epi16(row0, row4); \
		 __m128i dif04 = _mm_sub_epi16(row0, row4); \
		 dct_widen(t0e, sum04); \
		 dct_widen(t1e, dif04); \
		 dct_wadd(x0, t0e, t3e); \
		 dct_wsub(x3, t0e, t3e); \
		 dct_wadd(x1, t1e, t2e); \
		 dct_wsub(x2, t1e, t2e); \
		 /* odd part */ \
		 dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
		 dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
		 __m128i sum17 = _mm_add_epi16(row1, row7); \
		 __m128i sum35 = _mm_add_epi16(row3, row5); \
		 dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
		 dct_wadd(x4, y0o, y4o); \
		 dct_wadd(x5, y1o, y5o); \
		 dct_wadd(x6, y2o, y5o); \
		 dct_wadd(x7, y3o, y4o); \
		 dct_bfly32o(row0,row7, x0,x7,bias,shift); \
		 dct_bfly32o(row1,row6, x1,x6,bias,shift); \
		 dct_bfly32o(row2,row5, x2,x5,bias,shift); \
		 dct_bfly32o(row3,row4, x3,x4,bias,shift); \
	  }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
	  // 16bit 8x8 transpose pass 1
	  dct_interleave16(row0, row4);
	  dct_interleave16(row1, row5);
	  dct_interleave16(row2, row6);
	  dct_interleave16(row3, row7);

	  // transpose pass 2
	  dct_interleave16(row0, row2);
	  dct_interleave16(row1, row3);
	  dct_interleave16(row4, row6);
	  dct_interleave16(row5, row7);

	  // transpose pass 3
	  dct_interleave16(row0, row1);
	  dct_interleave16(row2, row3);
	  dct_interleave16(row4, row5);
	  dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
	  // pack
	  __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
	  __m128i p1 = _mm_packus_epi16(row2, row3);
	  __m128i p2 = _mm_packus_epi16(row4, row5);
	  __m128i p3 = _mm_packus_epi16(row6, row7);

	  // 8bit 8x8 transpose pass 1
	  dct_interleave8(p0, p2); // a0e0a1e1...
	  dct_interleave8(p1, p3); // c0g0c1g1...

	  // transpose pass 2
	  dct_interleave8(p0, p1); // a0c0e0g0...
	  dct_interleave8(p2, p3); // b0d0f0h0...

	  // transpose pass 3
	  dct_interleave8(p0, p2); // a0b0c0d0...
	  dct_interleave8(p1, p3); // a4b4c4d4...

	  // store
	  _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
	  dct_wadd(sum, a, b); \
	  dct_wsub(dif, a, b); \
	  out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
	  out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
	  /* even part */ \
	  int16x8_t sum26 = vaddq_s16(row2, row6); \
	  dct_long_mul(p1e, sum26, rot0_0); \
	  dct_long_mac(t2e, p1e, row6, rot0_1); \
	  dct_long_mac(t3e, p1e, row2, rot0_2); \
	  int16x8_t sum04 = vaddq_s16(row0, row4); \
	  int16x8_t dif04 = vsubq_s16(row0, row4); \
	  dct_widen(t0e, sum04); \
	  dct_widen(t1e, dif04); \
	  dct_wadd(x0, t0e, t3e); \
	  dct_wsub(x3, t0e, t3e); \
	  dct_wadd(x1, t1e, t2e); \
	  dct_wsub(x2, t1e, t2e); \
	  /* odd part */ \
	  int16x8_t sum15 = vaddq_s16(row1, row5); \
	  int16x8_t sum17 = vaddq_s16(row1, row7); \
	  int16x8_t sum35 = vaddq_s16(row3, row5); \
	  int16x8_t sum37 = vaddq_s16(row3, row7); \
	  int16x8_t sumodd = vaddq_s16(sum17, sum35); \
	  dct_long_mul(p5o, sumodd, rot1_0); \
	  dct_long_mac(p1o, p5o, sum17, rot1_1); \
	  dct_long_mac(p2o, p5o, sum35, rot1_2); \
	  dct_long_mul(p3o, sum37, rot2_0); \
	  dct_long_mul(p4o, sum15, rot2_1); \
	  dct_wadd(sump13o, p1o, p3o); \
	  dct_wadd(sump24o, p2o, p4o); \
	  dct_wadd(sump23o, p2o, p3o); \
	  dct_wadd(sump14o, p1o, p4o); \
	  dct_long_mac(x4, sump13o, row7, rot3_0); \
	  dct_long_mac(x5, sump24o, row5, rot3_1); \
	  dct_long_mac(x6, sump23o, row3, rot3_2); \
	  dct_long_mac(x7, sump14o, row1, rot3_3); \
	  dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
	  dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
	  dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
	  dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

	  // pass 1
	  dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
	  dct_trn16(row2, row3);
	  dct_trn16(row4, row5);
	  dct_trn16(row6, row7);

	  // pass 2
	  dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
	  dct_trn32(row1, row3);
	  dct_trn32(row4, row6);
	  dct_trn32(row5, row7);

	  // pass 3
	  dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
	  dct_trn64(row1, row5);
	  dct_trn64(row2, row6);
	  dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
	  // pack and round
	  uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
	  uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
	  uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
	  uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
	  uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
	  uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
	  uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
	  uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

	  // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

	  // sadly can't use interleaved stores here since we only write
	  // 8 bytes to each scan line!

	  // 8x8 8-bit transpose pass 1
	  dct_trn8_8(p0, p1);
	  dct_trn8_8(p2, p3);
	  dct_trn8_8(p4, p5);
	  dct_trn8_8(p6, p7);

	  // pass 2
	  dct_trn8_16(p0, p2);
	  dct_trn8_16(p1, p3);
	  dct_trn8_16(p4, p6);
	  dct_trn8_16(p5, p7);

	  // pass 3
	  dct_trn8_32(p0, p4);
	  dct_trn8_32(p1, p5);
	  dct_trn8_32(p2, p6);
	  dct_trn8_32(p3, p7);

	  // store
	  vst1_u8(out, p0); out += out_stride;
	  vst1_u8(out, p1); out += out_stride;
	  vst1_u8(out, p2); out += out_stride;
	  vst1_u8(out, p3); out += out_stride;
	  vst1_u8(out, p4); out += out_stride;
	  vst1_u8(out, p5); out += out_stride;
	  vst1_u8(out, p6); out += out_stride;
	  vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
	  x = stbi__get8(j->s);
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
	  if (z->scan_n == 1) {
		 int i,j;
		 STBI_SIMD_ALIGN(short, data[64]);
		 int n = z->order[0];
		 // non-interleaved data, we just need to process one block at a time,
		 // in trivial scanline order
		 // number of blocks to do just depends on how many actual "pixels" this
		 // component has, independent of interleaved MCU blocking and such
		 int w = (z->img_comp[n].x+7) >> 3;
		 int h = (z->img_comp[n].y+7) >> 3;
		 for (j=0; j < h; ++j) {
			for (i=0; i < w; ++i) {
			   int ha = z->img_comp[n].ha;
			   if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
			   z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
			   // every data block is an MCU, so countdown the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  // if it's NOT a restart, then just bail, so we get corrupt data
				  // rather than no data
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  } else { // interleaved
		 int i,j,k,x,y;
		 STBI_SIMD_ALIGN(short, data[64]);
		 for (j=0; j < z->img_mcu_y; ++j) {
			for (i=0; i < z->img_mcu_x; ++i) {
			   // scan an interleaved mcu... process scan_n components in order
			   for (k=0; k < z->scan_n; ++k) {
				  int n = z->order[k];
				  // scan out an mcu's worth of this component; that's just determined
				  // by the basic H and V specified for the component
				  for (y=0; y < z->img_comp[n].v; ++y) {
					 for (x=0; x < z->img_comp[n].h; ++x) {
						int x2 = (i*z->img_comp[n].h + x)*8;
						int y2 = (j*z->img_comp[n].v + y)*8;
						int ha = z->img_comp[n].ha;
						if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
						z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
					 }
				  }
			   }
			   // after all interleaved components, that's an interleaved MCU,
			   // so now count down the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  }
   } else {
	  if (z->scan_n == 1) {
		 int i,j;
		 int n = z->order[0];
		 // non-interleaved data, we just need to process one block at a time,
		 // in trivial scanline order
		 // number of blocks to do just depends on how many actual "pixels" this
		 // component has, independent of interleaved MCU blocking and such
		 int w = (z->img_comp[n].x+7) >> 3;
		 int h = (z->img_comp[n].y+7) >> 3;
		 for (j=0; j < h; ++j) {
			for (i=0; i < w; ++i) {
			   short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
			   if (z->spec_start == 0) {
				  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
					 return 0;
			   } else {
				  int ha = z->img_comp[n].ha;
				  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
					 return 0;
			   }
			   // every data block is an MCU, so countdown the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  } else { // interleaved
		 int i,j,k,x,y;
		 for (j=0; j < z->img_mcu_y; ++j) {
			for (i=0; i < z->img_mcu_x; ++i) {
			   // scan an interleaved mcu... process scan_n components in order
			   for (k=0; k < z->scan_n; ++k) {
				  int n = z->order[k];
				  // scan out an mcu's worth of this component; that's just determined
				  // by the basic H and V specified for the component
				  for (y=0; y < z->img_comp[n].v; ++y) {
					 for (x=0; x < z->img_comp[n].h; ++x) {
						int x2 = (i*z->img_comp[n].h + x);
						int y2 = (j*z->img_comp[n].v + y);
						short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
						if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
						   return 0;
					 }
				  }
			   }
			   // after all interleaved components, that's an interleaved MCU,
			   // so now count down the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi_uc *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
	  data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
	  // dequantize and idct the data
	  int i,j,n;
	  for (n=0; n < z->s->img_n; ++n) {
		 int w = (z->img_comp[n].x+7) >> 3;
		 int h = (z->img_comp[n].y+7) >> 3;
		 for (j=0; j < h; ++j) {
			for (i=0; i < w; ++i) {
			   short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
			   stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
			   z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
			}
		 }
	  }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
	  case STBI__MARKER_none: // no marker found
		 return stbi__err("expected marker","Corrupt JPEG");

	  case 0xDD: // DRI - specify restart interval
		 if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
		 z->restart_interval = stbi__get16be(z->s);
		 return 1;

	  case 0xDB: // DQT - define quantization table
		 L = stbi__get16be(z->s)-2;
		 while (L > 0) {
			int q = stbi__get8(z->s);
			int p = q >> 4;
			int t = q & 15,i;
			if (p != 0) return stbi__err("bad DQT type","Corrupt JPEG");
			if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");
			for (i=0; i < 64; ++i)
			   z->dequant[t][stbi__jpeg_dezigzag[i]] = stbi__get8(z->s);
			L -= 65;
		 }
		 return L==0;

	  case 0xC4: // DHT - define huffman table
		 L = stbi__get16be(z->s)-2;
		 while (L > 0) {
			stbi_uc *v;
			int sizes[16],i,n=0;
			int q = stbi__get8(z->s);
			int tc = q >> 4;
			int th = q & 15;
			if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
			for (i=0; i < 16; ++i) {
			   sizes[i] = stbi__get8(z->s);
			   n += sizes[i];
			}
			L -= 17;
			if (tc == 0) {
			   if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
			   v = z->huff_dc[th].values;
			} else {
			   if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
			   v = z->huff_ac[th].values;
			}
			for (i=0; i < n; ++i)
			   v[i] = stbi__get8(z->s);
			if (tc != 0)
			   stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
			L -= n;
		 }
		 return L==0;
   }
   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
	  stbi__skip(z->s, stbi__get16be(z->s)-2);
	  return 1;
   }
   return 0;
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
	  int id = stbi__get8(z->s), which;
	  int q = stbi__get8(z->s);
	  for (which = 0; which < z->s->img_n; ++which)
		 if (z->img_comp[which].id == id)
			break;
	  if (which == z->s->img_n) return 0; // no match
	  z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
	  z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
	  z->order[i] = which;
   }

   {
	  int aa;
	  z->spec_start = stbi__get8(z->s);
	  z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
	  aa = stbi__get8(z->s);
	  z->succ_high = (aa >> 4);
	  z->succ_low  = (aa & 15);
	  if (z->progressive) {
		 if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
			return stbi__err("bad SOS", "Corrupt JPEG");
	  } else {
		 if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
		 if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
		 z->spec_end = 63;
	  }
   }

   return 1;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   c = stbi__get8(s);
   if (c != 3 && c != 1) return stbi__err("bad component count","Corrupt JPEG");    // JFIF requires
   s->img_n = c;
   for (i=0; i < c; ++i) {
	  z->img_comp[i].data = NULL;
	  z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   for (i=0; i < s->img_n; ++i) {
	  z->img_comp[i].id = stbi__get8(s);
	  if (z->img_comp[i].id != i+1)   // JFIF requires
		 if (z->img_comp[i].id != i)  // some version of jpegtran outputs non-JFIF-compliant files!
			return stbi__err("bad component ID","Corrupt JPEG");
	  q = stbi__get8(s);
	  z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
	  z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
	  z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
	  if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
	  if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
	  // number of effective pixels (e.g. for non-interleaved MCU)
	  z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
	  z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
	  // to simplify generation, we'll allocate enough memory to decode
	  // the bogus oversized data from using interleaved MCUs and their
	  // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
	  // discard the extra data until colorspace conversion
	  z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
	  z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
	  z->img_comp[i].raw_data = stbi__malloc(z->img_comp[i].w2 * z->img_comp[i].h2+15);

	  if (z->img_comp[i].raw_data == NULL) {
		 for(--i; i >= 0; --i) {
			STBI_FREE(z->img_comp[i].raw_data);
			z->img_comp[i].data = NULL;
		 }
		 return stbi__err("outofmem", "Out of memory");
	  }
	  // align blocks for idct using mmx/sse
	  z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
	  z->img_comp[i].linebuf = NULL;
	  if (z->progressive) {
		 z->img_comp[i].coeff_w = (z->img_comp[i].w2 + 7) >> 3;
		 z->img_comp[i].coeff_h = (z->img_comp[i].h2 + 7) >> 3;
		 z->img_comp[i].raw_coeff = STBI_MALLOC(z->img_comp[i].coeff_w * z->img_comp[i].coeff_h * 64 * sizeof(short) + 15);
		 z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
	  } else {
		 z->img_comp[i].coeff = 0;
		 z->img_comp[i].raw_coeff = 0;
	  }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
	  if (!stbi__process_marker(z,m)) return 0;
	  m = stbi__get_marker(z);
	  while (m == STBI__MARKER_none) {
		 // some files have extra padding after their blocks, so ok, we'll scan
		 if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
		 m = stbi__get_marker(z);
	  }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
	  if (stbi__SOS(m)) {
		 if (!stbi__process_scan_header(j)) return 0;
		 if (!stbi__parse_entropy_coded_data(j)) return 0;
		 if (j->marker == STBI__MARKER_none ) {
			// handle 0s at the end of image data from IP Kamera 9060
			while (!stbi__at_eof(j->s)) {
			   int x = stbi__get8(j->s);
			   if (x == 255) {
				  j->marker = stbi__get8(j->s);
				  break;
			   } else if (x != 0) {
				  return stbi__err("junk before marker", "Corrupt JPEG");
			   }
			}
			// if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
		 }
	  } else {
		 if (!stbi__process_marker(j, m)) return 0;
	  }
	  m = stbi__get_marker(j);
   }
   if (j->progressive)
	  stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
									int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
	  out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
	  // if only one sample, can't do any interpolation
	  out[0] = out[1] = input[0];
	  return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
	  int n = 3*input[i]+2;
	  out[i*2+0] = stbi__div4(n+input[i-1]);
	  out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
	  out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
	  return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
	  t0 = t1;
	  t1 = 3*in_near[i]+in_far[i];
	  out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
	  out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
	  out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
	  return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
	  // load and perform the vertical filtering pass
	  // this uses 3*x + y = 4*x + (y - x)
	  __m128i zero  = _mm_setzero_si128();
	  __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
	  __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
	  __m128i farw  = _mm_unpacklo_epi8(farb, zero);
	  __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
	  __m128i diff  = _mm_sub_epi16(farw, nearw);
	  __m128i nears = _mm_slli_epi16(nearw, 2);
	  __m128i curr  = _mm_add_epi16(nears, diff); // current row

	  // horizontal filter works the same based on shifted vers of current
	  // row. "prev" is current row shifted right by 1 pixel; we need to
	  // insert the previous pixel value (from t1).
	  // "next" is current row shifted left by 1 pixel, with first pixel
	  // of next block of 8 pixels added in.
	  __m128i prv0 = _mm_slli_si128(curr, 2);
	  __m128i nxt0 = _mm_srli_si128(curr, 2);
	  __m128i prev = _mm_insert_epi16(prv0, t1, 0);
	  __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

	  // horizontal filter, polyphase implementation since it's convenient:
	  // even pixels = 3*cur + prev = cur*4 + (prev - cur)
	  // odd  pixels = 3*cur + next = cur*4 + (next - cur)
	  // note the shared term.
	  __m128i bias  = _mm_set1_epi16(8);
	  __m128i curs = _mm_slli_epi16(curr, 2);
	  __m128i prvd = _mm_sub_epi16(prev, curr);
	  __m128i nxtd = _mm_sub_epi16(next, curr);
	  __m128i curb = _mm_add_epi16(curs, bias);
	  __m128i even = _mm_add_epi16(prvd, curb);
	  __m128i odd  = _mm_add_epi16(nxtd, curb);

	  // interleave even and odd pixels, then undo scaling.
	  __m128i int0 = _mm_unpacklo_epi16(even, odd);
	  __m128i int1 = _mm_unpackhi_epi16(even, odd);
	  __m128i de0  = _mm_srli_epi16(int0, 4);
	  __m128i de1  = _mm_srli_epi16(int1, 4);

	  // pack and write output
	  __m128i outv = _mm_packus_epi16(de0, de1);
	  _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
	  // load and perform the vertical filtering pass
	  // this uses 3*x + y = 4*x + (y - x)
	  uint8x8_t farb  = vld1_u8(in_far + i);
	  uint8x8_t nearb = vld1_u8(in_near + i);
	  int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
	  int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
	  int16x8_t curr  = vaddq_s16(nears, diff); // current row

	  // horizontal filter works the same based on shifted vers of current
	  // row. "prev" is current row shifted right by 1 pixel; we need to
	  // insert the previous pixel value (from t1).
	  // "next" is current row shifted left by 1 pixel, with first pixel
	  // of next block of 8 pixels added in.
	  int16x8_t prv0 = vextq_s16(curr, curr, 7);
	  int16x8_t nxt0 = vextq_s16(curr, curr, 1);
	  int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
	  int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

	  // horizontal filter, polyphase implementation since it's convenient:
	  // even pixels = 3*cur + prev = cur*4 + (prev - cur)
	  // odd  pixels = 3*cur + next = cur*4 + (next - cur)
	  // note the shared term.
	  int16x8_t curs = vshlq_n_s16(curr, 2);
	  int16x8_t prvd = vsubq_s16(prev, curr);
	  int16x8_t nxtd = vsubq_s16(next, curr);
	  int16x8_t even = vaddq_s16(curs, prvd);
	  int16x8_t odd  = vaddq_s16(curs, nxtd);

	  // undo scaling and round, then store with even/odd phases interleaved
	  uint8x8x2_t o;
	  o.val[0] = vqrshrun_n_s16(even, 4);
	  o.val[1] = vqrshrun_n_s16(odd,  4);
	  vst2_u8(out + i*2, o);
#endif

	  // "previous" value for next iter
	  t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
	  t0 = t1;
	  t1 = 3*in_near[i]+in_far[i];
	  out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
	  out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
	  for (j=0; j < hs; ++j)
		 out[i*hs+j] = in_near[i];
   return out;
}

#ifdef STBI_JPEG_OLD
// this is the same YCbCr-to-RGB calculation that stb_image has used
// historically before the algorithm changes in 1.49
#define float2fixed(x)  ((int) ((x) * 65536 + 0.5))
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
	  int y_fixed = (y[i] << 16) + 32768; // rounding
	  int r,g,b;
	  int cr = pcr[i] - 128;
	  int cb = pcb[i] - 128;
	  r = y_fixed + cr*float2fixed(1.40200f);
	  g = y_fixed - cr*float2fixed(0.71414f) - cb*float2fixed(0.34414f);
	  b = y_fixed                            + cb*float2fixed(1.77200f);
	  r >>= 16;
	  g >>= 16;
	  b >>= 16;
	  if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
	  if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
	  if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
	  out[0] = (stbi_uc)r;
	  out[1] = (stbi_uc)g;
	  out[2] = (stbi_uc)b;
	  out[3] = 255;
	  out += step;
   }
}
#else
// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
	  int y_fixed = (y[i] << 20) + (1<<19); // rounding
	  int r,g,b;
	  int cr = pcr[i] - 128;
	  int cb = pcb[i] - 128;
	  r = y_fixed +  cr* float2fixed(1.40200f);
	  g = y_fixed + (cr*-float2fixed(0.71414f)) + ((cb*-float2fixed(0.34414f)) & 0xffff0000);
	  b = y_fixed                               +   cb* float2fixed(1.77200f);
	  r >>= 20;
	  g >>= 20;
	  b >>= 20;
	  if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
	  if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
	  if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
	  out[0] = (stbi_uc)r;
	  out[1] = (stbi_uc)g;
	  out[2] = (stbi_uc)b;
	  out[3] = 255;
	  out += step;
   }
}
#endif

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
	  // this is a fairly straightforward implementation and not super-optimized.
	  __m128i signflip  = _mm_set1_epi8(-0x80);
	  __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
	  __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
	  __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
	  __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
	  __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
	  __m128i xw = _mm_set1_epi16(255); // alpha channel

	  for (; i+7 < count; i += 8) {
		 // load
		 __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
		 __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
		 __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
		 __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
		 __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

		 // unpack to short (and left-shift cr, cb by 8)
		 __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
		 __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
		 __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

		 // color transform
		 __m128i yws = _mm_srli_epi16(yw, 4);
		 __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
		 __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
		 __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
		 __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
		 __m128i rws = _mm_add_epi16(cr0, yws);
		 __m128i gwt = _mm_add_epi16(cb0, yws);
		 __m128i bws = _mm_add_epi16(yws, cb1);
		 __m128i gws = _mm_add_epi16(gwt, cr1);

		 // descale
		 __m128i rw = _mm_srai_epi16(rws, 4);
		 __m128i bw = _mm_srai_epi16(bws, 4);
		 __m128i gw = _mm_srai_epi16(gws, 4);

		 // back to byte, set up for transpose
		 __m128i brb = _mm_packus_epi16(rw, bw);
		 __m128i gxb = _mm_packus_epi16(gw, xw);

		 // transpose to interleave channels
		 __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
		 __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
		 __m128i o0 = _mm_unpacklo_epi16(t0, t1);
		 __m128i o1 = _mm_unpackhi_epi16(t0, t1);

		 // store
		 _mm_storeu_si128((__m128i *) (out + 0), o0);
		 _mm_storeu_si128((__m128i *) (out + 16), o1);
		 out += 32;
	  }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
	  // this is a fairly straightforward implementation and not super-optimized.
	  uint8x8_t signflip = vdup_n_u8(0x80);
	  int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
	  int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
	  int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
	  int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

	  for (; i+7 < count; i += 8) {
		 // load
		 uint8x8_t y_bytes  = vld1_u8(y + i);
		 uint8x8_t cr_bytes = vld1_u8(pcr + i);
		 uint8x8_t cb_bytes = vld1_u8(pcb + i);
		 int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
		 int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

		 // expand to s16
		 int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
		 int16x8_t crw = vshll_n_s8(cr_biased, 7);
		 int16x8_t cbw = vshll_n_s8(cb_biased, 7);

		 // color transform
		 int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
		 int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
		 int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
		 int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
		 int16x8_t rws = vaddq_s16(yws, cr0);
		 int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
		 int16x8_t bws = vaddq_s16(yws, cb1);

		 // undo scaling, round, convert to byte
		 uint8x8x4_t o;
		 o.val[0] = vqrshrun_n_s16(rws, 4);
		 o.val[1] = vqrshrun_n_s16(gws, 4);
		 o.val[2] = vqrshrun_n_s16(bws, 4);
		 o.val[3] = vdup_n_u8(255);

		 // store, interleaving r/g/b/a
		 vst4_u8(out, o);
		 out += 8*4;
	  }
   }
#endif

   for (; i < count; ++i) {
	  int y_fixed = (y[i] << 20) + (1<<19); // rounding
	  int r,g,b;
	  int cr = pcr[i] - 128;
	  int cb = pcb[i] - 128;
	  r = y_fixed + cr* float2fixed(1.40200f);
	  g = y_fixed + cr*-float2fixed(0.71414f) + ((cb*-float2fixed(0.34414f)) & 0xffff0000);
	  b = y_fixed                             +   cb* float2fixed(1.77200f);
	  r >>= 20;
	  g >>= 20;
	  b >>= 20;
	  if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
	  if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
	  if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
	  out[0] = (stbi_uc)r;
	  out[1] = (stbi_uc)g;
	  out[2] = (stbi_uc)b;
	  out[3] = 255;
	  out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
	  j->idct_block_kernel = stbi__idct_simd;
	  #ifndef STBI_JPEG_OLD
	  j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
	  #endif
	  j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   #ifndef STBI_JPEG_OLD
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   #endif
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   int i;
   for (i=0; i < j->s->img_n; ++i) {
	  if (j->img_comp[i].raw_data) {
		 STBI_FREE(j->img_comp[i].raw_data);
		 j->img_comp[i].raw_data = NULL;
		 j->img_comp[i].data = NULL;
	  }
	  if (j->img_comp[i].raw_coeff) {
		 STBI_FREE(j->img_comp[i].raw_coeff);
		 j->img_comp[i].raw_coeff = 0;
		 j->img_comp[i].coeff = 0;
	  }
	  if (j->img_comp[i].linebuf) {
		 STBI_FREE(j->img_comp[i].linebuf);
		 j->img_comp[i].linebuf = NULL;
	  }
   }
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n;

   if (z->s->img_n == 3 && n < 3)
	  decode_n = 1;
   else
	  decode_n = z->s->img_n;

   // resample and color-convert
   {
	  int k;
	  unsigned int i,j;
	  stbi_uc *output;
	  stbi_uc *coutput[4];

	  stbi__resample res_comp[4];

	  for (k=0; k < decode_n; ++k) {
		 stbi__resample *r = &res_comp[k];

		 // allocate line buffer big enough for upsampling off the edges
		 // with upsample factor of 4
		 z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
		 if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

		 r->hs      = z->img_h_max / z->img_comp[k].h;
		 r->vs      = z->img_v_max / z->img_comp[k].v;
		 r->ystep   = r->vs >> 1;
		 r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
		 r->ypos    = 0;
		 r->line0   = r->line1 = z->img_comp[k].data;

		 if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
		 else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
		 else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
		 else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
		 else                               r->resample = stbi__resample_row_generic;
	  }

	  // can't error after this so, this is safe
	  output = (stbi_uc *) stbi__malloc(n * z->s->img_x * z->s->img_y + 1);
	  if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	  // now go ahead and resample
	  for (j=0; j < z->s->img_y; ++j) {
		 stbi_uc *out = output + n * z->s->img_x * j;
		 for (k=0; k < decode_n; ++k) {
			stbi__resample *r = &res_comp[k];
			int y_bot = r->ystep >= (r->vs >> 1);
			coutput[k] = r->resample(z->img_comp[k].linebuf,
									 y_bot ? r->line1 : r->line0,
									 y_bot ? r->line0 : r->line1,
									 r->w_lores, r->hs);
			if (++r->ystep >= r->vs) {
			   r->ystep = 0;
			   r->line0 = r->line1;
			   if (++r->ypos < z->img_comp[k].y)
				  r->line1 += z->img_comp[k].w2;
			}
		 }
		 if (n >= 3) {
			stbi_uc *y = coutput[0];
			if (z->s->img_n == 3) {
			   z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
			} else
			   for (i=0; i < z->s->img_x; ++i) {
				  out[0] = out[1] = out[2] = y[i];
				  out[3] = 255; // not used if n==3
				  out += n;
			   }
		 } else {
			stbi_uc *y = coutput[0];
			if (n == 1)
			   for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
			else
			   for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
		 }
	  }
	  stbi__cleanup_jpeg(z);
	  *out_x = z->s->img_x;
	  *out_y = z->s->img_y;
	  if (comp) *comp  = z->s->img_n; // report original components, not output
	  return output;
   }
}

static unsigned char *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__jpeg j;
   j.s = s;
   stbi__setup_jpeg(&j);
   return load_jpeg_image(&j, x,y,comp,req_comp);
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg j;
   j.s = s;
   stbi__setup_jpeg(&j);
   r = stbi__decode_jpeg_header(&j, STBI__SCAN_type);
   stbi__rewind(s);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
	  stbi__rewind( j->s );
	  return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__jpeg j;
   j.s = s;
   return stbi__jpeg_info_raw(&j, x, y, comp);
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[288];
   stbi__uint16 value[288];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
	  ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
	  STBI_ASSERT(sizes[i] <= (1 << i));
   code = 0;
   for (i=1; i < 16; ++i) {
	  next_code[i] = code;
	  z->firstcode[i] = (stbi__uint16) code;
	  z->firstsymbol[i] = (stbi__uint16) k;
	  code = (code + sizes[i]);
	  if (sizes[i])
		 if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt JPEG");
	  z->maxcode[i] = code << (16-i); // preshift for inner loop
	  code <<= 1;
	  k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
	  int s = sizelist[i];
	  if (s) {
		 int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
		 stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
		 z->size [c] = (stbi_uc     ) s;
		 z->value[c] = (stbi__uint16) i;
		 if (s <= STBI__ZFAST_BITS) {
			int k = stbi__bit_reverse(next_code[s],s);
			while (k < (1 << STBI__ZFAST_BITS)) {
			   z->fast[k] = fastv;
			   k += (1 << s);
			}
		 }
		 ++next_code[s];
	  }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   if (z->zbuffer >= z->zbuffer_end) return 0;
   return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
	  STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
	  z->code_buffer |= stbi__zget8(z) << z->num_bits;
	  z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
	  if (k < z->maxcode[s])
		 break;
   if (s == 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   STBI_ASSERT(z->size[b] == s);
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) stbi__fill_bits(a);
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
	  s = b >> 9;
	  a->code_buffer >>= s;
	  a->num_bits -= s;
	  return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   int cur, limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (int) (z->zout     - z->zout_start);
   limit = (int) (z->zout_end - z->zout_start);
   while (cur + n > limit)
	  limit *= 2;
   q = (char *) STBI_REALLOC(z->zout_start, limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
	  int z = stbi__zhuffman_decode(a, &a->z_length);
	  if (z < 256) {
		 if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
		 if (zout >= a->zout_end) {
			if (!stbi__zexpand(a, zout, 1)) return 0;
			zout = a->zout;
		 }
		 *zout++ = (char) z;
	  } else {
		 stbi_uc *p;
		 int len,dist;
		 if (z == 256) {
			a->zout = zout;
			return 1;
		 }
		 z -= 257;
		 len = stbi__zlength_base[z];
		 if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
		 z = stbi__zhuffman_decode(a, &a->z_distance);
		 if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
		 dist = stbi__zdist_base[z];
		 if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
		 if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
		 if (zout + len > a->zout_end) {
			if (!stbi__zexpand(a, zout, len)) return 0;
			zout = a->zout;
		 }
		 p = (stbi_uc *) (zout - dist);
		 if (dist == 1) { // run of one byte; common in images.
			stbi_uc v = *p;
			do *zout++ = v; while (--len);
		 } else {
			do *zout++ = *p++; while (--len);
		 }
	  }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
	  int s = stbi__zreceive(a,3);
	  codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < hlit + hdist) {
	  int c = stbi__zhuffman_decode(a, &z_codelength);
	  STBI_ASSERT(c >= 0 && c < 19);
	  if (c < 16)
		 lencodes[n++] = (stbi_uc) c;
	  else if (c == 16) {
		 c = stbi__zreceive(a,2)+3;
		 memset(lencodes+n, lencodes[n-1], c);
		 n += c;
	  } else if (c == 17) {
		 c = stbi__zreceive(a,3)+3;
		 memset(lencodes+n, 0, c);
		 n += c;
	  } else {
		 STBI_ASSERT(c == 18);
		 c = stbi__zreceive(a,7)+11;
		 memset(lencodes+n, 0, c);
		 n += c;
	  }
   }
   if (n != hlit+hdist) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncomperssed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
	  stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
	  header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
	  a->code_buffer >>= 8;
	  a->num_bits -= 8;
   }
   STBI_ASSERT(a->num_bits == 0);
   // now fill header the normal way
   while (k < 4)
	  header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
	  if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

// @TODO: should statically initialize these for optimal thread safety
static stbi_uc stbi__zdefault_length[288], stbi__zdefault_distance[32];
static void stbi__init_zdefaults(void)
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
	  if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
	  final = stbi__zreceive(a,1);
	  type = stbi__zreceive(a,2);
	  if (type == 0) {
		 if (!stbi__parse_uncomperssed_block(a)) return 0;
	  } else if (type == 3) {
		 return 0;
	  } else {
		 if (type == 1) {
			// use fixed code lengths
			if (!stbi__zdefault_distance[31]) stbi__init_zdefaults();
			if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
			if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
		 } else {
			if (!stbi__compute_huffman_codes(a)) return 0;
		 }
		 if (!stbi__parse_huffman_block(a)) return 0;
	  }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
	  if (outlen) *outlen = (int) (a.zout - a.zout_start);
	  return a.zout_start;
   } else {
	  STBI_FREE(a.zout_start);
	  return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
	  if (outlen) *outlen = (int) (a.zout - a.zout_start);
	  return a.zout_start;
   } else {
	  STBI_FREE(a.zout_start);
	  return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
	  return (int) (a.zout - a.zout_start);
   else
	  return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
	  if (outlen) *outlen = (int) (a.zout - a.zout_start);
	  return a.zout_start;
   } else {
	  STBI_FREE(a.zout_start);
	  return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
	  return (int) (a.zout - a.zout_start);
   else
	  return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
	  if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
} stbi__png;

enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc(x * y * out_n); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;
   if (s->img_x == x && s->img_y == y) {
	  if (raw_len != img_len) return stbi__err("not enough pixels","Corrupt PNG");
   } else { // interlaced:
	  if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
   }

   for (j=0; j < y; ++j) {
	  stbi_uc *cur = a->out + stride*j;
	  stbi_uc *prior = cur - stride;
	  int filter = *raw++;
	  int filter_bytes = img_n;
	  int width = x;
	  if (filter > 4)
		 return stbi__err("invalid filter","Corrupt PNG");

	  if (depth < 8) {
		 STBI_ASSERT(img_width_bytes <= x);
		 cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
		 filter_bytes = 1;
		 width = img_width_bytes;
	  }

	  // if first row, use special filter that doesn't sample previous row
	  if (j == 0) filter = first_row_filter[filter];

	  // handle first byte explicitly
	  for (k=0; k < filter_bytes; ++k) {
		 switch (filter) {
			case STBI__F_none       : cur[k] = raw[k]; break;
			case STBI__F_sub        : cur[k] = raw[k]; break;
			case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
			case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
			case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
			case STBI__F_avg_first  : cur[k] = raw[k]; break;
			case STBI__F_paeth_first: cur[k] = raw[k]; break;
		 }
	  }

	  if (depth == 8) {
		 if (img_n != out_n)
			cur[img_n] = 255; // first pixel
		 raw += img_n;
		 cur += out_n;
		 prior += out_n;
	  } else {
		 raw += 1;
		 cur += 1;
		 prior += 1;
	  }

	  // this is a little gross, so that we don't switch per-pixel or per-component
	  if (depth < 8 || img_n == out_n) {
		 int nk = (width - 1)*img_n;
		 #define CASE(f) \
			 case f:     \
				for (k=0; k < nk; ++k)
		 switch (filter) {
			// "none" filter turns into a memcpy here; make that explicit.
			case STBI__F_none:         memcpy(cur, raw, nk); break;
			CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); break;
			CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
			CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); break;
			CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); break;
			CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); break;
			CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); break;
		 }
		 #undef CASE
		 raw += nk;
	  } else {
		 STBI_ASSERT(img_n+1 == out_n);
		 #define CASE(f) \
			 case f:     \
				for (i=x-1; i >= 1; --i, cur[img_n]=255,raw+=img_n,cur+=out_n,prior+=out_n) \
				   for (k=0; k < img_n; ++k)
		 switch (filter) {
			CASE(STBI__F_none)         cur[k] = raw[k]; break;
			CASE(STBI__F_sub)          cur[k] = STBI__BYTECAST(raw[k] + cur[k-out_n]); break;
			CASE(STBI__F_up)           cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
			CASE(STBI__F_avg)          cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-out_n])>>1)); break;
			CASE(STBI__F_paeth)        cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-out_n],prior[k],prior[k-out_n])); break;
			CASE(STBI__F_avg_first)    cur[k] = STBI__BYTECAST(raw[k] + (cur[k-out_n] >> 1)); break;
			CASE(STBI__F_paeth_first)  cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-out_n],0,0)); break;
		 }
		 #undef CASE
	  }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
	  for (j=0; j < y; ++j) {
		 stbi_uc *cur = a->out + stride*j;
		 stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
		 // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
		 // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
		 stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

		 // note that the final byte might overshoot and write more data than desired.
		 // we can allocate enough data that this never writes out of memory, but it
		 // could also overwrite the next scanline. can it overwrite non-empty data
		 // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
		 // so we need to explicitly clamp the final ones

		 if (depth == 4) {
			for (k=x*img_n; k >= 2; k-=2, ++in) {
			   *cur++ = scale * ((*in >> 4)       );
			   *cur++ = scale * ((*in     ) & 0x0f);
			}
			if (k > 0) *cur++ = scale * ((*in >> 4)       );
		 } else if (depth == 2) {
			for (k=x*img_n; k >= 4; k-=4, ++in) {
			   *cur++ = scale * ((*in >> 6)       );
			   *cur++ = scale * ((*in >> 4) & 0x03);
			   *cur++ = scale * ((*in >> 2) & 0x03);
			   *cur++ = scale * ((*in     ) & 0x03);
			}
			if (k > 0) *cur++ = scale * ((*in >> 6)       );
			if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
			if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
		 } else if (depth == 1) {
			for (k=x*img_n; k >= 8; k-=8, ++in) {
			   *cur++ = scale * ((*in >> 7)       );
			   *cur++ = scale * ((*in >> 6) & 0x01);
			   *cur++ = scale * ((*in >> 5) & 0x01);
			   *cur++ = scale * ((*in >> 4) & 0x01);
			   *cur++ = scale * ((*in >> 3) & 0x01);
			   *cur++ = scale * ((*in >> 2) & 0x01);
			   *cur++ = scale * ((*in >> 1) & 0x01);
			   *cur++ = scale * ((*in     ) & 0x01);
			}
			if (k > 0) *cur++ = scale * ((*in >> 7)       );
			if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
			if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
			if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
			if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
			if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
			if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
		 }
		 if (img_n != out_n) {
			// insert alpha = 255
			stbi_uc *cur = a->out + stride*j;
			int i;
			if (img_n == 1) {
			   for (i=x-1; i >= 0; --i) {
				  cur[i*2+1] = 255;
				  cur[i*2+0] = cur[i];
			   }
			} else {
			   STBI_ASSERT(img_n == 3);
			   for (i=x-1; i >= 0; --i) {
				  cur[i*4+3] = 255;
				  cur[i*4+2] = cur[i*3+2];
				  cur[i*4+1] = cur[i*3+1];
				  cur[i*4+0] = cur[i*3+0];
			   }
			}
		 }
	  }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   stbi_uc *final;
   int p;
   if (!interlaced)
	  return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc(a->s->img_x * a->s->img_y * out_n);
   for (p=0; p < 7; ++p) {
	  int xorig[] = { 0,4,0,2,0,1,0 };
	  int yorig[] = { 0,0,4,0,2,0,1 };
	  int xspc[]  = { 8,8,4,4,2,2,1 };
	  int yspc[]  = { 8,8,8,4,4,2,2 };
	  int i,j,x,y;
	  // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
	  x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
	  y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
	  if (x && y) {
		 stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
		 if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
			STBI_FREE(final);
			return 0;
		 }
		 for (j=0; j < y; ++j) {
			for (i=0; i < x; ++i) {
			   int out_y = j*yspc[p]+yorig[p];
			   int out_x = i*xspc[p]+xorig[p];
			   memcpy(final + out_y*a->s->img_x*out_n + out_x*out_n,
					  a->out + (j*x+i)*out_n, out_n);
			}
		 }
		 STBI_FREE(a->out);
		 image_data += img_len;
		 image_data_len -= img_len;
	  }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
	  for (i=0; i < pixel_count; ++i) {
		 p[1] = (p[0] == tc[0] ? 0 : 255);
		 p += 2;
	  }
   } else {
	  for (i=0; i < pixel_count; ++i) {
		 if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
			p[3] = 0;
		 p += 4;
	  }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc(pixel_count * pal_img_n);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
	  for (i=0; i < pixel_count; ++i) {
		 int n = orig[i]*4;
		 p[0] = palette[n  ];
		 p[1] = palette[n+1];
		 p[2] = palette[n+2];
		 p += 3;
	  }
   } else {
	  for (i=0; i < pixel_count; ++i) {
		 int n = orig[i]*4;
		 p[0] = palette[n  ];
		 p[1] = palette[n+1];
		 p[2] = palette[n+2];
		 p[3] = palette[n+3];
		 p += 4;
	  }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
	  for (i=0; i < pixel_count; ++i) {
		 stbi_uc t = p[0];
		 p[0] = p[2];
		 p[2] = t;
		 p += 3;
	  }
   } else {
	  STBI_ASSERT(s->img_out_n == 4);
	  if (stbi__unpremultiply_on_load) {
		 // convert bgr to rgb and unpremultiply
		 for (i=0; i < pixel_count; ++i) {
			stbi_uc a = p[3];
			stbi_uc t = p[0];
			if (a) {
			   p[0] = p[2] * 255 / a;
			   p[1] = p[1] * 255 / a;
			   p[2] =  t   * 255 / a;
			} else {
			   p[0] = p[2];
			   p[2] = t;
			}
			p += 4;
		 }
	  } else {
		 // convert bgr to rgb
		 for (i=0; i < pixel_count; ++i) {
			stbi_uc t = p[0];
			p[0] = p[2];
			p[2] = t;
			p += 4;
		 }
	  }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, depth=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
	  stbi__pngchunk c = stbi__get_chunk_header(s);
	  switch (c.type) {
		 case STBI__PNG_TYPE('C','g','B','I'):
			is_iphone = 1;
			stbi__skip(s, c.length);
			break;
		 case STBI__PNG_TYPE('I','H','D','R'): {
			int comp,filter;
			if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
			first = 0;
			if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
			s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
			s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
			depth = stbi__get8(s);  if (depth != 1 && depth != 2 && depth != 4 && depth != 8)  return stbi__err("1/2/4/8-bit only","PNG not supported: 1/2/4/8-bit only");
			color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
			if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
			comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
			filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
			interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
			if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
			if (!pal_img_n) {
			   s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
			   if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
			   if (scan == STBI__SCAN_header) return 1;
			} else {
			   // if paletted, then pal_n is our final components, and
			   // img_n is # components to decompress/filter.
			   s->img_n = 1;
			   if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
			   // if SCAN_header, have to scan to see if we have a tRNS
			}
			break;
		 }

		 case STBI__PNG_TYPE('P','L','T','E'):  {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
			pal_len = c.length / 3;
			if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
			for (i=0; i < pal_len; ++i) {
			   palette[i*4+0] = stbi__get8(s);
			   palette[i*4+1] = stbi__get8(s);
			   palette[i*4+2] = stbi__get8(s);
			   palette[i*4+3] = 255;
			}
			break;
		 }

		 case STBI__PNG_TYPE('t','R','N','S'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
			if (pal_img_n) {
			   if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
			   if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
			   if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
			   pal_img_n = 4;
			   for (i=0; i < c.length; ++i)
				  palette[i*4+3] = stbi__get8(s);
			} else {
			   if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
			   if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
			   has_trans = 1;
			   for (k=0; k < s->img_n; ++k)
				  tc[k] = (stbi_uc) (stbi__get16be(s) & 255) * stbi__depth_scale_table[depth]; // non 8-bit images will be larger
			}
			break;
		 }

		 case STBI__PNG_TYPE('I','D','A','T'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
			if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
			if (ioff + c.length > idata_limit) {
			   stbi_uc *p;
			   if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
			   while (ioff + c.length > idata_limit)
				  idata_limit *= 2;
			   p = (stbi_uc *) STBI_REALLOC(z->idata, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
			   z->idata = p;
			}
			if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
			ioff += c.length;
			break;
		 }

		 case STBI__PNG_TYPE('I','E','N','D'): {
			stbi__uint32 raw_len, bpl;
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (scan != STBI__SCAN_load) return 1;
			if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
			// initial guess for decoded data size to avoid unnecessary reallocs
			bpl = (s->img_x * depth + 7) / 8; // bytes per line, per component
			raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
			z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
			if (z->expanded == NULL) return 0; // zlib should set error
			STBI_FREE(z->idata); z->idata = NULL;
			if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
			   s->img_out_n = s->img_n+1;
			else
			   s->img_out_n = s->img_n;
			if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, depth, color, interlace)) return 0;
			if (has_trans)
			   if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
			if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
			   stbi__de_iphone(z);
			if (pal_img_n) {
			   // pal_img_n == 3 or 4
			   s->img_n = pal_img_n; // record the actual colors we had
			   s->img_out_n = pal_img_n;
			   if (req_comp >= 3) s->img_out_n = req_comp;
			   if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
				  return 0;
			}
			STBI_FREE(z->expanded); z->expanded = NULL;
			return 1;
		 }

		 default:
			// if critical, fail
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if ((c.type & (1 << 29)) == 0) {
			   #ifndef STBI_NO_FAILURE_STRINGS
			   // not threadsafe
			   static char invalid_chunk[] = "XXXX PNG chunk not known";
			   invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
			   invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
			   invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
			   invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
			   #endif
			   return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
			}
			stbi__skip(s, c.length);
			break;
	  }
	  // end of PNG chunk, read and skip CRC
	  stbi__get32be(s);
   }
}

static unsigned char *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp)
{
   unsigned char *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
	  result = p->out;
	  p->out = NULL;
	  if (req_comp && req_comp != p->s->img_out_n) {
		 result = stbi__convert_format(result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
		 p->s->img_out_n = req_comp;
		 if (result == NULL) return result;
	  }
	  *x = p->s->img_x;
	  *y = p->s->img_y;
	  if (n) *n = p->s->img_out_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static unsigned char *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
	  stbi__rewind( p->s );
	  return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}

// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) n += 16, z >>= 16;
   if (z >= 0x00100) n +=  8, z >>=  8;
   if (z >= 0x00010) n +=  4, z >>=  4;
   if (z >= 0x00004) n +=  2, z >>=  2;
   if (z >= 0x00002) n +=  1, z >>=  1;
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

static int stbi__shiftsigned(int v, int shift, int bits)
{
   int result;
   int z=0;

   if (shift < 0) v <<= -shift;
   else v >>= shift;
   result = v;

   z = bits;
   while (z < 8) {
	  result += v >> z;
	  z += bits;
   }
   return result;
}

static stbi_uc *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, fake_a=0;
   stbi_uc pal[256][4];
   int psize=0,i,j,compress=0,width;
   int bpp, flip_vertically, pad, target, offset, hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   offset = stbi__get32le(s);
   hsz = stbi__get32le(s);
   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
	  s->img_x = stbi__get16le(s);
	  s->img_y = stbi__get16le(s);
   } else {
	  s->img_x = stbi__get32le(s);
	  s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   bpp = stbi__get16le(s);
   if (bpp == 1) return stbi__errpuc("monochrome", "BMP type not supported: 1-bit");
   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);
   if (hsz == 12) {
	  if (bpp < 24)
		 psize = (offset - 14 - 24) / 3;
   } else {
	  compress = stbi__get32le(s);
	  if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
	  stbi__get32le(s); // discard sizeof
	  stbi__get32le(s); // discard hres
	  stbi__get32le(s); // discard vres
	  stbi__get32le(s); // discard colorsused
	  stbi__get32le(s); // discard max important
	  if (hsz == 40 || hsz == 56) {
		 if (hsz == 56) {
			stbi__get32le(s);
			stbi__get32le(s);
			stbi__get32le(s);
			stbi__get32le(s);
		 }
		 if (bpp == 16 || bpp == 32) {
			mr = mg = mb = 0;
			if (compress == 0) {
			   if (bpp == 32) {
				  mr = 0xffu << 16;
				  mg = 0xffu <<  8;
				  mb = 0xffu <<  0;
				  ma = 0xffu << 24;
				  fake_a = 1; // @TODO: check for cases like alpha value is all 0 and switch it to 255
				  STBI_NOTUSED(fake_a);
			   } else {
				  mr = 31u << 10;
				  mg = 31u <<  5;
				  mb = 31u <<  0;
			   }
			} else if (compress == 3) {
			   mr = stbi__get32le(s);
			   mg = stbi__get32le(s);
			   mb = stbi__get32le(s);
			   // not documented, but generated by photoshop and handled by mspaint
			   if (mr == mg && mg == mb) {
				  // ?!?!?
				  return stbi__errpuc("bad BMP", "bad BMP");
			   }
			} else
			   return stbi__errpuc("bad BMP", "bad BMP");
		 }
	  } else {
		 STBI_ASSERT(hsz == 108 || hsz == 124);
		 mr = stbi__get32le(s);
		 mg = stbi__get32le(s);
		 mb = stbi__get32le(s);
		 ma = stbi__get32le(s);
		 stbi__get32le(s); // discard color space
		 for (i=0; i < 12; ++i)
			stbi__get32le(s); // discard color space parameters
		 if (hsz == 124) {
			stbi__get32le(s); // discard rendering intent
			stbi__get32le(s); // discard offset of profile data
			stbi__get32le(s); // discard size of profile data
			stbi__get32le(s); // discard reserved
		 }
	  }
	  if (bpp < 16)
		 psize = (offset - 14 - hsz) >> 2;
   }
   s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
	  target = req_comp;
   else
	  target = s->img_n; // if they want monochrome, we'll post-convert
   out = (stbi_uc *) stbi__malloc(target * s->img_x * s->img_y);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (bpp < 16) {
	  int z=0;
	  if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
	  for (i=0; i < psize; ++i) {
		 pal[i][2] = stbi__get8(s);
		 pal[i][1] = stbi__get8(s);
		 pal[i][0] = stbi__get8(s);
		 if (hsz != 12) stbi__get8(s);
		 pal[i][3] = 255;
	  }
	  stbi__skip(s, offset - 14 - hsz - psize * (hsz == 12 ? 3 : 4));
	  if (bpp == 4) width = (s->img_x + 1) >> 1;
	  else if (bpp == 8) width = s->img_x;
	  else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
	  pad = (-width)&3;
	  for (j=0; j < (int) s->img_y; ++j) {
		 for (i=0; i < (int) s->img_x; i += 2) {
			int v=stbi__get8(s),v2=0;
			if (bpp == 4) {
			   v2 = v & 15;
			   v >>= 4;
			}
			out[z++] = pal[v][0];
			out[z++] = pal[v][1];
			out[z++] = pal[v][2];
			if (target == 4) out[z++] = 255;
			if (i+1 == (int) s->img_x) break;
			v = (bpp == 8) ? stbi__get8(s) : v2;
			out[z++] = pal[v][0];
			out[z++] = pal[v][1];
			out[z++] = pal[v][2];
			if (target == 4) out[z++] = 255;
		 }
		 stbi__skip(s, pad);
	  }
   } else {
	  int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
	  int z = 0;
	  int easy=0;
	  stbi__skip(s, offset - 14 - hsz);
	  if (bpp == 24) width = 3 * s->img_x;
	  else if (bpp == 16) width = 2*s->img_x;
	  else /* bpp = 32 and pad = 0 */ width=0;
	  pad = (-width) & 3;
	  if (bpp == 24) {
		 easy = 1;
	  } else if (bpp == 32) {
		 if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
			easy = 2;
	  }
	  if (!easy) {
		 if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
		 // right shift amt to put high bit in position #7
		 rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
		 gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
		 bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
		 ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
	  }
	  for (j=0; j < (int) s->img_y; ++j) {
		 if (easy) {
			for (i=0; i < (int) s->img_x; ++i) {
			   unsigned char a;
			   out[z+2] = stbi__get8(s);
			   out[z+1] = stbi__get8(s);
			   out[z+0] = stbi__get8(s);
			   z += 3;
			   a = (easy == 2 ? stbi__get8(s) : 255);
			   if (target == 4) out[z++] = a;
			}
		 } else {
			for (i=0; i < (int) s->img_x; ++i) {
			   stbi__uint32 v = (stbi__uint32) (bpp == 16 ? stbi__get16le(s) : stbi__get32le(s));
			   int a;
			   out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
			   out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
			   out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
			   a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
			   if (target == 4) out[z++] = STBI__BYTECAST(a);
			}
		 }
		 stbi__skip(s, pad);
	  }
   }
   if (flip_vertically) {
	  stbi_uc t;
	  for (j=0; j < (int) s->img_y>>1; ++j) {
		 stbi_uc *p1 = out +      j     *s->img_x*target;
		 stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
		 for (i=0; i < (int) s->img_x*target; ++i) {
			t = p1[i], p1[i] = p2[i], p2[i] = t;
		 }
	  }
   }

   if (req_comp && req_comp != target) {
	  out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
	  if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
	int tga_w, tga_h, tga_comp;
	int sz;
	stbi__get8(s);                   // discard Offset
	sz = stbi__get8(s);              // color type
	if( sz > 1 ) {
		stbi__rewind(s);
		return 0;      // only RGB or indexed allowed
	}
	sz = stbi__get8(s);              // image type
	// only RGB or grey allowed, +/- RLE
	if ((sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11)) return 0;
	stbi__skip(s,9);
	tga_w = stbi__get16le(s);
	if( tga_w < 1 ) {
		stbi__rewind(s);
		return 0;   // test width
	}
	tga_h = stbi__get16le(s);
	if( tga_h < 1 ) {
		stbi__rewind(s);
		return 0;   // test height
	}
	sz = stbi__get8(s);               // bits per pixel
	// only RGB or RGBA or grey allowed
	if ((sz != 8) && (sz != 16) && (sz != 24) && (sz != 32)) {
		stbi__rewind(s);
		return 0;
	}
	tga_comp = sz;
	if (x) *x = tga_w;
	if (y) *y = tga_h;
	if (comp) *comp = tga_comp / 8;
	return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res;
   int sz;
   stbi__get8(s);      //   discard Offset
   sz = stbi__get8(s);   //   color type
   if ( sz > 1 ) return 0;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( (sz != 1) && (sz != 2) && (sz != 3) && (sz != 9) && (sz != 10) && (sz != 11) ) return 0;   //   only RGB or grey allowed, +/- RLE
   stbi__get16be(s);      //   discard palette start
   stbi__get16be(s);      //   discard palette length
   stbi__get8(s);         //   discard bits per palette color entry
   stbi__get16be(s);      //   discard x origin
   stbi__get16be(s);      //   discard y origin
   if ( stbi__get16be(s) < 1 ) return 0;      //   test width
   if ( stbi__get16be(s) < 1 ) return 0;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (sz != 8) && (sz != 16) && (sz != 24) && (sz != 32) )
	  res = 0;
   else
	  res = 1;
   stbi__rewind(s);
   return res;
}

static stbi_uc *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp = tga_bits_per_pixel / 8;
   int tga_inverted = stbi__get8(s);
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4];
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
	  tga_image_type -= 8;
	  tga_is_RLE = 1;
   }
   /* int tga_alpha_bits = tga_inverted & 15; */
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   error check
   if ( //(tga_indexed) ||
	  (tga_width < 1) || (tga_height < 1) ||
	  (tga_image_type < 1) || (tga_image_type > 3) ||
	  ((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16) &&
	  (tga_bits_per_pixel != 24) && (tga_bits_per_pixel != 32))
	  )
   {
	  return NULL; // we don't report this as a bad TGA because we don't even know if it's TGA
   }

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed )
   {
	  tga_comp = tga_palette_bits / 8;
   }

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   tga_data = (unsigned char*)stbi__malloc( tga_width * tga_height * tga_comp );
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE) {
	  for (i=0; i < tga_height; ++i) {
		 int y = tga_inverted ? tga_height -i - 1 : i;
		 stbi_uc *tga_row = tga_data + y*tga_width*tga_comp;
		 stbi__getn(s, tga_row, tga_width * tga_comp);
	  }
   } else  {
	  //   do I need to load a palette?
	  if ( tga_indexed)
	  {
		 //   any data to skip? (offset usually = 0)
		 stbi__skip(s, tga_palette_start );
		 //   load the palette
		 tga_palette = (unsigned char*)stbi__malloc( tga_palette_len * tga_palette_bits / 8 );
		 if (!tga_palette) {
			STBI_FREE(tga_data);
			return stbi__errpuc("outofmem", "Out of memory");
		 }
		 if (!stbi__getn(s, tga_palette, tga_palette_len * tga_palette_bits / 8 )) {
			STBI_FREE(tga_data);
			STBI_FREE(tga_palette);
			return stbi__errpuc("bad palette", "Corrupt TGA");
		 }
	  }
	  //   load the data
	  for (i=0; i < tga_width * tga_height; ++i)
	  {
		 //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
		 if ( tga_is_RLE )
		 {
			if ( RLE_count == 0 )
			{
			   //   yep, get the next byte as a RLE command
			   int RLE_cmd = stbi__get8(s);
			   RLE_count = 1 + (RLE_cmd & 127);
			   RLE_repeating = RLE_cmd >> 7;
			   read_next_pixel = 1;
			} else if ( !RLE_repeating )
			{
			   read_next_pixel = 1;
			}
		 } else
		 {
			read_next_pixel = 1;
		 }
		 //   OK, if I need to read a pixel, do it now
		 if ( read_next_pixel )
		 {
			//   load however much data we did have
			if ( tga_indexed )
			{
			   //   read in 1 byte, then perform the lookup
			   int pal_idx = stbi__get8(s);
			   if ( pal_idx >= tga_palette_len )
			   {
				  //   invalid index
				  pal_idx = 0;
			   }
			   pal_idx *= tga_bits_per_pixel / 8;
			   for (j = 0; j*8 < tga_bits_per_pixel; ++j)
			   {
				  raw_data[j] = tga_palette[pal_idx+j];
			   }
			} else
			{
			   //   read in the data raw
			   for (j = 0; j*8 < tga_bits_per_pixel; ++j)
			   {
				  raw_data[j] = stbi__get8(s);
			   }
			}
			//   clear the reading flag for the next pixel
			read_next_pixel = 0;
		 } // end of reading a pixel

		 // copy data
		 for (j = 0; j < tga_comp; ++j)
		   tga_data[i*tga_comp+j] = raw_data[j];

		 //   in case we're in RLE mode, keep counting down
		 --RLE_count;
	  }
	  //   do I need to invert the image?
	  if ( tga_inverted )
	  {
		 for (j = 0; j*2 < tga_height; ++j)
		 {
			int index1 = j * tga_width * tga_comp;
			int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
			for (i = tga_width * tga_comp; i > 0; --i)
			{
			   unsigned char temp = tga_data[index1];
			   tga_data[index1] = tga_data[index2];
			   tga_data[index2] = temp;
			   ++index1;
			   ++index2;
			}
		 }
	  }
	  //   clear my palette, if I had one
	  if ( tga_palette != NULL )
	  {
		 STBI_FREE( tga_palette );
	  }
   }

   // swap RGB
   if (tga_comp >= 3)
   {
	  unsigned char* tga_pixel = tga_data;
	  for (i=0; i < tga_width * tga_height; ++i)
	  {
		 unsigned char temp = tga_pixel[0];
		 tga_pixel[0] = tga_pixel[2];
		 tga_pixel[2] = temp;
		 tga_pixel += tga_comp;
	  }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
	  tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
		 tga_x_origin = tga_y_origin = 0;
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static stbi_uc *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   int   pixelCount;
   int channelCount, compression;
   int channel, i, count, len;
   int w,h;
   stbi_uc *out;

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
	  return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
	  return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
	  return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   // Make sure the depth is 8 bits.
   if (stbi__get16be(s) != 8)
	  return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
	  return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
	  return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Create the destination image.
   out = (stbi_uc *) stbi__malloc(channelCount * w*h);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
	  // RLE as used by .PSD and .TIFF
	  // Loop until you get the number of unpacked bytes you are expecting:
	  //     Read the next source byte into n.
	  //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
	  //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
	  //     Else if n is 128, noop.
	  // Endloop

	  // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
	  // which we're going to just skip.
	  stbi__skip(s, h * channelCount * 2 );

	  // Read the RLE data by channel.
	  for (channel = 0; channel < channelCount; channel++) {
		 stbi_uc *p;

		 p = out+channel;
		 if (channel >= channelCount) {
			// Fill this channel with default data.
			for (i = 0; i < pixelCount; i++) *p = (channel == 3 ? 255 : 0), p += channelCount;
		 } else {
			// Read the RLE data.
			count = 0;
			while (count < pixelCount) {
			   len = stbi__get8(s);
			   if (len == 128) {
				  // No-op.
			   } else if (len < 128) {
				  // Copy next len+1 bytes literally.
				  len++;
				  count += len;
				  while (len) {
					 *p = stbi__get8(s);
					 p += channelCount;
					 len--;
				  }
			   } else if (len > 128) {
				  stbi_uc   val;
				  // Next -len+1 bytes in the dest are replicated from next source byte.
				  // (Interpret len as a negative 8-bit int.)
				  len ^= 0x0FF;
				  len += 2;
				  val = stbi__get8(s);
				  count += len;
				  while (len) {
					 *p = val;
					 p += channelCount;
					 len--;
				  }
			   }
			}
		 }
	  }

   } else {
	  // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
	  // where each channel consists of an 8-bit value for each pixel in the image.

	  // Read the data by channel.
	  for (channel = 0; channel < channelCount; channel++) {
		 stbi_uc *p;

		 p = out + channel;
		 if (channel > channelCount) {
			// Fill this channel with default data.
			for (i = 0; i < pixelCount; i++) *p = channel == 3 ? 255 : 0, p += channelCount;
		 } else {
			// Read the data.
			for (i = 0; i < pixelCount; i++)
			   *p = stbi__get8(s), p += channelCount;
		 }
	  }
   }

   if (req_comp && req_comp != channelCount) {
	  out = stbi__convert_format(out, channelCount, req_comp, w, h);
	  if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = channelCount;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
	  if (stbi__get8(s) != (stbi_uc)str[i])
		 return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
	  return 0;

   for(i=0;i<84;++i)
	  stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
	  return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
	  if (channel & mask) {
		 if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
		 dest[i]=stbi__get8(s);
	  }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
	  if (channel&mask)
		 dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
	// for the same channel in multiple packets.
   do {
	  stbi__pic_packet *packet;

	  if (num_packets==sizeof(packets)/sizeof(packets[0]))
		 return stbi__errpuc("bad format","too many packets");

	  packet = &packets[num_packets++];

	  chained = stbi__get8(s);
	  packet->size    = stbi__get8(s);
	  packet->type    = stbi__get8(s);
	  packet->channel = stbi__get8(s);

	  act_comp |= packet->channel;

	  if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
	  if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
	  int packet_idx;

	  for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
		 stbi__pic_packet *packet = &packets[packet_idx];
		 stbi_uc *dest = result+y*width*4;

		 switch (packet->type) {
			default:
			   return stbi__errpuc("bad format","packet has bad compression type");

			case 0: {//uncompressed
			   int x;

			   for(x=0;x<width;++x, dest+=4)
				  if (!stbi__readval(s,packet->channel,dest))
					 return 0;
			   break;
			}

			case 1://Pure RLE
			   {
				  int left=width, i;

				  while (left>0) {
					 stbi_uc count,value[4];

					 count=stbi__get8(s);
					 if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

					 if (count > left)
						count = (stbi_uc) left;

					 if (!stbi__readval(s,packet->channel,value))  return 0;

					 for(i=0; i<count; ++i,dest+=4)
						stbi__copyval(packet->channel,dest,value);
					 left -= count;
				  }
			   }
			   break;

			case 2: {//Mixed RLE
			   int left=width;
			   while (left>0) {
				  int count = stbi__get8(s), i;
				  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

				  if (count >= 128) { // Repeated
					 stbi_uc value[4];
					 int i;

					 if (count==128)
						count = stbi__get16be(s);
					 else
						count -= 127;
					 if (count > left)
						return stbi__errpuc("bad file","scanline overrun");

					 if (!stbi__readval(s,packet->channel,value))
						return 0;

					 for(i=0;i<count;++i, dest += 4)
						stbi__copyval(packet->channel,dest,value);
				  } else { // Raw
					 ++count;
					 if (count>left) return stbi__errpuc("bad file","scanline overrun");

					 for(i=0;i<count;++i, dest+=4)
						if (!stbi__readval(s,packet->channel,dest))
						   return 0;
				  }
				  left-=count;
			   }
			   break;
			}
		 }
	  }
   }

   return result;
}

static stbi_uc *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp)
{
   stbi_uc *result;
   int i, x,y;

   for (i=0; i<92; ++i)
	  stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);
   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if ((1 << 28) / x < y) return stbi__errpuc("too large", "Image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc(x*y*4);
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
	  STBI_FREE(result);
	  result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out;                 // output buffer (always 4 components)
   int flags, bgindex, ratio, transparent, eflags;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[4096];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
	  pal[i][2] = stbi__get8(s);
	  pal[i][1] = stbi__get8(s);
	  pal[i][0] = stbi__get8(s);
	  pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
	  return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
	  stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif g;
   if (!stbi__gif_header(s, &g, comp, 1)) {
	  stbi__rewind( s );
	  return 0;
   }
   if (x) *x = g.w;
   if (y) *y = g.h;
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
	  stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   p = &g->out[g->cur_x + g->cur_y];
   c = &g->color_table[g->codes[code].suffix * 4];

   if (c[3] >= 128) {
	  p[0] = c[2];
	  p[1] = c[1];
	  p[2] = c[0];
	  p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
	  g->cur_x = g->start_x;
	  g->cur_y += g->step;

	  while (g->cur_y >= g->max_y && g->parse > 0) {
		 g->step = (1 << g->parse) * g->line_size;
		 g->cur_y = g->start_y + (g->step >> 1);
		 --g->parse;
	  }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (code = 0; code < clear; code++) {
	  g->codes[code].prefix = -1;
	  g->codes[code].first = (stbi_uc) code;
	  g->codes[code].suffix = (stbi_uc) code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
	  if (valid_bits < codesize) {
		 if (len == 0) {
			len = stbi__get8(s); // start new block
			if (len == 0)
			   return g->out;
		 }
		 --len;
		 bits |= (stbi__int32) stbi__get8(s) << valid_bits;
		 valid_bits += 8;
	  } else {
		 stbi__int32 code = bits & codemask;
		 bits >>= codesize;
		 valid_bits -= codesize;
		 // @OPTIMIZE: is there some way we can accelerate the non-clear path?
		 if (code == clear) {  // clear code
			codesize = lzw_cs + 1;
			codemask = (1 << codesize) - 1;
			avail = clear + 2;
			oldcode = -1;
			first = 0;
		 } else if (code == clear + 1) { // end of stream code
			stbi__skip(s, len);
			while ((len = stbi__get8(s)) > 0)
			   stbi__skip(s,len);
			return g->out;
		 } else if (code <= avail) {
			if (first) return stbi__errpuc("no clear code", "Corrupt GIF");

			if (oldcode >= 0) {
			   p = &g->codes[avail++];
			   if (avail > 4096)        return stbi__errpuc("too many codes", "Corrupt GIF");
			   p->prefix = (stbi__int16) oldcode;
			   p->first = g->codes[oldcode].first;
			   p->suffix = (code == avail) ? p->first : g->codes[code].first;
			} else if (code == avail)
			   return stbi__errpuc("illegal code in raster", "Corrupt GIF");

			stbi__out_gif_code(g, (stbi__uint16) code);

			if ((avail & codemask) == 0 && avail <= 0x0FFF) {
			   codesize++;
			   codemask = (1 << codesize) - 1;
			}

			oldcode = code;
		 } else {
			return stbi__errpuc("illegal code in raster", "Corrupt GIF");
		 }
	  }
   }
}

static void stbi__fill_gif_background(stbi__gif *g)
{
   int i;
   stbi_uc *c = g->pal[g->bgindex];
   // @OPTIMIZE: write a dword at a time
   for (i = 0; i < g->w * g->h * 4; i += 4) {
	  stbi_uc *p  = &g->out[i];
	  p[0] = c[2];
	  p[1] = c[1];
	  p[2] = c[0];
	  p[3] = c[3];
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)
{
   int i;
   stbi_uc *old_out = 0;

   if (g->out == 0) {
	  if (!stbi__gif_header(s, g, comp,0))     return 0; // stbi__g_failure_reason set by stbi__gif_header
	  g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);
	  if (g->out == 0)                      return stbi__errpuc("outofmem", "Out of memory");
	  stbi__fill_gif_background(g);
   } else {
	  // animated-gif-only path
	  if (((g->eflags & 0x1C) >> 2) == 3) {
		 old_out = g->out;
		 g->out = (stbi_uc *) stbi__malloc(4 * g->w * g->h);
		 if (g->out == 0)                   return stbi__errpuc("outofmem", "Out of memory");
		 memcpy(g->out, old_out, g->w*g->h*4);
	  }
   }

   for (;;) {
	  switch (stbi__get8(s)) {
		 case 0x2C: /* Image Descriptor */
		 {
			stbi__int32 x, y, w, h;
			stbi_uc *o;

			x = stbi__get16le(s);
			y = stbi__get16le(s);
			w = stbi__get16le(s);
			h = stbi__get16le(s);
			if (((x + w) > (g->w)) || ((y + h) > (g->h)))
			   return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

			g->line_size = g->w * 4;
			g->start_x = x * 4;
			g->start_y = y * g->line_size;
			g->max_x   = g->start_x + w * 4;
			g->max_y   = g->start_y + h * g->line_size;
			g->cur_x   = g->start_x;
			g->cur_y   = g->start_y;

			g->lflags = stbi__get8(s);

			if (g->lflags & 0x40) {
			   g->step = 8 * g->line_size; // first interlaced spacing
			   g->parse = 3;
			} else {
			   g->step = g->line_size;
			   g->parse = 0;
			}

			if (g->lflags & 0x80) {
			   stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
			   g->color_table = (stbi_uc *) g->lpal;
			} else if (g->flags & 0x80) {
			   for (i=0; i < 256; ++i)  // @OPTIMIZE: stbi__jpeg_reset only the previous transparent
				  g->pal[i][3] = 255;
			   if (g->transparent >= 0 && (g->eflags & 0x01))
				  g->pal[g->transparent][3] = 0;
			   g->color_table = (stbi_uc *) g->pal;
			} else
			   return stbi__errpuc("missing color table", "Corrupt GIF");

			o = stbi__process_gif_raster(s, g);
			if (o == NULL) return NULL;

			if (req_comp && req_comp != 4)
			   o = stbi__convert_format(o, 4, req_comp, g->w, g->h);
			return o;
		 }

		 case 0x21: // Comment Extension.
		 {
			int len;
			if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.
			   len = stbi__get8(s);
			   if (len == 4) {
				  g->eflags = stbi__get8(s);
				  stbi__get16le(s); // delay
				  g->transparent = stbi__get8(s);
			   } else {
				  stbi__skip(s, len);
				  break;
			   }
			}
			while ((len = stbi__get8(s)) != 0)
			   stbi__skip(s, len);
			break;
		 }

		 case 0x3B: // gif stream termination code
			return (stbi_uc *) s; // using '1' causes warning on some compilers

		 default:
			return stbi__errpuc("unknown code", "Corrupt GIF");
	  }
   }
}

static stbi_uc *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *u = 0;
   stbi__gif g;
   memset(&g, 0, sizeof(g));

   u = stbi__gif_load_next(s, &g, comp, req_comp);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
	  *x = g.w;
	  *y = g.h;
   }

   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s)
{
   const char *signature = "#?RADIANCE\n";
   int i;
   for (i=0; signature[i]; ++i)
	  if (stbi__get8(s) != signature[i])
		 return 0;
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s);
   stbi__rewind(s);
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
	  buffer[len++] = c;
	  if (len == STBI__HDR_BUFLEN-1) {
		 // flush to end of line
		 while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
			;
		 break;
	  }
	  c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
	  float f1;
	  // Exponent
	  f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
	  if (req_comp <= 2)
		 output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
	  else {
		 output[0] = input[0] * f1;
		 output[1] = input[1] * f1;
		 output[2] = input[2] * f1;
	  }
	  if (req_comp == 2) output[1] = 1;
	  if (req_comp == 4) output[3] = 1;
   } else {
	  switch (req_comp) {
		 case 4: output[3] = 1; /* fallthrough */
		 case 3: output[0] = output[1] = output[2] = 0;
				 break;
		 case 2: output[1] = 1; /* fallthrough */
		 case 1: output[0] = 0;
				 break;
	  }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;

   // Check identifier
   if (strcmp(stbi__hdr_gettoken(s,buffer), "#?RADIANCE") != 0)
	  return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
	  token = stbi__hdr_gettoken(s,buffer);
	  if (token[0] == 0) break;
	  if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   // Read data
   hdr_data = (float *) stbi__malloc(height * width * req_comp * sizeof(float));

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
	  // Read flat data
	  for (j=0; j < height; ++j) {
		 for (i=0; i < width; ++i) {
			stbi_uc rgbe[4];
		   main_decode_loop:
			stbi__getn(s, rgbe, 4);
			stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
		 }
	  }
   } else {
	  // Read RLE-encoded data
	  scanline = NULL;

	  for (j = 0; j < height; ++j) {
		 c1 = stbi__get8(s);
		 c2 = stbi__get8(s);
		 len = stbi__get8(s);
		 if (c1 != 2 || c2 != 2 || (len & 0x80)) {
			// not run-length encoded, so we have to actually use THIS data as a decoded
			// pixel (note this can't be a valid pixel--one of RGB must be >= 128)
			stbi_uc rgbe[4];
			rgbe[0] = (stbi_uc) c1;
			rgbe[1] = (stbi_uc) c2;
			rgbe[2] = (stbi_uc) len;
			rgbe[3] = (stbi_uc) stbi__get8(s);
			stbi__hdr_convert(hdr_data, rgbe, req_comp);
			i = 1;
			j = 0;
			STBI_FREE(scanline);
			goto main_decode_loop; // yes, this makes no sense
		 }
		 len <<= 8;
		 len |= stbi__get8(s);
		 if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
		 if (scanline == NULL) scanline = (stbi_uc *) stbi__malloc(width * 4);

		 for (k = 0; k < 4; ++k) {
			i = 0;
			while (i < width) {
			   count = stbi__get8(s);
			   if (count > 128) {
				  // Run
				  value = stbi__get8(s);
				  count -= 128;
				  for (z = 0; z < count; ++z)
					 scanline[i++ * 4 + k] = value;
			   } else {
				  // Dump
				  for (z = 0; z < count; ++z)
					 scanline[i++ * 4 + k] = stbi__get8(s);
			   }
			}
		 }
		 for (i=0; i < width; ++i)
			stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
	  }
	  STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;

   if (strcmp(stbi__hdr_gettoken(s,buffer), "#?RADIANCE") != 0) {
	   stbi__rewind( s );
	   return 0;
   }

   for(;;) {
	  token = stbi__hdr_gettoken(s,buffer);
	  if (token[0] == 0) break;
	  if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
	   stbi__rewind( s );
	   return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
	   stbi__rewind( s );
	   return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
	   stbi__rewind( s );
	   return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') {
	   stbi__rewind( s );
	   return 0;
   }
   stbi__skip(s,12);
   hsz = stbi__get32le(s);
   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) {
	   stbi__rewind( s );
	   return 0;
   }
   if (hsz == 12) {
	  *x = stbi__get16le(s);
	  *y = stbi__get16le(s);
   } else {
	  *x = stbi__get32le(s);
	  *y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) {
	   stbi__rewind( s );
	   return 0;
   }
   *comp = stbi__get16le(s) / 8;
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount;
   if (stbi__get32be(s) != 0x38425053) {
	   stbi__rewind( s );
	   return 0;
   }
   if (stbi__get16be(s) != 1) {
	   stbi__rewind( s );
	   return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
	   stbi__rewind( s );
	   return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   if (stbi__get16be(s) != 8) {
	   stbi__rewind( s );
	   return 0;
   }
   if (stbi__get16be(s) != 3) {
	   stbi__rewind( s );
	   return 0;
   }
   *comp = 4;
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained;
   stbi__pic_packet packets[10];

   stbi__skip(s, 92);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s))  return 0;
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
	   stbi__rewind( s );
	   return 0;
   }

   stbi__skip(s, 8);

   do {
	  stbi__pic_packet *packet;

	  if (num_packets==sizeof(packets)/sizeof(packets[0]))
		 return 0;

	  packet = &packets[num_packets++];
	  chained = stbi__get8(s);
	  packet->size    = stbi__get8(s);
	  packet->type    = stbi__get8(s);
	  packet->channel = stbi__get8(s);
	  act_comp |= packet->channel;

	  if (stbi__at_eof(s)) {
		  stbi__rewind( s );
		  return 0;
	  }
	  if (packet->size != 8) {
		  stbi__rewind( s );
		  return 0;
	  }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)
//    Does not support 16-bit-per-channel

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
	   stbi__rewind( s );
	   return 0;
   }
   return 1;
}

static stbi_uc *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *out;
   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
	  return 0;
   *x = s->img_x;
   *y = s->img_y;
   *comp = s->img_n;

   out = (stbi_uc *) stbi__malloc(s->img_n * s->img_x * s->img_y);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

   if (req_comp && req_comp != s->img_n) {
	  out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
	  if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
	  *c = (char) stbi__get8(s);
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
	  value = value*10 + (*c - '0');
	  *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv;
   char c, p, t;

   stbi__rewind( s );

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
	   stbi__rewind( s );
	   return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value

   if (maxv > 255)
	  return stbi__err("max value > 255", "PPM image not 8-bit");
   else
	  return 1;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
	   return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
	FILE *f = stbi__fopen(filename, "rb");
	int result;
	if (!f) return stbi__err("can't fopen", "Unable to open file");
	result = stbi_info_from_file(f, x, y, comp);
	fclose(f);
	return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

// add in my DDS loading support
#ifndef STBI_NO_DDS

//#line 1 "stbi_DDS_c.h"
///	DDS file support, does decoding, _not_ direct uploading
///	(use SOIL for that ;-)

///	A bunch of DirectDraw Surface structures and flags
typedef struct {
	unsigned int    dwMagic;
	unsigned int    dwSize;
	unsigned int    dwFlags;
	unsigned int    dwHeight;
	unsigned int    dwWidth;
	unsigned int    dwPitchOrLinearSize;
	unsigned int    dwDepth;
	unsigned int    dwMipMapCount;
	unsigned int    dwReserved1[ 11 ];

	//  DDPIXELFORMAT
	struct {
	  unsigned int    dwSize;
	  unsigned int    dwFlags;
	  unsigned int    dwFourCC;
	  unsigned int    dwRGBBitCount;
	  unsigned int    dwRBitMask;
	  unsigned int    dwGBitMask;
	  unsigned int    dwBBitMask;
	  unsigned int    dwAlphaBitMask;
	}               sPixelFormat;

	//  DDCAPS2
	struct {
	  unsigned int    dwCaps1;
	  unsigned int    dwCaps2;
	  unsigned int    dwDDSX;
	  unsigned int    dwReserved;
	}               sCaps;
	unsigned int    dwReserved2;
} DDS_header ;

//	the following constants were copied directly off the MSDN website

//	The dwFlags member of the original DDSURFACEDESC2 structure
//	can be set to one or more of the following values.
#define DDSD_CAPS	0x00000001
#define DDSD_HEIGHT	0x00000002
#define DDSD_WIDTH	0x00000004
#define DDSD_PITCH	0x00000008
#define DDSD_PIXELFORMAT	0x00001000
#define DDSD_MIPMAPCOUNT	0x00020000
#define DDSD_LINEARSIZE	0x00080000
#define DDSD_DEPTH	0x00800000

//	DirectDraw Pixel Format
#define DDPF_ALPHAPIXELS	0x00000001
#define DDPF_FOURCC	0x00000004
#define DDPF_RGB	0x00000040

//	The dwCaps1 member of the DDSCAPS2 structure can be
//	set to one or more of the following values.
#define DDSCAPS_COMPLEX	0x00000008
#define DDSCAPS_TEXTURE	0x00001000
#define DDSCAPS_MIPMAP	0x00400000

//	The dwCaps2 member of the DDSCAPS2 structure can be
//	set to one or more of the following values.
#define DDSCAPS2_CUBEMAP	0x00000200
#define DDSCAPS2_CUBEMAP_POSITIVEX	0x00000400
#define DDSCAPS2_CUBEMAP_NEGATIVEX	0x00000800
#define DDSCAPS2_CUBEMAP_POSITIVEY	0x00001000
#define DDSCAPS2_CUBEMAP_NEGATIVEY	0x00002000
#define DDSCAPS2_CUBEMAP_POSITIVEZ	0x00004000
#define DDSCAPS2_CUBEMAP_NEGATIVEZ	0x00008000
#define DDSCAPS2_VOLUME	0x00200000

static int stbi__dds_test(stbi__context *s)
{
	//	check the magic number
	if (stbi__get8(s) != 'D') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'D') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'S') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != ' ') {
		stbi__rewind(s);
		return 0;
	}

	//	check header size
	if (stbi__get32le(s) != 124) {
		stbi__rewind(s);
		return 0;
	}

	// Also rewind because the loader needs to read the header
	stbi__rewind(s);

	return 1;
}
#ifndef STBI_NO_STDIO

int      stbi__dds_test_filename        		(char const *filename)
{
   int r;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   r = stbi__dds_test_file(f);
   fclose(f);
   return r;
}

int      stbi__dds_test_file        (FILE *f)
{
   stbi__context s;
   int r,n = ftell(f);
   stbi__start_file(&s,f);
   r = stbi__dds_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi__dds_test_memory      (stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__dds_test(&s);
}

int      stbi__dds_test_callbacks      (stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__dds_test(&s);
}

//	helper functions
int stbi_convert_bit_range( int c, int from_bits, int to_bits )
{
	int b = (1 << (from_bits - 1)) + c * ((1 << to_bits) - 1);
	return (b + (b >> from_bits)) >> from_bits;
}
void stbi_rgb_888_from_565( unsigned int c, int *r, int *g, int *b )
{
	*r = stbi_convert_bit_range( (c >> 11) & 31, 5, 8 );
	*g = stbi_convert_bit_range( (c >> 05) & 63, 6, 8 );
	*b = stbi_convert_bit_range( (c >> 00) & 31, 5, 8 );
}
void stbi_decode_DXT1_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int next_bit = 4*8;
	int i, r, g, b;
	int c0, c1;
	unsigned char decode_colors[4*4];
	//	find the 2 primary colors
	c0 = compressed[0] + (compressed[1] << 8);
	c1 = compressed[2] + (compressed[3] << 8);
	stbi_rgb_888_from_565( c0, &r, &g, &b );
	decode_colors[0] = r;
	decode_colors[1] = g;
	decode_colors[2] = b;
	decode_colors[3] = 255;
	stbi_rgb_888_from_565( c1, &r, &g, &b );
	decode_colors[4] = r;
	decode_colors[5] = g;
	decode_colors[6] = b;
	decode_colors[7] = 255;
	if( c0 > c1 )
	{
		//	no alpha, 2 interpolated colors
		decode_colors[8] = (2*decode_colors[0] + decode_colors[4]) / 3;
		decode_colors[9] = (2*decode_colors[1] + decode_colors[5]) / 3;
		decode_colors[10] = (2*decode_colors[2] + decode_colors[6]) / 3;
		decode_colors[11] = 255;
		decode_colors[12] = (decode_colors[0] + 2*decode_colors[4]) / 3;
		decode_colors[13] = (decode_colors[1] + 2*decode_colors[5]) / 3;
		decode_colors[14] = (decode_colors[2] + 2*decode_colors[6]) / 3;
		decode_colors[15] = 255;
	} else
	{
		//	1 interpolated color, alpha
		decode_colors[8] = (decode_colors[0] + decode_colors[4]) / 2;
		decode_colors[9] = (decode_colors[1] + decode_colors[5]) / 2;
		decode_colors[10] = (decode_colors[2] + decode_colors[6]) / 2;
		decode_colors[11] = 255;
		decode_colors[12] = 0;
		decode_colors[13] = 0;
		decode_colors[14] = 0;
		decode_colors[15] = 0;
	}
	//	decode the block
	for( i = 0; i < 16*4; i += 4 )
	{
		int idx = ((compressed[next_bit>>3] >> (next_bit & 7)) & 3) * 4;
		next_bit += 2;
		uncompressed[i+0] = decode_colors[idx+0];
		uncompressed[i+1] = decode_colors[idx+1];
		uncompressed[i+2] = decode_colors[idx+2];
		uncompressed[i+3] = decode_colors[idx+3];
	}
	//	done
}
void stbi_decode_DXT23_alpha_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int i, next_bit = 0;
	//	each alpha value gets 4 bits
	for( i = 3; i < 16*4; i += 4 )
	{
		uncompressed[i] = stbi_convert_bit_range(
				(compressed[next_bit>>3] >> (next_bit&7)) & 15,
				4, 8 );
		next_bit += 4;
	}
}
void stbi_decode_DXT45_alpha_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int i, next_bit = 8*2;
	unsigned char decode_alpha[8];
	//	each alpha value gets 3 bits, and the 1st 2 bytes are the range
	decode_alpha[0] = compressed[0];
	decode_alpha[1] = compressed[1];
	if( decode_alpha[0] > decode_alpha[1] )
	{
		//	6 step intermediate
		decode_alpha[2] = (6*decode_alpha[0] + 1*decode_alpha[1]) / 7;
		decode_alpha[3] = (5*decode_alpha[0] + 2*decode_alpha[1]) / 7;
		decode_alpha[4] = (4*decode_alpha[0] + 3*decode_alpha[1]) / 7;
		decode_alpha[5] = (3*decode_alpha[0] + 4*decode_alpha[1]) / 7;
		decode_alpha[6] = (2*decode_alpha[0] + 5*decode_alpha[1]) / 7;
		decode_alpha[7] = (1*decode_alpha[0] + 6*decode_alpha[1]) / 7;
	} else
	{
		//	4 step intermediate, pluss full and none
		decode_alpha[2] = (4*decode_alpha[0] + 1*decode_alpha[1]) / 5;
		decode_alpha[3] = (3*decode_alpha[0] + 2*decode_alpha[1]) / 5;
		decode_alpha[4] = (2*decode_alpha[0] + 3*decode_alpha[1]) / 5;
		decode_alpha[5] = (1*decode_alpha[0] + 4*decode_alpha[1]) / 5;
		decode_alpha[6] = 0;
		decode_alpha[7] = 255;
	}
	for( i = 3; i < 16*4; i += 4 )
	{
		int idx = 0, bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 0;
		++next_bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 1;
		++next_bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 2;
		++next_bit;
		uncompressed[i] = decode_alpha[idx & 7];
	}
	//	done
}
void stbi_decode_DXT_color_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int next_bit = 4*8;
	int i, r, g, b;
	int c0, c1;
	unsigned char decode_colors[4*3];
	//	find the 2 primary colors
	c0 = compressed[0] + (compressed[1] << 8);
	c1 = compressed[2] + (compressed[3] << 8);
	stbi_rgb_888_from_565( c0, &r, &g, &b );
	decode_colors[0] = r;
	decode_colors[1] = g;
	decode_colors[2] = b;
	stbi_rgb_888_from_565( c1, &r, &g, &b );
	decode_colors[3] = r;
	decode_colors[4] = g;
	decode_colors[5] = b;
	//	Like DXT1, but no choicees:
	//	no alpha, 2 interpolated colors
	decode_colors[6] = (2*decode_colors[0] + decode_colors[3]) / 3;
	decode_colors[7] = (2*decode_colors[1] + decode_colors[4]) / 3;
	decode_colors[8] = (2*decode_colors[2] + decode_colors[5]) / 3;
	decode_colors[9] = (decode_colors[0] + 2*decode_colors[3]) / 3;
	decode_colors[10] = (decode_colors[1] + 2*decode_colors[4]) / 3;
	decode_colors[11] = (decode_colors[2] + 2*decode_colors[5]) / 3;
	//	decode the block
	for( i = 0; i < 16*4; i += 4 )
	{
		int idx = ((compressed[next_bit>>3] >> (next_bit & 7)) & 3) * 3;
		next_bit += 2;
		uncompressed[i+0] = decode_colors[idx+0];
		uncompressed[i+1] = decode_colors[idx+1];
		uncompressed[i+2] = decode_colors[idx+2];
	}
	//	done
}

static int stbi__dds_info( stbi__context *s, int *x, int *y, int *comp, int *iscompressed ) {
	int flags,is_compressed,has_alpha,cubemap_faces;
	DDS_header header={0};

	if( sizeof( DDS_header ) != 128 )
	{
		return 0;
	}

	stbi__getn( s, (stbi_uc*)(&header), 128 );

	if( header.dwMagic != (('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24)) ) {
	   stbi__rewind( s );
	   return 0;
	}
	if( header.dwSize != 124 ) {
	   stbi__rewind( s );
	   return 0;
	}
	flags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flags) != flags ) {
	   stbi__rewind( s );
	   return 0;
	}
	if( header.sPixelFormat.dwSize != 32 ) {
	   stbi__rewind( s );
	   return 0;
	}
	flags = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flags) == 0 ) {
	   stbi__rewind( s );
	   return 0;
	}
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) {
	   stbi__rewind( s );
	   return 0;
	}

	is_compressed = (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	has_alpha = (header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS) / DDPF_ALPHAPIXELS;
	cubemap_faces = (header.sCaps.dwCaps2 & DDSCAPS2_CUBEMAP) / DDSCAPS2_CUBEMAP;
	/*	I need cubemaps to have square faces	*/
	cubemap_faces &= (header.dwWidth == header.dwHeight);
	cubemap_faces *= 5;
	cubemap_faces += 1;

	*x = header.dwWidth;
	*y = header.dwHeight * cubemap_faces;

	if ( !is_compressed ) {
		*comp = 3;

		if ( has_alpha )
			*comp = 4;
	}
	else
		*comp = 4;

	if ( iscompressed )
		*iscompressed = is_compressed;

	return 1;
}

int stbi__dds_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int *iscompressed)
{
	stbi__context s;
	stbi__start_mem(&s,buffer, len);
	return stbi__dds_info( &s, x, y, comp, iscompressed );
}

int stbi__dds_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int *iscompressed)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
	return stbi__dds_info( &s, x, y, comp, iscompressed );
}

#ifndef STBI_NO_STDIO
int stbi__dds_info_from_path(char const *filename,     int *x, int *y, int *comp, int *iscompressed)
{
   int res;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   res = stbi__dds_info_from_file( f, x, y, comp, iscompressed );
   fclose(f);
   return res;
}

int stbi__dds_info_from_file(FILE *f,                  int *x, int *y, int *comp, int *iscompressed)
{
   stbi__context s;
   int res;
   long n = ftell(f);
   stbi__start_file(&s, f);
   res = stbi__dds_info(&s, x, y, comp, iscompressed);
   fseek(f, n, SEEK_SET);
   return res;
}
#endif

static stbi_uc * stbi__dds_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	//	all variables go up front
	stbi_uc *dds_data = NULL;
	stbi_uc block[16*4];
	stbi_uc compressed[8];
	int flags, DXT_family;
	int has_alpha, has_mipmap;
	int is_compressed, cubemap_faces;
	int block_pitch, num_blocks;
	DDS_header header={0};
	int i, sz, cf;
	//	load the header
	if( sizeof( DDS_header ) != 128 )
	{
		return NULL;
	}
	stbi__getn( s, (stbi_uc*)(&header), 128 );
	//	and do some checking
	if( header.dwMagic != (('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24)) ) return NULL;
	if( header.dwSize != 124 ) return NULL;
	flags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flags) != flags ) return NULL;
	/*	According to the MSDN spec, the dwFlags should contain
		DDSD_LINEARSIZE if it's compressed, or DDSD_PITCH if
		uncompressed.  Some DDS writers do not conform to the
		spec, so I need to make my reader more tolerant	*/
	if( header.sPixelFormat.dwSize != 32 ) return NULL;
	flags = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flags) == 0 ) return NULL;
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) return NULL;
	//	get the image data
	s->img_x = header.dwWidth;
	s->img_y = header.dwHeight;
	s->img_n = 4;
	is_compressed = (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	has_alpha = (header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS) / DDPF_ALPHAPIXELS;
	has_mipmap = (header.sCaps.dwCaps1 & DDSCAPS_MIPMAP) && (header.dwMipMapCount > 1);
	cubemap_faces = (header.sCaps.dwCaps2 & DDSCAPS2_CUBEMAP) / DDSCAPS2_CUBEMAP;
	/*	I need cubemaps to have square faces	*/
	cubemap_faces &= (s->img_x == s->img_y);
	cubemap_faces *= 5;
	cubemap_faces += 1;
	block_pitch = (s->img_x+3) >> 2;
	num_blocks = block_pitch * ((s->img_y+3) >> 2);
	/*	let the user know what's going on	*/
	*x = s->img_x;
	*y = s->img_y;
	*comp = s->img_n;
	/*	is this uncompressed?	*/
	if( is_compressed )
	{
		/*	compressed	*/
		//	note: header.sPixelFormat.dwFourCC is something like (('D'<<0)|('X'<<8)|('T'<<16)|('1'<<24))
		DXT_family = 1 + (header.sPixelFormat.dwFourCC >> 24) - '1';
		if( (DXT_family < 1) || (DXT_family > 5) ) return NULL;
		/*	check the expected size...oops, nevermind...
			those non-compliant writers leave
			dwPitchOrLinearSize == 0	*/
		//	passed all the tests, get the RAM for decoding
		sz = (s->img_x)*(s->img_y)*4*cubemap_faces;
		dds_data = (unsigned char*)STBI_MALLOC( sz );
		/*	do this once for each face	*/
		for( cf = 0; cf < cubemap_faces; ++ cf )
		{
			//	now read and decode all the blocks
			for( i = 0; i < num_blocks; ++i )
			{
				//	where are we?
				int bx, by, bw=4, bh=4;
				int ref_x = 4 * (i % block_pitch);
				int ref_y = 4 * (i / block_pitch);
				//	get the next block's worth of compressed data, and decompress it
				if( DXT_family == 1 )
				{
					//	DXT1
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT1_block( block, compressed );
				} else if( DXT_family < 4 )
				{
					//	DXT2/3
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT23_alpha_block ( block, compressed );
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT_color_block ( block, compressed );
				} else
				{
					//	DXT4/5
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT45_alpha_block ( block, compressed );
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT_color_block ( block, compressed );
				}
				//	is this a partial block?
				if( ref_x + 4 > (int)s->img_x )
				{
					bw = s->img_x - ref_x;
				}
				if( ref_y + 4 > (int)s->img_y )
				{
					bh = s->img_y - ref_y;
				}
				//	now drop our decompressed data into the buffer
				for( by = 0; by < bh; ++by )
				{
					int idx = 4*((ref_y+by+cf*s->img_x)*s->img_x + ref_x);
					for( bx = 0; bx < bw*4; ++bx )
					{

						dds_data[idx+bx] = block[by*16+bx];
					}
				}
			}
			/*	done reading and decoding the main image...
				stbi__skip MIPmaps if present	*/
			if( has_mipmap )
			{
				int block_size = 16;
				if( DXT_family == 1 )
				{
					block_size = 8;
				}
				for( i = 1; i < (int)header.dwMipMapCount; ++i )
				{
					int mx = s->img_x >> (i + 2);
					int my = s->img_y >> (i + 2);
					if( mx < 1 )
					{
						mx = 1;
					}
					if( my < 1 )
					{
						my = 1;
					}
					stbi__skip( s, mx*my*block_size );
				}
			}
		}/* per cubemap face */
	} else
	{
		/*	uncompressed	*/
		DXT_family = 0;
		s->img_n = 3;
		if( has_alpha )
		{
			s->img_n = 4;
		}
		*comp = s->img_n;
		sz = s->img_x*s->img_y*s->img_n*cubemap_faces;
		dds_data = (unsigned char*)malloc( sz );
		/*	do this once for each face	*/
		for( cf = 0; cf < cubemap_faces; ++ cf )
		{
			/*	read the main image for this face	*/
			stbi__getn( s, &dds_data[cf*s->img_x*s->img_y*s->img_n], s->img_x*s->img_y*s->img_n );
			/*	done reading and decoding the main image...
				stbi__skip MIPmaps if present	*/
			if( has_mipmap )
			{
				for( i = 1; i < (int)header.dwMipMapCount; ++i )
				{
					int mx = s->img_x >> i;
					int my = s->img_y >> i;
					if( mx < 1 )
					{
						mx = 1;
					}
					if( my < 1 )
					{
						my = 1;
					}
					stbi__skip( s, mx*my*s->img_n );
				}
			}
		}
		/*	data was BGR, I need it RGB	*/
		for( i = 0; i < sz; i += s->img_n )
		{
			unsigned char temp = dds_data[i];
			dds_data[i] = dds_data[i+2];
			dds_data[i+2] = temp;
		}
	}
	/*	finished decompressing into RGBA,
		adjust the y size if we have a cubemap
		note: sz is already up to date	*/
	s->img_y *= cubemap_faces;
	*y = s->img_y;
	//	did the user want something else, or
	//	see if all the alpha values are 255 (i.e. no transparency)
	has_alpha = 0;
	if( s->img_n == 4)
	{
		for( i = 3; (i < sz) && (has_alpha == 0); i += 4 )
		{
			has_alpha |= (dds_data[i] < 255);
		}
	}
	if( (req_comp <= 4) && (req_comp >= 1) )
	{
		//	user has some requirements, meet them
		if( req_comp != s->img_n )
		{
			dds_data = stbi__convert_format( dds_data, s->img_n, req_comp, s->img_x, s->img_y );
			*comp = req_comp;
		}
	} else
	{
		//	user had no requirements, only drop to RGB is no alpha
		if( (has_alpha == 0) && (s->img_n == 4) )
		{
			dds_data = stbi__convert_format( dds_data, 4, 3, s->img_x, s->img_y );
			*comp = 3;
		}
	}
	//	OK, done
	return dds_data;
}

#ifndef STBI_NO_STDIO
stbi_uc *stbi__dds_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s,f);
	return stbi__dds_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi__dds_load_from_path             (const char *filename,           int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi__dds_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

stbi_uc *stbi__dds_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__dds_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi__dds_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__dds_load(&s,x,y,comp,req_comp);
}


#endif

// add in my pvr loading support
#ifndef STBI_NO_PVR

//#line 1 "stbi_pvr_c.h"

//#line 1 "pvr_helper.h"
#ifndef PVR_HELPER_H
#define PVR_HELPER_H

// Taken from PowerVR SDK

/*!***************************************************************************
 Describes the header of a PVR header-texture
 *****************************************************************************/
typedef struct
{
	unsigned int dwHeaderSize;			/*!< size of the structure */
	unsigned int dwHeight;				/*!< height of surface to be created */
	unsigned int dwWidth;				/*!< width of input surface */
	unsigned int dwMipMapCount;			/*!< number of mip-map levels requested */
	unsigned int dwpfFlags;				/*!< pixel format flags */
	unsigned int dwTextureDataSize;		/*!< Total size in bytes */
	unsigned int dwBitCount;			/*!< number of bits per pixel  */
	unsigned int dwRBitMask;			/*!< mask for red bit */
	unsigned int dwGBitMask;			/*!< mask for green bits */
	unsigned int dwBBitMask;			/*!< mask for blue bits */
	unsigned int dwAlphaBitMask;		/*!< mask for alpha channel */
	unsigned int dwPVR;					/*!< magic number identifying pvr file */
	unsigned int dwNumSurfs;			/*!< the number of surfaces present in the pvr */
} PVR_Texture_Header;

/*****************************************************************************
 * ENUMS
 *****************************************************************************/

enum PixelType
{
	MGLPT_ARGB_4444 = 0x00,
	MGLPT_ARGB_1555,
	MGLPT_RGB_565,
	MGLPT_RGB_555,
	MGLPT_RGB_888,
	MGLPT_ARGB_8888,
	MGLPT_ARGB_8332,
	MGLPT_I_8,
	MGLPT_AI_88,
	MGLPT_1_BPP,
	MGLPT_VY1UY0,
	MGLPT_Y1VY0U,
	MGLPT_PVRTC2,
	MGLPT_PVRTC4,
	MGLPT_PVRTC2_2,
	MGLPT_PVRTC2_4,

	OGL_RGBA_4444= 0x10,
	OGL_RGBA_5551,
	OGL_RGBA_8888,
	OGL_RGB_565,
	OGL_RGB_555,
	OGL_RGB_888,
	OGL_I_8,
	OGL_AI_88,
	OGL_PVRTC2,
	OGL_PVRTC4,

	// OGL_BGRA_8888 extension
	OGL_BGRA_8888,

	D3D_DXT1 = 0x20,
	D3D_DXT2,
	D3D_DXT3,
	D3D_DXT4,
	D3D_DXT5,

	D3D_RGB_332,
	D3D_AI_44,
	D3D_LVU_655,
	D3D_XLVU_8888,
	D3D_QWVU_8888,

	//10 bits per channel
	D3D_ABGR_2101010,
	D3D_ARGB_2101010,
	D3D_AWVU_2101010,

	//16 bits per channel
	D3D_GR_1616,
	D3D_VU_1616,
	D3D_ABGR_16161616,

	//HDR formats
	D3D_R16F,
	D3D_GR_1616F,
	D3D_ABGR_16161616F,

	//32 bits per channel
	D3D_R32F,
	D3D_GR_3232F,
	D3D_ABGR_32323232F,

	// Ericsson
	ETC_RGB_4BPP,
	ETC_RGBA_EXPLICIT,
	ETC_RGBA_INTERPOLATED,

	// DX10

	ePT_DX10_R32G32B32A32_FLOAT= 0x50,
	ePT_DX10_R32G32B32A32_UINT ,
	ePT_DX10_R32G32B32A32_SINT,

	ePT_DX10_R32G32B32_FLOAT,
	ePT_DX10_R32G32B32_UINT,
	ePT_DX10_R32G32B32_SINT,

	ePT_DX10_R16G16B16A16_FLOAT ,
	ePT_DX10_R16G16B16A16_UNORM,
	ePT_DX10_R16G16B16A16_UINT ,
	ePT_DX10_R16G16B16A16_SNORM ,
	ePT_DX10_R16G16B16A16_SINT ,

	ePT_DX10_R32G32_FLOAT ,
	ePT_DX10_R32G32_UINT ,
	ePT_DX10_R32G32_SINT ,

	ePT_DX10_R10G10B10A2_UNORM ,
	ePT_DX10_R10G10B10A2_UINT ,

	ePT_DX10_R11G11B10_FLOAT ,

	ePT_DX10_R8G8B8A8_UNORM ,
	ePT_DX10_R8G8B8A8_UNORM_SRGB ,
	ePT_DX10_R8G8B8A8_UINT ,
	ePT_DX10_R8G8B8A8_SNORM ,
	ePT_DX10_R8G8B8A8_SINT ,

	ePT_DX10_R16G16_FLOAT ,
	ePT_DX10_R16G16_UNORM ,
	ePT_DX10_R16G16_UINT ,
	ePT_DX10_R16G16_SNORM ,
	ePT_DX10_R16G16_SINT ,

	ePT_DX10_R32_FLOAT ,
	ePT_DX10_R32_UINT ,
	ePT_DX10_R32_SINT ,

	ePT_DX10_R8G8_UNORM ,
	ePT_DX10_R8G8_UINT ,
	ePT_DX10_R8G8_SNORM ,
	ePT_DX10_R8G8_SINT ,

	ePT_DX10_R16_FLOAT ,
	ePT_DX10_R16_UNORM ,
	ePT_DX10_R16_UINT ,
	ePT_DX10_R16_SNORM ,
	ePT_DX10_R16_SINT ,

	ePT_DX10_R8_UNORM,
	ePT_DX10_R8_UINT,
	ePT_DX10_R8_SNORM,
	ePT_DX10_R8_SINT,

	ePT_DX10_A8_UNORM,
	ePT_DX10_R1_UNORM,
	ePT_DX10_R9G9B9E5_SHAREDEXP,
	ePT_DX10_R8G8_B8G8_UNORM,
	ePT_DX10_G8R8_G8B8_UNORM,

	ePT_DX10_BC1_UNORM,
	ePT_DX10_BC1_UNORM_SRGB,

	ePT_DX10_BC2_UNORM,
	ePT_DX10_BC2_UNORM_SRGB,

	ePT_DX10_BC3_UNORM,
	ePT_DX10_BC3_UNORM_SRGB,

	ePT_DX10_BC4_UNORM,
	ePT_DX10_BC4_SNORM,

	ePT_DX10_BC5_UNORM,
	ePT_DX10_BC5_SNORM,

	//ePT_DX10_B5G6R5_UNORM,			// defined but obsolete - won't actually load in DX10
	//ePT_DX10_B5G5R5A1_UNORM,
	//ePT_DX10_B8G8R8A8_UNORM,
	//ePT_DX10_B8G8R8X8_UNORM,

	// OpenVG

	/* RGB{A,X} channel ordering */
	ePT_VG_sRGBX_8888  = 0x90,
	ePT_VG_sRGBA_8888,
	ePT_VG_sRGBA_8888_PRE,
	ePT_VG_sRGB_565,
	ePT_VG_sRGBA_5551,
	ePT_VG_sRGBA_4444,
	ePT_VG_sL_8,
	ePT_VG_lRGBX_8888,
	ePT_VG_lRGBA_8888,
	ePT_VG_lRGBA_8888_PRE,
	ePT_VG_lL_8,
	ePT_VG_A_8,
	ePT_VG_BW_1,

	/* {A,X}RGB channel ordering */
	ePT_VG_sXRGB_8888,
	ePT_VG_sARGB_8888,
	ePT_VG_sARGB_8888_PRE,
	ePT_VG_sARGB_1555,
	ePT_VG_sARGB_4444,
	ePT_VG_lXRGB_8888,
	ePT_VG_lARGB_8888,
	ePT_VG_lARGB_8888_PRE,

	/* BGR{A,X} channel ordering */
	ePT_VG_sBGRX_8888,
	ePT_VG_sBGRA_8888,
	ePT_VG_sBGRA_8888_PRE,
	ePT_VG_sBGR_565,
	ePT_VG_sBGRA_5551,
	ePT_VG_sBGRA_4444,
	ePT_VG_lBGRX_8888,
	ePT_VG_lBGRA_8888,
	ePT_VG_lBGRA_8888_PRE,

	/* {A,X}BGR channel ordering */
	ePT_VG_sXBGR_8888,
	ePT_VG_sABGR_8888 ,
	ePT_VG_sABGR_8888_PRE,
	ePT_VG_sABGR_1555,
	ePT_VG_sABGR_4444,
	ePT_VG_lXBGR_8888,
	ePT_VG_lABGR_8888,
	ePT_VG_lABGR_8888_PRE,

	// max cap for iterating
	END_OF_PIXEL_TYPES,

	MGLPT_NOTYPE = 0xff

};

/*****************************************************************************
 * constants
 *****************************************************************************/

#define PVRTEX_MIPMAP		(1<<8)		// has mip map levels
#define PVRTEX_TWIDDLE		(1<<9)		// is twiddled
#define PVRTEX_BUMPMAP		(1<<10)		// has normals encoded for a bump map
#define PVRTEX_TILING		(1<<11)		// is bordered for tiled pvr
#define PVRTEX_CUBEMAP		(1<<12)		// is a cubemap/skybox
#define PVRTEX_FALSEMIPCOL	(1<<13)		//
#define PVRTEX_VOLUME		(1<<14)
#define PVRTEX_PIXELTYPE	0xff			// pixel type is always in the last 16bits of the flags
#define PVRTEX_IDENTIFIER	0x21525650	// the pvr identifier is the characters 'P','V','R'

#define PVRTEX_V1_HEADER_SIZE 44			// old header size was 44 for identification purposes

#define PVRTC2_MIN_TEXWIDTH		16
#define PVRTC2_MIN_TEXHEIGHT	8
#define PVRTC4_MIN_TEXWIDTH		8
#define PVRTC4_MIN_TEXHEIGHT	8
#define ETC_MIN_TEXWIDTH		4
#define ETC_MIN_TEXHEIGHT		4
#define DXT_MIN_TEXWIDTH		4
#define DXT_MIN_TEXHEIGHT		4

#endif

static int stbi__pvr_test(stbi__context *s)
{
	//	check header size
	if (stbi__get32le(s) != sizeof(PVR_Texture_Header)) {
		stbi__rewind(s);
		return 0;
	}

	// stbi__skip until the magic number
	stbi__skip(s, 10*4);

	// check the magic number
	if ( stbi__get32le(s) != PVRTEX_IDENTIFIER ) {
		stbi__rewind(s);
		return 0;
	}

	// Also rewind because the loader needs to read the header
	stbi__rewind(s);

	return 1;
}

#ifndef STBI_NO_STDIO

int      stbi__pvr_test_filename        		(char const *filename)
{
   int r;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   r = stbi__pvr_test_file(f);
   fclose(f);
   return r;
}

int      stbi__pvr_test_file        (FILE *f)
{
   stbi__context s;
   int r,n = ftell(f);
   stbi__start_file(&s,f);
   r = stbi__pvr_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi__pvr_test_memory      (stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pvr_test(&s);
}

int      stbi__pvr_test_callbacks      (stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pvr_test(&s);
}

static int stbi__pvr_info(stbi__context *s, int *x, int *y, int *comp, int * iscompressed )
{
	PVR_Texture_Header header={0};

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PVR_Texture_Header) );

	// Check the header size
	if ( header.dwHeaderSize != sizeof(PVR_Texture_Header) ) {
		stbi__rewind( s );
		return 0;
	}

	// Check the magic identifier
	if ( header.dwPVR != PVRTEX_IDENTIFIER ) {
		stbi__rewind(s);
		return 0;
	}

	*x = s->img_x = header.dwWidth;
	*y = s->img_y = header.dwHeight;
	*comp = s->img_n = ( header.dwBitCount + 7 ) / 8;

	if ( iscompressed )
		*iscompressed = 0;

	switch ( header.dwpfFlags & PVRTEX_PIXELTYPE )
	{
		case OGL_RGBA_4444:
			s->img_n = 2;
			break;
		case OGL_RGBA_5551:
			s->img_n = 2;
			break;
		case OGL_RGBA_8888:
			s->img_n = 4;
			break;
		case OGL_RGB_565:
			s->img_n = 2;
			break;
		case OGL_RGB_888:
			s->img_n = 3;
			break;
		case OGL_I_8:
			s->img_n = 1;
			break;
		case OGL_AI_88:
			s->img_n = 2;
			break;
		case OGL_PVRTC2:
			s->img_n = 4;
			if ( iscompressed )
				*iscompressed = 1;
			break;
		case OGL_PVRTC4:
			s->img_n = 4;
			if ( iscompressed )
				*iscompressed = 1;
			break;
		case OGL_RGB_555:
		default:
			stbi__rewind(s);
			return 0;
	}

	*comp = s->img_n;

	return 1;
}

int stbi__pvr_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int * iscompressed )
{
	stbi__context s;
	stbi__start_mem(&s,buffer, len);
	return stbi__pvr_info( &s, x, y, comp, iscompressed );
}

int stbi__pvr_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int * iscompressed)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
	return stbi__pvr_info( &s, x, y, comp, iscompressed );
}

#ifndef STBI_NO_STDIO
int stbi__pvr_info_from_path(char const *filename,     int *x, int *y, int *comp, int * iscompressed)
{
   int res;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   res = stbi__pvr_info_from_file( f, x, y, comp, iscompressed );
   fclose(f);
   return res;
}

int stbi__pvr_info_from_file(FILE *f,                  int *x, int *y, int *comp, int * iscompressed)
{
   stbi__context s;
   int res;
   long n = ftell(f);
   stbi__start_file(&s, f);
   res = stbi__pvr_info(&s, x, y, comp, iscompressed);
   fseek(f, n, SEEK_SET);
   return res;
}
#endif

/******************************************************************************
 Taken from:
 @File         PVRTDecompress.cpp
 @Title        PVRTDecompress
 @Copyright    Copyright (C)  Imagination Technologies Limited.
 @Platform     ANSI compatible
 @Description  PVRTC Texture Decompression.
******************************************************************************/

typedef unsigned char      PVRTuint8;
typedef unsigned short     PVRTuint16;
typedef unsigned int       PVRTuint32;

/*****************************************************************************
 * defines and consts
 *****************************************************************************/
#define PT_INDEX (2)	// The Punch-through index

#define BLK_Y_SIZE 	(4) // always 4 for all 2D block types

#define BLK_X_MAX	(8)	// Max X dimension for blocks

#define BLK_X_2BPP	(8) // dimensions for the two formats
#define BLK_X_4BPP	(4)

#define WRAP_COORD(Val, Size) ((Val) & ((Size)-1))

#define POWER_OF_2(X)   util_number_is_power_2(X)

/*
	Define an expression to either wrap or clamp large or small vals to the
	legal coordinate range
*/
#define PVRT_MIN(a,b)            (((a) < (b)) ? (a) : (b))
#define PVRT_MAX(a,b)            (((a) > (b)) ? (a) : (b))
#define PVRT_CLAMP(x, l, h)      (PVRT_MIN((h), PVRT_MAX((x), (l))))

#define LIMIT_COORD(Val, Size, AssumeImageTiles) \
	  ((AssumeImageTiles)? WRAP_COORD((Val), (Size)): PVRT_CLAMP((Val), 0, (Size)-1))

/*****************************************************************************
 * Useful typedefs
 *****************************************************************************/
typedef PVRTuint32 U32;
typedef PVRTuint8 U8;

/***********************************************************
				DECOMPRESSION ROUTINES
************************************************************/

/*!***********************************************************************
 @Struct	AMTC_BLOCK_STRUCT
 @Brief
*************************************************************************/
typedef struct
{
	// Uses 64 bits pre block
	U32 PackedData[2];
}AMTC_BLOCK_STRUCT;

 /*!***********************************************************************
  @Function		util_number_is_power_2
  @Input		input A number
  @Returns		TRUE if the number is an integer power of two, else FALSE.
  @Description	Check that a number is an integer power of two, i.e.
				1, 2, 4, 8, ... etc.
				Returns FALSE for zero.
*************************************************************************/
int util_number_is_power_2( unsigned  input )
{
  unsigned minus1;

  if( !input ) return 0;

  minus1 = input - 1;
  return ( (input | minus1) == (input ^ minus1) ) ? 1 : 0;
}

/*!***********************************************************************
 @Function		Unpack5554Colour
 @Input			pBlock
 @Input			ABColours
 @Description	Given a block, extract the colour information and convert
				to 5554 formats
*************************************************************************/
static void Unpack5554Colour(const AMTC_BLOCK_STRUCT *pBlock,
							 int   ABColours[2][4])
{
	U32 RawBits[2];

	int i;

	// Extract A and B
	RawBits[0] = pBlock->PackedData[1] & (0xFFFE); // 15 bits (shifted up by one)
	RawBits[1] = pBlock->PackedData[1] >> 16;	   // 16 bits

	// step through both colours
	for(i = 0; i < 2; i++)
	{
		// If completely opaque
		if(RawBits[i] & (1<<15))
		{
			// Extract R and G (both 5 bit)
			ABColours[i][0] = (RawBits[i] >> 10) & 0x1F;
			ABColours[i][1] = (RawBits[i] >>  5) & 0x1F;

			/*
				The precision of Blue depends on  A or B. If A then we need to
				replicate the top bit to get 5 bits in total
			*/
			ABColours[i][2] = RawBits[i] & 0x1F;
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// set 4bit alpha fully on...
			ABColours[i][3] = 0xF;
		}
		else // Else if colour has variable translucency
		{
			/*
				Extract R and G (both 4 bit).
				(Leave a space on the end for the replication of bits
			*/
			ABColours[i][0] = (RawBits[i] >>  (8-1)) & 0x1E;
			ABColours[i][1] = (RawBits[i] >>  (4-1)) & 0x1E;

			// replicate bits to truly expand to 5 bits
			ABColours[i][0] |= ABColours[i][0] >> 4;
			ABColours[i][1] |= ABColours[i][1] >> 4;

			// grab the 3(+padding) or 4 bits of blue and add an extra padding bit
			ABColours[i][2] = (RawBits[i] & 0xF) << 1;

			/*
				expand from 3 to 5 bits if this is from colour A, or 4 to 5 bits if from
				colour B
			*/
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 3;
			}
			else
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// Set the alpha bits to be 3 + a zero on the end
			ABColours[i][3] = (RawBits[i] >> 11) & 0xE;
		}
	}
}

/*!***********************************************************************
 @Function		UnpackModulations
 @Input			pBlock
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			StartX
 @Input			StartY
 @Description	Given the block and the texture type and it's relative
				position in the 2x2 group of blocks, extract the bit
				patterns for the fully defined pixels.
*************************************************************************/
static void	UnpackModulations(const AMTC_BLOCK_STRUCT *pBlock,
							  const int Do2bitMode,
							  int ModulationVals[8][16],
							  int ModulationModes[8][16],
							  int StartX,
							  int StartY)
{
	int BlockModMode;
	U32 ModulationBits;

	int x, y;

	BlockModMode= pBlock->PackedData[1] & 1;
	ModulationBits	= pBlock->PackedData[0];

	// if it's in an interpolated mode
	if(Do2bitMode && BlockModMode)
	{
		/*
			run through all the pixels in the block. Note we can now treat all the
			"stored" values as if they have 2bits (even when they didn't!)
		*/
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// if this is a stored value...
				if(((x^y)&1) == 0)
				{
					ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
					ModulationBits >>= 2;
				}
			}
		}
	}
	else if(Do2bitMode) // else if direct encoded 2bit mode - i.e. 1 mode bit per pixel
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// double the bits so 0=> 00, and 1=>11
				if(ModulationBits & 1)
				{
					ModulationVals[y+StartY][x+StartX] = 0x3;
				}
				else
				{
					ModulationVals[y+StartY][x+StartX] = 0x0;
				}
				ModulationBits >>= 1;
			}
		}
	}
	else // else its the 4bpp mode so each value has 2 bits
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_4BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
				ModulationBits >>= 2;
			}
		}
	}

	// make sure nothing is left over
	assert(ModulationBits==0);
}

/*!***********************************************************************
 @Function		InterpolateColours
 @Input			ColourP
 @Input			ColourQ
 @Input			ColourR
 @Input			ColourS
 @Input			Do2bitMode
 @Input			x
 @Input			y
 @Modified		Result
 @Description	This performs a HW bit accurate interpolation of either the
				A or B colours for a particular pixel.

				NOTE: It is assumed that the source colours are in ARGB 5554
				format - This means that some "preparation" of the values will
				be necessary.
*************************************************************************/
static void InterpolateColours(const int ColourP[4],
						  const int ColourQ[4],
						  const int ColourR[4],
						  const int ColourS[4],
						  const int Do2bitMode,
						  const int x,
						  const int y,
						  int Result[4])
{
	int u, v, uscale;
	int k;

	int tmp1, tmp2;

	int P[4], Q[4], R[4], S[4];

	// Copy the colours
	for(k = 0; k < 4; k++)
	{
		P[k] = ColourP[k];
		Q[k] = ColourQ[k];
		R[k] = ColourR[k];
		S[k] = ColourS[k];
	}

	// put the x and y values into the right range
	v = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		u = (x & 0x7) | ((~x & 0x4) << 1);
	else
		u = (x & 0x3) | ((~x & 0x2) << 1);

	// get the u and v scale amounts
	v  = v - BLK_Y_SIZE/2;

	if(Do2bitMode)
	{
		u = u - BLK_X_2BPP/2;
		uscale = 8;
	}
	else
	{
		u = u - BLK_X_4BPP/2;
		uscale = 4;
	}

	for(k = 0; k < 4; k++)
	{
		tmp1 = P[k] * uscale + u * (Q[k] - P[k]);
		tmp2 = R[k] * uscale + u * (S[k] - R[k]);

		tmp1 = tmp1 * 4 + v * (tmp2 - tmp1);

		Result[k] = tmp1;
	}

	// Lop off the appropriate number of bits to get us to 8 bit precision
	if(Do2bitMode)
	{
		// do RGB
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 2;
		}

		Result[3] >>= 1;
	}
	else
	{
		// do RGB  (A is ok)
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 1;
		}
	}

	// sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

	/*
		Convert from 5554 to 8888

		do RGB 5.3 => 8
	*/
	for(k = 0; k < 3; k++)
	{
		Result[k] += Result[k] >> 5;
	}

	Result[3] += Result[3] >> 4;

	// 2nd sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

}

/*!***********************************************************************
 @Function		GetModulationValue
 @Input			x
 @Input			y
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			Mod
 @Input			DoPT
 @Description	Get the modulation value as a numerator of a fraction of 8ths
*************************************************************************/
static void GetModulationValue(int x,
							   int y,
							   const int Do2bitMode,
							   const int ModulationVals[8][16],
							   const int ModulationModes[8][16],
							   int *Mod,
							   int *DoPT)
{
	static const int RepVals0[4] = {0, 3, 5, 8};
	static const int RepVals1[4] = {0, 4, 4, 8};

	int ModVal;

	// Map X and Y into the local 2x2 block
	y = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		x = (x & 0x7) | ((~x & 0x4) << 1);
	else
		x = (x & 0x3) | ((~x & 0x2) << 1);

	// assume no PT for now
	*DoPT = 0;

	// extract the modulation value. If a simple encoding
	if(ModulationModes[y][x]==0)
	{
		ModVal = RepVals0[ModulationVals[y][x]];
	}
	else if(Do2bitMode)
	{
		// if this is a stored value
		if(((x^y)&1)==0)
			ModVal = RepVals0[ModulationVals[y][x]];
		else if(ModulationModes[y][x] == 1) // else average from the neighbours if H&V interpolation..
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] +
					  RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 2) / 4;
		}
		else if(ModulationModes[y][x] == 2) // else if H-Only
		{
			ModVal = (RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 1) / 2;
		}
		else // else it's V-Only
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] + 1) / 2;
		}
	}
	else // else it's 4BPP and PT encoding
	{
		ModVal = RepVals1[ModulationVals[y][x]];

		*DoPT = ModulationVals[y][x] == PT_INDEX;
	}

	*Mod =ModVal;
}

/*!***********************************************************************
 @Function		TwiddleUV
 @Input			YSize	Y dimension of the texture in pixels
 @Input			XSize	X dimension of the texture in pixels
 @Input			YPos	Pixel Y position
 @Input			XPos	Pixel X position
 @Returns		The twiddled offset of the pixel
 @Description	Given the Block (or pixel) coordinates and the dimension of
				the texture in blocks (or pixels) this returns the twiddled
				offset of the block (or pixel) from the start of the map.

				NOTE the dimensions of the texture must be a power of 2
*************************************************************************/
static int DisableTwiddlingRoutine = 0;

static U32 TwiddleUV(U32 YSize, U32 XSize, U32 YPos, U32 XPos)
{
	U32 Twiddled;

	U32 MinDimension;
	U32 MaxValue;

	U32 SrcBitPos;
	U32 DstBitPos;

	int ShiftCount;

	assert(YPos < YSize);
	assert(XPos < XSize);

	assert(POWER_OF_2(YSize));
	assert(POWER_OF_2(XSize));

	if(YSize < XSize)
	{
		MinDimension = YSize;
		MaxValue	 = XPos;
	}
	else
	{
		MinDimension = XSize;
		MaxValue	 = YPos;
	}

	// Nasty hack to disable twiddling
	if(DisableTwiddlingRoutine)
		return (YPos* XSize + XPos);

	// Step through all the bits in the "minimum" dimension
	SrcBitPos = 1;
	DstBitPos = 1;
	Twiddled  = 0;
	ShiftCount = 0;

	while(SrcBitPos < MinDimension)
	{
		if(YPos & SrcBitPos)
		{
			Twiddled |= DstBitPos;
		}

		if(XPos & SrcBitPos)
		{
			Twiddled |= (DstBitPos << 1);
		}

		SrcBitPos <<= 1;
		DstBitPos <<= 2;
		ShiftCount += 1;

	}

	// prepend any unused bits
	MaxValue >>= ShiftCount;

	Twiddled |=  (MaxValue << (2*ShiftCount));

	return Twiddled;
}

/***********************************************************/
/*
// Decompress
//
// Takes the compressed input data and outputs the equivalent decompressed
// image.
*/
/***********************************************************/

static void Decompress(AMTC_BLOCK_STRUCT *pCompressedData,
					   const int Do2bitMode,
					   const int XDim,
					   const int YDim,
					   const int AssumeImageTiles,
					   unsigned char* pResultImage)
{
	int x, y;
	int i, j;

	int BlkX, BlkY;
	int BlkXp1, BlkYp1;
	int XBlockSize;
	int BlkXDim, BlkYDim;

	int StartX, StartY;

	int ModulationVals[8][16];
	int ModulationModes[8][16];

	int Mod, DoPT;

	unsigned int uPosition;

	/*
	// local neighbourhood of blocks
	*/
	AMTC_BLOCK_STRUCT *pBlocks[2][2];

	AMTC_BLOCK_STRUCT *pPrevious[2][2] = {{NULL, NULL}, {NULL, NULL}};

	/*
	// Low precision colours extracted from the blocks
	*/
	struct
	{
		int Reps[2][4];
	}Colours5554[2][2];

	/*
	// Interpolated A and B colours for the pixel
	*/
	int ASig[4], BSig[4];

	int Result[4];

	if(Do2bitMode)
	{
		XBlockSize = BLK_X_2BPP;
	}
	else
	{
		XBlockSize = BLK_X_4BPP;
	}

	/*
	// For MBX don't allow the sizes to get too small
	*/
	BlkXDim = PVRT_MAX(2, XDim / XBlockSize);
	BlkYDim = PVRT_MAX(2, YDim / BLK_Y_SIZE);

	/*
	// Step through the pixels of the image decompressing each one in turn
	//
	// Note that this is a hideously inefficient way to do this!
	*/
	for(y = 0; y < YDim; y++)
	{
		for(x = 0; x < XDim; x++)
		{
			/*
			// map this pixel to the top left neighbourhood of blocks
			*/
			BlkX = (x - XBlockSize/2);
			BlkY = (y - BLK_Y_SIZE/2);

			BlkX = LIMIT_COORD(BlkX, XDim, AssumeImageTiles);
			BlkY = LIMIT_COORD(BlkY, YDim, AssumeImageTiles);

			BlkX /= XBlockSize;
			BlkY /= BLK_Y_SIZE;

			//BlkX = LIMIT_COORD(BlkX, BlkXDim, AssumeImageTiles);
			//BlkY = LIMIT_COORD(BlkY, BlkYDim, AssumeImageTiles);

			/*
			// compute the positions of the other 3 blocks
			*/
			BlkXp1 = LIMIT_COORD(BlkX+1, BlkXDim, AssumeImageTiles);
			BlkYp1 = LIMIT_COORD(BlkY+1, BlkYDim, AssumeImageTiles);

			/*
			// Map to block memory locations
			*/
			pBlocks[0][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkX);
			pBlocks[0][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkXp1);
			pBlocks[1][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkX);
			pBlocks[1][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkXp1);

			/*
			// extract the colours and the modulation information IF the previous values
			// have changed.
			*/
			if(memcmp(pPrevious, pBlocks, 4*sizeof(void*)) != 0)
			{
				StartY = 0;
				for(i = 0; i < 2; i++)
				{
					StartX = 0;
					for(j = 0; j < 2; j++)
					{
						Unpack5554Colour(pBlocks[i][j], Colours5554[i][j].Reps);

						UnpackModulations(pBlocks[i][j],
							Do2bitMode,
							ModulationVals,
							ModulationModes,
							StartX, StartY);

						StartX += XBlockSize;
					}/*end for j*/

					StartY += BLK_Y_SIZE;
				}/*end for i*/

				/*
				// make a copy of the new pointers
				*/
				memcpy(pPrevious, pBlocks, 4*sizeof(void*));
			}/*end if the blocks have changed*/

			/*
			// decompress the pixel.  First compute the interpolated A and B signals
			*/
			InterpolateColours(Colours5554[0][0].Reps[0],
				Colours5554[0][1].Reps[0],
				Colours5554[1][0].Reps[0],
				Colours5554[1][1].Reps[0],
				Do2bitMode, x, y,
				ASig);

			InterpolateColours(Colours5554[0][0].Reps[1],
				Colours5554[0][1].Reps[1],
				Colours5554[1][0].Reps[1],
				Colours5554[1][1].Reps[1],
				Do2bitMode, x, y,
				BSig);

			GetModulationValue(x,y, Do2bitMode, (const int (*)[16])ModulationVals, (const int (*)[16])ModulationModes,
				&Mod, &DoPT);

			/*
			// compute the modulated colour
			*/
			for(i = 0; i < 4; i++)
			{
				Result[i] = ASig[i] * 8 + Mod * (BSig[i] - ASig[i]);
				Result[i] >>= 3;
			}
			if(DoPT)
			{
				Result[3] = 0;
			}

			/*
			// Store the result in the output image
			*/
			uPosition = (x+y*XDim)<<2;
			pResultImage[uPosition+0] = (unsigned char)Result[0];
			pResultImage[uPosition+1] = (unsigned char)Result[1];
			pResultImage[uPosition+2] = (unsigned char)Result[2];
			pResultImage[uPosition+3] = (unsigned char)Result[3];

		}/*end for x*/
	}/*end for y*/

}

static stbi_uc * stbi__pvr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi_uc *pvr_data = NULL;
	stbi_uc *pvr_res_data = NULL;
	PVR_Texture_Header header={0};
	int iscompressed = 0;
	int bitmode = 0;
	unsigned int levelSize = 0;

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PVR_Texture_Header) );

	// Check the header size
	if ( header.dwHeaderSize != sizeof(PVR_Texture_Header) ) {
		return NULL;
	}

	// Check the magic identifier
	if ( header.dwPVR != PVRTEX_IDENTIFIER ) {
		return NULL;
	}

	*x = s->img_x = header.dwWidth;
	*y = s->img_y = header.dwHeight;

	/* Get if the texture is compressed and the texture mode ( 2bpp or 4bpp ) */
	switch ( header.dwpfFlags & PVRTEX_PIXELTYPE )
	{
		case OGL_RGBA_4444:
			s->img_n = 2;
			break;
		case OGL_RGBA_5551:
			s->img_n = 2;
			break;
		case OGL_RGBA_8888:
			s->img_n = 4;
			break;
		case OGL_RGB_565:
			s->img_n = 2;
			break;
		case OGL_RGB_888:
			s->img_n = 3;
			break;
		case OGL_I_8:
			s->img_n = 1;
			break;
		case OGL_AI_88:
			s->img_n = 2;
			break;
		case OGL_PVRTC2:
			bitmode = 1;
			s->img_n = 4;
			iscompressed = 1;
			break;
		case OGL_PVRTC4:
			s->img_n = 4;
			iscompressed = 1;
			break;
		case OGL_RGB_555:
		default:
			return NULL;
	}

	*comp = s->img_n;

	// Load only the first mip map level
	levelSize = (s->img_x * s->img_y * header.dwBitCount + 7) / 8;

	// get the raw data
	pvr_data = (stbi_uc *)STBI_MALLOC( levelSize );
	stbi__getn( s, pvr_data, levelSize );

	// if compressed decompress as RGBA
	if ( iscompressed ) {
		pvr_res_data = (stbi_uc *)STBI_MALLOC( s->img_x * s->img_y * 4 );
		Decompress( (AMTC_BLOCK_STRUCT*)pvr_data, bitmode, s->img_x, s->img_y, 1, (unsigned char*)pvr_res_data );
		STBI_FREE( pvr_data );
	} else {
		// otherwise use the raw data
		pvr_res_data = pvr_data;
	}

	if( (req_comp <= 4) && (req_comp >= 1) ) {
		//	user has some requirements, meet them
		if( req_comp != s->img_n ) {
			pvr_res_data = stbi__convert_format( pvr_res_data, s->img_n, req_comp, s->img_x, s->img_y );
			*comp = req_comp;
		}
	}

	return pvr_res_data;
}

#ifndef STBI_NO_STDIO
stbi_uc *stbi__pvr_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s,f);
	return stbi__pvr_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi__pvr_load_from_path             (char const*filename,           int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi__pvr_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

stbi_uc *stbi__pvr_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pvr_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi__pvr_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pvr_load(&s,x,y,comp,req_comp);
}


#endif

// add in my pkm ( ETC1 ) loading support
#ifndef STBI_NO_PKM

//#line 1 "stbi_pkm_c.h"

//#line 1 "pkm_helper.h"
#ifndef PKM_HELPER_H
#define PKM_HELPER_H

typedef struct {
	char aName[6];
	unsigned short iBlank;
	unsigned char iPaddedWidthMSB;
	unsigned char iPaddedWidthLSB;
	unsigned char iPaddedHeightMSB;
	unsigned char iPaddedHeightLSB;
	unsigned char iWidthMSB;
	unsigned char iWidthLSB;
	unsigned char iHeightMSB;
	unsigned char iHeightLSB;
} PKMHeader;

#define PKM_HEADER_SIZE 16

#endif


//#line 1 "etc1_utils.h"
// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef __etc1_h__
#define __etc1_h__

#define ETC1_ENCODED_BLOCK_SIZE 8
#define ETC1_DECODED_BLOCK_SIZE 48

#ifndef ETC1_RGB8_OES
#define ETC1_RGB8_OES 0x8D64
#endif

typedef unsigned char etc1_byte;
typedef int etc1_bool;
typedef unsigned int etc1_uint32;

#ifdef __cplusplus
extern "C" {
#endif

// Encode a block of pixels.
//
// pIn is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).
//
// validPixelMask is a 16-bit mask where bit (1 << (x + y * 4)) indicates whether
// the corresponding (x,y) pixel is valid. Invalid pixel color values are ignored when compressing.
//
// pOut is an ETC1 compressed version of the data.

void etc1_encode_block(const etc1_byte* pIn, etc1_uint32 validPixelMask, etc1_byte* pOut);

// Decode a block of pixels.
//
// pIn is an ETC1 compressed version of the data.
//
// pOut is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).

void etc1_decode_block(const etc1_byte* pIn, etc1_byte* pOut);

// Return the size of the encoded image data (does not include size of PKM header).

etc1_uint32 etc1_get_encoded_data_size(etc1_uint32 width, etc1_uint32 height);

// Encode an entire image.
// pIn - pointer to the image data. Formatted such that
//       pixel (x,y) is at pIn + pixelSize * x + stride * y;
// pOut - pointer to encoded data. Must be large enough to store entire encoded image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_encode_image(const etc1_byte* pIn, etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride, etc1_byte* pOut);

// Decode an entire image.
// pIn - pointer to encoded data.
// pOut - pointer to the image data. Will be written such that
//        pixel (x,y) is at pIn + pixelSize * x + stride * y. Must be
//        large enough to store entire image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_decode_image(const etc1_byte* pIn, etc1_byte* pOut,
		etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride);

// Size of a PKM header, in bytes.

#define ETC_PKM_HEADER_SIZE 16

// Format a PKM header

void etc1_pkm_format_header(etc1_byte* pHeader, etc1_uint32 width, etc1_uint32 height);

// Check if a PKM header is correctly formatted.

etc1_bool etc1_pkm_is_valid(const etc1_byte* pHeader);

// Read the image width from a PKM header

etc1_uint32 etc1_pkm_get_width(const etc1_byte* pHeader);

// Read the image height from a PKM header

etc1_uint32 etc1_pkm_get_height(const etc1_byte* pHeader);

#ifdef __cplusplus
}
#endif

#endif
static int stbi__pkm_test(stbi__context *s)
{
	//	check the magic number
	if (stbi__get8(s) != 'P') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'K') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'M') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != ' ') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != '1') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != '0') {
		stbi__rewind(s);
		return 0;
	}

	stbi__rewind(s);
	return 1;
}

#ifndef STBI_NO_STDIO

int      stbi__pkm_test_filename        		(char const *filename)
{
   int r;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   r = stbi__pkm_test_file(f);
   fclose(f);
   return r;
}

int      stbi__pkm_test_file        (FILE *f)
{
   stbi__context s;
   int r,n = ftell(f);
   stbi__start_file(&s,f);
   r = stbi__pkm_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi__pkm_test_memory      (stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pkm_test(&s);
}

int      stbi__pkm_test_callbacks      (stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pkm_test(&s);
}

static int stbi__pkm_info(stbi__context *s, int *x, int *y, int *comp )
{
	PKMHeader header;
	unsigned int width, height;

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PKMHeader) );

	if ( 0 != strcmp( header.aName, "PKM 10" ) ) {
		stbi__rewind(s);
		return 0;
	}

	width = (header.iWidthMSB << 8) | header.iWidthLSB;
	height = (header.iHeightMSB << 8) | header.iHeightLSB;

	*x = s->img_x = width;
	*y = s->img_y = height;
	*comp = s->img_n = 3;

	stbi__rewind(s);

	return 1;
}

int stbi__pkm_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp )
{
	stbi__context s;
	stbi__start_mem(&s,buffer, len);
	return stbi__pkm_info( &s, x, y, comp );
}

int stbi__pkm_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
	return stbi__pkm_info( &s, x, y, comp );
}

#ifndef STBI_NO_STDIO
int stbi__pkm_info_from_path(char const *filename,     int *x, int *y, int *comp)
{
   int res;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   res = stbi__pkm_info_from_file( f, x, y, comp );
   fclose(f);
   return res;
}

int stbi__pkm_info_from_file(FILE *f,                  int *x, int *y, int *comp)
{
   stbi__context s;
   int res;
   long n = ftell(f);
   stbi__start_file(&s, f);
   res = stbi__pkm_info(&s, x, y, comp);
   fseek(f, n, SEEK_SET);
   return res;
}
#endif

static stbi_uc * stbi__pkm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi_uc *pkm_data = NULL;
	stbi_uc *pkm_res_data = NULL;
	PKMHeader header;
	unsigned int width;
	unsigned int height;
	unsigned int align = 0;
	unsigned int bpr;
	unsigned int size;
	unsigned int compressedSize;

	int res;

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PKMHeader) );

	if ( 0 != strcmp( header.aName, "PKM 10" ) ) {
		return NULL;
	}

	width = (header.iWidthMSB << 8) | header.iWidthLSB;
	height = (header.iHeightMSB << 8) | header.iHeightLSB;

	*x = s->img_x = width;
	*y = s->img_y = height;
	*comp = s->img_n = 3;

	compressedSize = etc1_get_encoded_data_size(width, height);

	pkm_data = (stbi_uc *)STBI_MALLOC(compressedSize);
	stbi__getn( s, pkm_data, compressedSize );

	bpr = ((width * 3) + align) & ~align;
	size = bpr * height;
	pkm_res_data = (stbi_uc *)STBI_MALLOC(size);

	res = etc1_decode_image((const etc1_byte*)pkm_data, (etc1_byte*)pkm_res_data, width, height, 3, bpr);

	STBI_FREE( pkm_data );

	if ( 0 == res ) {
		if( (req_comp <= 4) && (req_comp >= 1) ) {
			//	user has some requirements, meet them
			if( req_comp != s->img_n ) {
				pkm_res_data = stbi__convert_format( pkm_res_data, s->img_n, req_comp, s->img_x, s->img_y );
				*comp = req_comp;
			}
		}

		return (stbi_uc *)pkm_res_data;
	} else {
		STBI_FREE( pkm_res_data );
	}

	return NULL;
}

#ifndef STBI_NO_STDIO
stbi_uc *stbi__pkm_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s,f);
	return stbi__pkm_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi__pkm_load_from_path             (char const*filename,           int *x, int *y, int *comp, int req_comp)
{
   stbi_uc *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi__pkm_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

stbi_uc *stbi__pkm_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pkm_load(&s,x,y,comp,req_comp);
}

stbi_uc *stbi__pkm_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pkm_load(&s,x,y,comp,req_comp);
}


#endif

#ifndef STBI_NO_EXT

//#line 1 "stbi_ext_c.h"
static int stbi_test_main(stbi__context *s)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return STBI_jpeg;
   #endif
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return STBI_png;
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return STBI_bmp;
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return STBI_gif;
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return STBI_psd;
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return STBI_pic;
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return STBI_pnm;
   #endif
   #ifndef STBI_NO_DDS
   if (stbi__dds_test(s))  return STBI_dds;
   #endif
   #ifndef STBI_NO_PVR
   if (stbi__pvr_test(s))  return STBI_pvr;
   #endif
   #ifndef STBI_NO_PKM
   if (stbi__pkm_test(s))  return STBI_pkm;
   #endif
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s))  return STBI_hdr;
   #endif
   #ifndef STBI_NO_TGA
   if (stbi__tga_test(s))  return STBI_tga;
   #endif
   return STBI_unknown;
}

#ifndef STBI_NO_STDIO
int stbi_test_from_file(FILE *f)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi_test_main(&s);
}

int stbi_test(char const *filename)
{
   FILE *f = fopen(filename, "rb");
   int result;
   if (!f) return STBI_unknown;
   result = stbi_test_from_file(f);
   fclose(f);
   return result;
}
#endif //!STBI_NO_STDIO

int stbi_test_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi_test_main(&s);
}

int stbi_test_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi_test_main(&s);
}


#endif



//#line 1 "stb_image_write.c"
//#ifdef STB_IMAGE_WRITE_IMPLEMENTATION

#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//#line 1 "stb_image_write.h"
#ifndef INCLUDE_STB_IMAGE_WRITE_H
#define INCLUDE_STB_IMAGE_WRITE_H

#ifdef __cplusplus
extern "C" {
#endif

int stbi_write_png(char const *filename, int w, int h, int comp, const void *data, int stride_in_bytes);
int stbi_write_bmp(char const *filename, int w, int h, int comp, const void *data);
int stbi_write_tga(char const *filename, int w, int h, int comp, const void *data);

#ifdef __cplusplus
}
#endif

#endif//INCLUDE_STB_IMAGE_WRITE_H


typedef unsigned int stbiw_uint32;
typedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];

static void writefv(FILE *f, const char *fmt, va_list v)
{
   while (*fmt) {
	  switch (*fmt++) {
		 case ' ': break;
		 case '1': { unsigned char x = (unsigned char) va_arg(v, int); fputc(x,f); break; }
		 case '2': { int x = va_arg(v,int); unsigned char b[2];
					 b[0] = (unsigned char) x; b[1] = (unsigned char) (x>>8);
					 fwrite(b,2,1,f); break; }
		 case '4': { stbiw_uint32 x = va_arg(v,int); unsigned char b[4];
					 b[0]=(unsigned char)x; b[1]=(unsigned char)(x>>8);
					 b[2]=(unsigned char)(x>>16); b[3]=(unsigned char)(x>>24);
					 fwrite(b,4,1,f); break; }
		 default:
			assert(0);
			return;
	  }
   }
}

static void write3(FILE *f, unsigned char a, unsigned char b, unsigned char c)
{
   unsigned char arr[3];
   arr[0] = a, arr[1] = b, arr[2] = c;
   fwrite(arr, 3, 1, f);
}

static void write_pixels(FILE *f, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad)
{
   unsigned char bg[3] = { 255, 0, 255}, px[3];
   stbiw_uint32 zero = 0;
   int i,j,k, j_end;

   if (y <= 0)
	  return;

   if (vdir < 0)
	  j_end = -1, j = y-1;
   else
	  j_end =  y, j = 0;

   for (; j != j_end; j += vdir) {
	  for (i=0; i < x; ++i) {
		 unsigned char *d = (unsigned char *) data + (j*x+i)*comp;
		 if (write_alpha < 0)
			fwrite(&d[comp-1], 1, 1, f);
		 switch (comp) {
			case 1:
			case 2: write3(f, d[0],d[0],d[0]);
					break;
			case 4:
			   if (!write_alpha) {
				  // composite against pink background
				  for (k=0; k < 3; ++k)
					 px[k] = bg[k] + ((d[k] - bg[k]) * d[3])/255;
				  write3(f, px[1-rgb_dir],px[1],px[1+rgb_dir]);
				  break;
			   }
			   /* FALLTHROUGH */
			case 3:
			   write3(f, d[1-rgb_dir],d[1],d[1+rgb_dir]);
			   break;
		 }
		 if (write_alpha > 0)
			fwrite(&d[comp-1], 1, 1, f);
	  }
	  fwrite(&zero,scanline_pad,1,f);
   }
}

static int outfile(char const *filename, int rgb_dir, int vdir, int x, int y, int comp, void *data, int alpha, int pad, const char *fmt, ...)
{
   FILE *f;
   if (y < 0 || x < 0) return 0;
   f = fopen(filename, "wb");
   if (f) {
	  va_list v;
	  va_start(v, fmt);
	  writefv(f, fmt, v);
	  va_end(v);
	  write_pixels(f,rgb_dir,vdir,x,y,comp,data,alpha,pad);
	  fclose(f);
   }
   return f != NULL;
}

int stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)
{
   int pad = (-x*3) & 3;
   return outfile(filename,-1,-1,x,y,comp,(void *) data,0,pad,
		   "11 4 22 4" "4 44 22 444444",
		   'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header
			40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header
}

int stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)
{
   int has_alpha = !(comp & 1);
   return outfile(filename, -1,-1, x, y, comp, (void *) data, has_alpha, 0,
				  "111 221 2222 11", 0,0,2, 0,0,0, 0,0,x,y, 24+8*has_alpha, 8*has_alpha);
}

// stretchy buffer; stbi__sbpush() == vector<>::push_back() -- stbi__sbcount() == vector<>::size()
#define stbi__sbraw(a) ((int *) (a) - 2)
#define stbi__sbm(a)   stbi__sbraw(a)[0]
#define stbi__sbn(a)   stbi__sbraw(a)[1]

#define stbi__sbneedgrow(a,n)  ((a)==0 || stbi__sbn(a)+n >= stbi__sbm(a))
#define stbi__sbmaybegrow(a,n) (stbi__sbneedgrow(a,(n)) ? stbi__sbgrow(a,n) : 0)
#define stbi__sbgrow(a,n)  stbi__sbgrowf((void **) &(a), (n), sizeof(*(a)))

#define stbi__sbpush(a, v)      (stbi__sbmaybegrow(a,1), (a)[stbi__sbn(a)++] = (v))
#define stbi__sbcount(a)        ((a) ? stbi__sbn(a) : 0)
#define stbi__sbfree(a)         ((a) ? free(stbi__sbraw(a)),0 : 0)

static void *stbi__sbgrowf(void **arr, int increment, int itemsize)
{
   int m = *arr ? 2*stbi__sbm(*arr)+increment : increment+1;
   void *p = realloc(*arr ? stbi__sbraw(*arr) : 0, itemsize * m + sizeof(int)*2);
   assert(p);
   if (p) {
	  if (!*arr) ((int *) p)[1] = 0;
	  *arr = (void *) ((int *) p + 2);
	  stbi__sbm(*arr) = m;
   }
   return *arr;
}

static unsigned char *stbi__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)
{
   while (*bitcount >= 8) {
	  stbi__sbpush(data, (unsigned char) *bitbuffer);
	  *bitbuffer >>= 8;
	  *bitcount -= 8;
   }
   return data;
}

static int stbi__zlib_bitrev(int code, int codebits)
{
   int res=0;
   while (codebits--) {
	  res = (res << 1) | (code & 1);
	  code >>= 1;
   }
   return res;
}

static unsigned int stbi__zlib_countm(unsigned char *a, unsigned char *b, int limit)
{
   int i;
   for (i=0; i < limit && i < 258; ++i)
	  if (a[i] != b[i]) break;
   return i;
}

static unsigned int stbi__zhash(unsigned char *data)
{
   stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);
   hash ^= hash << 3;
   hash += hash >> 5;
   hash ^= hash << 4;
   hash += hash >> 17;
   hash ^= hash << 25;
   hash += hash >> 6;
   return hash;
}

#define stbi__zlib_flush() (out = stbi__zlib_flushf(out, &bitbuf, &bitcount))
#define stbi__zlib_add(code,codebits) \
	  (bitbuf |= (code) << bitcount, bitcount += (codebits), stbi__zlib_flush())
#define stbi__zlib_huffa(b,c)  stbi__zlib_add(stbi__zlib_bitrev(b,c),c)
// default huffman tables
#define stbi__zlib_huff1(n)  stbi__zlib_huffa(0x30 + (n), 8)
#define stbi__zlib_huff2(n)  stbi__zlib_huffa(0x190 + (n)-144, 9)
#define stbi__zlib_huff3(n)  stbi__zlib_huffa(0 + (n)-256,7)
#define stbi__zlib_huff4(n)  stbi__zlib_huffa(0xc0 + (n)-280,8)
#define stbi__zlib_huff(n)  ((n) <= 143 ? stbi__zlib_huff1(n) : (n) <= 255 ? stbi__zlib_huff2(n) : (n) <= 279 ? stbi__zlib_huff3(n) : stbi__zlib_huff4(n))
#define stbi__zlib_huffb(n) ((n) <= 143 ? stbi__zlib_huff1(n) : stbi__zlib_huff2(n))

#define stbi__ZHASH   16384

unsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)
{
   static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };
   static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };
   static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };
   static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };
   unsigned int bitbuf=0;
   int i,j, bitcount=0;
   unsigned char *out = NULL;
   unsigned char **hash_table[stbi__ZHASH]; // 64KB on the stack!
   if (quality < 5) quality = 5;

   stbi__sbpush(out, 0x78);   // DEFLATE 32K window
   stbi__sbpush(out, 0x5e);   // FLEVEL = 1
   stbi__zlib_add(1,1);  // BFINAL = 1
   stbi__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman

   for (i=0; i < stbi__ZHASH; ++i)
	  hash_table[i] = NULL;

   i=0;
   while (i < data_len-3) {
	  // hash next 3 bytes of data to be compressed
	  int h = stbi__zhash(data+i)&(stbi__ZHASH-1), best=3;
	  unsigned char *bestloc = 0;
	  unsigned char **hlist = hash_table[h];
	  int n = stbi__sbcount(hlist);
	  for (j=0; j < n; ++j) {
		 if (hlist[j]-data > i-32768) { // if entry lies within window
			int d = stbi__zlib_countm(hlist[j], data+i, data_len-i);
			if (d >= best) best=d,bestloc=hlist[j];
		 }
	  }
	  // when hash table entry is too long, delete half the entries
	  if (hash_table[h] && stbi__sbn(hash_table[h]) == 2*quality) {
		 memcpy(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);
		 stbi__sbn(hash_table[h]) = quality;
	  }
	  stbi__sbpush(hash_table[h],data+i);

	  if (bestloc) {
		 // "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal
		 h = stbi__zhash(data+i+1)&(stbi__ZHASH-1);
		 hlist = hash_table[h];
		 n = stbi__sbcount(hlist);
		 for (j=0; j < n; ++j) {
			if (hlist[j]-data > i-32767) {
			   int e = stbi__zlib_countm(hlist[j], data+i+1, data_len-i-1);
			   if (e > best) { // if next match is better, bail on current match
				  bestloc = NULL;
				  break;
			   }
			}
		 }
	  }

	  if (bestloc) {
		 int d = (int)( data+i - bestloc ); // distance back
		 assert(d <= 32767 && best <= 258);
		 for (j=0; best > lengthc[j+1]-1; ++j);
		 stbi__zlib_huff(j+257);
		 if (lengtheb[j]) stbi__zlib_add(best - lengthc[j], lengtheb[j]);
		 for (j=0; d > distc[j+1]-1; ++j);
		 stbi__zlib_add(stbi__zlib_bitrev(j,5),5);
		 if (disteb[j]) stbi__zlib_add(d - distc[j], disteb[j]);
		 i += best;
	  } else {
		 stbi__zlib_huffb(data[i]);
		 ++i;
	  }
   }
   // write out final bytes
   for (;i < data_len; ++i)
	  stbi__zlib_huffb(data[i]);
   stbi__zlib_huff(256); // end of block
   // pad with 0 bits to byte boundary
   while (bitcount)
	  stbi__zlib_add(0,1);

   for (i=0; i < stbi__ZHASH; ++i)
	  (void) stbi__sbfree(hash_table[i]);

   {
	  // compute adler32 on input
	  unsigned int i=0, s1=1, s2=0, blocklen = data_len % 5552;
	  int j=0;
	  while (j < data_len) {
		 for (i=0; i < blocklen; ++i) s1 += data[j+i], s2 += s1;
		 s1 %= 65521, s2 %= 65521;
		 j += blocklen;
		 blocklen = 5552;
	  }
	  stbi__sbpush(out, (unsigned char) (s2 >> 8));
	  stbi__sbpush(out, (unsigned char) s2);
	  stbi__sbpush(out, (unsigned char) (s1 >> 8));
	  stbi__sbpush(out, (unsigned char) s1);
   }
   *out_len = stbi__sbn(out);
   // make returned pointer freeable
   memmove(stbi__sbraw(out), out, *out_len);
   return (unsigned char *) stbi__sbraw(out);
}

unsigned int stbi__crc32(unsigned char *buffer, int len)
{
   static unsigned int crc_table[256];
   unsigned int crc = ~0u;
   int i,j;
   if (crc_table[1] == 0)
	  for(i=0; i < 256; i++)
		 for (crc_table[i]=i, j=0; j < 8; ++j)
			crc_table[i] = (crc_table[i] >> 1) ^ (crc_table[i] & 1 ? 0xedb88320 : 0);
   for (i=0; i < len; ++i)
	  crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];
   return ~crc;
}

#define stbi__wpng4(o,a,b,c,d) ((o)[0]=(unsigned char)(a),(o)[1]=(unsigned char)(b),(o)[2]=(unsigned char)(c),(o)[3]=(unsigned char)(d),(o)+=4)
#define stbi__wp32(data,v) stbi__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));
#define stbi__wptag(data,s) stbi__wpng4(data, s[0],s[1],s[2],s[3])

static void stbi__wpcrc(unsigned char **data, int len)
{
   unsigned int crc = stbi__crc32(*data - len - 4, len+4);
   stbi__wp32(*data, crc);
}

static unsigned char stbiw__paeth(int a, int b, int c)
{
   int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);
   if (pa <= pb && pa <= pc) return (unsigned char) a;
   if (pb <= pc) return (unsigned char) b;
   return (unsigned char) c;
}

unsigned char *stbi_write_png_to_mem(unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)
{
   int ctype[5] = { -1, 0, 4, 2, 6 };
   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };
   unsigned char *out,*o, *filt, *zlib;
   signed char *line_buffer;
   int i,j,k,p,zlen;

   if (stride_bytes == 0)
	  stride_bytes = x * n;

   filt = (unsigned char *) malloc((x*n+1) * y); if (!filt) return 0;
   line_buffer = (signed char *) malloc(x * n); if (!line_buffer) { free(filt); return 0; }
   for (j=0; j < y; ++j) {
	  static int mapping[] = { 0,1,2,3,4 };
	  static int firstmap[] = { 0,1,0,5,6 };
	  int *mymap = j ? mapping : firstmap;
	  int best = 0, bestval = 0x7fffffff;
	  for (p=0; p < 2; ++p) {
		 for (k= p?best:0; k < 5; ++k) {
			int type = mymap[k],est=0;
			unsigned char *z = pixels + stride_bytes*j;
			for (i=0; i < n; ++i)
			   switch (type) {
				  case 0: line_buffer[i] = z[i]; break;
				  case 1: line_buffer[i] = z[i]; break;
				  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;
				  case 3: line_buffer[i] = z[i] - (z[i-stride_bytes]>>1); break;
				  case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-stride_bytes],0)); break;
				  case 5: line_buffer[i] = z[i]; break;
				  case 6: line_buffer[i] = z[i]; break;
			   }
			for (i=n; i < x*n; ++i) {
			   switch (type) {
				  case 0: line_buffer[i] = z[i]; break;
				  case 1: line_buffer[i] = z[i] - z[i-n]; break;
				  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;
				  case 3: line_buffer[i] = z[i] - ((z[i-n] + z[i-stride_bytes])>>1); break;
				  case 4: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-stride_bytes], z[i-stride_bytes-n]); break;
				  case 5: line_buffer[i] = z[i] - (z[i-n]>>1); break;
				  case 6: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;
			   }
			}
			if (p) break;
			for (i=0; i < x*n; ++i)
			   est += abs((signed char) line_buffer[i]);
			if (est < bestval) { bestval = est; best = k; }
		 }
	  }
	  // when we get here, best contains the filter type, and line_buffer contains the data
	  filt[j*(x*n+1)] = (unsigned char) best;
	  memcpy(filt+j*(x*n+1)+1, line_buffer, x*n);
   }
   free(line_buffer);
   zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, 8); // increase 8 to get smaller but use more memory
   free(filt);
   if (!zlib) return 0;

   // each tag requires 12 bytes of overhead
   out = (unsigned char *) malloc(8 + 12+13 + 12+zlen + 12);
   if (!out) return 0;
   *out_len = 8 + 12+13 + 12+zlen + 12;

   o=out;
   memcpy(o,sig,8); o+= 8;
   stbi__wp32(o, 13); // header length
   stbi__wptag(o, "IHDR");
   stbi__wp32(o, x);
   stbi__wp32(o, y);
   *o++ = 8;
   *o++ = (unsigned char) ctype[n];
   *o++ = 0;
   *o++ = 0;
   *o++ = 0;
   stbi__wpcrc(&o,13);

   stbi__wp32(o, zlen);
   stbi__wptag(o, "IDAT");
   memcpy(o, zlib, zlen); o += zlen; free(zlib);
   stbi__wpcrc(&o, zlen);

   stbi__wp32(o,0);
   stbi__wptag(o, "IEND");
   stbi__wpcrc(&o,0);

   assert(o == out + *out_len);

   return out;
}

int stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)
{
   FILE *f;
   int len;
   unsigned char *png = stbi_write_png_to_mem((unsigned char *) data, stride_bytes, x, y, comp, &len);
   if (!png) return 0;
   f = fopen(filename, "wb");
   if (!f) { free(png); return 0; }
   fwrite(png, 1, len, f);
   fclose(f);
   free(png);
   return 1;
}
//#endif // STB_IMAGE_WRITE_IMPLEMENTATION

/* Revision history

	  0.92 (2010-08-01)
			 casts to unsigned char to fix warnings
	  0.91 (2010-07-17)
			 first public release
	  0.90   first internal release
*/

#define DDS_header DDS_header2

//#line 1 "image_DXT.h"
#ifndef HEADER_IMAGE_DXT
#define HEADER_IMAGE_DXT

/**
	Converts an image from an array of unsigned chars (RGB or RGBA) to
	DXT1 or DXT5, then saves the converted image to disk.
	\return 0 if failed, otherwise returns 1
**/
int
save_image_as_DDS
(
	const char *filename,
	int width, int height, int channels,
	const unsigned char *const data
);

/**
	take an image and convert it to DXT1 (no alpha)
**/
unsigned char*
convert_image_to_DXT1
(
	const unsigned char *const uncompressed,
	int width, int height, int channels,
	int *out_size
);

/**
	take an image and convert it to DXT5 (with alpha)
**/
unsigned char*
convert_image_to_DXT5
(
	const unsigned char *const uncompressed,
	int width, int height, int channels,
	int *out_size
);

/**	A bunch of DirectDraw Surface structures and flags **/
typedef struct
{
	unsigned int    dwMagic;
	unsigned int    dwSize;
	unsigned int    dwFlags;
	unsigned int    dwHeight;
	unsigned int    dwWidth;
	unsigned int    dwPitchOrLinearSize;
	unsigned int    dwDepth;
	unsigned int    dwMipMapCount;
	unsigned int    dwReserved1[ 11 ];

	/*  DDPIXELFORMAT	*/
	struct
	{
		unsigned int    dwSize;
		unsigned int    dwFlags;
		unsigned int    dwFourCC;
		unsigned int    dwRGBBitCount;
		unsigned int    dwRBitMask;
		unsigned int    dwGBitMask;
		unsigned int    dwBBitMask;
		unsigned int    dwAlphaBitMask;
	}
	sPixelFormat;

	/*  DDCAPS2	*/
	struct
	{
		unsigned int    dwCaps1;
		unsigned int    dwCaps2;
		unsigned int    dwDDSX;
		unsigned int    dwReserved;
	}
	sCaps;
	unsigned int    dwReserved2;
}
DDS_header ;

/*	the following constants were copied directly off the MSDN website	*/

/*	The dwFlags member of the original DDSURFACEDESC2 structure
	can be set to one or more of the following values.	*/
#define DDSD_CAPS	0x00000001
#define DDSD_HEIGHT	0x00000002
#define DDSD_WIDTH	0x00000004
#define DDSD_PITCH	0x00000008
#define DDSD_PIXELFORMAT	0x00001000
#define DDSD_MIPMAPCOUNT	0x00020000
#define DDSD_LINEARSIZE	0x00080000
#define DDSD_DEPTH	0x00800000

/*	DirectDraw Pixel Format	*/
#define DDPF_ALPHAPIXELS	0x00000001
#define DDPF_FOURCC	0x00000004
#define DDPF_RGB	0x00000040

/*	The dwCaps1 member of the DDSCAPS2 structure can be
	set to one or more of the following values.	*/
#define DDSCAPS_COMPLEX	0x00000008
#define DDSCAPS_TEXTURE	0x00001000
#define DDSCAPS_MIPMAP	0x00400000

/*	The dwCaps2 member of the DDSCAPS2 structure can be
	set to one or more of the following values.		*/
#define DDSCAPS2_CUBEMAP	0x00000200
#define DDSCAPS2_CUBEMAP_POSITIVEX	0x00000400
#define DDSCAPS2_CUBEMAP_NEGATIVEX	0x00000800
#define DDSCAPS2_CUBEMAP_POSITIVEY	0x00001000
#define DDSCAPS2_CUBEMAP_NEGATIVEY	0x00002000
#define DDSCAPS2_CUBEMAP_POSITIVEZ	0x00004000
#define DDSCAPS2_CUBEMAP_NEGATIVEZ	0x00008000
#define DDSCAPS2_VOLUME	0x00200000

#endif /* HEADER_IMAGE_DXT	*/



//#line 1 "image_DXT.c"
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/*	set this =1 if you want to use the covarince matrix method...
	which is better than my method of using standard deviations
	overall, except on the infintesimal chance that the power
	method fails for finding the largest eigenvector	*/
#define USE_COV_MAT	1

/********* Function Prototypes *********/
/*
	Takes a 4x4 block of pixels and compresses it into 8 bytes
	in DXT1 format (color only, no alpha).  Speed is valued
	over prettyness, at least for now.
*/
void compress_DDS_color_block(
				int channels,
				const unsigned char *const uncompressed,
				unsigned char compressed[8] );
/*
	Takes a 4x4 block of pixels and compresses the alpha
	component it into 8 bytes for use in DXT5 DDS files.
	Speed is valued over prettyness, at least for now.
*/
void compress_DDS_alpha_block(
				const unsigned char *const uncompressed,
				unsigned char compressed[8] );

/********* Actual Exposed Functions *********/
int
	save_image_as_DDS
	(
		const char *filename,
		int width, int height, int channels,
		const unsigned char *const data
	)
{
	/*	variables	*/
	FILE *fout;
	unsigned char *DDS_data;
	DDS_header header;
	int DDS_size;
	/*	error check	*/
	if( (NULL == filename) ||
		(width < 1) || (height < 1) ||
		(channels < 1) || (channels > 4) ||
		(data == NULL ) )
	{
		return 0;
	}
	/*	Convert the image	*/
	if( (channels & 1) == 1 )
	{
		/*	no alpha, just use DXT1	*/
		DDS_data = convert_image_to_DXT1( data, width, height, channels, &DDS_size );
	} else
	{
		/*	has alpha, so use DXT5	*/
		DDS_data = convert_image_to_DXT5( data, width, height, channels, &DDS_size );
	}
	/*	save it	*/
	memset( &header, 0, sizeof( DDS_header ) );
	header.dwMagic = ('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24);
	header.dwSize = 124;
	header.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE;
	header.dwWidth = width;
	header.dwHeight = height;
	header.dwPitchOrLinearSize = DDS_size;
	header.sPixelFormat.dwSize = 32;
	header.sPixelFormat.dwFlags = DDPF_FOURCC;
	if( (channels & 1) == 1 )
	{
		header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('1' << 24);
	} else
	{
		header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('5' << 24);
	}
	header.sCaps.dwCaps1 = DDSCAPS_TEXTURE;
	/*	write it out	*/
	fout = fopen( filename, "wb");
	fwrite( &header, sizeof( DDS_header ), 1, fout );
	fwrite( DDS_data, 1, DDS_size, fout );
	fclose( fout );
	/*	done	*/
	free( DDS_data );
	return 1;
}

unsigned char* convert_image_to_DXT1(
		const unsigned char *const uncompressed,
		int width, int height, int channels,
		int *out_size )
{
	unsigned char *compressed;
	int i, j, x, y;
	unsigned char ublock[16*3];
	unsigned char cblock[8];
	int index = 0, chan_step = 1;
	int block_count = 0;
	/*	error check	*/
	*out_size = 0;
	if( (width < 1) || (height < 1) ||
		(NULL == uncompressed) ||
		(channels < 1) || (channels > 4) )
	{
		return NULL;
	}
	/*	for channels == 1 or 2, I do not step forward for R,G,B values	*/
	if( channels < 3 )
	{
		chan_step = 0;
	}
	/*	get the RAM for the compressed image
		(8 bytes per 4x4 pixel block)	*/
	*out_size = ((width+3) >> 2) * ((height+3) >> 2) * 8;
	compressed = (unsigned char*)malloc( *out_size );
	/*	go through each block	*/
	for( j = 0; j < height; j += 4 )
	{
		for( i = 0; i < width; i += 4 )
		{
			/*	copy this block into a new one	*/
			int idx = 0;
			int mx = 4, my = 4;
			if( j+4 >= height )
			{
				my = height - j;
			}
			if( i+4 >= width )
			{
				mx = width - i;
			}
			for( y = 0; y < my; ++y )
			{
				for( x = 0; x < mx; ++x )
				{
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step+chan_step];
				}
				for( x = mx; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
				}
			}
			for( y = my; y < 4; ++y )
			{
				for( x = 0; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
				}
			}
			/*	compress the block	*/
			++block_count;
			compress_DDS_color_block( 3, ublock, cblock );
			/*	copy the data from the block into the main block	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
		}
	}
	return compressed;
}

unsigned char* convert_image_to_DXT5(
		const unsigned char *const uncompressed,
		int width, int height, int channels,
		int *out_size )
{
	unsigned char *compressed;
	int i, j, x, y;
	unsigned char ublock[16*4];
	unsigned char cblock[8];
	int index = 0, chan_step = 1;
	int block_count = 0, has_alpha;
	/*	error check	*/
	*out_size = 0;
	if( (width < 1) || (height < 1) ||
		(NULL == uncompressed) ||
		(channels < 1) || ( channels > 4) )
	{
		return NULL;
	}
	/*	for channels == 1 or 2, I do not step forward for R,G,B vales	*/
	if( channels < 3 )
	{
		chan_step = 0;
	}
	/*	# channels = 1 or 3 have no alpha, 2 & 4 do have alpha	*/
	has_alpha = 1 - (channels & 1);
	/*	get the RAM for the compressed image
		(16 bytes per 4x4 pixel block)	*/
	*out_size = ((width+3) >> 2) * ((height+3) >> 2) * 16;
	compressed = (unsigned char*)malloc( *out_size );
	/*	go through each block	*/
	for( j = 0; j < height; j += 4 )
	{
		for( i = 0; i < width; i += 4 )
		{
			/*	local variables, and my block counter	*/
			int idx = 0;
			int mx = 4, my = 4;
			if( j+4 >= height )
			{
				my = height - j;
			}
			if( i+4 >= width )
			{
				mx = width - i;
			}
			for( y = 0; y < my; ++y )
			{
				for( x = 0; x < mx; ++x )
				{
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step+chan_step];
					ublock[idx++] =
						has_alpha * uncompressed[(j+y)*width*channels+(i+x)*channels+channels-1]
						+ (1-has_alpha)*255;
				}
				for( x = mx; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
					ublock[idx++] = ublock[3];
				}
			}
			for( y = my; y < 4; ++y )
			{
				for( x = 0; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
					ublock[idx++] = ublock[3];
				}
			}
			/*	now compress the alpha block	*/
			compress_DDS_alpha_block( ublock, cblock );
			/*	copy the data from the compressed alpha block into the main buffer	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
			/*	then compress the color block	*/
			++block_count;
			compress_DDS_color_block( 4, ublock, cblock );
			/*	copy the data from the compressed color block into the main buffer	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
		}
	}
	return compressed;
}

/********* Helper Functions *********/
int convert_bit_range( int c, int from_bits, int to_bits )
{
	int b = (1 << (from_bits - 1)) + c * ((1 << to_bits) - 1);
	return (b + (b >> from_bits)) >> from_bits;
}

int rgb_to_565( int r, int g, int b )
{
	return
		(convert_bit_range( r, 8, 5 ) << 11) |
		(convert_bit_range( g, 8, 6 ) << 05) |
		(convert_bit_range( b, 8, 5 ) << 00);
}

void rgb_888_from_565( unsigned int c, int *r, int *g, int *b )
{
	*r = convert_bit_range( (c >> 11) & 31, 5, 8 );
	*g = convert_bit_range( (c >> 05) & 63, 6, 8 );
	*b = convert_bit_range( (c >> 00) & 31, 5, 8 );
}

void compute_color_line_STDEV(
		const unsigned char *const uncompressed,
		int channels,
		float point[3], float direction[3] )
{
	const float inv_16 = 1.0f / 16.0f;
	int i;
	float sum_r = 0.0f, sum_g = 0.0f, sum_b = 0.0f;
	float sum_rr = 0.0f, sum_gg = 0.0f, sum_bb = 0.0f;
	float sum_rg = 0.0f, sum_rb = 0.0f, sum_gb = 0.0f;
	/*	calculate all data needed for the covariance matrix
		( to compare with _rygdxt code)	*/
	for( i = 0; i < 16*channels; i += channels )
	{
		sum_r += uncompressed[i+0];
		sum_rr += uncompressed[i+0] * uncompressed[i+0];
		sum_g += uncompressed[i+1];
		sum_gg += uncompressed[i+1] * uncompressed[i+1];
		sum_b += uncompressed[i+2];
		sum_bb += uncompressed[i+2] * uncompressed[i+2];
		sum_rg += uncompressed[i+0] * uncompressed[i+1];
		sum_rb += uncompressed[i+0] * uncompressed[i+2];
		sum_gb += uncompressed[i+1] * uncompressed[i+2];
	}
	/*	convert the sums to averages	*/
	sum_r *= inv_16;
	sum_g *= inv_16;
	sum_b *= inv_16;
	/*	and convert the squares to the squares of the value - avg_value	*/
	sum_rr -= 16.0f * sum_r * sum_r;
	sum_gg -= 16.0f * sum_g * sum_g;
	sum_bb -= 16.0f * sum_b * sum_b;
	sum_rg -= 16.0f * sum_r * sum_g;
	sum_rb -= 16.0f * sum_r * sum_b;
	sum_gb -= 16.0f * sum_g * sum_b;
	/*	the point on the color line is the average	*/
	point[0] = sum_r;
	point[1] = sum_g;
	point[2] = sum_b;
	#if USE_COV_MAT
	/*
		The following idea was from ryg.
		(https://mollyrocket.com/forums/viewtopic.php?t=392)
		The method worked great (less RMSE than mine) most of
		the time, but had some issues handling some simple
		boundary cases, like full green next to full red,
		which would generate a covariance matrix like this:

		| 1  -1  0 |
		| -1  1  0 |
		| 0   0  0 |

		For a given starting vector, the power method can
		generate all zeros!  So no starting with {1,1,1}
		as I was doing!  This kind of error is still a
		slight posibillity, but will be very rare.
	*/
	/*	use the covariance matrix directly
		(1st iteration, don't use all 1.0 values!)	*/
	sum_r = 1.0f;
	sum_g = 2.718281828f;
	sum_b = 3.141592654f;
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	/*	2nd iteration, use results from the 1st guy	*/
	sum_r = direction[0];
	sum_g = direction[1];
	sum_b = direction[2];
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	/*	3rd iteration, use results from the 2nd guy	*/
	sum_r = direction[0];
	sum_g = direction[1];
	sum_b = direction[2];
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	#else
	/*	use my standard deviation method
		(very robust, a tiny bit slower and less accurate)	*/
	direction[0] = sqrt( sum_rr );
	direction[1] = sqrt( sum_gg );
	direction[2] = sqrt( sum_bb );
	/*	which has a greater component	*/
	if( sum_gg > sum_rr )
	{
		/*	green has greater component, so base the other signs off of green	*/
		if( sum_rg < 0.0f )
		{
			direction[0] = -direction[0];
		}
		if( sum_gb < 0.0f )
		{
			direction[2] = -direction[2];
		}
	} else
	{
		/*	red has a greater component	*/
		if( sum_rg < 0.0f )
		{
			direction[1] = -direction[1];
		}
		if( sum_rb < 0.0f )
		{
			direction[2] = -direction[2];
		}
	}
	#endif
}

void LSE_master_colors_max_min(
		int *cmax, int *cmin,
		int channels,
		const unsigned char *const uncompressed )
{
	int i, j;
	/*	the master colors	*/
	int c0[3], c1[3];
	/*	used for fitting the line	*/
	float sum_x[] = { 0.0f, 0.0f, 0.0f };
	float sum_x2[] = { 0.0f, 0.0f, 0.0f };
	float dot_max = 1.0f, dot_min = -1.0f;
	float vec_len2 = 0.0f;
	float dot;
	/*	error check	*/
	if( (channels < 3) || (channels > 4) )
	{
		return;
	}
	compute_color_line_STDEV( uncompressed, channels, sum_x, sum_x2 );
	vec_len2 = 1.0f / ( 0.00001f +
			sum_x2[0]*sum_x2[0] + sum_x2[1]*sum_x2[1] + sum_x2[2]*sum_x2[2] );
	/*	finding the max and min vector values	*/
	dot_max =
			(
				sum_x2[0] * uncompressed[0] +
				sum_x2[1] * uncompressed[1] +
				sum_x2[2] * uncompressed[2]
			);
	dot_min = dot_max;
	for( i = 1; i < 16; ++i )
	{
		dot =
			(
				sum_x2[0] * uncompressed[i*channels+0] +
				sum_x2[1] * uncompressed[i*channels+1] +
				sum_x2[2] * uncompressed[i*channels+2]
			);
		if( dot < dot_min )
		{
			dot_min = dot;
		} else if( dot > dot_max )
		{
			dot_max = dot;
		}
	}
	/*	and the offset (from the average location)	*/
	dot = sum_x2[0]*sum_x[0] + sum_x2[1]*sum_x[1] + sum_x2[2]*sum_x[2];
	dot_min -= dot;
	dot_max -= dot;
	/*	post multiply by the scaling factor	*/
	dot_min *= vec_len2;
	dot_max *= vec_len2;
	/*	OK, build the master colors	*/
	for( i = 0; i < 3; ++i )
	{
		/*	color 0	*/
		c0[i] = (int)(0.5f + sum_x[i] + dot_max * sum_x2[i]);
		if( c0[i] < 0 )
		{
			c0[i] = 0;
		} else if( c0[i] > 255 )
		{
			c0[i] = 255;
		}
		/*	color 1	*/
		c1[i] = (int)(0.5f + sum_x[i] + dot_min * sum_x2[i]);
		if( c1[i] < 0 )
		{
			c1[i] = 0;
		} else if( c1[i] > 255 )
		{
			c1[i] = 255;
		}
	}
	/*	down_sample (with rounding?)	*/
	i = rgb_to_565( c0[0], c0[1], c0[2] );
	j = rgb_to_565( c1[0], c1[1], c1[2] );
	if( i > j )
	{
		*cmax = i;
		*cmin = j;
	} else
	{
		*cmax = j;
		*cmin = i;
	}
}

void
	compress_DDS_color_block
	(
		int channels,
		const unsigned char *const uncompressed,
		unsigned char compressed[8]
	)
{
	/*	variables	*/
	int i;
	int next_bit;
	int enc_c0, enc_c1;
	int c0[4], c1[4];
	float color_line[] = { 0.0f, 0.0f, 0.0f, 0.0f };
	float vec_len2 = 0.0f, dot_offset = 0.0f;
	/*	stupid order	*/
	int swizzle4[] = { 0, 2, 3, 1 };
	/*	get the master colors	*/
	LSE_master_colors_max_min( &enc_c0, &enc_c1, channels, uncompressed );
	/*	store the 565 color 0 and color 1	*/
	compressed[0] = (enc_c0 >> 0) & 255;
	compressed[1] = (enc_c0 >> 8) & 255;
	compressed[2] = (enc_c1 >> 0) & 255;
	compressed[3] = (enc_c1 >> 8) & 255;
	/*	zero out the compressed data	*/
	compressed[4] = 0;
	compressed[5] = 0;
	compressed[6] = 0;
	compressed[7] = 0;
	/*	reconstitute the master color vectors	*/
	rgb_888_from_565( enc_c0, &c0[0], &c0[1], &c0[2] );
	rgb_888_from_565( enc_c1, &c1[0], &c1[1], &c1[2] );
	/*	the new vector	*/
	vec_len2 = 0.0f;
	for( i = 0; i < 3; ++i )
	{
		color_line[i] = (float)(c1[i] - c0[i]);
		vec_len2 += color_line[i] * color_line[i];
	}
	if( vec_len2 > 0.0f )
	{
		vec_len2 = 1.0f / vec_len2;
	}
	/*	pre-proform the scaling	*/
	color_line[0] *= vec_len2;
	color_line[1] *= vec_len2;
	color_line[2] *= vec_len2;
	/*	compute the offset (constant) portion of the dot product	*/
	dot_offset = color_line[0]*c0[0] + color_line[1]*c0[1] + color_line[2]*c0[2];
	/*	store the rest of the bits	*/
	next_bit = 8*4;
	for( i = 0; i < 16; ++i )
	{
		/*	find the dot product of this color, to place it on the line
			(should be [-1,1])	*/
		int next_value = 0;
		float dot_product =
			color_line[0] * uncompressed[i*channels+0] +
			color_line[1] * uncompressed[i*channels+1] +
			color_line[2] * uncompressed[i*channels+2] -
			dot_offset;
		/*	map to [0,3]	*/
		next_value = (int)( dot_product * 3.0f + 0.5f );
		if( next_value > 3 )
		{
			next_value = 3;
		} else if( next_value < 0 )
		{
			next_value = 0;
		}
		/*	OK, store this value	*/
		compressed[next_bit >> 3] |= swizzle4[ next_value ] << (next_bit & 7);
		next_bit += 2;
	}
	/*	done compressing to DXT1	*/
}

void
	compress_DDS_alpha_block
	(
		const unsigned char *const uncompressed,
		unsigned char compressed[8]
	)
{
	/*	variables	*/
	int i;
	int next_bit;
	int a0, a1;
	float scale_me;
	/*	stupid order	*/
	int swizzle8[] = { 1, 7, 6, 5, 4, 3, 2, 0 };
	/*	get the alpha limits (a0 > a1)	*/
	a0 = a1 = uncompressed[3];
	for( i = 4+3; i < 16*4; i += 4 )
	{
		if( uncompressed[i] > a0 )
		{
			a0 = uncompressed[i];
		} else if( uncompressed[i] < a1 )
		{
			a1 = uncompressed[i];
		}
	}
	/*	store those limits, and zero the rest of the compressed dataset	*/
	compressed[0] = a0;
	compressed[1] = a1;
	/*	zero out the compressed data	*/
	compressed[2] = 0;
	compressed[3] = 0;
	compressed[4] = 0;
	compressed[5] = 0;
	compressed[6] = 0;
	compressed[7] = 0;
	/*	store the all of the alpha values	*/
	next_bit = 8*2;
	scale_me = 7.9999f / (a0 - a1);
	for( i = 3; i < 16*4; i += 4 )
	{
		/*	convert this alpha value to a 3 bit number	*/
		int svalue;
		int value = (int)((uncompressed[i] - a1) * scale_me);
		svalue = swizzle8[ value&7 ];
		/*	OK, store this value, start with the 1st byte	*/
		compressed[next_bit >> 3] |= svalue << (next_bit & 7);
		if( (next_bit & 7) > 5 )
		{
			/*	spans 2 bytes, fill in the start of the 2nd byte	*/
			compressed[1 + (next_bit >> 3)] |= svalue >> (8 - (next_bit & 7) );
		}
		next_bit += 3;
	}
	/*	done compressing to DXT1	*/
}

#define clamp clamp2

//#line 1 "etc1_utils.c"
// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


//#line 1 "etc1_utils.h"
// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef __etc1_h__
#define __etc1_h__

#define ETC1_ENCODED_BLOCK_SIZE 8
#define ETC1_DECODED_BLOCK_SIZE 48

#ifndef ETC1_RGB8_OES
#define ETC1_RGB8_OES 0x8D64
#endif

typedef unsigned char etc1_byte;
typedef int etc1_bool;
typedef unsigned int etc1_uint32;

#ifdef __cplusplus
extern "C" {
#endif

// Encode a block of pixels.
//
// pIn is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).
//
// validPixelMask is a 16-bit mask where bit (1 << (x + y * 4)) indicates whether
// the corresponding (x,y) pixel is valid. Invalid pixel color values are ignored when compressing.
//
// pOut is an ETC1 compressed version of the data.

void etc1_encode_block(const etc1_byte* pIn, etc1_uint32 validPixelMask, etc1_byte* pOut);

// Decode a block of pixels.
//
// pIn is an ETC1 compressed version of the data.
//
// pOut is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).

void etc1_decode_block(const etc1_byte* pIn, etc1_byte* pOut);

// Return the size of the encoded image data (does not include size of PKM header).

etc1_uint32 etc1_get_encoded_data_size(etc1_uint32 width, etc1_uint32 height);

// Encode an entire image.
// pIn - pointer to the image data. Formatted such that
//       pixel (x,y) is at pIn + pixelSize * x + stride * y;
// pOut - pointer to encoded data. Must be large enough to store entire encoded image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_encode_image(const etc1_byte* pIn, etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride, etc1_byte* pOut);

// Decode an entire image.
// pIn - pointer to encoded data.
// pOut - pointer to the image data. Will be written such that
//        pixel (x,y) is at pIn + pixelSize * x + stride * y. Must be
//        large enough to store entire image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_decode_image(const etc1_byte* pIn, etc1_byte* pOut,
		etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride);

// Size of a PKM header, in bytes.

#define ETC_PKM_HEADER_SIZE 16

// Format a PKM header

void etc1_pkm_format_header(etc1_byte* pHeader, etc1_uint32 width, etc1_uint32 height);

// Check if a PKM header is correctly formatted.

etc1_bool etc1_pkm_is_valid(const etc1_byte* pHeader);

// Read the image width from a PKM header

etc1_uint32 etc1_pkm_get_width(const etc1_byte* pHeader);

// Read the image height from a PKM header

etc1_uint32 etc1_pkm_get_height(const etc1_byte* pHeader);

#ifdef __cplusplus
}
#endif

#endif
#include <string.h>

/* From http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt

 The number of bits that represent a 4x4 texel block is 64 bits if
 <internalformat> is given by ETC1_RGB8_OES.

 The data for a block is a number of bytes,

 {q0, q1, q2, q3, q4, q5, q6, q7}

 where byte q0 is located at the lowest memory address and q7 at
 the highest. The 64 bits specifying the block is then represented
 by the following 64 bit integer:

 int64bit = 256*(256*(256*(256*(256*(256*(256*q0+q1)+q2)+q3)+q4)+q5)+q6)+q7;

 ETC1_RGB8_OES:

 a) bit layout in bits 63 through 32 if diffbit = 0

 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48
 -----------------------------------------------
 | base col1 | base col2 | base col1 | base col2 |
 | R1 (4bits)| R2 (4bits)| G1 (4bits)| G2 (4bits)|
 -----------------------------------------------

 47 46 45 44 43 42 41 40 39 38 37 36 35 34  33  32
 ---------------------------------------------------
 | base col1 | base col2 | table  | table  |diff|flip|
 | B1 (4bits)| B2 (4bits)| cw 1   | cw 2   |bit |bit |
 ---------------------------------------------------

 b) bit layout in bits 63 through 32 if diffbit = 1

 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48
 -----------------------------------------------
 | base col1    | dcol 2 | base col1    | dcol 2 |
 | R1' (5 bits) | dR2    | G1' (5 bits) | dG2    |
 -----------------------------------------------

 47 46 45 44 43 42 41 40 39 38 37 36 35 34  33  32
 ---------------------------------------------------
 | base col 1   | dcol 2 | table  | table  |diff|flip|
 | B1' (5 bits) | dB2    | cw 1   | cw 2   |bit |bit |
 ---------------------------------------------------

 c) bit layout in bits 31 through 0 (in both cases)

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
 -----------------------------------------------
 |       most significant pixel index bits       |
 | p| o| n| m| l| k| j| i| h| g| f| e| d| c| b| a|
 -----------------------------------------------

 15 14 13 12 11 10  9  8  7  6  5  4  3   2   1  0
 --------------------------------------------------
 |         least significant pixel index bits       |
 | p| o| n| m| l| k| j| i| h| g| f| e| d| c | b | a |
 --------------------------------------------------

 Add table 3.17.2: Intensity modifier sets for ETC1 compressed textures:

 table codeword                modifier table
 ------------------        ----------------------
 0                     -8  -2  2   8
 1                    -17  -5  5  17
 2                    -29  -9  9  29
 3                    -42 -13 13  42
 4                    -60 -18 18  60
 5                    -80 -24 24  80
 6                   -106 -33 33 106
 7                   -183 -47 47 183

 Add table 3.17.3 Mapping from pixel index values to modifier values for
 ETC1 compressed textures:

 pixel index value
 ---------------
 msb     lsb           resulting modifier value
 -----   -----          -------------------------
 1       1            -b (large negative value)
 1       0            -a (small negative value)
 0       0             a (small positive value)
 0       1             b (large positive value)

 */

static const int kModifierTable[] = {
/* 0 */2, 8, -2, -8,
/* 1 */5, 17, -5, -17,
/* 2 */9, 29, -9, -29,
/* 3 */13, 42, -13, -42,
/* 4 */18, 60, -18, -60,
/* 5 */24, 80, -24, -80,
/* 6 */33, 106, -33, -106,
/* 7 */47, 183, -47, -183 };

static const int kLookup[8] = { 0, 1, 2, 3, -4, -3, -2, -1 };

static inline etc1_byte clamp(int x) {
	return (etc1_byte) (x >= 0 ? (x < 255 ? x : 255) : 0);
}

static
inline int convert4To8(int b) {
	int c = b & 0xf;
	return (c << 4) | c;
}

static
inline int convert5To8(int b) {
	int c = b & 0x1f;
	return (c << 3) | (c >> 2);
}

static
inline int convert6To8(int b) {
	int c = b & 0x3f;
	return (c << 2) | (c >> 4);
}

static
inline int divideBy255(int d) {
	return (d + 128 + (d >> 8)) >> 8;
}

static
inline int convert8To4(int b) {
	//int c = b & 0xff;
	return divideBy255(b * 15);
}

static
inline int convert8To5(int b) {
	//int c = b & 0xff;
	return divideBy255(b * 31);
}

static
inline int convertDiff(int base, int diff) {
	return convert5To8((0x1f & base) + kLookup[0x7 & diff]);
}

static
void decode_subblock(etc1_byte* pOut, int r, int g, int b, const int* table,
		etc1_uint32 low, etc1_bool second, etc1_bool flipped) {
	int baseX = 0;
	int baseY = 0;
	int i;

	if (second) {
		if (flipped) {
			baseY = 2;
		} else {
			baseX = 2;
		}
	}
	for (i = 0; i < 8; i++) {
		int x, y;
		if (flipped) {
			x = baseX + (i >> 1);
			y = baseY + (i & 1);
		} else {
			x = baseX + (i >> 2);
			y = baseY + (i & 3);
		}
		int k = y + (x * 4);
		int offset = ((low >> k) & 1) | ((low >> (k + 15)) & 2);
		int delta = table[offset];
		etc1_byte* q = pOut + 3 * (x + 4 * y);
		*q++ = clamp(r + delta);
		*q++ = clamp(g + delta);
		*q++ = clamp(b + delta);
	}
}

// Input is an ETC1 compressed version of the data.
// Output is a 4 x 4 square of 3-byte pixels in form R, G, B

void etc1_decode_block(const etc1_byte* pIn, etc1_byte* pOut) {
	etc1_uint32 high = (pIn[0] << 24) | (pIn[1] << 16) | (pIn[2] << 8) | pIn[3];
	etc1_uint32 low = (pIn[4] << 24) | (pIn[5] << 16) | (pIn[6] << 8) | pIn[7];
	int r1, r2, g1, g2, b1, b2;
	if (high & 2) {
		// differential
		int rBase = high >> 27;
		int gBase = high >> 19;
		int bBase = high >> 11;
		r1 = convert5To8(rBase);
		r2 = convertDiff(rBase, high >> 24);
		g1 = convert5To8(gBase);
		g2 = convertDiff(gBase, high >> 16);
		b1 = convert5To8(bBase);
		b2 = convertDiff(bBase, high >> 8);
	} else {
		// not differential
		r1 = convert4To8(high >> 28);
		r2 = convert4To8(high >> 24);
		g1 = convert4To8(high >> 20);
		g2 = convert4To8(high >> 16);
		b1 = convert4To8(high >> 12);
		b2 = convert4To8(high >> 8);
	}
	int tableIndexA = 7 & (high >> 5);
	int tableIndexB = 7 & (high >> 2);
	const int* tableA = kModifierTable + tableIndexA * 4;
	const int* tableB = kModifierTable + tableIndexB * 4;
	etc1_bool flipped = (high & 1) != 0;
	decode_subblock(pOut, r1, g1, b1, tableA, low, 0, flipped);
	decode_subblock(pOut, r2, g2, b2, tableB, low, 1, flipped);
}

typedef struct {
	etc1_uint32 high;
	etc1_uint32 low;
	etc1_uint32 score; // Lower is more accurate
} etc_compressed;

static
inline void take_best(etc_compressed* a, const etc_compressed* b) {
	if (a->score > b->score) {
		*a = *b;
	}
}

static
void etc_average_colors_subblock(const etc1_byte* pIn, etc1_uint32 inMask,
		etc1_byte* pColors, etc1_bool flipped, etc1_bool second) {
	int r = 0;
	int g = 0;
	int b = 0;
	int y, x;

	if (flipped) {
		int by = 0;
		if (second) {
			by = 2;
		}
		for ( y = 0; y < 2; y++) {
			int yy = by + y;
			for ( x = 0; x < 4; x++) {
				int i = x + 4 * yy;
				if (inMask & (1 << i)) {
					const etc1_byte* p = pIn + i * 3;
					r += *(p++);
					g += *(p++);
					b += *(p++);
				}
			}
		}
	} else {
		int bx = 0;
		if (second) {
			bx = 2;
		}
		for ( y = 0; y < 4; y++) {
			for ( x = 0; x < 2; x++) {
				int xx = bx + x;
				int i = xx + 4 * y;
				if (inMask & (1 << i)) {
					const etc1_byte* p = pIn + i * 3;
					r += *(p++);
					g += *(p++);
					b += *(p++);
				}
			}
		}
	}
	pColors[0] = (etc1_byte)((r + 4) >> 3);
	pColors[1] = (etc1_byte)((g + 4) >> 3);
	pColors[2] = (etc1_byte)((b + 4) >> 3);
}

static
inline int square(int x) {
	return x * x;
}

static etc1_uint32 chooseModifier(const etc1_byte* pBaseColors,
		const etc1_byte* pIn, etc1_uint32 *pLow, int bitIndex,
		const int* pModifierTable) {
	etc1_uint32 bestScore = ~0;
	int bestIndex = 0;
	int pixelR = pIn[0];
	int pixelG = pIn[1];
	int pixelB = pIn[2];
	int r = pBaseColors[0];
	int g = pBaseColors[1];
	int b = pBaseColors[2];
	int i;
	for ( i = 0; i < 4; i++) {
		int modifier = pModifierTable[i];
		int decodedG = clamp(g + modifier);
		etc1_uint32 score = (etc1_uint32) (6 * square(decodedG - pixelG));
		if (score >= bestScore) {
			continue;
		}
		int decodedR = clamp(r + modifier);
		score += (etc1_uint32) (3 * square(decodedR - pixelR));
		if (score >= bestScore) {
			continue;
		}
		int decodedB = clamp(b + modifier);
		score += (etc1_uint32) square(decodedB - pixelB);
		if (score < bestScore) {
			bestScore = score;
			bestIndex = i;
		}
	}
	etc1_uint32 lowMask = (((bestIndex >> 1) << 16) | (bestIndex & 1))
			<< bitIndex;
	*pLow |= lowMask;
	return bestScore;
}

static
void etc_encode_subblock_helper(const etc1_byte* pIn, etc1_uint32 inMask,
		etc_compressed* pCompressed, etc1_bool flipped, etc1_bool second,
		const etc1_byte* pBaseColors, const int* pModifierTable) {
	int score = pCompressed->score;
	int y, x;
	if (flipped) {
		int by = 0;
		if (second) {
			by = 2;
		}
		for ( y = 0; y < 2; y++) {
			int yy = by + y;
			for ( x = 0; x < 4; x++) {
				int i = x + 4 * yy;
				if (inMask & (1 << i)) {
					score += chooseModifier(pBaseColors, pIn + i * 3,
							&pCompressed->low, yy + x * 4, pModifierTable);
				}
			}
		}
	} else {
		int bx = 0;
		if (second) {
			bx = 2;
		}
		for ( y = 0; y < 4; y++) {
			for ( x = 0; x < 2; x++) {
				int xx = bx + x;
				int i = xx + 4 * y;
				if (inMask & (1 << i)) {
					score += chooseModifier(pBaseColors, pIn + i * 3,
							&pCompressed->low, y + xx * 4, pModifierTable);
				}
			}
		}
	}
	pCompressed->score = score;
}

static etc1_bool inRange4bitSigned(int color) {
	return color >= -4 && color <= 3;
}

static void etc_encodeBaseColors(etc1_byte* pBaseColors,
		const etc1_byte* pColors, etc_compressed* pCompressed) {
	int r1, g1, b1, r2 = 0, g2 = 0, b2 = 0; // 8 bit base colors for sub-blocks
	etc1_bool differential;
	{
		int r51 = convert8To5(pColors[0]);
		int g51 = convert8To5(pColors[1]);
		int b51 = convert8To5(pColors[2]);
		int r52 = convert8To5(pColors[3]);
		int g52 = convert8To5(pColors[4]);
		int b52 = convert8To5(pColors[5]);

		r1 = convert5To8(r51);
		g1 = convert5To8(g51);
		b1 = convert5To8(b51);

		int dr = r52 - r51;
		int dg = g52 - g51;
		int db = b52 - b51;

		differential = inRange4bitSigned(dr) && inRange4bitSigned(dg)
				&& inRange4bitSigned(db);
		if (differential) {
			r2 = convert5To8(r51 + dr);
			g2 = convert5To8(g51 + dg);
			b2 = convert5To8(b51 + db);
			pCompressed->high |= (r51 << 27) | ((7 & dr) << 24) | (g51 << 19)
					| ((7 & dg) << 16) | (b51 << 11) | ((7 & db) << 8) | 2;
		}
	}

	if (!differential) {
		int r41 = convert8To4(pColors[0]);
		int g41 = convert8To4(pColors[1]);
		int b41 = convert8To4(pColors[2]);
		int r42 = convert8To4(pColors[3]);
		int g42 = convert8To4(pColors[4]);
		int b42 = convert8To4(pColors[5]);
		r1 = convert4To8(r41);
		g1 = convert4To8(g41);
		b1 = convert4To8(b41);
		r2 = convert4To8(r42);
		g2 = convert4To8(g42);
		b2 = convert4To8(b42);
		pCompressed->high |= (r41 << 28) | (r42 << 24) | (g41 << 20) | (g42
				<< 16) | (b41 << 12) | (b42 << 8);
	}
	pBaseColors[0] = r1;
	pBaseColors[1] = g1;
	pBaseColors[2] = b1;
	pBaseColors[3] = r2;
	pBaseColors[4] = g2;
	pBaseColors[5] = b2;
}

static
void etc_encode_block_helper(const etc1_byte* pIn, etc1_uint32 inMask,
		const etc1_byte* pColors, etc_compressed* pCompressed, etc1_bool flipped) {
	int i;

	pCompressed->score = ~0;
	pCompressed->high = (flipped ? 1 : 0);
	pCompressed->low = 0;

	etc1_byte pBaseColors[6];

	etc_encodeBaseColors(pBaseColors, pColors, pCompressed);

	int originalHigh = pCompressed->high;

	const int* pModifierTable = kModifierTable;
	for ( i = 0; i < 8; i++, pModifierTable += 4) {
		etc_compressed temp;
		temp.score = 0;
		temp.high = originalHigh | (i << 5);
		temp.low = 0;
		etc_encode_subblock_helper(pIn, inMask, &temp, flipped, 0,
				pBaseColors, pModifierTable);
		take_best(pCompressed, &temp);
	}
	pModifierTable = kModifierTable;
	etc_compressed firstHalf = *pCompressed;
	for ( i = 0; i < 8; i++, pModifierTable += 4) {
		etc_compressed temp;
		temp.score = firstHalf.score;
		temp.high = firstHalf.high | (i << 2);
		temp.low = firstHalf.low;
		etc_encode_subblock_helper(pIn, inMask, &temp, flipped, 1,
				pBaseColors + 3, pModifierTable);
		if (i == 0) {
			*pCompressed = temp;
		} else {
			take_best(pCompressed, &temp);
		}
	}
}

static void writeBigEndian(etc1_byte* pOut, etc1_uint32 d) {
	pOut[0] = (etc1_byte)(d >> 24);
	pOut[1] = (etc1_byte)(d >> 16);
	pOut[2] = (etc1_byte)(d >> 8);
	pOut[3] = (etc1_byte) d;
}

// Input is a 4 x 4 square of 3-byte pixels in form R, G, B
// inmask is a 16-bit mask where bit (1 << (x + y * 4)) tells whether the corresponding (x,y)
// pixel is valid or not. Invalid pixel color values are ignored when compressing.
// Output is an ETC1 compressed version of the data.

void etc1_encode_block(const etc1_byte* pIn, etc1_uint32 inMask,
		etc1_byte* pOut) {
	etc1_byte colors[6];
	etc1_byte flippedColors[6];
	etc_average_colors_subblock(pIn, inMask, colors, 0, 0);
	etc_average_colors_subblock(pIn, inMask, colors + 3, 0, 1);
	etc_average_colors_subblock(pIn, inMask, flippedColors, 1, 0);
	etc_average_colors_subblock(pIn, inMask, flippedColors + 3, 1, 1);

	etc_compressed a, b;
	etc_encode_block_helper(pIn, inMask, colors, &a, 0);
	etc_encode_block_helper(pIn, inMask, flippedColors, &b, 1);
	take_best(&a, &b);
	writeBigEndian(pOut, a.high);
	writeBigEndian(pOut + 4, a.low);
}

// Return the size of the encoded image data (does not include size of PKM header).

etc1_uint32 etc1_get_encoded_data_size(etc1_uint32 width, etc1_uint32 height) {
	return (((width + 3) & ~3) * ((height + 3) & ~3)) >> 1;
}

// Encode an entire image.
// pIn - pointer to the image data. Formatted such that the Red component of
//       pixel (x,y) is at pIn + pixelSize * x + stride * y + redOffset;
// pOut - pointer to encoded data. Must be large enough to store entire encoded image.

int etc1_encode_image(const etc1_byte* pIn, etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride, etc1_byte* pOut) {
	if (pixelSize < 2 || pixelSize > 3) {
		return -1;
	}
	static const unsigned short kYMask[] = { 0x0, 0xf, 0xff, 0xfff, 0xffff };
	static const unsigned short kXMask[] = { 0x0, 0x1111, 0x3333, 0x7777,
			0xffff };
	etc1_byte block[ETC1_DECODED_BLOCK_SIZE];
	etc1_byte encoded[ETC1_ENCODED_BLOCK_SIZE];
	etc1_uint32 y, x, cy, cx;

	etc1_uint32 encodedWidth = (width + 3) & ~3;
	etc1_uint32 encodedHeight = (height + 3) & ~3;

	for ( y = 0; y < encodedHeight; y += 4) {
		etc1_uint32 yEnd = height - y;
		if (yEnd > 4) {
			yEnd = 4;
		}
		int ymask = kYMask[yEnd];
		for ( x = 0; x < encodedWidth; x += 4) {
			etc1_uint32 xEnd = width - x;
			if (xEnd > 4) {
				xEnd = 4;
			}
			int mask = ymask & kXMask[xEnd];
			for ( cy = 0; cy < yEnd; cy++) {
				etc1_byte* q = block + (cy * 4) * 3;
				const etc1_byte* p = pIn + pixelSize * x + stride * (y + cy);
				if (pixelSize == 3) {
					memcpy(q, p, xEnd * 3);
				} else {
					for ( cx = 0; cx < xEnd; cx++) {
						int pixel = (p[1] << 8) | p[0];
						*q++ = convert5To8(pixel >> 11);
						*q++ = convert6To8(pixel >> 5);
						*q++ = convert5To8(pixel);
						p += pixelSize;
					}
				}
			}
			etc1_encode_block(block, mask, encoded);
			memcpy(pOut, encoded, sizeof(encoded));
			pOut += sizeof(encoded);
		}
	}
	return 0;
}

// Decode an entire image.
// pIn - pointer to encoded data.
// pOut - pointer to the image data. Will be written such that the Red component of
//       pixel (x,y) is at pIn + pixelSize * x + stride * y + redOffset. Must be
//        large enough to store entire image.

int etc1_decode_image(const etc1_byte* pIn, etc1_byte* pOut,
		etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride) {
	if (pixelSize < 2 || pixelSize > 3) {
		return -1;
	}
	etc1_byte block[ETC1_DECODED_BLOCK_SIZE];

	etc1_uint32 encodedWidth = (width + 3) & ~3;
	etc1_uint32 encodedHeight = (height + 3) & ~3;

	etc1_uint32 y, x, cy, cx;

	for ( y = 0; y < encodedHeight; y += 4) {
		etc1_uint32 yEnd = height - y;
		if (yEnd > 4) {
			yEnd = 4;
		}
		for ( x = 0; x < encodedWidth; x += 4) {
			etc1_uint32 xEnd = width - x;
			if (xEnd > 4) {
				xEnd = 4;
			}
			etc1_decode_block(pIn, block);
			pIn += ETC1_ENCODED_BLOCK_SIZE;
			for ( cy = 0; cy < yEnd; cy++) {
				const etc1_byte* q = block + (cy * 4) * 3;
				etc1_byte* p = pOut + pixelSize * x + stride * (y + cy);
				if (pixelSize == 3) {
					memcpy(p, q, xEnd * 3);
				} else {
					for ( cx = 0; cx < xEnd; cx++) {
						etc1_byte r = *q++;
						etc1_byte g = *q++;
						etc1_byte b = *q++;
						etc1_uint32 pixel = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
						*p++ = (etc1_byte) pixel;
						*p++ = (etc1_byte) (pixel >> 8);
					}
				}
			}
		}
	}
	return 0;
}

static const char kMagic[] = { 'P', 'K', 'M', ' ', '1', '0' };

static const etc1_uint32 ETC1_PKM_FORMAT_OFFSET = 6;
static const etc1_uint32 ETC1_PKM_ENCODED_WIDTH_OFFSET = 8;
static const etc1_uint32 ETC1_PKM_ENCODED_HEIGHT_OFFSET = 10;
static const etc1_uint32 ETC1_PKM_WIDTH_OFFSET = 12;
static const etc1_uint32 ETC1_PKM_HEIGHT_OFFSET = 14;

static const etc1_uint32 ETC1_RGB_NO_MIPMAPS = 0;

static void writeBEUint16(etc1_byte* pOut, etc1_uint32 data) {
	pOut[0] = (etc1_byte) (data >> 8);
	pOut[1] = (etc1_byte) data;
}

static etc1_uint32 readBEUint16(const etc1_byte* pIn) {
	return (pIn[0] << 8) | pIn[1];
}

// Format a PKM header

void etc1_pkm_format_header(etc1_byte* pHeader, etc1_uint32 width, etc1_uint32 height) {
	memcpy(pHeader, kMagic, sizeof(kMagic));
	etc1_uint32 encodedWidth = (width + 3) & ~3;
	etc1_uint32 encodedHeight = (height + 3) & ~3;
	writeBEUint16(pHeader + ETC1_PKM_FORMAT_OFFSET, ETC1_RGB_NO_MIPMAPS);
	writeBEUint16(pHeader + ETC1_PKM_ENCODED_WIDTH_OFFSET, encodedWidth);
	writeBEUint16(pHeader + ETC1_PKM_ENCODED_HEIGHT_OFFSET, encodedHeight);
	writeBEUint16(pHeader + ETC1_PKM_WIDTH_OFFSET, width);
	writeBEUint16(pHeader + ETC1_PKM_HEIGHT_OFFSET, height);
}

// Check if a PKM header is correctly formatted.

etc1_bool etc1_pkm_is_valid(const etc1_byte* pHeader) {
	if (memcmp(pHeader, kMagic, sizeof(kMagic))) {
		return 0;
	}
	etc1_uint32 format = readBEUint16(pHeader + ETC1_PKM_FORMAT_OFFSET);
	etc1_uint32 encodedWidth = readBEUint16(pHeader + ETC1_PKM_ENCODED_WIDTH_OFFSET);
	etc1_uint32 encodedHeight = readBEUint16(pHeader + ETC1_PKM_ENCODED_HEIGHT_OFFSET);
	etc1_uint32 width = readBEUint16(pHeader + ETC1_PKM_WIDTH_OFFSET);
	etc1_uint32 height = readBEUint16(pHeader + ETC1_PKM_HEIGHT_OFFSET);
	return format == ETC1_RGB_NO_MIPMAPS &&
			encodedWidth >= width && encodedWidth - width < 4 &&
			encodedHeight >= height && encodedHeight - height < 4;
}

// Read the image width from a PKM header

etc1_uint32 etc1_pkm_get_width(const etc1_byte* pHeader) {
	return readBEUint16(pHeader + ETC1_PKM_WIDTH_OFFSET);
}

// Read the image height from a PKM header

etc1_uint32 etc1_pkm_get_height(const etc1_byte* pHeader){
	return readBEUint16(pHeader + ETC1_PKM_HEIGHT_OFFSET);
}



//#line 1 "image_helper.c"

//#line 1 "image_helper.h"
#ifndef HEADER_IMAGE_HELPER
#define HEADER_IMAGE_HELPER

#ifdef __cplusplus
extern "C" {
#endif

/**
	This function upscales an image.
	Not to be used to create MIPmaps,
	but to make it square,
	or to make it a power-of-two sized.
**/
int
	up_scale_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int resampled_width, int resampled_height
	);

/**
	This function downscales an image.
	Used for creating MIPmaps,
	the incoming image should be a
	power-of-two sized.
**/
int
	mipmap_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int block_size_x, int block_size_y
	);

/**
	This function takes the RGB components of the image
	and scales each channel from [0,255] to [16,235].
	This makes the colors "Safe" for display on NTSC
	displays.  Note that this is _NOT_ a good idea for
	loading images like normal- or height-maps!
**/
int
	scale_image_RGB_to_NTSC_safe
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	This function takes the RGB components of the image
	and converts them into YCoCg.  3 components will be
	re-ordered to CoYCg (for optimum DXT1 compression),
	while 4 components will be ordered CoCgAY (for DXT5
	compression).
**/
int
	convert_RGB_to_YCoCg
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	This function takes the YCoCg components of the image
	and converts them into RGB.  See above.
**/
int
	convert_YCoCg_to_RGB
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	Converts an HDR image from an array
	of unsigned chars (RGBE) to RGBdivA
	\return 0 if failed, otherwise returns 1
**/
int
	RGBE_to_RGBdivA
	(
		unsigned char *image,
		int width, int height,
		int rescale_to_max
	);

/**
	Converts an HDR image from an array
	of unsigned chars (RGBE) to RGBdivA2
	\return 0 if failed, otherwise returns 1
**/
int
	RGBE_to_RGBdivA2
	(
		unsigned char *image,
		int width, int height,
		int rescale_to_max
	);

#ifdef __cplusplus
}
#endif

#endif /* HEADER_IMAGE_HELPER	*/

#include <stdlib.h>
#include <math.h>

/*	Upscaling the image uses simple bilinear interpolation	*/
int
	up_scale_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int resampled_width, int resampled_height
	)
{
	float dx, dy;
	int x, y, c;

	/* error(s) check	*/
	if ( 	(width < 1) || (height < 1) ||
			(resampled_width < 2) || (resampled_height < 2) ||
			(channels < 1) ||
			(NULL == orig) || (NULL == resampled) )
	{
		/*	signify badness	*/
		return 0;
	}
	/*
		for each given pixel in the new map, find the exact location
		from the original map which would contribute to this guy
	*/
	dx = (width - 1.0f) / (resampled_width - 1.0f);
	dy = (height - 1.0f) / (resampled_height - 1.0f);
	for ( y = 0; y < resampled_height; ++y )
	{
		/* find the base y index and fractional offset from that	*/
		float sampley = y * dy;
		int inty = (int)sampley;
		/*	if( inty < 0 ) { inty = 0; } else	*/
		if( inty > height - 2 ) { inty = height - 2; }
		sampley -= inty;
		for ( x = 0; x < resampled_width; ++x )
		{
			float samplex = x * dx;
			int intx = (int)samplex;
			int base_index;
			/* find the base x index and fractional offset from that	*/
			/*	if( intx < 0 ) { intx = 0; } else	*/
			if( intx > width - 2 ) { intx = width - 2; }
			samplex -= intx;
			/*	base index into the original image	*/
			base_index = (inty * width + intx) * channels;
			for ( c = 0; c < channels; ++c )
			{
				/*	do the sampling	*/
				float value = 0.5f;
				value += orig[base_index]
							*(1.0f-samplex)*(1.0f-sampley);
				value += orig[base_index+channels]
							*(samplex)*(1.0f-sampley);
				value += orig[base_index+width*channels]
							*(1.0f-samplex)*(sampley);
				value += orig[base_index+width*channels+channels]
							*(samplex)*(sampley);
				/*	move to the next channel	*/
				++base_index;
				/*	save the new value	*/
				resampled[y*resampled_width*channels+x*channels+c] =
						(unsigned char)(value);
			}
		}
	}
	/*	done	*/
	return 1;
}

int
	mipmap_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int block_size_x, int block_size_y
	)
{
	int mip_width, mip_height;
	int i, j, c;

	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (orig == NULL) ||
		(resampled == NULL) ||
		(block_size_x < 1) || (block_size_y < 1) )
	{
		/*	nothing to do	*/
		return 0;
	}
	mip_width = width / block_size_x;
	mip_height = height / block_size_y;
	if( mip_width < 1 )
	{
		mip_width = 1;
	}
	if( mip_height < 1 )
	{
		mip_height = 1;
	}
	for( j = 0; j < mip_height; ++j )
	{
		for( i = 0; i < mip_width; ++i )
		{
			for( c = 0; c < channels; ++c )
			{
				const int index = (j*block_size_y)*width*channels + (i*block_size_x)*channels + c;
				int sum_value;
				int u,v;
				int u_block = block_size_x;
				int v_block = block_size_y;
				int block_area;
				/*	do a bit of checking so we don't over-run the boundaries
					(necessary for non-square textures!)	*/
				if( block_size_x * (i+1) > width )
				{
					u_block = width - i*block_size_y;
				}
				if( block_size_y * (j+1) > height )
				{
					v_block = height - j*block_size_y;
				}
				block_area = u_block*v_block;
				/*	for this pixel, see what the average
					of all the values in the block are.
					note: start the sum at the rounding value, not at 0	*/
				sum_value = block_area >> 1;
				for( v = 0; v < v_block; ++v )
				for( u = 0; u < u_block; ++u )
				{
					sum_value += orig[index + v*width*channels + u*channels];
				}
				resampled[j*mip_width*channels + i*channels + c] = sum_value / block_area;
			}
		}
	}
	return 1;
}

int
	scale_image_RGB_to_NTSC_safe
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	const float scale_lo = 16.0f - 0.499f;
	const float scale_hi = 235.0f + 0.499f;
	int i, j;
	int nc = channels;
	unsigned char scale_LUT[256];
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (orig == NULL) )
	{
		/*	nothing to do	*/
		return 0;
	}
	/*	set up the scaling Look Up Table	*/
	for( i = 0; i < 256; ++i )
	{
		scale_LUT[i] = (unsigned char)((scale_hi - scale_lo) * i / 255.0f + scale_lo);
	}
	/*	for channels = 2 or 4, ignore the alpha component	*/
	nc -= 1 - (channels & 1);
	/*	OK, go through the image and scale any non-alpha components	*/
	for( i = 0; i < width*height*channels; i += channels )
	{
		for( j = 0; j < nc; ++j )
		{
			orig[i+j] = scale_LUT[orig[i+j]];
		}
	}
	return 1;
}

unsigned char clamp_byte( int x ) { return ( (x) < 0 ? (0) : ( (x) > 255 ? 255 : (x) ) ); }

/*
	This function takes the RGB components of the image
	and converts them into YCoCg.  3 components will be
	re-ordered to CoYCg (for optimum DXT1 compression),
	while 4 components will be ordered CoCgAY (for DXT5
	compression).
*/
int
	convert_RGB_to_YCoCg
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	int i;
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 3) || (channels > 4) ||
		(orig == NULL) )
	{
		/*	nothing to do	*/
		return -1;
	}
	/*	do the conversion	*/
	if( channels == 3 )
	{
		for( i = 0; i < width*height*3; i += 3 )
		{
			int r = orig[i+0];
			int g = (orig[i+1] + 1) >> 1;
			int b = orig[i+2];
			int tmp = (2 + r + b) >> 2;
			/*	Co	*/
			orig[i+0] = clamp_byte( 128 + ((r - b + 1) >> 1) );
			/*	Y	*/
			orig[i+1] = clamp_byte( g + tmp );
			/*	Cg	*/
			orig[i+2] = clamp_byte( 128 + g - tmp );
		}
	} else
	{
		for( i = 0; i < width*height*4; i += 4 )
		{
			int r = orig[i+0];
			int g = (orig[i+1] + 1) >> 1;
			int b = orig[i+2];
			unsigned char a = orig[i+3];
			int tmp = (2 + r + b) >> 2;
			/*	Co	*/
			orig[i+0] = clamp_byte( 128 + ((r - b + 1) >> 1) );
			/*	Cg	*/
			orig[i+1] = clamp_byte( 128 + g - tmp );
			/*	Alpha	*/
			orig[i+2] = a;
			/*	Y	*/
			orig[i+3] = clamp_byte( g + tmp );
		}
	}
	/*	done	*/
	return 0;
}

/*
	This function takes the YCoCg components of the image
	and converts them into RGB.  See above.
*/
int
	convert_YCoCg_to_RGB
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	int i;
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 3) || (channels > 4) ||
		(orig == NULL) )
	{
		/*	nothing to do	*/
		return -1;
	}
	/*	do the conversion	*/
	if( channels == 3 )
	{
		for( i = 0; i < width*height*3; i += 3 )
		{
			int co = orig[i+0] - 128;
			int y  = orig[i+1];
			int cg = orig[i+2] - 128;
			/*	R	*/
			orig[i+0] = clamp_byte( y + co - cg );
			/*	G	*/
			orig[i+1] = clamp_byte( y + cg );
			/*	B	*/
			orig[i+2] = clamp_byte( y - co - cg );
		}
	} else
	{
		for( i = 0; i < width*height*4; i += 4 )
		{
			int co = orig[i+0] - 128;
			int cg = orig[i+1] - 128;
			unsigned char a  = orig[i+2];
			int y  = orig[i+3];
			/*	R	*/
			orig[i+0] = clamp_byte( y + co - cg );
			/*	G	*/
			orig[i+1] = clamp_byte( y + cg );
			/*	B	*/
			orig[i+2] = clamp_byte( y - co - cg );
			/*	A	*/
			orig[i+3] = a;
		}
	}
	/*	done	*/
	return 0;
}

float
find_max_RGBE
(
	unsigned char *image,
	int width, int height
)
{
	float max_val = 0.0f;
	unsigned char *img = image;
	int i, j;
	for( i = width * height; i > 0; --i )
	{
		/* float scale = powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		float scale = (float)ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		for( j = 0; j < 3; ++j )
		{
			if( img[j] * scale > max_val )
			{
				max_val = img[j] * scale;
			}
		}
		/* next pixel */
		img += 4;
	}
	return max_val;
}

int
RGBE_to_RGBdivA
(
	unsigned char *image,
	int width, int height,
	int rescale_to_max
)
{
	/* local variables */
	int i, iv;
	unsigned char *img = image;
	float scale = 1.0f;
	/* error check */
	if( (!image) || (width < 1) || (height < 1) )
	{
		return 0;
	}
	/* convert (note: no negative numbers, but 0.0 is possible) */
	if( rescale_to_max )
	{
		scale = 255.0f / find_max_RGBE( image, width, height );
	}
	for( i = width * height; i > 0; --i )
	{
		/* decode this pixel, and find the max */
		float r,g,b,e, m;
		/* e = scale * powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		e = scale * (float)ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		r = e * img[0];
		g = e * img[1];
		b = e * img[2];
		m = (r > g) ? r : g;
		m = (b > m) ? b : m;
		/* and encode it into RGBdivA */
		iv = (m != 0.0f) ? (int)(255.0f / m) : 1;
		iv = (iv < 1) ? 1 : iv;
		img[3] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * r + 0.5f);
		img[0] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * g + 0.5f);
		img[1] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * b + 0.5f);
		img[2] = (iv > 255) ? 255 : iv;
		/* and on to the next pixel */
		img += 4;
	}
	return 1;
}

int
RGBE_to_RGBdivA2
(
	unsigned char *image,
	int width, int height,
	int rescale_to_max
)
{
	/* local variables */
	int i, iv;
	unsigned char *img = image;
	float scale = 1.0f;
	/* error check */
	if( (!image) || (width < 1) || (height < 1) )
	{
		return 0;
	}
	/* convert (note: no negative numbers, but 0.0 is possible) */
	if( rescale_to_max )
	{
		scale = 255.0f * 255.0f / find_max_RGBE( image, width, height );
	}
	for( i = width * height; i > 0; --i )
	{
		/* decode this pixel, and find the max */
		float r,g,b,e, m;
		/* e = scale * powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		e = scale * (float)ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		r = e * img[0];
		g = e * img[1];
		b = e * img[2];
		m = (r > g) ? r : g;
		m = (b > m) ? b : m;
		/* and encode it into RGBdivA */
		iv = (m != 0.0f) ? (int)sqrtf( 255.0f * 255.0f / m ) : 1;
		iv = (iv < 1) ? 1 : iv;
		img[3] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * r / 255.0f + 0.5f);
		img[0] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * g / 255.0f + 0.5f);
		img[1] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * b / 255.0f + 0.5f);
		img[2] = (iv > 255) ? 255 : iv;
		/* and on to the next pixel */
		img += 4;
	}
	return 1;
}


//#line 1 "rg_etc1.cpp"
// File: rg_etc1.cpp - Fast, high quality ETC1 block packer/unpacker - Rich Geldreich <richgel99@gmail.com>
// Please see ZLIB license at the end of rg_etc1.h.
//
// For more information Ericsson Texture Compression (ETC/ETC1), see:
// http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt
//
// v1.04 - 5/15/14 - Fix signed vs. unsigned subtraction problem (noticed when compiled with gcc) in pack_etc1_block_init().
//         This issue would cause an assert when this func. was called in debug. (Note this module was developed/testing with MSVC,
//         I still need to test it throughly when compiled with gcc.)
//
// v1.03 - 5/12/13 - Initial public release

//#line 1 "rg_etc1.h"
// File: rg_etc1.h - Fast, high quality ETC1 block packer/unpacker - Rich Geldreich <richgel99@gmail.com>
// Please see ZLIB license at the end of this file.
//#pragma once

namespace rg_etc1
{
   // Unpacks an 8-byte ETC1 compressed block to a block of 4x4 32bpp RGBA pixels.
   // Returns false if the block is invalid. Invalid blocks will still be unpacked with clamping.
   // This function is thread safe, and does not dynamically allocate any memory.
   // If preserve_alpha is true, the alpha channel of the destination pixels will not be overwritten. Otherwise, alpha will be set to 255.
   bool unpack_etc1_block(const void *pETC1_block, unsigned int* pDst_pixels_rgba, bool preserve_alpha = false);

   // Quality setting = the higher the quality, the slower.
   // To pack large textures, it is highly recommended to call pack_etc1_block() in parallel, on different blocks, from multiple threads (particularly when using cHighQuality).
   enum etc1_quality
   {
	  cLowQuality,
	  cMediumQuality,
	  cHighQuality,
   };

   struct etc1_pack_params
   {
	  etc1_quality m_quality;
	  bool m_dithering;

	  inline etc1_pack_params()
	  {
		 clear();
	  }

	  void clear()
	  {
		 m_quality = cHighQuality;
		 m_dithering = false;
	  }
   };

   // Important: pack_etc1_block_init() must be called before calling pack_etc1_block().
   void pack_etc1_block_init();

   // Packs a 4x4 block of 32bpp RGBA pixels to an 8-byte ETC1 block.
   // 32-bit RGBA pixels must always be arranged as (R,G,B,A) (R first, A last) in memory, independent of platform endianness. A should always be 255.
   // Returns squared error of result.
   // This function is thread safe, and does not dynamically allocate any memory.
   // pack_etc1_block() does not currently support "perceptual" colorspace metrics - it primarily optimizes for RGB RMSE.
   unsigned int pack_etc1_block(void* pETC1_block, const unsigned int* pSrc_pixels_rgba, etc1_pack_params& pack_params);

} // namespace rg_etc1

//------------------------------------------------------------------------------
//
// rg_etc1 uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2012 Rich Geldreich
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------


#include <stdlib.h>
#include <memory.h>
#include <assert.h>
//#include <stdio.h>
#include <math.h>

#pragma warning (disable: 4201) //  nonstandard extension used : nameless struct/union

#if defined(_DEBUG) || defined(DEBUG)
#define RG_ETC1_BUILD_DEBUG
#endif

#define RG_ETC1_ASSERT assert

namespace rg_etc1
{
   typedef unsigned char uint8;
   typedef unsigned short uint16;
   typedef unsigned int uint;
   typedef unsigned int uint32;
   typedef long long int64;
   typedef unsigned long long uint64;

   const uint32 cUINT32_MAX = 0xFFFFFFFFU;
   const uint64 cUINT64_MAX = 0xFFFFFFFFFFFFFFFFULL; //0xFFFFFFFFFFFFFFFFui64;

   template<typename T> inline T minimum(T a, T b) { return (a < b) ? a : b; }
   template<typename T> inline T minimum(T a, T b, T c) { return minimum(minimum(a, b), c); }
   template<typename T> inline T maximum(T a, T b) { return (a > b) ? a : b; }
   template<typename T> inline T maximum(T a, T b, T c) { return maximum(maximum(a, b), c); }
   template<typename T> inline T clamp(T value, T low, T high) { return (value < low) ? low : ((value > high) ? high : value); }
   template<typename T> inline T square(T value) { return value * value; }
   template<typename T> inline void zero_object(T& obj) { memset((void*)&obj, 0, sizeof(obj)); }
   template<typename T> inline void zero_this(T* pObj) { memset((void*)pObj, 0, sizeof(*pObj)); }

   template<class T, size_t N> T decay_array_to_subtype(T (&a)[N]);

#define RG_ETC1_ARRAY_SIZE(X) (sizeof(X) / sizeof(decay_array_to_subtype(X)))

   enum eNoClamp { cNoClamp };

   struct color_quad_u8
   {
	  static inline int clamp(int v) { if (v & 0xFFFFFF00U) v = (~(static_cast<int>(v) >> 31)) & 0xFF; return v; }

	  struct component_traits { enum { cSigned = false, cFloat = false, cMin = 0U, cMax = 255U }; };

   public:
	  typedef unsigned char component_t;
	  typedef int parameter_t;

	  enum { cNumComps = 4 };

	  union
	  {
		 struct
		 {
			component_t r;
			component_t g;
			component_t b;
			component_t a;
		 };

		 component_t c[cNumComps];

		 uint32 m_u32;
	  };

	  inline color_quad_u8()
	  {
	  }

	  inline color_quad_u8(const color_quad_u8& other) : m_u32(other.m_u32)
	  {
	  }

	  explicit inline color_quad_u8(parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 set(y, alpha);
	  }

	  inline color_quad_u8(parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha = component_traits::cMax)
	  {
		 set(red, green, blue, alpha);
	  }

	  explicit inline color_quad_u8(eNoClamp, parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 set_noclamp_y_alpha(y, alpha);
	  }

	  inline color_quad_u8(eNoClamp, parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha = component_traits::cMax)
	  {
		 set_noclamp_rgba(red, green, blue, alpha);
	  }

	  inline void clear()
	  {
		 m_u32 = 0;
	  }

	  inline color_quad_u8& operator= (const color_quad_u8& other)
	  {
		 m_u32 = other.m_u32;
		 return *this;
	  }

	  inline color_quad_u8& set_rgb(const color_quad_u8& other)
	  {
		 r = other.r;
		 g = other.g;
		 b = other.b;
		 return *this;
	  }

	  inline color_quad_u8& operator= (parameter_t y)
	  {
		 set(y, component_traits::cMax);
		 return *this;
	  }

	  inline color_quad_u8& set(parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 y = clamp(y);
		 alpha = clamp(alpha);
		 r = static_cast<component_t>(y);
		 g = static_cast<component_t>(y);
		 b = static_cast<component_t>(y);
		 a = static_cast<component_t>(alpha);
		 return *this;
	  }

	  inline color_quad_u8& set_noclamp_y_alpha(parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 RG_ETC1_ASSERT( (y >= component_traits::cMin) && (y <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (alpha >= component_traits::cMin) && (alpha <= component_traits::cMax) );

		 r = static_cast<component_t>(y);
		 g = static_cast<component_t>(y);
		 b = static_cast<component_t>(y);
		 a = static_cast<component_t>(alpha);
		 return *this;
	  }

	  inline color_quad_u8& set(parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha = component_traits::cMax)
	  {
		 r = static_cast<component_t>(clamp(red));
		 g = static_cast<component_t>(clamp(green));
		 b = static_cast<component_t>(clamp(blue));
		 a = static_cast<component_t>(clamp(alpha));
		 return *this;
	  }

	  inline color_quad_u8& set_noclamp_rgba(parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha)
	  {
		 RG_ETC1_ASSERT( (red >= component_traits::cMin) && (red <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (green >= component_traits::cMin) && (green <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (blue >= component_traits::cMin) && (blue <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (alpha >= component_traits::cMin) && (alpha <= component_traits::cMax) );

		 r = static_cast<component_t>(red);
		 g = static_cast<component_t>(green);
		 b = static_cast<component_t>(blue);
		 a = static_cast<component_t>(alpha);
		 return *this;
	  }

	  inline color_quad_u8& set_noclamp_rgb(parameter_t red, parameter_t green, parameter_t blue)
	  {
		 RG_ETC1_ASSERT( (red >= component_traits::cMin) && (red <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (green >= component_traits::cMin) && (green <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (blue >= component_traits::cMin) && (blue <= component_traits::cMax) );

		 r = static_cast<component_t>(red);
		 g = static_cast<component_t>(green);
		 b = static_cast<component_t>(blue);
		 return *this;
	  }

	  static inline parameter_t get_min_comp() { return component_traits::cMin; }
	  static inline parameter_t get_max_comp() { return component_traits::cMax; }
	  static inline bool get_comps_are_signed() { return component_traits::cSigned; }

	  inline component_t operator[] (uint i) const { RG_ETC1_ASSERT(i < cNumComps); return c[i]; }
	  inline component_t& operator[] (uint i) { RG_ETC1_ASSERT(i < cNumComps); return c[i]; }

	  inline color_quad_u8& set_component(uint i, parameter_t f)
	  {
		 RG_ETC1_ASSERT(i < cNumComps);

		 c[i] = static_cast<component_t>(clamp(f));

		 return *this;
	  }

	  inline color_quad_u8& set_grayscale(parameter_t l)
	  {
		 component_t x = static_cast<component_t>(clamp(l));
		 c[0] = x;
		 c[1] = x;
		 c[2] = x;
		 return *this;
	  }

	  inline color_quad_u8& clamp(const color_quad_u8& l, const color_quad_u8& h)
	  {
		 for (uint i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_t>(rg_etc1::clamp<parameter_t>(c[i], l[i], h[i]));
		 return *this;
	  }

	  inline color_quad_u8& clamp(parameter_t l, parameter_t h)
	  {
		 for (uint i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_t>(rg_etc1::clamp<parameter_t>(c[i], l, h));
		 return *this;
	  }

	  // Returns CCIR 601 luma (consistent with color_utils::RGB_To_Y).
	  inline parameter_t get_luma() const
	  {
		 return static_cast<parameter_t>((19595U * r + 38470U * g + 7471U * b + 32768U) >> 16U);
	  }

	  // Returns REC 709 luma.
	  inline parameter_t get_luma_rec709() const
	  {
		 return static_cast<parameter_t>((13938U * r + 46869U * g + 4729U * b + 32768U) >> 16U);
	  }

	  inline uint squared_distance_rgb(const color_quad_u8& c) const
	  {
		 return rg_etc1::square(r - c.r) + rg_etc1::square(g - c.g) + rg_etc1::square(b - c.b);
	  }

	  inline uint squared_distance_rgba(const color_quad_u8& c) const
	  {
		 return rg_etc1::square(r - c.r) + rg_etc1::square(g - c.g) + rg_etc1::square(b - c.b) + rg_etc1::square(a - c.a);
	  }

	  inline bool rgb_equals(const color_quad_u8& rhs) const
	  {
		 return (r == rhs.r) && (g == rhs.g) && (b == rhs.b);
	  }

	  inline bool operator== (const color_quad_u8& rhs) const
	  {
		 return m_u32 == rhs.m_u32;
	  }

	  color_quad_u8& operator+= (const color_quad_u8& other)
	  {
		 for (uint i = 0; i < 4; i++)
			c[i] = static_cast<component_t>(clamp(c[i] + other.c[i]));
		 return *this;
	  }

	  color_quad_u8& operator-= (const color_quad_u8& other)
	  {
		 for (uint i = 0; i < 4; i++)
			c[i] = static_cast<component_t>(clamp(c[i] - other.c[i]));
		 return *this;
	  }

	  friend color_quad_u8 operator+ (const color_quad_u8& lhs, const color_quad_u8& rhs)
	  {
		 color_quad_u8 result(lhs);
		 result += rhs;
		 return result;
	  }

	  friend color_quad_u8 operator- (const color_quad_u8& lhs, const color_quad_u8& rhs)
	  {
		 color_quad_u8 result(lhs);
		 result -= rhs;
		 return result;
	  }
   }; // class color_quad_u8

   struct vec3F
   {
	  float m_s[3];

	  inline vec3F() { }
	  inline vec3F(float s) { m_s[0] = s; m_s[1] = s; m_s[2] = s; }
	  inline vec3F(float x, float y, float z) { m_s[0] = x; m_s[1] = y; m_s[2] = z; }

	  inline float operator[] (uint i) const { RG_ETC1_ASSERT(i < 3); return m_s[i]; }

	  inline vec3F& operator += (const vec3F& other) { for (uint i = 0; i < 3; i++) m_s[i] += other.m_s[i]; return *this; }

	  inline vec3F& operator *= (float s) { for (uint i = 0; i < 3; i++) m_s[i] *= s; return *this; }
   };

   enum etc_constants
   {
	  cETC1BytesPerBlock = 8U,

	  cETC1SelectorBits = 2U,
	  cETC1SelectorValues = 1U << cETC1SelectorBits,
	  cETC1SelectorMask = cETC1SelectorValues - 1U,

	  cETC1BlockShift = 2U,
	  cETC1BlockSize = 1U << cETC1BlockShift,

	  cETC1LSBSelectorIndicesBitOffset = 0,
	  cETC1MSBSelectorIndicesBitOffset = 16,

	  cETC1FlipBitOffset = 32,
	  cETC1DiffBitOffset = 33,

	  cETC1IntenModifierNumBits = 3,
	  cETC1IntenModifierValues = 1 << cETC1IntenModifierNumBits,
	  cETC1RightIntenModifierTableBitOffset = 34,
	  cETC1LeftIntenModifierTableBitOffset = 37,

	  // Base+Delta encoding (5 bit bases, 3 bit delta)
	  cETC1BaseColorCompNumBits = 5,
	  cETC1BaseColorCompMax = 1 << cETC1BaseColorCompNumBits,

	  cETC1DeltaColorCompNumBits = 3,
	  cETC1DeltaColorComp = 1 << cETC1DeltaColorCompNumBits,
	  cETC1DeltaColorCompMax = 1 << cETC1DeltaColorCompNumBits,

	  cETC1BaseColor5RBitOffset = 59,
	  cETC1BaseColor5GBitOffset = 51,
	  cETC1BaseColor5BBitOffset = 43,

	  cETC1DeltaColor3RBitOffset = 56,
	  cETC1DeltaColor3GBitOffset = 48,
	  cETC1DeltaColor3BBitOffset = 40,

	  // Absolute (non-delta) encoding (two 4-bit per component bases)
	  cETC1AbsColorCompNumBits = 4,
	  cETC1AbsColorCompMax = 1 << cETC1AbsColorCompNumBits,

	  cETC1AbsColor4R1BitOffset = 60,
	  cETC1AbsColor4G1BitOffset = 52,
	  cETC1AbsColor4B1BitOffset = 44,

	  cETC1AbsColor4R2BitOffset = 56,
	  cETC1AbsColor4G2BitOffset = 48,
	  cETC1AbsColor4B2BitOffset = 40,

	  cETC1ColorDeltaMin = -4,
	  cETC1ColorDeltaMax = 3,

	  // Delta3:
	  // 0   1   2   3   4   5   6   7
	  // 000 001 010 011 100 101 110 111
	  // 0   1   2   3   -4  -3  -2  -1
   };

   static uint8 g_quant5_tab[256+16];

   static const int g_etc1_inten_tables[cETC1IntenModifierValues][cETC1SelectorValues] =
   {
	  { -8,  -2,   2,   8 }, { -17,  -5,  5,  17 }, { -29,  -9,   9,  29 }, {  -42, -13, 13,  42 },
	  { -60, -18, 18,  60 }, { -80, -24, 24,  80 }, { -106, -33, 33, 106 }, { -183, -47, 47, 183 }
   };

   static const uint8 g_etc1_to_selector_index[cETC1SelectorValues] = { 2, 3, 1, 0 };
   static const uint8 g_selector_index_to_etc1[cETC1SelectorValues] = { 3, 2, 0, 1 };

   // Given an ETC1 diff/inten_table/selector, and an 8-bit desired color, this table encodes the best packed_color in the low byte, and the abs error in the high byte.
   static uint16 g_etc1_inverse_lookup[2*8*4][256];      // [diff/inten_table/selector][desired_color]

   // g_color8_to_etc_block_config[color][table_index] = Supplies for each 8-bit color value a list of packed ETC1 diff/intensity table/selectors/packed_colors that map to that color.
   // To pack: diff | (inten << 1) | (selector << 4) | (packed_c << 8)
   static const uint16 g_color8_to_etc_block_config_0_255[2][33] =
   {
	  { 0x0000,  0x0010,  0x0002,  0x0012,  0x0004,  0x0014,  0x0006,  0x0016,  0x0008,  0x0018,  0x000A,  0x001A,  0x000C,  0x001C,  0x000E,  0x001E,
		0x0001,  0x0011,  0x0003,  0x0013,  0x0005,  0x0015,  0x0007,  0x0017,  0x0009,  0x0019,  0x000B,  0x001B,  0x000D,  0x001D,  0x000F,  0x001F, 0xFFFF },
	  { 0x0F20,  0x0F30,  0x0E32,  0x0F22,  0x0E34,  0x0F24,  0x0D36,  0x0F26,  0x0C38,  0x0E28,  0x0B3A,  0x0E2A,  0x093C,  0x0E2C,  0x053E,  0x0D2E,
		0x1E31,  0x1F21,  0x1D33,  0x1F23,  0x1C35,  0x1E25,  0x1A37,  0x1E27,  0x1839,  0x1D29,  0x163B,  0x1C2B,  0x133D,  0x1B2D,  0x093F,  0x1A2F, 0xFFFF },
   };

   // Really only [254][11].
   static const uint16 g_color8_to_etc_block_config_1_to_254[254][12] =
   {
	  { 0x021C, 0x0D0D, 0xFFFF }, { 0x0020, 0x0021, 0x0A0B, 0x061F, 0xFFFF }, { 0x0113, 0x0217, 0xFFFF }, { 0x0116, 0x031E,
	  0x0B0E, 0x0405, 0xFFFF }, { 0x0022, 0x0204, 0x050A, 0x0023, 0xFFFF }, { 0x0111, 0x0319, 0x0809, 0x170F, 0xFFFF }, {
	  0x0303, 0x0215, 0x0607, 0xFFFF }, { 0x0030, 0x0114, 0x0408, 0x0031, 0x0201, 0x051D, 0xFFFF }, { 0x0100, 0x0024, 0x0306,
	  0x0025, 0x041B, 0x0E0D, 0xFFFF }, { 0x021A, 0x0121, 0x0B0B, 0x071F, 0xFFFF }, { 0x0213, 0x0317, 0xFFFF }, { 0x0112,
	  0x0505, 0xFFFF }, { 0x0026, 0x070C, 0x0123, 0x0027, 0xFFFF }, { 0x0211, 0x0909, 0xFFFF }, { 0x0110, 0x0315, 0x0707,
	  0x0419, 0x180F, 0xFFFF }, { 0x0218, 0x0131, 0x0301, 0x0403, 0x061D, 0xFFFF }, { 0x0032, 0x0202, 0x0033, 0x0125, 0x051B,
	  0x0F0D, 0xFFFF }, { 0x0028, 0x031C, 0x0221, 0x0029, 0xFFFF }, { 0x0120, 0x0313, 0x0C0B, 0x081F, 0xFFFF }, { 0x0605,
	  0x0417, 0xFFFF }, { 0x0216, 0x041E, 0x0C0E, 0x0223, 0x0127, 0xFFFF }, { 0x0122, 0x0304, 0x060A, 0x0311, 0x0A09, 0xFFFF
	  }, { 0x0519, 0x190F, 0xFFFF }, { 0x002A, 0x0231, 0x0503, 0x0415, 0x0807, 0x002B, 0x071D, 0xFFFF }, { 0x0130, 0x0214,
	  0x0508, 0x0401, 0x0133, 0x0225, 0x061B, 0xFFFF }, { 0x0200, 0x0124, 0x0406, 0x0321, 0x0129, 0x100D, 0xFFFF }, { 0x031A,
	  0x0D0B, 0x091F, 0xFFFF }, { 0x0413, 0x0705, 0x0517, 0xFFFF }, { 0x0212, 0x0034, 0x0323, 0x0035, 0x0227, 0xFFFF }, {
	  0x0126, 0x080C, 0x0B09, 0xFFFF }, { 0x0411, 0x0619, 0x1A0F, 0xFFFF }, { 0x0210, 0x0331, 0x0603, 0x0515, 0x0907, 0x012B,
	  0xFFFF }, { 0x0318, 0x002C, 0x0501, 0x0233, 0x0325, 0x071B, 0x002D, 0x081D, 0xFFFF }, { 0x0132, 0x0302, 0x0229, 0x110D,
	  0xFFFF }, { 0x0128, 0x041C, 0x0421, 0x0E0B, 0x0A1F, 0xFFFF }, { 0x0220, 0x0513, 0x0617, 0xFFFF }, { 0x0135, 0x0805,
	  0x0327, 0xFFFF }, { 0x0316, 0x051E, 0x0D0E, 0x0423, 0xFFFF }, { 0x0222, 0x0404, 0x070A, 0x0511, 0x0719, 0x0C09, 0x1B0F,
	  0xFFFF }, { 0x0703, 0x0615, 0x0A07, 0x022B, 0xFFFF }, { 0x012A, 0x0431, 0x0601, 0x0333, 0x012D, 0x091D, 0xFFFF }, {
	  0x0230, 0x0314, 0x0036, 0x0608, 0x0425, 0x0037, 0x0329, 0x081B, 0x120D, 0xFFFF }, { 0x0300, 0x0224, 0x0506, 0x0521,
	  0x0F0B, 0x0B1F, 0xFFFF }, { 0x041A, 0x0613, 0x0717, 0xFFFF }, { 0x0235, 0x0905, 0xFFFF }, { 0x0312, 0x0134, 0x0523,
	  0x0427, 0xFFFF }, { 0x0226, 0x090C, 0x002E, 0x0611, 0x0D09, 0x002F, 0xFFFF }, { 0x0715, 0x0B07, 0x0819, 0x032B, 0x1C0F,
	  0xFFFF }, { 0x0310, 0x0531, 0x0701, 0x0803, 0x022D, 0x0A1D, 0xFFFF }, { 0x0418, 0x012C, 0x0433, 0x0525, 0x0137, 0x091B,
	  0x130D, 0xFFFF }, { 0x0232, 0x0402, 0x0621, 0x0429, 0xFFFF }, { 0x0228, 0x051C, 0x0713, 0x100B, 0x0C1F, 0xFFFF }, {
	  0x0320, 0x0335, 0x0A05, 0x0817, 0xFFFF }, { 0x0623, 0x0527, 0xFFFF }, { 0x0416, 0x061E, 0x0E0E, 0x0711, 0x0E09, 0x012F,
	  0xFFFF }, { 0x0322, 0x0504, 0x080A, 0x0919, 0x1D0F, 0xFFFF }, { 0x0631, 0x0903, 0x0815, 0x0C07, 0x042B, 0x032D, 0x0B1D,
	  0xFFFF }, { 0x022A, 0x0801, 0x0533, 0x0625, 0x0237, 0x0A1B, 0xFFFF }, { 0x0330, 0x0414, 0x0136, 0x0708, 0x0721, 0x0529,
	  0x140D, 0xFFFF }, { 0x0400, 0x0324, 0x0606, 0x0038, 0x0039, 0x110B, 0x0D1F, 0xFFFF }, { 0x051A, 0x0813, 0x0B05, 0x0917,
	  0xFFFF }, { 0x0723, 0x0435, 0x0627, 0xFFFF }, { 0x0412, 0x0234, 0x0F09, 0x022F, 0xFFFF }, { 0x0326, 0x0A0C, 0x012E,
	  0x0811, 0x0A19, 0x1E0F, 0xFFFF }, { 0x0731, 0x0A03, 0x0915, 0x0D07, 0x052B, 0xFFFF }, { 0x0410, 0x0901, 0x0633, 0x0725,
	  0x0337, 0x0B1B, 0x042D, 0x0C1D, 0xFFFF }, { 0x0518, 0x022C, 0x0629, 0x150D, 0xFFFF }, { 0x0332, 0x0502, 0x0821, 0x0139,
	  0x120B, 0x0E1F, 0xFFFF }, { 0x0328, 0x061C, 0x0913, 0x0A17, 0xFFFF }, { 0x0420, 0x0535, 0x0C05, 0x0727, 0xFFFF }, {
	  0x0823, 0x032F, 0xFFFF }, { 0x0516, 0x071E, 0x0F0E, 0x0911, 0x0B19, 0x1009, 0x1F0F, 0xFFFF }, { 0x0422, 0x0604, 0x090A,
	  0x0B03, 0x0A15, 0x0E07, 0x062B, 0xFFFF }, { 0x0831, 0x0A01, 0x0733, 0x052D, 0x0D1D, 0xFFFF }, { 0x032A, 0x0825, 0x0437,
	  0x0729, 0x0C1B, 0x160D, 0xFFFF }, { 0x0430, 0x0514, 0x0236, 0x0808, 0x0921, 0x0239, 0x130B, 0x0F1F, 0xFFFF }, { 0x0500,
	  0x0424, 0x0706, 0x0138, 0x0A13, 0x0B17, 0xFFFF }, { 0x061A, 0x0635, 0x0D05, 0xFFFF }, { 0x0923, 0x0827, 0xFFFF }, {
	  0x0512, 0x0334, 0x003A, 0x0A11, 0x1109, 0x003B, 0x042F, 0xFFFF }, { 0x0426, 0x0B0C, 0x022E, 0x0B15, 0x0F07, 0x0C19,
	  0x072B, 0xFFFF }, { 0x0931, 0x0B01, 0x0C03, 0x062D, 0x0E1D, 0xFFFF }, { 0x0510, 0x0833, 0x0925, 0x0537, 0x0D1B, 0x170D,
	  0xFFFF }, { 0x0618, 0x032C, 0x0A21, 0x0339, 0x0829, 0xFFFF }, { 0x0432, 0x0602, 0x0B13, 0x140B, 0x101F, 0xFFFF }, {
	  0x0428, 0x071C, 0x0735, 0x0E05, 0x0C17, 0xFFFF }, { 0x0520, 0x0A23, 0x0927, 0xFFFF }, { 0x0B11, 0x1209, 0x013B, 0x052F,
	  0xFFFF }, { 0x0616, 0x081E, 0x0D19, 0xFFFF }, { 0x0522, 0x0704, 0x0A0A, 0x0A31, 0x0D03, 0x0C15, 0x1007, 0x082B, 0x072D,
	  0x0F1D, 0xFFFF }, { 0x0C01, 0x0933, 0x0A25, 0x0637, 0x0E1B, 0xFFFF }, { 0x042A, 0x0B21, 0x0929, 0x180D, 0xFFFF }, {
	  0x0530, 0x0614, 0x0336, 0x0908, 0x0439, 0x150B, 0x111F, 0xFFFF }, { 0x0600, 0x0524, 0x0806, 0x0238, 0x0C13, 0x0F05,
	  0x0D17, 0xFFFF }, { 0x071A, 0x0B23, 0x0835, 0x0A27, 0xFFFF }, { 0x1309, 0x023B, 0x062F, 0xFFFF }, { 0x0612, 0x0434,
	  0x013A, 0x0C11, 0x0E19, 0xFFFF }, { 0x0526, 0x0C0C, 0x032E, 0x0B31, 0x0E03, 0x0D15, 0x1107, 0x092B, 0xFFFF }, { 0x0D01,
	  0x0A33, 0x0B25, 0x0737, 0x0F1B, 0x082D, 0x101D, 0xFFFF }, { 0x0610, 0x0A29, 0x190D, 0xFFFF }, { 0x0718, 0x042C, 0x0C21,
	  0x0539, 0x160B, 0x121F, 0xFFFF }, { 0x0532, 0x0702, 0x0D13, 0x0E17, 0xFFFF }, { 0x0528, 0x081C, 0x0935, 0x1005, 0x0B27,
	  0xFFFF }, { 0x0620, 0x0C23, 0x033B, 0x072F, 0xFFFF }, { 0x0D11, 0x0F19, 0x1409, 0xFFFF }, { 0x0716, 0x003C, 0x091E,
	  0x0F03, 0x0E15, 0x1207, 0x0A2B, 0x003D, 0xFFFF }, { 0x0622, 0x0804, 0x0B0A, 0x0C31, 0x0E01, 0x0B33, 0x092D, 0x111D,
	  0xFFFF }, { 0x0C25, 0x0837, 0x0B29, 0x101B, 0x1A0D, 0xFFFF }, { 0x052A, 0x0D21, 0x0639, 0x170B, 0x131F, 0xFFFF }, {
	  0x0630, 0x0714, 0x0436, 0x0A08, 0x0E13, 0x0F17, 0xFFFF }, { 0x0700, 0x0624, 0x0906, 0x0338, 0x0A35, 0x1105, 0xFFFF }, {
	  0x081A, 0x0D23, 0x0C27, 0xFFFF }, { 0x0E11, 0x1509, 0x043B, 0x082F, 0xFFFF }, { 0x0712, 0x0534, 0x023A, 0x0F15, 0x1307,
	  0x1019, 0x0B2B, 0x013D, 0xFFFF }, { 0x0626, 0x0D0C, 0x042E, 0x0D31, 0x0F01, 0x1003, 0x0A2D, 0x121D, 0xFFFF }, { 0x0C33,
	  0x0D25, 0x0937, 0x111B, 0x1B0D, 0xFFFF }, { 0x0710, 0x0E21, 0x0739, 0x0C29, 0xFFFF }, { 0x0818, 0x052C, 0x0F13, 0x180B,
	  0x141F, 0xFFFF }, { 0x0632, 0x0802, 0x0B35, 0x1205, 0x1017, 0xFFFF }, { 0x0628, 0x091C, 0x0E23, 0x0D27, 0xFFFF }, {
	  0x0720, 0x0F11, 0x1609, 0x053B, 0x092F, 0xFFFF }, { 0x1119, 0x023D, 0xFFFF }, { 0x0816, 0x013C, 0x0A1E, 0x0E31, 0x1103,
	  0x1015, 0x1407, 0x0C2B, 0x0B2D, 0x131D, 0xFFFF }, { 0x0722, 0x0904, 0x0C0A, 0x1001, 0x0D33, 0x0E25, 0x0A37, 0x121B,
	  0xFFFF }, { 0x0F21, 0x0D29, 0x1C0D, 0xFFFF }, { 0x062A, 0x0839, 0x190B, 0x151F, 0xFFFF }, { 0x0730, 0x0814, 0x0536,
	  0x0B08, 0x1013, 0x1305, 0x1117, 0xFFFF }, { 0x0800, 0x0724, 0x0A06, 0x0438, 0x0F23, 0x0C35, 0x0E27, 0xFFFF }, { 0x091A,
	  0x1709, 0x063B, 0x0A2F, 0xFFFF }, { 0x1011, 0x1219, 0x033D, 0xFFFF }, { 0x0812, 0x0634, 0x033A, 0x0F31, 0x1203, 0x1115,
	  0x1507, 0x0D2B, 0xFFFF }, { 0x0726, 0x0E0C, 0x052E, 0x1101, 0x0E33, 0x0F25, 0x0B37, 0x131B, 0x0C2D, 0x141D, 0xFFFF }, {
	  0x0E29, 0x1D0D, 0xFFFF }, { 0x0810, 0x1021, 0x0939, 0x1A0B, 0x161F, 0xFFFF }, { 0x0918, 0x062C, 0x1113, 0x1217, 0xFFFF
	  }, { 0x0732, 0x0902, 0x0D35, 0x1405, 0x0F27, 0xFFFF }, { 0x0728, 0x0A1C, 0x1023, 0x073B, 0x0B2F, 0xFFFF }, { 0x0820,
	  0x1111, 0x1319, 0x1809, 0xFFFF }, { 0x1303, 0x1215, 0x1607, 0x0E2B, 0x043D, 0xFFFF }, { 0x0916, 0x023C, 0x0B1E, 0x1031,
	  0x1201, 0x0F33, 0x0D2D, 0x151D, 0xFFFF }, { 0x0822, 0x0A04, 0x0D0A, 0x1025, 0x0C37, 0x0F29, 0x141B, 0x1E0D, 0xFFFF }, {
	  0x1121, 0x0A39, 0x1B0B, 0x171F, 0xFFFF }, { 0x072A, 0x1213, 0x1317, 0xFFFF }, { 0x0830, 0x0914, 0x0636, 0x0C08, 0x0E35,
	  0x1505, 0xFFFF }, { 0x0900, 0x0824, 0x0B06, 0x0538, 0x1123, 0x1027, 0xFFFF }, { 0x0A1A, 0x1211, 0x1909, 0x083B, 0x0C2F,
	  0xFFFF }, { 0x1315, 0x1707, 0x1419, 0x0F2B, 0x053D, 0xFFFF }, { 0x0912, 0x0734, 0x043A, 0x1131, 0x1301, 0x1403, 0x0E2D,
	  0x161D, 0xFFFF }, { 0x0826, 0x0F0C, 0x062E, 0x1033, 0x1125, 0x0D37, 0x151B, 0x1F0D, 0xFFFF }, { 0x1221, 0x0B39, 0x1029,
	  0xFFFF }, { 0x0910, 0x1313, 0x1C0B, 0x181F, 0xFFFF }, { 0x0A18, 0x072C, 0x0F35, 0x1605, 0x1417, 0xFFFF }, { 0x0832,
	  0x0A02, 0x1223, 0x1127, 0xFFFF }, { 0x0828, 0x0B1C, 0x1311, 0x1A09, 0x093B, 0x0D2F, 0xFFFF }, { 0x0920, 0x1519, 0x063D,
	  0xFFFF }, { 0x1231, 0x1503, 0x1415, 0x1807, 0x102B, 0x0F2D, 0x171D, 0xFFFF }, { 0x0A16, 0x033C, 0x0C1E, 0x1401, 0x1133,
	  0x1225, 0x0E37, 0x161B, 0xFFFF }, { 0x0922, 0x0B04, 0x0E0A, 0x1321, 0x1129, 0xFFFF }, { 0x0C39, 0x1D0B, 0x191F, 0xFFFF
	  }, { 0x082A, 0x1413, 0x1705, 0x1517, 0xFFFF }, { 0x0930, 0x0A14, 0x0736, 0x0D08, 0x1323, 0x1035, 0x1227, 0xFFFF }, {
	  0x0A00, 0x0924, 0x0C06, 0x0638, 0x1B09, 0x0A3B, 0x0E2F, 0xFFFF }, { 0x0B1A, 0x1411, 0x1619, 0x073D, 0xFFFF }, { 0x1331,
	  0x1603, 0x1515, 0x1907, 0x112B, 0xFFFF }, { 0x0A12, 0x0834, 0x053A, 0x1501, 0x1233, 0x1325, 0x0F37, 0x171B, 0x102D,
	  0x181D, 0xFFFF }, { 0x0926, 0x072E, 0x1229, 0xFFFF }, { 0x1421, 0x0D39, 0x1E0B, 0x1A1F, 0xFFFF }, { 0x0A10, 0x1513,
	  0x1617, 0xFFFF }, { 0x0B18, 0x082C, 0x1135, 0x1805, 0x1327, 0xFFFF }, { 0x0932, 0x0B02, 0x1423, 0x0B3B, 0x0F2F, 0xFFFF
	  }, { 0x0928, 0x0C1C, 0x1511, 0x1719, 0x1C09, 0xFFFF }, { 0x0A20, 0x1703, 0x1615, 0x1A07, 0x122B, 0x083D, 0xFFFF }, {
	  0x1431, 0x1601, 0x1333, 0x112D, 0x191D, 0xFFFF }, { 0x0B16, 0x043C, 0x0D1E, 0x1425, 0x1037, 0x1329, 0x181B, 0xFFFF }, {
	  0x0A22, 0x0C04, 0x0F0A, 0x1521, 0x0E39, 0x1F0B, 0x1B1F, 0xFFFF }, { 0x1613, 0x1717, 0xFFFF }, { 0x092A, 0x1235, 0x1905,
	  0xFFFF }, { 0x0A30, 0x0B14, 0x0836, 0x0E08, 0x1523, 0x1427, 0xFFFF }, { 0x0B00, 0x0A24, 0x0D06, 0x0738, 0x1611, 0x1D09,
	  0x0C3B, 0x102F, 0xFFFF }, { 0x0C1A, 0x1715, 0x1B07, 0x1819, 0x132B, 0x093D, 0xFFFF }, { 0x1531, 0x1701, 0x1803, 0x122D,
	  0x1A1D, 0xFFFF }, { 0x0B12, 0x0934, 0x063A, 0x1433, 0x1525, 0x1137, 0x191B, 0xFFFF }, { 0x0A26, 0x003E, 0x082E, 0x1621,
	  0x0F39, 0x1429, 0x003F, 0xFFFF }, { 0x1713, 0x1C1F, 0xFFFF }, { 0x0B10, 0x1335, 0x1A05, 0x1817, 0xFFFF }, { 0x0C18,
	  0x092C, 0x1623, 0x1527, 0xFFFF }, { 0x0A32, 0x0C02, 0x1711, 0x1E09, 0x0D3B, 0x112F, 0xFFFF }, { 0x0A28, 0x0D1C, 0x1919,
	  0x0A3D, 0xFFFF }, { 0x0B20, 0x1631, 0x1903, 0x1815, 0x1C07, 0x142B, 0x132D, 0x1B1D, 0xFFFF }, { 0x1801, 0x1533, 0x1625,
	  0x1237, 0x1A1B, 0xFFFF }, { 0x0C16, 0x053C, 0x0E1E, 0x1721, 0x1529, 0x013F, 0xFFFF }, { 0x0B22, 0x0D04, 0x1039, 0x1D1F,
	  0xFFFF }, { 0x1813, 0x1B05, 0x1917, 0xFFFF }, { 0x0A2A, 0x1723, 0x1435, 0x1627, 0xFFFF }, { 0x0B30, 0x0C14, 0x0936,
	  0x0F08, 0x1F09, 0x0E3B, 0x122F, 0xFFFF }, { 0x0C00, 0x0B24, 0x0E06, 0x0838, 0x1811, 0x1A19, 0x0B3D, 0xFFFF }, { 0x0D1A,
	  0x1731, 0x1A03, 0x1915, 0x1D07, 0x152B, 0xFFFF }, { 0x1901, 0x1633, 0x1725, 0x1337, 0x1B1B, 0x142D, 0x1C1D, 0xFFFF }, {
	  0x0C12, 0x0A34, 0x073A, 0x1629, 0x023F, 0xFFFF }, { 0x0B26, 0x013E, 0x092E, 0x1821, 0x1139, 0x1E1F, 0xFFFF }, { 0x1913,
	  0x1A17, 0xFFFF }, { 0x0C10, 0x1535, 0x1C05, 0x1727, 0xFFFF }, { 0x0D18, 0x0A2C, 0x1823, 0x0F3B, 0x132F, 0xFFFF }, {
	  0x0B32, 0x0D02, 0x1911, 0x1B19, 0xFFFF }, { 0x0B28, 0x0E1C, 0x1B03, 0x1A15, 0x1E07, 0x162B, 0x0C3D, 0xFFFF }, { 0x0C20,
	  0x1831, 0x1A01, 0x1733, 0x152D, 0x1D1D, 0xFFFF }, { 0x1825, 0x1437, 0x1729, 0x1C1B, 0x033F, 0xFFFF }, { 0x0D16, 0x063C,
	  0x0F1E, 0x1921, 0x1239, 0x1F1F, 0xFFFF }, { 0x0C22, 0x0E04, 0x1A13, 0x1B17, 0xFFFF }, { 0x1635, 0x1D05, 0xFFFF }, {
	  0x0B2A, 0x1923, 0x1827, 0xFFFF }, { 0x0C30, 0x0D14, 0x0A36, 0x1A11, 0x103B, 0x142F, 0xFFFF }, { 0x0D00, 0x0C24, 0x0F06,
	  0x0938, 0x1B15, 0x1F07, 0x1C19, 0x172B, 0x0D3D, 0xFFFF }, { 0x0E1A, 0x1931, 0x1B01, 0x1C03, 0x162D, 0x1E1D, 0xFFFF }, {
	  0x1833, 0x1925, 0x1537, 0x1D1B, 0xFFFF }, { 0x0D12, 0x0B34, 0x083A, 0x1A21, 0x1339, 0x1829, 0x043F, 0xFFFF }, { 0x0C26,
	  0x023E, 0x0A2E, 0x1B13, 0xFFFF }, { 0x1735, 0x1E05, 0x1C17, 0xFFFF }, { 0x0D10, 0x1A23, 0x1927, 0xFFFF }, { 0x0E18,
	  0x0B2C, 0x1B11, 0x113B, 0x152F, 0xFFFF }, { 0x0C32, 0x0E02, 0x1D19, 0x0E3D, 0xFFFF }, { 0x0C28, 0x0F1C, 0x1A31, 0x1D03,
	  0x1C15, 0x182B, 0x172D, 0x1F1D, 0xFFFF }, { 0x0D20, 0x1C01, 0x1933, 0x1A25, 0x1637, 0x1E1B, 0xFFFF }, { 0x1B21, 0x1929,
	  0x053F, 0xFFFF }, { 0x0E16, 0x073C, 0x1439, 0xFFFF }, { 0x0D22, 0x0F04, 0x1C13, 0x1F05, 0x1D17, 0xFFFF }, { 0x1B23,
	  0x1835, 0x1A27, 0xFFFF }, { 0x0C2A, 0x123B, 0x162F, 0xFFFF }, { 0x0D30, 0x0E14, 0x0B36, 0x1C11, 0x1E19, 0x0F3D, 0xFFFF
	  }, { 0x0E00, 0x0D24, 0x0A38, 0x1B31, 0x1E03, 0x1D15, 0x192B, 0xFFFF }, { 0x0F1A, 0x1D01, 0x1A33, 0x1B25, 0x1737, 0x1F1B,
	  0x182D, 0xFFFF }, { 0x1A29, 0x063F, 0xFFFF }, { 0x0E12, 0x0C34, 0x093A, 0x1C21, 0x1539, 0xFFFF }, { 0x0D26, 0x033E,
	  0x0B2E, 0x1D13, 0x1E17, 0xFFFF }, { 0x1935, 0x1B27, 0xFFFF }, { 0x0E10, 0x1C23, 0x133B, 0x172F, 0xFFFF }, { 0x0F18,
	  0x0C2C, 0x1D11, 0x1F19, 0xFFFF }, { 0x0D32, 0x0F02, 0x1F03, 0x1E15, 0x1A2B, 0x103D, 0xFFFF }, { 0x0D28, 0x1C31, 0x1E01,
	  0x1B33, 0x192D, 0xFFFF }, { 0x0E20, 0x1C25, 0x1837, 0x1B29, 0x073F, 0xFFFF }, { 0x1D21, 0x1639, 0xFFFF }, { 0x0F16,
	  0x083C, 0x1E13, 0x1F17, 0xFFFF }, { 0x0E22, 0x1A35, 0xFFFF }, { 0x1D23, 0x1C27, 0xFFFF }, { 0x0D2A, 0x1E11, 0x143B,
	  0x182F, 0xFFFF }, { 0x0E30, 0x0F14, 0x0C36, 0x1F15, 0x1B2B, 0x113D, 0xFFFF }, { 0x0F00, 0x0E24, 0x0B38, 0x1D31, 0x1F01,
	  0x1A2D, 0xFFFF }, { 0x1C33, 0x1D25, 0x1937, 0xFFFF }, { 0x1E21, 0x1739, 0x1C29, 0x083F, 0xFFFF }, { 0x0F12, 0x0D34,
	  0x0A3A, 0x1F13, 0xFFFF }, { 0x0E26, 0x043E, 0x0C2E, 0x1B35, 0xFFFF }, { 0x1E23, 0x1D27, 0xFFFF }, { 0x0F10, 0x1F11,
	  0x153B, 0x192F, 0xFFFF }, { 0x0D2C, 0x123D, 0xFFFF },
   };

   struct etc1_block
   {
	  // big endian uint64:
	  // bit ofs:  56  48  40  32  24  16   8   0
	  // byte ofs: b0, b1, b2, b3, b4, b5, b6, b7
	  union
	  {
		 uint64 m_uint64;
		 uint8 m_bytes[8];
	  };

	  uint8 m_low_color[2];
	  uint8 m_high_color[2];

	  enum { cNumSelectorBytes = 4 };
	  uint8 m_selectors[cNumSelectorBytes];

	  inline void clear()
	  {
		 zero_this(this);
	  }

	  inline uint get_byte_bits(uint ofs, uint num) const
	  {
		 RG_ETC1_ASSERT((ofs + num) <= 64U);
		 RG_ETC1_ASSERT(num && (num <= 8U));
		 RG_ETC1_ASSERT((ofs >> 3) == ((ofs + num - 1) >> 3));
		 const uint byte_ofs = 7 - (ofs >> 3);
		 const uint byte_bit_ofs = ofs & 7;
		 return (m_bytes[byte_ofs] >> byte_bit_ofs) & ((1 << num) - 1);
	  }

	  inline void set_byte_bits(uint ofs, uint num, uint bits)
	  {
		 RG_ETC1_ASSERT((ofs + num) <= 64U);
		 RG_ETC1_ASSERT(num && (num < 32U));
		 RG_ETC1_ASSERT((ofs >> 3) == ((ofs + num - 1) >> 3));
		 RG_ETC1_ASSERT(bits < (1U << num));
		 const uint byte_ofs = 7 - (ofs >> 3);
		 const uint byte_bit_ofs = ofs & 7;
		 const uint mask = (1 << num) - 1;
		 m_bytes[byte_ofs] &= ~(mask << byte_bit_ofs);
		 m_bytes[byte_ofs] |= (bits << byte_bit_ofs);
	  }

	  // false = left/right subblocks
	  // true = upper/lower subblocks
	  inline bool get_flip_bit() const
	  {
		 return (m_bytes[3] & 1) != 0;
	  }

	  inline void set_flip_bit(bool flip)
	  {
		 m_bytes[3] &= ~1;
		 m_bytes[3] |= static_cast<uint8>(flip);
	  }

	  inline bool get_diff_bit() const
	  {
		 return (m_bytes[3] & 2) != 0;
	  }

	  inline void set_diff_bit(bool diff)
	  {
		 m_bytes[3] &= ~2;
		 m_bytes[3] |= (static_cast<uint>(diff) << 1);
	  }

	  // Returns intensity modifier table (0-7) used by subblock subblock_id.
	  // subblock_id=0 left/top (CW 1), 1=right/bottom (CW 2)
	  inline uint get_inten_table(uint subblock_id) const
	  {
		 RG_ETC1_ASSERT(subblock_id < 2);
		 const uint ofs = subblock_id ? 2 : 5;
		 return (m_bytes[3] >> ofs) & 7;
	  }

	  // Sets intensity modifier table (0-7) used by subblock subblock_id (0 or 1)
	  inline void set_inten_table(uint subblock_id, uint t)
	  {
		 RG_ETC1_ASSERT(subblock_id < 2);
		 RG_ETC1_ASSERT(t < 8);
		 const uint ofs = subblock_id ? 2 : 5;
		 m_bytes[3] &= ~(7 << ofs);
		 m_bytes[3] |= (t << ofs);
	  }

	  // Returned selector value ranges from 0-3 and is a direct index into g_etc1_inten_tables.
	  inline uint get_selector(uint x, uint y) const
	  {
		 RG_ETC1_ASSERT((x | y) < 4);

		 const uint bit_index = x * 4 + y;
		 const uint byte_bit_ofs = bit_index & 7;
		 const uint8 *p = &m_bytes[7 - (bit_index >> 3)];
		 const uint lsb = (p[0] >> byte_bit_ofs) & 1;
		 const uint msb = (p[-2] >> byte_bit_ofs) & 1;
		 const uint val = lsb | (msb << 1);

		 return g_etc1_to_selector_index[val];
	  }

	  // Selector "val" ranges from 0-3 and is a direct index into g_etc1_inten_tables.
	  inline void set_selector(uint x, uint y, uint val)
	  {
		 RG_ETC1_ASSERT((x | y | val) < 4);
		 const uint bit_index = x * 4 + y;

		 uint8 *p = &m_bytes[7 - (bit_index >> 3)];

		 const uint byte_bit_ofs = bit_index & 7;
		 const uint mask = 1 << byte_bit_ofs;

		 const uint etc1_val = g_selector_index_to_etc1[val];

		 const uint lsb = etc1_val & 1;
		 const uint msb = etc1_val >> 1;

		 p[0] &= ~mask;
		 p[0] |= (lsb << byte_bit_ofs);

		 p[-2] &= ~mask;
		 p[-2] |= (msb << byte_bit_ofs);
	  }

	  inline void set_base4_color(uint idx, uint16 c)
	  {
		 if (idx)
		 {
			set_byte_bits(cETC1AbsColor4R2BitOffset, 4, (c >> 8) & 15);
			set_byte_bits(cETC1AbsColor4G2BitOffset, 4, (c >> 4) & 15);
			set_byte_bits(cETC1AbsColor4B2BitOffset, 4, c & 15);
		 }
		 else
		 {
			set_byte_bits(cETC1AbsColor4R1BitOffset, 4, (c >> 8) & 15);
			set_byte_bits(cETC1AbsColor4G1BitOffset, 4, (c >> 4) & 15);
			set_byte_bits(cETC1AbsColor4B1BitOffset, 4, c & 15);
		 }
	  }

	  inline uint16 get_base4_color(uint idx) const
	  {
		 uint r, g, b;
		 if (idx)
		 {
			r = get_byte_bits(cETC1AbsColor4R2BitOffset, 4);
			g = get_byte_bits(cETC1AbsColor4G2BitOffset, 4);
			b = get_byte_bits(cETC1AbsColor4B2BitOffset, 4);
		 }
		 else
		 {
			r = get_byte_bits(cETC1AbsColor4R1BitOffset, 4);
			g = get_byte_bits(cETC1AbsColor4G1BitOffset, 4);
			b = get_byte_bits(cETC1AbsColor4B1BitOffset, 4);
		 }
		 return static_cast<uint16>(b | (g << 4U) | (r << 8U));
	  }

	  inline void set_base5_color(uint16 c)
	  {
		 set_byte_bits(cETC1BaseColor5RBitOffset, 5, (c >> 10) & 31);
		 set_byte_bits(cETC1BaseColor5GBitOffset, 5, (c >> 5) & 31);
		 set_byte_bits(cETC1BaseColor5BBitOffset, 5, c & 31);
	  }

	  inline uint16 get_base5_color() const
	  {
		 const uint r = get_byte_bits(cETC1BaseColor5RBitOffset, 5);
		 const uint g = get_byte_bits(cETC1BaseColor5GBitOffset, 5);
		 const uint b = get_byte_bits(cETC1BaseColor5BBitOffset, 5);
		 return static_cast<uint16>(b | (g << 5U) | (r << 10U));
	  }

	  void set_delta3_color(uint16 c)
	  {
		 set_byte_bits(cETC1DeltaColor3RBitOffset, 3, (c >> 6) & 7);
		 set_byte_bits(cETC1DeltaColor3GBitOffset, 3, (c >> 3) & 7);
		 set_byte_bits(cETC1DeltaColor3BBitOffset, 3, c & 7);
	  }

	  inline uint16 get_delta3_color() const
	  {
		 const uint r = get_byte_bits(cETC1DeltaColor3RBitOffset, 3);
		 const uint g = get_byte_bits(cETC1DeltaColor3GBitOffset, 3);
		 const uint b = get_byte_bits(cETC1DeltaColor3BBitOffset, 3);
		 return static_cast<uint16>(b | (g << 3U) | (r << 6U));
	  }

	  // Base color 5
	  static uint16 pack_color5(const color_quad_u8& color, bool scaled, uint bias = 127U);
	  static uint16 pack_color5(uint r, uint g, uint b, bool scaled, uint bias = 127U);

	  static color_quad_u8 unpack_color5(uint16 packed_color5, bool scaled, uint alpha = 255U);
	  static void unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color, bool scaled);

	  static bool unpack_color5(color_quad_u8& result, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha = 255U);
	  static bool unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha = 255U);

	  // Delta color 3
	  // Inputs range from -4 to 3 (cETC1ColorDeltaMin to cETC1ColorDeltaMax)
	  static uint16 pack_delta3(int r, int g, int b);

	  // Results range from -4 to 3 (cETC1ColorDeltaMin to cETC1ColorDeltaMax)
	  static void unpack_delta3(int& r, int& g, int& b, uint16 packed_delta3);

	  // Abs color 4
	  static uint16 pack_color4(const color_quad_u8& color, bool scaled, uint bias = 127U);
	  static uint16 pack_color4(uint r, uint g, uint b, bool scaled, uint bias = 127U);

	  static color_quad_u8 unpack_color4(uint16 packed_color4, bool scaled, uint alpha = 255U);
	  static void unpack_color4(uint& r, uint& g, uint& b, uint16 packed_color4, bool scaled);

	  // subblock colors
	  static void get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint table_idx);
	  static bool get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint16 packed_delta3, uint table_idx);
	  static void get_abs_subblock_colors(color_quad_u8* pDst, uint16 packed_color4, uint table_idx);

	  static inline void unscaled_to_scaled_color(color_quad_u8& dst, const color_quad_u8& src, bool color4)
	  {
		 if (color4)
		 {
			dst.r = src.r | (src.r << 4);
			dst.g = src.g | (src.g << 4);
			dst.b = src.b | (src.b << 4);
		 }
		 else
		 {
			dst.r = (src.r >> 2) | (src.r << 3);
			dst.g = (src.g >> 2) | (src.g << 3);
			dst.b = (src.b >> 2) | (src.b << 3);
		 }
		 dst.a = src.a;
	  }
   };

   // Returns pointer to sorted array.
   template<typename T, typename Q>
   T* indirect_radix_sort(uint num_indices, T* pIndices0, T* pIndices1, const Q* pKeys, uint key_ofs, uint key_size, bool init_indices)
   {
	  RG_ETC1_ASSERT((key_ofs >= 0) && (key_ofs < sizeof(T)));
	  RG_ETC1_ASSERT((key_size >= 1) && (key_size <= 4));

	  if (init_indices)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + (num_indices >> 1) * 2;
		 uint i;
		 for (i = 0; p != q; p += 2, i += 2)
		 {
			p[0] = static_cast<T>(i);
			p[1] = static_cast<T>(i + 1);
		 }

		 if (num_indices & 1)
			*p = static_cast<T>(i);
	  }

	  uint hist[256 * 4];

	  memset(hist, 0, sizeof(hist[0]) * 256 * key_size);

#define RG_ETC1_GET_KEY(p) (*(const uint*)((const uint8*)(pKeys + *(p)) + key_ofs))
#define RG_ETC1_GET_KEY_FROM_INDEX(i) (*(const uint*)((const uint8*)(pKeys + (i)) + key_ofs))

	  if (key_size == 4)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + num_indices;
		 for ( ; p != q; p++)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[        key        & 0xFF]++;
			hist[256 + ((key >>  8) & 0xFF)]++;
			hist[512 + ((key >> 16) & 0xFF)]++;
			hist[768 + ((key >> 24) & 0xFF)]++;
		 }
	  }
	  else if (key_size == 3)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + num_indices;
		 for ( ; p != q; p++)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[        key        & 0xFF]++;
			hist[256 + ((key >>  8) & 0xFF)]++;
			hist[512 + ((key >> 16) & 0xFF)]++;
		 }
	  }
	  else if (key_size == 2)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + (num_indices >> 1) * 2;

		 for ( ; p != q; p += 2)
		 {
			const uint key0 = RG_ETC1_GET_KEY(p);
			const uint key1 = RG_ETC1_GET_KEY(p+1);

			hist[        key0         & 0xFF]++;
			hist[256 + ((key0 >>  8) & 0xFF)]++;

			hist[        key1        & 0xFF]++;
			hist[256 + ((key1 >>  8) & 0xFF)]++;
		 }

		 if (num_indices & 1)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[        key        & 0xFF]++;
			hist[256 + ((key >>  8) & 0xFF)]++;
		 }
	  }
	  else
	  {
		 RG_ETC1_ASSERT(key_size == 1);
		 if (key_size != 1)
			return NULL;

		 T* p = pIndices0;
		 T* q = pIndices0 + (num_indices >> 1) * 2;

		 for ( ; p != q; p += 2)
		 {
			const uint key0 = RG_ETC1_GET_KEY(p);
			const uint key1 = RG_ETC1_GET_KEY(p+1);

			hist[key0 & 0xFF]++;
			hist[key1 & 0xFF]++;
		 }

		 if (num_indices & 1)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[key & 0xFF]++;
		 }
	  }

	  T* pCur = pIndices0;
	  T* pNew = pIndices1;

	  for (uint pass = 0; pass < key_size; pass++)
	  {
		 const uint* pHist = &hist[pass << 8];

		 uint offsets[256];

		 uint cur_ofs = 0;
		 for (uint i = 0; i < 256; i += 2)
		 {
			offsets[i] = cur_ofs;
			cur_ofs += pHist[i];

			offsets[i+1] = cur_ofs;
			cur_ofs += pHist[i+1];
		 }

		 const uint pass_shift = pass << 3;

		 T* p = pCur;
		 T* q = pCur + (num_indices >> 1) * 2;

		 for ( ; p != q; p += 2)
		 {
			uint index0 = p[0];
			uint index1 = p[1];

			uint c0 = (RG_ETC1_GET_KEY_FROM_INDEX(index0) >> pass_shift) & 0xFF;
			uint c1 = (RG_ETC1_GET_KEY_FROM_INDEX(index1) >> pass_shift) & 0xFF;

			if (c0 == c1)
			{
			   uint dst_offset0 = offsets[c0];

			   offsets[c0] = dst_offset0 + 2;

			   pNew[dst_offset0] = static_cast<T>(index0);
			   pNew[dst_offset0 + 1] = static_cast<T>(index1);
			}
			else
			{
			   uint dst_offset0 = offsets[c0]++;
			   uint dst_offset1 = offsets[c1]++;

			   pNew[dst_offset0] = static_cast<T>(index0);
			   pNew[dst_offset1] = static_cast<T>(index1);
			}
		 }

		 if (num_indices & 1)
		 {
			uint index = *p;
			uint c = (RG_ETC1_GET_KEY_FROM_INDEX(index) >> pass_shift) & 0xFF;

			uint dst_offset = offsets[c];
			offsets[c] = dst_offset + 1;

			pNew[dst_offset] = static_cast<T>(index);
		 }

		 T* t = pCur;
		 pCur = pNew;
		 pNew = t;
	  }

	  return pCur;
   }

#undef RG_ETC1_GET_KEY
#undef RG_ETC1_GET_KEY_FROM_INDEX

   uint16 etc1_block::pack_color5(const color_quad_u8& color, bool scaled, uint bias)
   {
	  return pack_color5(color.r, color.g, color.b, scaled, bias);
   }

   uint16 etc1_block::pack_color5(uint r, uint g, uint b, bool scaled, uint bias)
   {
	  if (scaled)
	  {
		 r = (r * 31U + bias) / 255U;
		 g = (g * 31U + bias) / 255U;
		 b = (b * 31U + bias) / 255U;
	  }

	  r = rg_etc1::minimum(r, 31U);
	  g = rg_etc1::minimum(g, 31U);
	  b = rg_etc1::minimum(b, 31U);

	  return static_cast<uint16>(b | (g << 5U) | (r << 10U));
   }

   color_quad_u8 etc1_block::unpack_color5(uint16 packed_color5, bool scaled, uint alpha)
   {
	  uint b = packed_color5 & 31U;
	  uint g = (packed_color5 >> 5U) & 31U;
	  uint r = (packed_color5 >> 10U) & 31U;

	  if (scaled)
	  {
		 b = (b << 3U) | (b >> 2U);
		 g = (g << 3U) | (g >> 2U);
		 r = (r << 3U) | (r >> 2U);
	  }

	  return color_quad_u8(cNoClamp, r, g, b, rg_etc1::minimum(alpha, 255U));
   }

   void etc1_block::unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color5, bool scaled)
   {
	  color_quad_u8 c(unpack_color5(packed_color5, scaled, 0));
	  r = c.r;
	  g = c.g;
	  b = c.b;
   }

   bool etc1_block::unpack_color5(color_quad_u8& result, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha)
   {
	  int dc_r, dc_g, dc_b;
	  unpack_delta3(dc_r, dc_g, dc_b, packed_delta3);

	  int b = (packed_color5 & 31U) + dc_b;
	  int g = ((packed_color5 >> 5U) & 31U) + dc_g;
	  int r = ((packed_color5 >> 10U) & 31U) + dc_r;

	  bool success = true;
	  if (static_cast<uint>(r | g | b) > 31U)
	  {
		 success = false;
		 r = rg_etc1::clamp<int>(r, 0, 31);
		 g = rg_etc1::clamp<int>(g, 0, 31);
		 b = rg_etc1::clamp<int>(b, 0, 31);
	  }

	  if (scaled)
	  {
		 b = (b << 3U) | (b >> 2U);
		 g = (g << 3U) | (g >> 2U);
		 r = (r << 3U) | (r >> 2U);
	  }

	  result.set_noclamp_rgba(r, g, b, rg_etc1::minimum(alpha, 255U));
	  return success;
   }

   bool etc1_block::unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha)
   {
	  color_quad_u8 result;
	  const bool success = unpack_color5(result, packed_color5, packed_delta3, scaled, alpha);
	  r = result.r;
	  g = result.g;
	  b = result.b;
	  return success;
   }

   uint16 etc1_block::pack_delta3(int r, int g, int b)
   {
	  RG_ETC1_ASSERT((r >= cETC1ColorDeltaMin) && (r <= cETC1ColorDeltaMax));
	  RG_ETC1_ASSERT((g >= cETC1ColorDeltaMin) && (g <= cETC1ColorDeltaMax));
	  RG_ETC1_ASSERT((b >= cETC1ColorDeltaMin) && (b <= cETC1ColorDeltaMax));
	  if (r < 0) r += 8;
	  if (g < 0) g += 8;
	  if (b < 0) b += 8;
	  return static_cast<uint16>(b | (g << 3) | (r << 6));
   }

   void etc1_block::unpack_delta3(int& r, int& g, int& b, uint16 packed_delta3)
   {
	  r = (packed_delta3 >> 6) & 7;
	  g = (packed_delta3 >> 3) & 7;
	  b = packed_delta3 & 7;
	  if (r >= 4) r -= 8;
	  if (g >= 4) g -= 8;
	  if (b >= 4) b -= 8;
   }

   uint16 etc1_block::pack_color4(const color_quad_u8& color, bool scaled, uint bias)
   {
	  return pack_color4(color.r, color.g, color.b, scaled, bias);
   }

   uint16 etc1_block::pack_color4(uint r, uint g, uint b, bool scaled, uint bias)
   {
	  if (scaled)
	  {
		 r = (r * 15U + bias) / 255U;
		 g = (g * 15U + bias) / 255U;
		 b = (b * 15U + bias) / 255U;
	  }

	  r = rg_etc1::minimum(r, 15U);
	  g = rg_etc1::minimum(g, 15U);
	  b = rg_etc1::minimum(b, 15U);

	  return static_cast<uint16>(b | (g << 4U) | (r << 8U));
   }

   color_quad_u8 etc1_block::unpack_color4(uint16 packed_color4, bool scaled, uint alpha)
   {
	  uint b = packed_color4 & 15U;
	  uint g = (packed_color4 >> 4U) & 15U;
	  uint r = (packed_color4 >> 8U) & 15U;

	  if (scaled)
	  {
		 b = (b << 4U) | b;
		 g = (g << 4U) | g;
		 r = (r << 4U) | r;
	  }

	  return color_quad_u8(cNoClamp, r, g, b, rg_etc1::minimum(alpha, 255U));
   }

   void etc1_block::unpack_color4(uint& r, uint& g, uint& b, uint16 packed_color4, bool scaled)
   {
	  color_quad_u8 c(unpack_color4(packed_color4, scaled, 0));
	  r = c.r;
	  g = c.g;
	  b = c.b;
   }

   void etc1_block::get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint table_idx)
   {
	  RG_ETC1_ASSERT(table_idx < cETC1IntenModifierValues);
	  const int *pInten_modifer_table = &g_etc1_inten_tables[table_idx][0];

	  uint r, g, b;
	  unpack_color5(r, g, b, packed_color5, true);

	  const int ir = static_cast<int>(r), ig = static_cast<int>(g), ib = static_cast<int>(b);

	  const int y0 = pInten_modifer_table[0];
	  pDst[0].set(ir + y0, ig + y0, ib + y0);

	  const int y1 = pInten_modifer_table[1];
	  pDst[1].set(ir + y1, ig + y1, ib + y1);

	  const int y2 = pInten_modifer_table[2];
	  pDst[2].set(ir + y2, ig + y2, ib + y2);

	  const int y3 = pInten_modifer_table[3];
	  pDst[3].set(ir + y3, ig + y3, ib + y3);
   }

   bool etc1_block::get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint16 packed_delta3, uint table_idx)
   {
	  RG_ETC1_ASSERT(table_idx < cETC1IntenModifierValues);
	  const int *pInten_modifer_table = &g_etc1_inten_tables[table_idx][0];

	  uint r, g, b;
	  bool success = unpack_color5(r, g, b, packed_color5, packed_delta3, true);

	  const int ir = static_cast<int>(r), ig = static_cast<int>(g), ib = static_cast<int>(b);

	  const int y0 = pInten_modifer_table[0];
	  pDst[0].set(ir + y0, ig + y0, ib + y0);

	  const int y1 = pInten_modifer_table[1];
	  pDst[1].set(ir + y1, ig + y1, ib + y1);

	  const int y2 = pInten_modifer_table[2];
	  pDst[2].set(ir + y2, ig + y2, ib + y2);

	  const int y3 = pInten_modifer_table[3];
	  pDst[3].set(ir + y3, ig + y3, ib + y3);

	  return success;
   }

   void etc1_block::get_abs_subblock_colors(color_quad_u8* pDst, uint16 packed_color4, uint table_idx)
   {
	  RG_ETC1_ASSERT(table_idx < cETC1IntenModifierValues);
	  const int *pInten_modifer_table = &g_etc1_inten_tables[table_idx][0];

	  uint r, g, b;
	  unpack_color4(r, g, b, packed_color4, true);

	  const int ir = static_cast<int>(r), ig = static_cast<int>(g), ib = static_cast<int>(b);

	  const int y0 = pInten_modifer_table[0];
	  pDst[0].set(ir + y0, ig + y0, ib + y0);

	  const int y1 = pInten_modifer_table[1];
	  pDst[1].set(ir + y1, ig + y1, ib + y1);

	  const int y2 = pInten_modifer_table[2];
	  pDst[2].set(ir + y2, ig + y2, ib + y2);

	  const int y3 = pInten_modifer_table[3];
	  pDst[3].set(ir + y3, ig + y3, ib + y3);
   }

   bool unpack_etc1_block(const void* pETC1_block, unsigned int* pDst_pixels_rgba, bool preserve_alpha)
   {
	  color_quad_u8* pDst = reinterpret_cast<color_quad_u8*>(pDst_pixels_rgba);
	  const etc1_block& block = *static_cast<const etc1_block*>(pETC1_block);

	  const bool diff_flag = block.get_diff_bit();
	  const bool flip_flag = block.get_flip_bit();
	  const uint table_index0 = block.get_inten_table(0);
	  const uint table_index1 = block.get_inten_table(1);

	  color_quad_u8 subblock_colors0[4];
	  color_quad_u8 subblock_colors1[4];
	  bool success = true;

	  if (diff_flag)
	  {
		 const uint16 base_color5 = block.get_base5_color();
		 const uint16 delta_color3 = block.get_delta3_color();
		 etc1_block::get_diff_subblock_colors(subblock_colors0, base_color5, table_index0);

		 if (!etc1_block::get_diff_subblock_colors(subblock_colors1, base_color5, delta_color3, table_index1))
			success = false;
	  }
	  else
	  {
		 const uint16 base_color4_0 = block.get_base4_color(0);
		 etc1_block::get_abs_subblock_colors(subblock_colors0, base_color4_0, table_index0);

		 const uint16 base_color4_1 = block.get_base4_color(1);
		 etc1_block::get_abs_subblock_colors(subblock_colors1, base_color4_1, table_index1);
	  }

	  if (preserve_alpha)
	  {
		 if (flip_flag)
		 {
			for (uint y = 0; y < 2; y++)
			{
			   pDst[0].set_rgb(subblock_colors0[block.get_selector(0, y)]);
			   pDst[1].set_rgb(subblock_colors0[block.get_selector(1, y)]);
			   pDst[2].set_rgb(subblock_colors0[block.get_selector(2, y)]);
			   pDst[3].set_rgb(subblock_colors0[block.get_selector(3, y)]);
			   pDst += 4;
			}

			for (uint y = 2; y < 4; y++)
			{
			   pDst[0].set_rgb(subblock_colors1[block.get_selector(0, y)]);
			   pDst[1].set_rgb(subblock_colors1[block.get_selector(1, y)]);
			   pDst[2].set_rgb(subblock_colors1[block.get_selector(2, y)]);
			   pDst[3].set_rgb(subblock_colors1[block.get_selector(3, y)]);
			   pDst += 4;
			}
		 }
		 else
		 {
			for (uint y = 0; y < 4; y++)
			{
			   pDst[0].set_rgb(subblock_colors0[block.get_selector(0, y)]);
			   pDst[1].set_rgb(subblock_colors0[block.get_selector(1, y)]);
			   pDst[2].set_rgb(subblock_colors1[block.get_selector(2, y)]);
			   pDst[3].set_rgb(subblock_colors1[block.get_selector(3, y)]);
			   pDst += 4;
			}
		 }
	  }
	  else
	  {
		 if (flip_flag)
		 {
			// 0000
			// 0000
			// 1111
			// 1111
			for (uint y = 0; y < 2; y++)
			{
			   pDst[0] = subblock_colors0[block.get_selector(0, y)];
			   pDst[1] = subblock_colors0[block.get_selector(1, y)];
			   pDst[2] = subblock_colors0[block.get_selector(2, y)];
			   pDst[3] = subblock_colors0[block.get_selector(3, y)];
			   pDst += 4;
			}

			for (uint y = 2; y < 4; y++)
			{
			   pDst[0] = subblock_colors1[block.get_selector(0, y)];
			   pDst[1] = subblock_colors1[block.get_selector(1, y)];
			   pDst[2] = subblock_colors1[block.get_selector(2, y)];
			   pDst[3] = subblock_colors1[block.get_selector(3, y)];
			   pDst += 4;
			}
		 }
		 else
		 {
			// 0011
			// 0011
			// 0011
			// 0011
			for (uint y = 0; y < 4; y++)
			{
			   pDst[0] = subblock_colors0[block.get_selector(0, y)];
			   pDst[1] = subblock_colors0[block.get_selector(1, y)];
			   pDst[2] = subblock_colors1[block.get_selector(2, y)];
			   pDst[3] = subblock_colors1[block.get_selector(3, y)];
			   pDst += 4;
			}
		 }
	  }

	  return success;
   }

   struct etc1_solution_coordinates
   {
	  inline etc1_solution_coordinates() :
	  m_unscaled_color(0, 0, 0, 0),
		 m_inten_table(0),
		 m_color4(false)
	  {
	  }

	  inline etc1_solution_coordinates(uint r, uint g, uint b, uint inten_table, bool color4) :
	  m_unscaled_color(r, g, b, 255),
		 m_inten_table(inten_table),
		 m_color4(color4)
	  {
	  }

	  inline etc1_solution_coordinates(const color_quad_u8& c, uint inten_table, bool color4) :
	  m_unscaled_color(c),
		 m_inten_table(inten_table),
		 m_color4(color4)
	  {
	  }

	  inline etc1_solution_coordinates(const etc1_solution_coordinates& other)
	  {
		 *this = other;
	  }

	  inline etc1_solution_coordinates& operator= (const etc1_solution_coordinates& rhs)
	  {
		 m_unscaled_color = rhs.m_unscaled_color;
		 m_inten_table = rhs.m_inten_table;
		 m_color4 = rhs.m_color4;
		 return *this;
	  }

	  inline void clear()
	  {
		 m_unscaled_color.clear();
		 m_inten_table = 0;
		 m_color4 = false;
	  }

	  inline color_quad_u8 get_scaled_color() const
	  {
		 int br, bg, bb;
		 if (m_color4)
		 {
			br = m_unscaled_color.r | (m_unscaled_color.r << 4);
			bg = m_unscaled_color.g | (m_unscaled_color.g << 4);
			bb = m_unscaled_color.b | (m_unscaled_color.b << 4);
		 }
		 else
		 {
			br = (m_unscaled_color.r >> 2) | (m_unscaled_color.r << 3);
			bg = (m_unscaled_color.g >> 2) | (m_unscaled_color.g << 3);
			bb = (m_unscaled_color.b >> 2) | (m_unscaled_color.b << 3);
		 }
		 return color_quad_u8(br, bg, bb);
	  }

	  inline void get_block_colors(color_quad_u8* pBlock_colors)
	  {
		 int br, bg, bb;
		 if (m_color4)
		 {
			br = m_unscaled_color.r | (m_unscaled_color.r << 4);
			bg = m_unscaled_color.g | (m_unscaled_color.g << 4);
			bb = m_unscaled_color.b | (m_unscaled_color.b << 4);
		 }
		 else
		 {
			br = (m_unscaled_color.r >> 2) | (m_unscaled_color.r << 3);
			bg = (m_unscaled_color.g >> 2) | (m_unscaled_color.g << 3);
			bb = (m_unscaled_color.b >> 2) | (m_unscaled_color.b << 3);
		 }
		 const int* pInten_table = g_etc1_inten_tables[m_inten_table];
		 pBlock_colors[0].set(br + pInten_table[0], bg + pInten_table[0], bb + pInten_table[0]);
		 pBlock_colors[1].set(br + pInten_table[1], bg + pInten_table[1], bb + pInten_table[1]);
		 pBlock_colors[2].set(br + pInten_table[2], bg + pInten_table[2], bb + pInten_table[2]);
		 pBlock_colors[3].set(br + pInten_table[3], bg + pInten_table[3], bb + pInten_table[3]);
	  }

	  color_quad_u8 m_unscaled_color;
	  uint m_inten_table;
	  bool m_color4;
   };

   class etc1_optimizer
   {
	  etc1_optimizer(const etc1_optimizer&);
	  etc1_optimizer& operator= (const etc1_optimizer&);

   public:
	  etc1_optimizer()
	  {
		 clear();
	  }

	  void clear()
	  {
		 m_pParams = NULL;
		 m_pResult = NULL;
		 m_pSorted_luma = NULL;
		 m_pSorted_luma_indices = NULL;
	  }

	  struct params : etc1_pack_params
	  {
		 params()
		 {
			clear();
		 }

		 params(const etc1_pack_params& base_params) :
		 etc1_pack_params(base_params)
		 {
			clear_optimizer_params();
		 }

		 void clear()
		 {
			etc1_pack_params::clear();
			clear_optimizer_params();
		 }

		 void clear_optimizer_params()
		 {
			m_num_src_pixels = 0;
			m_pSrc_pixels = 0;

			m_use_color4 = false;
			static const int s_default_scan_delta[] = { 0 };
			m_pScan_deltas = s_default_scan_delta;
			m_scan_delta_size = 1;

			m_base_color5.clear();
			m_constrain_against_base_color5 = false;
		 }

		 uint m_num_src_pixels;
		 const color_quad_u8* m_pSrc_pixels;

		 bool m_use_color4;
		 const int* m_pScan_deltas;
		 uint m_scan_delta_size;

		 color_quad_u8 m_base_color5;
		 bool m_constrain_against_base_color5;
	  };

	  struct results
	  {
		 uint64 m_error;
		 color_quad_u8 m_block_color_unscaled;
		 uint m_block_inten_table;
		 uint m_n;
		 uint8* m_pSelectors;
		 bool m_block_color4;

		 inline results& operator= (const results& rhs)
		 {
			m_block_color_unscaled = rhs.m_block_color_unscaled;
			m_block_color4 = rhs.m_block_color4;
			m_block_inten_table = rhs.m_block_inten_table;
			m_error = rhs.m_error;
			RG_ETC1_ASSERT(m_n == rhs.m_n);
			memcpy(m_pSelectors, rhs.m_pSelectors, rhs.m_n);
			return *this;
		 }
	  };

	  void init(const params& params, results& result);
	  bool compute();

   private:
	  struct potential_solution
	  {
		 potential_solution() : m_coords(), m_error(cUINT64_MAX), m_valid(false)
		 {
		 }

		 etc1_solution_coordinates  m_coords;
		 uint8                      m_selectors[8];
		 uint64                     m_error;
		 bool                       m_valid;

		 void clear()
		 {
			m_coords.clear();
			m_error = cUINT64_MAX;
			m_valid = false;
		 }
	  };

	  const params* m_pParams;
	  results* m_pResult;

	  int m_limit;

	  vec3F m_avg_color;
	  int m_br, m_bg, m_bb;
	  uint16 m_luma[8];
	  uint32 m_sorted_luma[2][8];
	  const uint32* m_pSorted_luma_indices;
	  uint32* m_pSorted_luma;

	  uint8 m_selectors[8];
	  uint8 m_best_selectors[8];

	  potential_solution m_best_solution;
	  potential_solution m_trial_solution;
	  uint8 m_temp_selectors[8];

	  bool evaluate_solution(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution);
	  bool evaluate_solution_fast(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution);
   };

   bool etc1_optimizer::compute()
   {
	  const uint n = m_pParams->m_num_src_pixels;
	  const int scan_delta_size = m_pParams->m_scan_delta_size;

	  // Scan through a subset of the 3D lattice centered around the avg block color trying each 3D (555 or 444) lattice point as a potential block color.
	  // Each time a better solution is found try to refine the current solution's block color based of the current selectors and intensity table index.
	  for (int zdi = 0; zdi < scan_delta_size; zdi++)
	  {
		 const int zd = m_pParams->m_pScan_deltas[zdi];
		 const int mbb = m_bb + zd;
		 if (mbb < 0) continue; else if (mbb > m_limit) break;

		 for (int ydi = 0; ydi < scan_delta_size; ydi++)
		 {
			const int yd = m_pParams->m_pScan_deltas[ydi];
			const int mbg = m_bg + yd;
			if (mbg < 0) continue; else if (mbg > m_limit) break;

			for (int xdi = 0; xdi < scan_delta_size; xdi++)
			{
			   const int xd = m_pParams->m_pScan_deltas[xdi];
			   const int mbr = m_br + xd;
			   if (mbr < 0) continue; else if (mbr > m_limit) break;

			   etc1_solution_coordinates coords(mbr, mbg, mbb, 0, m_pParams->m_use_color4);
			   if (m_pParams->m_quality == cHighQuality)
			   {
				  if (!evaluate_solution(coords, m_trial_solution, &m_best_solution))
					 continue;
			   }
			   else
			   {
				  if (!evaluate_solution_fast(coords, m_trial_solution, &m_best_solution))
					 continue;
			   }

			   // Now we have the input block, the avg. color of the input pixels, a set of trial selector indices, and the block color+intensity index.
			   // Now, for each component, attempt to refine the current solution by solving a simple linear equation. For example, for 4 colors:
			   // The goal is:
			   // pixel0 - (block_color+inten_table[selector0]) + pixel1 - (block_color+inten_table[selector1]) + pixel2 - (block_color+inten_table[selector2]) + pixel3 - (block_color+inten_table[selector3]) = 0
			   // Rearranging this:
			   // (pixel0 + pixel1 + pixel2 + pixel3) - (block_color+inten_table[selector0]) - (block_color+inten_table[selector1]) - (block_color+inten_table[selector2]) - (block_color+inten_table[selector3]) = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3) - block_color - inten_table[selector0] - block_color-inten_table[selector1] - block_color-inten_table[selector2] - block_color-inten_table[selector3] = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3) - 4*block_color - inten_table[selector0] - inten_table[selector1] - inten_table[selector2] - inten_table[selector3] = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3) - 4*block_color - (inten_table[selector0] + inten_table[selector1] + inten_table[selector2] + inten_table[selector3]) = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3)/4 - block_color - (inten_table[selector0] + inten_table[selector1] + inten_table[selector2] + inten_table[selector3])/4 = 0
			   // block_color = (pixel0 + pixel1 + pixel2 + pixel3)/4 - (inten_table[selector0] + inten_table[selector1] + inten_table[selector2] + inten_table[selector3])/4
			   // So what this means:
			   // optimal_block_color = avg_input - avg_inten_delta
			   // So the optimal block color can be computed by taking the average block color and subtracting the current average of the intensity delta.
			   // Unfortunately, optimal_block_color must then be quantized to 555 or 444 so it's not always possible to improve matters using this formula.
			   // Also, the above formula is for unclamped intensity deltas. The actual implementation takes into account clamping.

			   const uint max_refinement_trials = (m_pParams->m_quality == cLowQuality) ? 2 : (((xd | yd | zd) == 0) ? 4 : 2);
			   for (uint refinement_trial = 0; refinement_trial < max_refinement_trials; refinement_trial++)
			   {
				  const uint8* pSelectors = m_best_solution.m_selectors;
				  const int* pInten_table = g_etc1_inten_tables[m_best_solution.m_coords.m_inten_table];

				  int delta_sum_r = 0, delta_sum_g = 0, delta_sum_b = 0;
				  const color_quad_u8 base_color(m_best_solution.m_coords.get_scaled_color());
				  for (uint r = 0; r < n; r++)
				  {
					 const uint s = *pSelectors++;
					 const int yd = pInten_table[s];
					 // Compute actual delta being applied to each pixel, taking into account clamping.
					 delta_sum_r += rg_etc1::clamp<int>(base_color.r + yd, 0, 255) - base_color.r;
					 delta_sum_g += rg_etc1::clamp<int>(base_color.g + yd, 0, 255) - base_color.g;
					 delta_sum_b += rg_etc1::clamp<int>(base_color.b + yd, 0, 255) - base_color.b;
				  }
				  if ((!delta_sum_r) && (!delta_sum_g) && (!delta_sum_b))
					 break;
				  const float avg_delta_r_f = static_cast<float>(delta_sum_r) / n;
				  const float avg_delta_g_f = static_cast<float>(delta_sum_g) / n;
				  const float avg_delta_b_f = static_cast<float>(delta_sum_b) / n;
				  const int br1 = rg_etc1::clamp<int>(static_cast<uint>((m_avg_color[0] - avg_delta_r_f) * m_limit / 255.0f + .5f), 0, m_limit);
				  const int bg1 = rg_etc1::clamp<int>(static_cast<uint>((m_avg_color[1] - avg_delta_g_f) * m_limit / 255.0f + .5f), 0, m_limit);
				  const int bb1 = rg_etc1::clamp<int>(static_cast<uint>((m_avg_color[2] - avg_delta_b_f) * m_limit / 255.0f + .5f), 0, m_limit);

				  bool skip = false;

				  if ((mbr == br1) && (mbg == bg1) && (mbb == bb1))
					 skip = true;
				  else if ((br1 == m_best_solution.m_coords.m_unscaled_color.r) && (bg1 == m_best_solution.m_coords.m_unscaled_color.g) && (bb1 == m_best_solution.m_coords.m_unscaled_color.b))
					 skip = true;
				  else if ((m_br == br1) && (m_bg == bg1) && (m_bb == bb1))
					 skip = true;

				  if (skip)
					 break;

				  etc1_solution_coordinates coords1(br1, bg1, bb1, 0, m_pParams->m_use_color4);
				  if (m_pParams->m_quality == cHighQuality)
				  {
					 if (!evaluate_solution(coords1, m_trial_solution, &m_best_solution))
						break;
				  }
				  else
				  {
					 if (!evaluate_solution_fast(coords1, m_trial_solution, &m_best_solution))
						break;
				  }

			   }  // refinement_trial

			} // xdi
		 } // ydi
	  } // zdi

	  if (!m_best_solution.m_valid)
	  {
		 m_pResult->m_error = cUINT32_MAX;
		 return false;
	  }

	  const uint8* pSelectors = m_best_solution.m_selectors;

#ifdef RG_ETC1_BUILD_DEBUG
	  {
		 color_quad_u8 block_colors[4];
		 m_best_solution.m_coords.get_block_colors(block_colors);

		 const color_quad_u8* pSrc_pixels = m_pParams->m_pSrc_pixels;
		 uint64 actual_error = 0;
		 for (uint i = 0; i < n; i++)
			actual_error += pSrc_pixels[i].squared_distance_rgb(block_colors[pSelectors[i]]);

		 RG_ETC1_ASSERT(actual_error == m_best_solution.m_error);
	  }
#endif

	  m_pResult->m_error = m_best_solution.m_error;

	  m_pResult->m_block_color_unscaled = m_best_solution.m_coords.m_unscaled_color;
	  m_pResult->m_block_color4 = m_best_solution.m_coords.m_color4;

	  m_pResult->m_block_inten_table = m_best_solution.m_coords.m_inten_table;
	  memcpy(m_pResult->m_pSelectors, pSelectors, n);
	  m_pResult->m_n = n;

	  return true;
   }

   void etc1_optimizer::init(const params& p, results& r)
   {
	  // This version is hardcoded for 8 pixel subblocks.
	  RG_ETC1_ASSERT(p.m_num_src_pixels == 8);

	  m_pParams = &p;
	  m_pResult = &r;

	  const uint n = 8;

	  m_limit = m_pParams->m_use_color4 ? 15 : 31;

	  vec3F avg_color(0.0f);

	  for (uint i = 0; i < n; i++)
	  {
		 const color_quad_u8& c = m_pParams->m_pSrc_pixels[i];
		 const vec3F fc(c.r, c.g, c.b);

		 avg_color += fc;

		 m_luma[i] = static_cast<uint16>(c.r + c.g + c.b);
		 m_sorted_luma[0][i] = i;
	  }
	  avg_color *= (1.0f / static_cast<float>(n));
	  m_avg_color = avg_color;

	  m_br = rg_etc1::clamp<int>(static_cast<uint>(m_avg_color[0] * m_limit / 255.0f + .5f), 0, m_limit);
	  m_bg = rg_etc1::clamp<int>(static_cast<uint>(m_avg_color[1] * m_limit / 255.0f + .5f), 0, m_limit);
	  m_bb = rg_etc1::clamp<int>(static_cast<uint>(m_avg_color[2] * m_limit / 255.0f + .5f), 0, m_limit);

	  if (m_pParams->m_quality <= cMediumQuality)
	  {
		 m_pSorted_luma_indices = indirect_radix_sort(n, m_sorted_luma[0], m_sorted_luma[1], m_luma, 0, sizeof(m_luma[0]), false);
		 m_pSorted_luma = m_sorted_luma[0];
		 if (m_pSorted_luma_indices == m_sorted_luma[0])
			m_pSorted_luma = m_sorted_luma[1];

		 for (uint i = 0; i < n; i++)
			m_pSorted_luma[i] = m_luma[m_pSorted_luma_indices[i]];
	  }

	  m_best_solution.m_coords.clear();
	  m_best_solution.m_valid = false;
	  m_best_solution.m_error = cUINT64_MAX;
   }

   bool etc1_optimizer::evaluate_solution(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution)
   {
	  trial_solution.m_valid = false;

	  if (m_pParams->m_constrain_against_base_color5)
	  {
		 const int dr = coords.m_unscaled_color.r - m_pParams->m_base_color5.r;
		 const int dg = coords.m_unscaled_color.g - m_pParams->m_base_color5.g;
		 const int db = coords.m_unscaled_color.b - m_pParams->m_base_color5.b;

		 if ((rg_etc1::minimum(dr, dg, db) < cETC1ColorDeltaMin) || (rg_etc1::maximum(dr, dg, db) > cETC1ColorDeltaMax))
			return false;
	  }

	  const color_quad_u8 base_color(coords.get_scaled_color());

	  const uint n = 8;

	  trial_solution.m_error = cUINT64_MAX;

	  for (uint inten_table = 0; inten_table < cETC1IntenModifierValues; inten_table++)
	  {
		 const int* pInten_table = g_etc1_inten_tables[inten_table];

		 color_quad_u8 block_colors[4];
		 for (uint s = 0; s < 4; s++)
		 {
			const int yd = pInten_table[s];
			block_colors[s].set(base_color.r + yd, base_color.g + yd, base_color.b + yd, 0);
		 }

		 uint64 total_error = 0;

		 const color_quad_u8* pSrc_pixels = m_pParams->m_pSrc_pixels;
		 for (uint c = 0; c < n; c++)
		 {
			const color_quad_u8& src_pixel = *pSrc_pixels++;

			uint best_selector_index = 0;
			uint best_error = rg_etc1::square(src_pixel.r - block_colors[0].r) + rg_etc1::square(src_pixel.g - block_colors[0].g) + rg_etc1::square(src_pixel.b - block_colors[0].b);

			uint trial_error = rg_etc1::square(src_pixel.r - block_colors[1].r) + rg_etc1::square(src_pixel.g - block_colors[1].g) + rg_etc1::square(src_pixel.b - block_colors[1].b);
			if (trial_error < best_error)
			{
			   best_error = trial_error;
			   best_selector_index = 1;
			}

			trial_error = rg_etc1::square(src_pixel.r - block_colors[2].r) + rg_etc1::square(src_pixel.g - block_colors[2].g) + rg_etc1::square(src_pixel.b - block_colors[2].b);
			if (trial_error < best_error)
			{
			   best_error = trial_error;
			   best_selector_index = 2;
			}

			trial_error = rg_etc1::square(src_pixel.r - block_colors[3].r) + rg_etc1::square(src_pixel.g - block_colors[3].g) + rg_etc1::square(src_pixel.b - block_colors[3].b);
			if (trial_error < best_error)
			{
			   best_error = trial_error;
			   best_selector_index = 3;
			}

			m_temp_selectors[c] = static_cast<uint8>(best_selector_index);

			total_error += best_error;
			if (total_error >= trial_solution.m_error)
			   break;
		 }

		 if (total_error < trial_solution.m_error)
		 {
			trial_solution.m_error = total_error;
			trial_solution.m_coords.m_inten_table = inten_table;
			memcpy(trial_solution.m_selectors, m_temp_selectors, 8);
			trial_solution.m_valid = true;
		 }
	  }
	  trial_solution.m_coords.m_unscaled_color = coords.m_unscaled_color;
	  trial_solution.m_coords.m_color4 = m_pParams->m_use_color4;

	  bool success = false;
	  if (pBest_solution)
	  {
		 if (trial_solution.m_error < pBest_solution->m_error)
		 {
			*pBest_solution = trial_solution;
			success = true;
		 }
	  }

	  return success;
   }

   bool etc1_optimizer::evaluate_solution_fast(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution)
   {
	  if (m_pParams->m_constrain_against_base_color5)
	  {
		 const int dr = coords.m_unscaled_color.r - m_pParams->m_base_color5.r;
		 const int dg = coords.m_unscaled_color.g - m_pParams->m_base_color5.g;
		 const int db = coords.m_unscaled_color.b - m_pParams->m_base_color5.b;

		 if ((rg_etc1::minimum(dr, dg, db) < cETC1ColorDeltaMin) || (rg_etc1::maximum(dr, dg, db) > cETC1ColorDeltaMax))
		 {
			trial_solution.m_valid = false;
			return false;
		 }
	  }

	  const color_quad_u8 base_color(coords.get_scaled_color());

	  const uint n = 8;

	  trial_solution.m_error = cUINT64_MAX;

	  for (int inten_table = cETC1IntenModifierValues - 1; inten_table >= 0; --inten_table)
	  {
		 const int* pInten_table = g_etc1_inten_tables[inten_table];

		 uint block_inten[4];
		 color_quad_u8 block_colors[4];
		 for (uint s = 0; s < 4; s++)
		 {
			const int yd = pInten_table[s];
			color_quad_u8 block_color(base_color.r + yd, base_color.g + yd, base_color.b + yd, 0);
			block_colors[s] = block_color;
			block_inten[s] = block_color.r + block_color.g + block_color.b;
		 }

		 // evaluate_solution_fast() enforces/assumesd a total ordering of the input colors along the intensity (1,1,1) axis to more quickly classify the inputs to selectors.
		 // The inputs colors have been presorted along the projection onto this axis, and ETC1 block colors are always ordered along the intensity axis, so this classification is fast.
		 // 0   1   2   3
		 //   01  12  23
		 const uint block_inten_midpoints[3] = { block_inten[0] + block_inten[1], block_inten[1] + block_inten[2], block_inten[2] + block_inten[3] };

		 uint64 total_error = 0;
		 const color_quad_u8* pSrc_pixels = m_pParams->m_pSrc_pixels;
		 if ((m_pSorted_luma[n - 1] * 2) < block_inten_midpoints[0])
		 {
			if (block_inten[0] > m_pSorted_luma[n - 1])
			{
			   const uint min_error = labs(block_inten[0] - m_pSorted_luma[n - 1]);
			   if (min_error >= trial_solution.m_error)
				  continue;
			}

			memset(&m_temp_selectors[0], 0, n);

			for (uint c = 0; c < n; c++)
			   total_error += block_colors[0].squared_distance_rgb(pSrc_pixels[c]);
		 }
		 else if ((m_pSorted_luma[0] * 2) >= block_inten_midpoints[2])
		 {
			if (m_pSorted_luma[0] > block_inten[3])
			{
			   const uint min_error = labs(m_pSorted_luma[0] - block_inten[3]);
			   if (min_error >= trial_solution.m_error)
				  continue;
			}

			memset(&m_temp_selectors[0], 3, n);

			for (uint c = 0; c < n; c++)
			   total_error += block_colors[3].squared_distance_rgb(pSrc_pixels[c]);
		 }
		 else
		 {
			uint cur_selector = 0, c;
			for (c = 0; c < n; c++)
			{
			   const uint y = m_pSorted_luma[c];
			   while ((y * 2) >= block_inten_midpoints[cur_selector])
				  if (++cur_selector > 2)
					 goto done;
			   const uint sorted_pixel_index = m_pSorted_luma_indices[c];
			   m_temp_selectors[sorted_pixel_index] = static_cast<uint8>(cur_selector);
			   total_error += block_colors[cur_selector].squared_distance_rgb(pSrc_pixels[sorted_pixel_index]);
			}
done:
			while (c < n)
			{
			   const uint sorted_pixel_index = m_pSorted_luma_indices[c];
			   m_temp_selectors[sorted_pixel_index] = 3;
			   total_error += block_colors[3].squared_distance_rgb(pSrc_pixels[sorted_pixel_index]);
			   ++c;
			}
		 }

		 if (total_error < trial_solution.m_error)
		 {
			trial_solution.m_error = total_error;
			trial_solution.m_coords.m_inten_table = inten_table;
			memcpy(trial_solution.m_selectors, m_temp_selectors, n);
			trial_solution.m_valid = true;
			if (!total_error)
			   break;
		 }
	  }
	  trial_solution.m_coords.m_unscaled_color = coords.m_unscaled_color;
	  trial_solution.m_coords.m_color4 = m_pParams->m_use_color4;

	  bool success = false;
	  if (pBest_solution)
	  {
		 if (trial_solution.m_error < pBest_solution->m_error)
		 {
			*pBest_solution = trial_solution;
			success = true;
		 }
	  }

	  return success;
   }

   static uint etc1_decode_value(uint diff, uint inten, uint selector, uint packed_c)
   {
	  const uint limit = diff ? 32 : 16; limit;
	  RG_ETC1_ASSERT((diff < 2) && (inten < 8) && (selector < 4) && (packed_c < limit));
	  int c;
	  if (diff)
		 c = (packed_c >> 2) | (packed_c << 3);
	  else
		 c = packed_c | (packed_c << 4);
	  c += g_etc1_inten_tables[inten][selector];
	  c = rg_etc1::clamp<int>(c, 0, 255);
	  return c;
   }

   static inline int mul_8bit(int a, int b) { int t = a*b + 128; return (t + (t >> 8)) >> 8; }

   void pack_etc1_block_init()
   {
	  for (uint diff = 0; diff < 2; diff++)
	  {
		 const uint limit = diff ? 32 : 16;

		 for (uint inten = 0; inten < 8; inten++)
		 {
			for (uint selector = 0; selector < 4; selector++)
			{
			   const uint inverse_table_index = diff + (inten << 1) + (selector << 4);
			   for (uint color = 0; color < 256; color++)
			   {
				  uint best_error = cUINT32_MAX, best_packed_c = 0;
				  for (uint packed_c = 0; packed_c < limit; packed_c++)
				  {
					 int v = etc1_decode_value(diff, inten, selector, packed_c);
					 uint err = labs(v - static_cast<int>(color));
					 if (err < best_error)
					 {
						best_error = err;
						best_packed_c = packed_c;
						if (!best_error)
						   break;
					 }
				  }
				  RG_ETC1_ASSERT(best_error <= 255);
				  g_etc1_inverse_lookup[inverse_table_index][color] = static_cast<uint16>(best_packed_c | (best_error << 8));
			   }
			}
		 }
	  }

	  uint expand5[32];
	  for(int i = 0; i < 32; i++)
		 expand5[i] = (i << 3) | (i >> 2);

	  for(int i = 0; i < 256 + 16; i++)
	  {
		 int v = clamp<int>(i - 8, 0, 255);
		 g_quant5_tab[i] = static_cast<uint8>(expand5[mul_8bit(v,31)]);
	  }
   }

   // Packs solid color blocks efficiently using a set of small precomputed tables.
   // For random 888 inputs, MSE results are better than Erricson's ETC1 packer in "slow" mode ~9.5% of the time, is slightly worse only ~.01% of the time, and is equal the rest of the time.
   static uint64 pack_etc1_block_solid_color(etc1_block& block, const uint8* pColor, etc1_pack_params& pack_params)
   {
	  pack_params;
	  RG_ETC1_ASSERT(g_etc1_inverse_lookup[0][255]);

	  static uint s_next_comp[4] = { 1, 2, 0, 1 };

	  uint best_error = cUINT32_MAX, best_i = 0;
	  int best_x = 0, best_packed_c1 = 0, best_packed_c2 = 0;

	  // For each possible 8-bit value, there is a precomputed list of diff/inten/selector configurations that allow that 8-bit value to be encoded with no error.
	  for (uint i = 0; i < 3; i++)
	  {
		 const uint c1 = pColor[s_next_comp[i]], c2 = pColor[s_next_comp[i + 1]];

		 const int delta_range = 1;
		 for (int delta = -delta_range; delta <= delta_range; delta++)
		 {
			const int c_plus_delta = rg_etc1::clamp<int>(pColor[i] + delta, 0, 255);

			const uint16* pTable;
			if (!c_plus_delta)
			   pTable = g_color8_to_etc_block_config_0_255[0];
			else if (c_plus_delta == 255)
			   pTable = g_color8_to_etc_block_config_0_255[1];
			else
			   pTable = g_color8_to_etc_block_config_1_to_254[c_plus_delta - 1];

			do
			{
			   const uint x = *pTable++;

#ifdef RG_ETC1_BUILD_DEBUG
			   const uint diff = x & 1;
			   const uint inten = (x >> 1) & 7;
			   const uint selector = (x >> 4) & 3;
			   const uint p0 = (x >> 8) & 255;
			   RG_ETC1_ASSERT(etc1_decode_value(diff, inten, selector, p0) == (uint)c_plus_delta);
#endif

			   const uint16* pInverse_table = g_etc1_inverse_lookup[x & 0xFF];
			   uint16 p1 = pInverse_table[c1];
			   uint16 p2 = pInverse_table[c2];
			   const uint trial_error = rg_etc1::square(c_plus_delta - pColor[i]) + rg_etc1::square(p1 >> 8) + rg_etc1::square(p2 >> 8);
			   if (trial_error < best_error)
			   {
				  best_error = trial_error;
				  best_x = x;
				  best_packed_c1 = p1 & 0xFF;
				  best_packed_c2 = p2 & 0xFF;
				  best_i = i;
				  if (!best_error)
					 goto found_perfect_match;
			   }
			} while (*pTable != 0xFFFF);
		 }
	  }
found_perfect_match:

	  const uint diff = best_x & 1;
	  const uint inten = (best_x >> 1) & 7;

	  block.m_bytes[3] = static_cast<uint8>(((inten | (inten << 3)) << 2) | (diff << 1));

	  const uint etc1_selector = g_selector_index_to_etc1[(best_x >> 4) & 3];
	  *reinterpret_cast<uint16*>(&block.m_bytes[4]) = (etc1_selector & 2) ? 0xFFFF : 0;
	  *reinterpret_cast<uint16*>(&block.m_bytes[6]) = (etc1_selector & 1) ? 0xFFFF : 0;

	  const uint best_packed_c0 = (best_x >> 8) & 255;
	  if (diff)
	  {
		 block.m_bytes[best_i] = static_cast<uint8>(best_packed_c0 << 3);
		 block.m_bytes[s_next_comp[best_i]] = static_cast<uint8>(best_packed_c1 << 3);
		 block.m_bytes[s_next_comp[best_i+1]] = static_cast<uint8>(best_packed_c2 << 3);
	  }
	  else
	  {
		 block.m_bytes[best_i] = static_cast<uint8>(best_packed_c0 | (best_packed_c0 << 4));
		 block.m_bytes[s_next_comp[best_i]] = static_cast<uint8>(best_packed_c1 | (best_packed_c1 << 4));
		 block.m_bytes[s_next_comp[best_i+1]] = static_cast<uint8>(best_packed_c2 | (best_packed_c2 << 4));
	  }

	  return best_error;
   }

   static uint pack_etc1_block_solid_color_constrained(
	  etc1_optimizer::results& results,
	  uint num_colors, const uint8* pColor,
	  etc1_pack_params& pack_params,
	  bool use_diff,
	  const color_quad_u8* pBase_color5_unscaled)
   {
	  RG_ETC1_ASSERT(g_etc1_inverse_lookup[0][255]);

	  pack_params;
	  static uint s_next_comp[4] = { 1, 2, 0, 1 };

	  uint best_error = cUINT32_MAX, best_i = 0;
	  int best_x = 0, best_packed_c1 = 0, best_packed_c2 = 0;

	  // For each possible 8-bit value, there is a precomputed list of diff/inten/selector configurations that allow that 8-bit value to be encoded with no error.
	  for (uint i = 0; i < 3; i++)
	  {
		 const uint c1 = pColor[s_next_comp[i]], c2 = pColor[s_next_comp[i + 1]];

		 const int delta_range = 1;
		 for (int delta = -delta_range; delta <= delta_range; delta++)
		 {
			const int c_plus_delta = rg_etc1::clamp<int>(pColor[i] + delta, 0, 255);

			const uint16* pTable;
			if (!c_plus_delta)
			   pTable = g_color8_to_etc_block_config_0_255[0];
			else if (c_plus_delta == 255)
			   pTable = g_color8_to_etc_block_config_0_255[1];
			else
			   pTable = g_color8_to_etc_block_config_1_to_254[c_plus_delta - 1];

			do
			{
			   const uint x = *pTable++;
			   const uint diff = x & 1;
			   if (static_cast<uint>(use_diff) != diff)
			   {
				  if (*pTable == 0xFFFF)
					 break;
				  continue;
			   }

			   if ((diff) && (pBase_color5_unscaled))
			   {
				  const int p0 = (x >> 8) & 255;
				  int delta = p0 - static_cast<int>(pBase_color5_unscaled->c[i]);
				  if ((delta < cETC1ColorDeltaMin) || (delta > cETC1ColorDeltaMax))
				  {
					 if (*pTable == 0xFFFF)
						break;
					 continue;
				  }
			   }

#ifdef RG_ETC1_BUILD_DEBUG
			   {
				  const uint inten = (x >> 1) & 7;
				  const uint selector = (x >> 4) & 3;
				  const uint p0 = (x >> 8) & 255;
				  RG_ETC1_ASSERT(etc1_decode_value(diff, inten, selector, p0) == (uint)c_plus_delta);
			   }
#endif

			   const uint16* pInverse_table = g_etc1_inverse_lookup[x & 0xFF];
			   uint16 p1 = pInverse_table[c1];
			   uint16 p2 = pInverse_table[c2];

			   if ((diff) && (pBase_color5_unscaled))
			   {
				  int delta1 = (p1 & 0xFF) - static_cast<int>(pBase_color5_unscaled->c[s_next_comp[i]]);
				  int delta2 = (p2 & 0xFF) - static_cast<int>(pBase_color5_unscaled->c[s_next_comp[i + 1]]);
				  if ((delta1 < cETC1ColorDeltaMin) || (delta1 > cETC1ColorDeltaMax) || (delta2 < cETC1ColorDeltaMin) || (delta2 > cETC1ColorDeltaMax))
				  {
					 if (*pTable == 0xFFFF)
						break;
					 continue;
				  }
			   }

			   const uint trial_error = rg_etc1::square(c_plus_delta - pColor[i]) + rg_etc1::square(p1 >> 8) + rg_etc1::square(p2 >> 8);
			   if (trial_error < best_error)
			   {
				  best_error = trial_error;
				  best_x = x;
				  best_packed_c1 = p1 & 0xFF;
				  best_packed_c2 = p2 & 0xFF;
				  best_i = i;
				  if (!best_error)
					 goto found_perfect_match;
			   }
			} while (*pTable != 0xFFFF);
		 }
	  }
found_perfect_match:

	  if (best_error == cUINT32_MAX)
		 return best_error;

	  best_error *= num_colors;

	  results.m_n = num_colors;
	  results.m_block_color4 = !(best_x & 1);
	  results.m_block_inten_table = (best_x >> 1) & 7;
	  memset(results.m_pSelectors, (best_x >> 4) & 3, num_colors);

	  const uint best_packed_c0 = (best_x >> 8) & 255;
	  results.m_block_color_unscaled[best_i] = static_cast<uint8>(best_packed_c0);
	  results.m_block_color_unscaled[s_next_comp[best_i]] = static_cast<uint8>(best_packed_c1);
	  results.m_block_color_unscaled[s_next_comp[best_i + 1]] = static_cast<uint8>(best_packed_c2);
	  results.m_error = best_error;

	  return best_error;
   }

   // Function originally from RYG's public domain real-time DXT1 compressor, modified for 555.
   static void dither_block_555(color_quad_u8* dest, const color_quad_u8* block)
   {
	  int err[8],*ep1 = err,*ep2 = err+4;
	  uint8 *quant = g_quant5_tab+8;

	  memset(dest, 0xFF, sizeof(color_quad_u8)*16);

	  // process channels seperately
	  for(int ch=0;ch<3;ch++)
	  {
		 uint8* bp = (uint8*)block;
		 uint8* dp = (uint8*)dest;

		 bp += ch; dp += ch;

		 memset(err,0, sizeof(err));
		 for(int y = 0; y < 4; y++)
		 {
			// pixel 0
			dp[ 0] = quant[bp[ 0] + ((3*ep2[1] + 5*ep2[0]) >> 4)];
			ep1[0] = bp[ 0] - dp[ 0];

			// pixel 1
			dp[ 4] = quant[bp[ 4] + ((7*ep1[0] + 3*ep2[2] + 5*ep2[1] + ep2[0]) >> 4)];
			ep1[1] = bp[ 4] - dp[ 4];

			// pixel 2
			dp[ 8] = quant[bp[ 8] + ((7*ep1[1] + 3*ep2[3] + 5*ep2[2] + ep2[1]) >> 4)];
			ep1[2] = bp[ 8] - dp[ 8];

			// pixel 3
			dp[12] = quant[bp[12] + ((7*ep1[2] + 5*ep2[3] + ep2[2]) >> 4)];
			ep1[3] = bp[12] - dp[12];

			// advance to next line
			int* tmp = ep1; ep1 = ep2; ep2 = tmp;
			bp += 16;
			dp += 16;
		 }
	  }
   }

   unsigned int pack_etc1_block(void* pETC1_block, const unsigned int* pSrc_pixels_rgba, etc1_pack_params& pack_params)
   {
	  const color_quad_u8* pSrc_pixels = reinterpret_cast<const color_quad_u8*>(pSrc_pixels_rgba);
	  etc1_block& dst_block = *static_cast<etc1_block*>(pETC1_block);

#ifdef RG_ETC1_BUILD_DEBUG
	  // Ensure all alpha values are 0xFF.
	  for (uint i = 0; i < 16; i++)
	  {
		 RG_ETC1_ASSERT(pSrc_pixels[i].a == 255);
	  }
#endif

	  color_quad_u8 src_pixel0(pSrc_pixels[0]);

	  // Check for solid block.
	  const uint32 first_pixel_u32 = pSrc_pixels->m_u32;
	  int r;
	  for (r = 15; r >= 1; --r)
		 if (pSrc_pixels[r].m_u32 != first_pixel_u32)
			break;
	  if (!r)
		 return static_cast<unsigned int>(16 * pack_etc1_block_solid_color(dst_block, &pSrc_pixels[0].r, pack_params));

	  color_quad_u8 dithered_pixels[16];
	  if (pack_params.m_dithering)
	  {
		 dither_block_555(dithered_pixels, pSrc_pixels);
		 pSrc_pixels = dithered_pixels;
	  }

	  etc1_optimizer optimizer;

	  uint64 best_error = cUINT64_MAX;
	  uint best_flip = false, best_use_color4 = false;

	  uint8 best_selectors[2][8];
	  etc1_optimizer::results best_results[2];
	  for (uint i = 0; i < 2; i++)
	  {
		 best_results[i].m_n = 8;
		 best_results[i].m_pSelectors = best_selectors[i];
	  }

	  uint8 selectors[3][8];
	  etc1_optimizer::results results[3];

	  for (uint i = 0; i < 3; i++)
	  {
		 results[i].m_n = 8;
		 results[i].m_pSelectors = selectors[i];
	  }

	  color_quad_u8 subblock_pixels[8];

	  etc1_optimizer::params params(pack_params);
	  params.m_num_src_pixels = 8;
	  params.m_pSrc_pixels = subblock_pixels;

	  for (uint flip = 0; flip < 2; flip++)
	  {
		 for (uint use_color4 = 0; use_color4 < 2; use_color4++)
		 {
			uint64 trial_error = 0;

			uint subblock;
			for (subblock = 0; subblock < 2; subblock++)
			{
			   if (flip)
				  memcpy(subblock_pixels, pSrc_pixels + subblock * 8, sizeof(color_quad_u8) * 8);
			   else
			   {
				  const color_quad_u8* pSrc_col = pSrc_pixels + subblock * 2;
				  subblock_pixels[0] = pSrc_col[0]; subblock_pixels[1] = pSrc_col[4]; subblock_pixels[2] = pSrc_col[8]; subblock_pixels[3] = pSrc_col[12];
				  subblock_pixels[4] = pSrc_col[1]; subblock_pixels[5] = pSrc_col[5]; subblock_pixels[6] = pSrc_col[9]; subblock_pixels[7] = pSrc_col[13];
			   }

			   results[2].m_error = cUINT64_MAX;
			   if ((params.m_quality >= cMediumQuality) && ((subblock) || (use_color4)))
			   {
				  const uint32 subblock_pixel0_u32 = subblock_pixels[0].m_u32;
				  for (r = 7; r >= 1; --r)
					 if (subblock_pixels[r].m_u32 != subblock_pixel0_u32)
						break;
				  if (!r)
				  {
					 pack_etc1_block_solid_color_constrained(results[2], 8, &subblock_pixels[0].r, pack_params, !use_color4, (subblock && !use_color4) ? &results[0].m_block_color_unscaled : NULL);
				  }
			   }

			   params.m_use_color4 = (use_color4 != 0);
			   params.m_constrain_against_base_color5 = false;

			   if ((!use_color4) && (subblock))
			   {
				  params.m_constrain_against_base_color5 = true;
				  params.m_base_color5 = results[0].m_block_color_unscaled;
			   }

			   if (params.m_quality == cHighQuality)
			   {
				  static const int s_scan_delta_0_to_4[] = { -4, -3, -2, -1, 0, 1, 2, 3, 4 };
				  params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_0_to_4);
				  params.m_pScan_deltas = s_scan_delta_0_to_4;
			   }
			   else if (params.m_quality == cMediumQuality)
			   {
				  static const int s_scan_delta_0_to_1[] = { -1, 0, 1 };
				  params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_0_to_1);
				  params.m_pScan_deltas = s_scan_delta_0_to_1;
			   }
			   else
			   {
				  static const int s_scan_delta_0[] = { 0 };
				  params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_0);
				  params.m_pScan_deltas = s_scan_delta_0;
			   }

			   optimizer.init(params, results[subblock]);
			   if (!optimizer.compute())
				  break;

			   if (params.m_quality >= cMediumQuality)
			   {
				  // TODO: Fix fairly arbitrary/unrefined thresholds that control how far away to scan for potentially better solutions.
				  const uint refinement_error_thresh0 = 3000;
				  const uint refinement_error_thresh1 = 6000;
				  if (results[subblock].m_error > refinement_error_thresh0)
				  {
					 if (params.m_quality == cMediumQuality)
					 {
						static const int s_scan_delta_2_to_3[] = { -3, -2, 2, 3 };
						params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_2_to_3);
						params.m_pScan_deltas = s_scan_delta_2_to_3;
					 }
					 else
					 {
						static const int s_scan_delta_5_to_5[] = { -5, 5 };
						static const int s_scan_delta_5_to_8[] = { -8, -7, -6, -5, 5, 6, 7, 8 };
						if (results[subblock].m_error > refinement_error_thresh1)
						{
						   params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_5_to_8);
						   params.m_pScan_deltas = s_scan_delta_5_to_8;
						}
						else
						{
						   params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_5_to_5);
						   params.m_pScan_deltas = s_scan_delta_5_to_5;
						}
					 }

					 if (!optimizer.compute())
						break;
				  }

				  if (results[2].m_error < results[subblock].m_error)
					 results[subblock] = results[2];
			   }

			   trial_error += results[subblock].m_error;
			   if (trial_error >= best_error)
				  break;
			}

			if (subblock < 2)
			   continue;

			best_error = trial_error;
			best_results[0] = results[0];
			best_results[1] = results[1];
			best_flip = flip;
			best_use_color4 = use_color4;

		 } // use_color4

	  } // flip

	  int dr = best_results[1].m_block_color_unscaled.r - best_results[0].m_block_color_unscaled.r;
	  int dg = best_results[1].m_block_color_unscaled.g - best_results[0].m_block_color_unscaled.g;
	  int db = best_results[1].m_block_color_unscaled.b - best_results[0].m_block_color_unscaled.b;
	  RG_ETC1_ASSERT(best_use_color4 || (rg_etc1::minimum(dr, dg, db) >= cETC1ColorDeltaMin) && (rg_etc1::maximum(dr, dg, db) <= cETC1ColorDeltaMax));

	  if (best_use_color4)
	  {
		 dst_block.m_bytes[0] = static_cast<uint8>(best_results[1].m_block_color_unscaled.r | (best_results[0].m_block_color_unscaled.r << 4));
		 dst_block.m_bytes[1] = static_cast<uint8>(best_results[1].m_block_color_unscaled.g | (best_results[0].m_block_color_unscaled.g << 4));
		 dst_block.m_bytes[2] = static_cast<uint8>(best_results[1].m_block_color_unscaled.b | (best_results[0].m_block_color_unscaled.b << 4));
	  }
	  else
	  {
		 if (dr < 0) dr += 8; dst_block.m_bytes[0] = static_cast<uint8>((best_results[0].m_block_color_unscaled.r << 3) | dr);
		 if (dg < 0) dg += 8; dst_block.m_bytes[1] = static_cast<uint8>((best_results[0].m_block_color_unscaled.g << 3) | dg);
		 if (db < 0) db += 8; dst_block.m_bytes[2] = static_cast<uint8>((best_results[0].m_block_color_unscaled.b << 3) | db);
	  }

	  dst_block.m_bytes[3] = static_cast<uint8>( (best_results[1].m_block_inten_table << 2) | (best_results[0].m_block_inten_table << 5) | ((~best_use_color4 & 1) << 1) | best_flip );

	  uint selector0 = 0, selector1 = 0;
	  if (best_flip)
	  {
		 // flipped:
		 // { 0, 0 }, { 1, 0 }, { 2, 0 }, { 3, 0 },
		 // { 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1 }
		 //
		 // { 0, 2 }, { 1, 2 }, { 2, 2 }, { 3, 2 },
		 // { 0, 3 }, { 1, 3 }, { 2, 3 }, { 3, 3 }
		 const uint8* pSelectors0 = best_results[0].m_pSelectors;
		 const uint8* pSelectors1 = best_results[1].m_pSelectors;
		 for (int x = 3; x >= 0; --x)
		 {
			uint b;
			b = g_selector_index_to_etc1[pSelectors1[4 + x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			b = g_selector_index_to_etc1[pSelectors1[x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			b = g_selector_index_to_etc1[pSelectors0[4 + x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			b = g_selector_index_to_etc1[pSelectors0[x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);
		 }
	  }
	  else
	  {
		 // non-flipped:
		 // { 0, 0 }, { 0, 1 }, { 0, 2 }, { 0, 3 },
		 // { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 }
		 //
		 // { 2, 0 }, { 2, 1 }, { 2, 2 }, { 2, 3 },
		 // { 3, 0 }, { 3, 1 }, { 3, 2 }, { 3, 3 }
		 for (int subblock = 1; subblock >= 0; --subblock)
		 {
			const uint8* pSelectors = best_results[subblock].m_pSelectors + 4;
			for (uint i = 0; i < 2; i++)
			{
			   uint b;
			   b = g_selector_index_to_etc1[pSelectors[3]];
			   selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			   b = g_selector_index_to_etc1[pSelectors[2]];
			   selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			   b = g_selector_index_to_etc1[pSelectors[1]];
			   selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			   b = g_selector_index_to_etc1[pSelectors[0]];
			   selector0 = (selector0 << 1) | (b & 1);selector1 = (selector1 << 1) | (b >> 1);

			   pSelectors -= 4;
			}
		 }
	  }

	  dst_block.m_bytes[4] = static_cast<uint8>(selector1 >> 8); dst_block.m_bytes[5] = static_cast<uint8>(selector1 & 0xFF);
	  dst_block.m_bytes[6] = static_cast<uint8>(selector0 >> 8); dst_block.m_bytes[7] = static_cast<uint8>(selector0 & 0xFF);

	  return static_cast<unsigned int>(best_error);
   }

} // namespace rg_etc1

#undef  clamp


//#line 1 "jpge.h"
// jpge.h - C++ class for JPEG compression.
// Public domain, Rich Geldreich <richgel99@gmail.com>
// Alex Evans: Added RGBA support, linear memory allocator.
#ifndef JPEG_ENCODER_H
#define JPEG_ENCODER_H

namespace jpge
{
  typedef unsigned char  uint8;
  typedef signed short   int16;
  typedef signed int     int32;
  typedef unsigned short uint16;
  typedef unsigned int   uint32;
  typedef unsigned int   uint;

  // JPEG chroma subsampling factors. Y_ONLY (grayscale images) and H2V2 (color images) are the most common.
  enum subsampling_t { Y_ONLY = 0, H1V1 = 1, H2V1 = 2, H2V2 = 3 };

  // JPEG compression parameters structure.
  struct params
  {
	inline params() : m_quality(85), m_subsampling(H2V2), m_no_chroma_discrim_flag(false), m_two_pass_flag(false) { }

	inline bool check() const
	{
	  if ((m_quality < 1) || (m_quality > 100)) return false;
	  if ((uint)m_subsampling > (uint)H2V2) return false;
	  return true;
	}

	// Quality: 1-100, higher is better. Typical values are around 50-95.
	int m_quality;

	// m_subsampling:
	// 0 = Y (grayscale) only
	// 1 = YCbCr, no subsampling (H1V1, YCbCr 1x1x1, 3 blocks per MCU)
	// 2 = YCbCr, H2V1 subsampling (YCbCr 2x1x1, 4 blocks per MCU)
	// 3 = YCbCr, H2V2 subsampling (YCbCr 4x1x1, 6 blocks per MCU-- very common)
	subsampling_t m_subsampling;

	// Disables CbCr discrimination - only intended for testing.
	// If true, the Y quantization table is also used for the CbCr channels.
	bool m_no_chroma_discrim_flag;

	bool m_two_pass_flag;
  };

  // Writes JPEG image to a file.
  // num_channels must be 1 (Y) or 3 (RGB), image pitch must be width*num_channels.
  bool compress_image_to_jpeg_file(const char *pFilename, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params = params());

  // Writes JPEG image to memory buffer.
  // On entry, buf_size is the size of the output buffer pointed at by pBuf, which should be at least ~1024 bytes.
  // If return value is true, buf_size will be set to the size of the compressed data.
  bool compress_image_to_jpeg_file_in_memory(void *pBuf, int &buf_size, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params = params());

  // Output stream abstract class - used by the jpeg_encoder class to write to the output stream.
  // put_buf() is generally called with len==JPGE_OUT_BUF_SIZE bytes, but for headers it'll be called with smaller amounts.
  class output_stream
  {
  public:
	virtual ~output_stream() { };
	virtual bool put_buf(const void* Pbuf, int len) = 0;
	template<class T> inline bool put_obj(const T& obj) { return put_buf(&obj, sizeof(T)); }
  };

  // Lower level jpeg_encoder class - useful if more control is needed than the above helper functions.
  class jpeg_encoder
  {
  public:
	jpeg_encoder();
	~jpeg_encoder();

	// Initializes the compressor.
	// pStream: The stream object to use for writing compressed data.
	// params - Compression parameters structure, defined above.
	// width, height  - Image dimensions.
	// channels - May be 1, or 3. 1 indicates grayscale, 3 indicates RGB source data.
	// Returns false on out of memory or if a stream write fails.
	bool init(output_stream *pStream, int width, int height, int src_channels, const params &comp_params = params());

	const params &get_params() const { return m_params; }

	// Deinitializes the compressor, freeing any allocated memory. May be called at any time.
	void deinit();

	uint get_total_passes() const { return m_params.m_two_pass_flag ? 2 : 1; }
	inline uint get_cur_pass() { return m_pass_num; }

	// Call this method with each source scanline.
	// width * src_channels bytes per scanline is expected (RGB or Y format).
	// You must call with NULL after all scanlines are processed to finish compression.
	// Returns false on out of memory or if a stream write fails.
	bool process_scanline(const void* pScanline);

  private:
	jpeg_encoder(const jpeg_encoder &);
	jpeg_encoder &operator =(const jpeg_encoder &);

	typedef int32 sample_array_t;

	output_stream *m_pStream;
	params m_params;
	uint8 m_num_components;
	uint8 m_comp_h_samp[3], m_comp_v_samp[3];
	int m_image_x, m_image_y, m_image_bpp, m_image_bpl;
	int m_image_x_mcu, m_image_y_mcu;
	int m_image_bpl_xlt, m_image_bpl_mcu;
	int m_mcus_per_row;
	int m_mcu_x, m_mcu_y;
	uint8 *m_mcu_lines[16];
	uint8 m_mcu_y_ofs;
	sample_array_t m_sample_array[64];
	int16 m_coefficient_array[64];
	int32 m_quantization_tables[2][64];
	uint m_huff_codes[4][256];
	uint8 m_huff_code_sizes[4][256];
	uint8 m_huff_bits[4][17];
	uint8 m_huff_val[4][256];
	uint32 m_huff_count[4][256];
	int m_last_dc_val[3];
	enum { JPGE_OUT_BUF_SIZE = 2048 };
	uint8 m_out_buf[JPGE_OUT_BUF_SIZE];
	uint8 *m_pOut_buf;
	uint m_out_buf_left;
	uint32 m_bit_buffer;
	uint m_bits_in;
	uint8 m_pass_num;
	bool m_all_stream_writes_succeeded;

	void optimize_huffman_table(int table_num, int table_len);
	void emit_byte(uint8 i);
	void emit_word(uint i);
	void emit_marker(int marker);
	void emit_jfif_app0();
	void emit_dqt();
	void emit_sof();
	void emit_dht(uint8 *bits, uint8 *val, int index, bool ac_flag);
	void emit_dhts();
	void emit_sos();
	void emit_markers();
	void compute_huffman_table(uint *codes, uint8 *code_sizes, uint8 *bits, uint8 *val);
	void compute_quant_table(int32 *dst, int16 *src);
	void adjust_quant_table(int32 *dst, int32 *src);
	void first_pass_init();
	bool second_pass_init();
	bool jpg_open(int p_x_res, int p_y_res, int src_channels);
	void load_block_8_8_grey(int x);
	void load_block_8_8(int x, int y, int c);
	void load_block_16_8(int x, int c);
	void load_block_16_8_8(int x, int c);
	void load_quantized_coefficients(int component_num);
	void flush_output_buffer();
	void put_bits(uint bits, uint len);
	void code_coefficients_pass_one(int component_num);
	void code_coefficients_pass_two(int component_num);
	void code_block(int component_num);
	void process_mcu_row();
	bool terminate_pass_one();
	bool terminate_pass_two();
	bool process_end_of_image();
	void load_mcu(const void* src);
	void clear();
	void init();
  };

} // namespace jpge

#endif // JPEG_ENCODER


//#line 1 "jpge.cpp"
// jpge.cpp - C++ class for JPEG compression.
// Public domain, Rich Geldreich <richgel99@gmail.com>
// v1.01, Dec. 18, 2010 - Initial release
// v1.02, Apr. 6, 2011 - Removed 2x2 ordered dither in H2V1 chroma subsampling method load_block_16_8_8(). (The rounding factor was 2, when it should have been 1. Either way, it wasn't helping.)
// v1.03, Apr. 16, 2011 - Added support for optimized Huffman code tables, optimized dynamic memory allocation down to only 1 alloc.
//                        Also from Alex Evans: Added RGBA support, linear memory allocator (no longer needed in v1.03).
// v1.04, May. 19, 2012: Forgot to set m_pFile ptr to NULL in cfile_stream::close(). Thanks to Owen Kaluza for reporting this bug.
//                       Code tweaks to fix VS2008 static code analysis warnings (all looked harmless).
//                       Code review revealed method load_block_16_8_8() (used for the non-default H2V1 sampling mode to downsample chroma) somehow didn't get the rounding factor fix from v1.02.

#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#define JPGE_MAX(a,b) (((a)>(b))?(a):(b))
#define JPGE_MIN(a,b) (((a)<(b))?(a):(b))

namespace jpge {

static inline void *jpge_malloc(size_t nSize) { return malloc(nSize); }
static inline void jpge_free(void *p) { free(p); }

// Various JPEG enums and tables.
enum { M_SOF0 = 0xC0, M_DHT = 0xC4, M_SOI = 0xD8, M_EOI = 0xD9, M_SOS = 0xDA, M_DQT = 0xDB, M_APP0 = 0xE0 };
enum { DC_LUM_CODES = 12, AC_LUM_CODES = 256, DC_CHROMA_CODES = 12, AC_CHROMA_CODES = 256, MAX_HUFF_SYMBOLS = 257, MAX_HUFF_CODESIZE = 32 };

static uint8 s_zag[64] = { 0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63 };
static int16 s_std_lum_quant[64] = { 16,11,12,14,12,10,16,14,13,14,18,17,16,19,24,40,26,24,22,22,24,49,35,37,29,40,58,51,61,60,57,51,56,55,64,72,92,78,64,68,87,69,55,56,80,109,81,87,95,98,103,104,103,62,77,113,121,112,100,120,92,101,103,99 };
static int16 s_std_croma_quant[64] = { 17,18,18,24,21,24,47,26,26,47,99,66,56,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99 };
static uint8 s_dc_lum_bits[17] = { 0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0 };
static uint8 s_dc_lum_val[DC_LUM_CODES] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
static uint8 s_ac_lum_bits[17] = { 0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d };
static uint8 s_ac_lum_val[AC_LUM_CODES]  =
{
  0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
  0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
  0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
  0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
  0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
  0xf9,0xfa
};
static uint8 s_dc_chroma_bits[17] = { 0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };
static uint8 s_dc_chroma_val[DC_CHROMA_CODES]  = { 0,1,2,3,4,5,6,7,8,9,10,11 };
static uint8 s_ac_chroma_bits[17] = { 0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77 };
static uint8 s_ac_chroma_val[AC_CHROMA_CODES] =
{
  0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
  0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
  0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
  0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
  0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
  0xf9,0xfa
};

// Low-level helper functions.
template <class T> inline void clear_obj(T &obj) { memset(&obj, 0, sizeof(obj)); }

const int YR = 19595, YG = 38470, YB = 7471, CB_R = -11059, CB_G = -21709, CB_B = 32768, CR_R = 32768, CR_G = -27439, CR_B = -5329;
static inline uint8 clamp(int i) { if (static_cast<uint>(i) > 255U) { if (i < 0) i = 0; else if (i > 255) i = 255; } return static_cast<uint8>(i); }

static void RGB_to_YCC(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst += 3, pSrc += 3, num_pixels--)
  {
	const int r = pSrc[0], g = pSrc[1], b = pSrc[2];
	pDst[0] = static_cast<uint8>((r * YR + g * YG + b * YB + 32768) >> 16);
	pDst[1] = clamp(128 + ((r * CB_R + g * CB_G + b * CB_B + 32768) >> 16));
	pDst[2] = clamp(128 + ((r * CR_R + g * CR_G + b * CR_B + 32768) >> 16));
  }
}

static void RGB_to_Y(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst++, pSrc += 3, num_pixels--)
	pDst[0] = static_cast<uint8>((pSrc[0] * YR + pSrc[1] * YG + pSrc[2] * YB + 32768) >> 16);
}

static void RGBA_to_YCC(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst += 3, pSrc += 4, num_pixels--)
  {
	const int r = pSrc[0], g = pSrc[1], b = pSrc[2];
	pDst[0] = static_cast<uint8>((r * YR + g * YG + b * YB + 32768) >> 16);
	pDst[1] = clamp(128 + ((r * CB_R + g * CB_G + b * CB_B + 32768) >> 16));
	pDst[2] = clamp(128 + ((r * CR_R + g * CR_G + b * CR_B + 32768) >> 16));
  }
}

static void RGBA_to_Y(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst++, pSrc += 4, num_pixels--)
	pDst[0] = static_cast<uint8>((pSrc[0] * YR + pSrc[1] * YG + pSrc[2] * YB + 32768) >> 16);
}

static void Y_to_YCC(uint8* pDst, const uint8* pSrc, int num_pixels)
{
  for( ; num_pixels; pDst += 3, pSrc++, num_pixels--) { pDst[0] = pSrc[0]; pDst[1] = 128; pDst[2] = 128; }
}

// Forward DCT - DCT derived from jfdctint.
enum { CONST_BITS = 13, ROW_BITS = 2 };
#define DCT_DESCALE(x, n) (((x) + (((int32)1) << ((n) - 1))) >> (n))
#define DCT_MUL(var, c) (static_cast<int16>(var) * static_cast<int32>(c))
#define DCT1D(s0, s1, s2, s3, s4, s5, s6, s7) \
  int32 t0 = s0 + s7, t7 = s0 - s7, t1 = s1 + s6, t6 = s1 - s6, t2 = s2 + s5, t5 = s2 - s5, t3 = s3 + s4, t4 = s3 - s4; \
  int32 t10 = t0 + t3, t13 = t0 - t3, t11 = t1 + t2, t12 = t1 - t2; \
  int32 u1 = DCT_MUL(t12 + t13, 4433); \
  s2 = u1 + DCT_MUL(t13, 6270); \
  s6 = u1 + DCT_MUL(t12, -15137); \
  u1 = t4 + t7; \
  int32 u2 = t5 + t6, u3 = t4 + t6, u4 = t5 + t7; \
  int32 z5 = DCT_MUL(u3 + u4, 9633); \
  t4 = DCT_MUL(t4, 2446); t5 = DCT_MUL(t5, 16819); \
  t6 = DCT_MUL(t6, 25172); t7 = DCT_MUL(t7, 12299); \
  u1 = DCT_MUL(u1, -7373); u2 = DCT_MUL(u2, -20995); \
  u3 = DCT_MUL(u3, -16069); u4 = DCT_MUL(u4, -3196); \
  u3 += z5; u4 += z5; \
  s0 = t10 + t11; s1 = t7 + u1 + u4; s3 = t6 + u2 + u3; s4 = t10 - t11; s5 = t5 + u2 + u4; s7 = t4 + u1 + u3;

static void DCT2D(int32 *p)
{
  int32 c, *q = p;
  for (c = 7; c >= 0; c--, q += 8)
  {
	int32 s0 = q[0], s1 = q[1], s2 = q[2], s3 = q[3], s4 = q[4], s5 = q[5], s6 = q[6], s7 = q[7];
	DCT1D(s0, s1, s2, s3, s4, s5, s6, s7);
	q[0] = s0 << ROW_BITS; q[1] = DCT_DESCALE(s1, CONST_BITS-ROW_BITS); q[2] = DCT_DESCALE(s2, CONST_BITS-ROW_BITS); q[3] = DCT_DESCALE(s3, CONST_BITS-ROW_BITS);
	q[4] = s4 << ROW_BITS; q[5] = DCT_DESCALE(s5, CONST_BITS-ROW_BITS); q[6] = DCT_DESCALE(s6, CONST_BITS-ROW_BITS); q[7] = DCT_DESCALE(s7, CONST_BITS-ROW_BITS);
  }
  for (q = p, c = 7; c >= 0; c--, q++)
  {
	int32 s0 = q[0*8], s1 = q[1*8], s2 = q[2*8], s3 = q[3*8], s4 = q[4*8], s5 = q[5*8], s6 = q[6*8], s7 = q[7*8];
	DCT1D(s0, s1, s2, s3, s4, s5, s6, s7);
	q[0*8] = DCT_DESCALE(s0, ROW_BITS+3); q[1*8] = DCT_DESCALE(s1, CONST_BITS+ROW_BITS+3); q[2*8] = DCT_DESCALE(s2, CONST_BITS+ROW_BITS+3); q[3*8] = DCT_DESCALE(s3, CONST_BITS+ROW_BITS+3);
	q[4*8] = DCT_DESCALE(s4, ROW_BITS+3); q[5*8] = DCT_DESCALE(s5, CONST_BITS+ROW_BITS+3); q[6*8] = DCT_DESCALE(s6, CONST_BITS+ROW_BITS+3); q[7*8] = DCT_DESCALE(s7, CONST_BITS+ROW_BITS+3);
  }
}

struct sym_freq { uint m_key, m_sym_index; };

// Radix sorts sym_freq[] array by 32-bit key m_key. Returns ptr to sorted values.
static inline sym_freq* radix_sort_syms(uint num_syms, sym_freq* pSyms0, sym_freq* pSyms1)
{
  const uint cMaxPasses = 4;
  uint32 hist[256 * cMaxPasses]; clear_obj(hist);
  for (uint i = 0; i < num_syms; i++) { uint freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; hist[256*2 + ((freq >> 16) & 0xFF)]++; hist[256*3 + ((freq >> 24) & 0xFF)]++; }
  sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1;
  uint total_passes = cMaxPasses; while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;
  for (uint pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
  {
	const uint32* pHist = &hist[pass << 8];
	uint offsets[256], cur_ofs = 0;
	for (uint i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }
	for (uint i = 0; i < num_syms; i++)
	  pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
	sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t;
  }
  return pCur_syms;
}

// calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
static void calculate_minimum_redundancy(sym_freq *A, int n)
{
  int root, leaf, next, avbl, used, dpth;
  if (n==0) return; else if (n==1) { A[0].m_key = 1; return; }
  A[0].m_key += A[1].m_key; root = 0; leaf = 2;
  for (next=1; next < n-1; next++)
  {
	if (leaf>=n || A[root].m_key<A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = next; } else A[next].m_key = A[leaf++].m_key;
	if (leaf>=n || (root<next && A[root].m_key<A[leaf].m_key)) { A[next].m_key += A[root].m_key; A[root++].m_key = next; } else A[next].m_key += A[leaf++].m_key;
  }
  A[n-2].m_key = 0;
  for (next=n-3; next>=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;
  avbl = 1; used = dpth = 0; root = n-2; next = n-1;
  while (avbl>0)
  {
	while (root>=0 && (int)A[root].m_key==dpth) { used++; root--; }
	while (avbl>used) { A[next--].m_key = dpth; avbl--; }
	avbl = 2*used; dpth++; used = 0;
  }
}

// Limits canonical Huffman code table's max code size to max_code_size.
static void huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
{
  if (code_list_len <= 1) return;

  for (int i = max_code_size + 1; i <= MAX_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];

  uint32 total = 0;
  for (int i = max_code_size; i > 0; i--)
	total += (((uint32)pNum_codes[i]) << (max_code_size - i));

  while (total != (1UL << max_code_size))
  {
	pNum_codes[max_code_size]--;
	for (int i = max_code_size - 1; i > 0; i--)
	{
	  if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }
	}
	total--;
  }
}

// Generates an optimized offman table.
void jpeg_encoder::optimize_huffman_table(int table_num, int table_len)
{
  sym_freq syms0[MAX_HUFF_SYMBOLS], syms1[MAX_HUFF_SYMBOLS];
  syms0[0].m_key = 1; syms0[0].m_sym_index = 0;  // dummy symbol, assures that no valid code contains all 1's
  int num_used_syms = 1;
  const uint32 *pSym_count = &m_huff_count[table_num][0];
  for (int i = 0; i < table_len; i++)
	if (pSym_count[i]) { syms0[num_used_syms].m_key = pSym_count[i]; syms0[num_used_syms++].m_sym_index = i + 1; }
  sym_freq* pSyms = radix_sort_syms(num_used_syms, syms0, syms1);
  calculate_minimum_redundancy(pSyms, num_used_syms);

  // Count the # of symbols of each code size.
  int num_codes[1 + MAX_HUFF_CODESIZE]; clear_obj(num_codes);
  for (int i = 0; i < num_used_syms; i++)
	num_codes[pSyms[i].m_key]++;

  const uint JPGE_CODE_SIZE_LIMIT = 16; // the maximum possible size of a JPEG Huffman code (valid range is [9,16] - 9 vs. 8 because of the dummy symbol)
  huffman_enforce_max_code_size(num_codes, num_used_syms, JPGE_CODE_SIZE_LIMIT);

  // Compute m_huff_bits array, which contains the # of symbols per code size.
  clear_obj(m_huff_bits[table_num]);
  for (int i = 1; i <= (int)JPGE_CODE_SIZE_LIMIT; i++)
	m_huff_bits[table_num][i] = static_cast<uint8>(num_codes[i]);

  // Remove the dummy symbol added above, which must be in largest bucket.
  for (int i = JPGE_CODE_SIZE_LIMIT; i >= 1; i--)
  {
	if (m_huff_bits[table_num][i]) { m_huff_bits[table_num][i]--; break; }
  }

  // Compute the m_huff_val array, which contains the symbol indices sorted by code size (smallest to largest).
  for (int i = num_used_syms - 1; i >= 1; i--)
	m_huff_val[table_num][num_used_syms - 1 - i] = static_cast<uint8>(pSyms[i].m_sym_index - 1);
}

// JPEG marker generation.
void jpeg_encoder::emit_byte(uint8 i)
{
  m_all_stream_writes_succeeded = m_all_stream_writes_succeeded && m_pStream->put_obj(i);
}

void jpeg_encoder::emit_word(uint i)
{
  emit_byte(uint8(i >> 8)); emit_byte(uint8(i & 0xFF));
}

void jpeg_encoder::emit_marker(int marker)
{
  emit_byte(uint8(0xFF)); emit_byte(uint8(marker));
}

// Emit JFIF marker
void jpeg_encoder::emit_jfif_app0()
{
  emit_marker(M_APP0);
  emit_word(2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);
  emit_byte(0x4A); emit_byte(0x46); emit_byte(0x49); emit_byte(0x46); /* Identifier: ASCII "JFIF" */
  emit_byte(0);
  emit_byte(1);      /* Major version */
  emit_byte(1);      /* Minor version */
  emit_byte(0);      /* Density unit */
  emit_word(1);
  emit_word(1);
  emit_byte(0);      /* No thumbnail image */
  emit_byte(0);
}

// Emit quantization tables
void jpeg_encoder::emit_dqt()
{
  for (int i = 0; i < ((m_num_components == 3) ? 2 : 1); i++)
  {
	emit_marker(M_DQT);
	emit_word(64 + 1 + 2);
	emit_byte(static_cast<uint8>(i));
	for (int j = 0; j < 64; j++)
	  emit_byte(static_cast<uint8>(m_quantization_tables[i][j]));
  }
}

// Emit start of frame marker
void jpeg_encoder::emit_sof()
{
  emit_marker(M_SOF0);                           /* baseline */
  emit_word(3 * m_num_components + 2 + 5 + 1);
  emit_byte(8);                                  /* precision */
  emit_word(m_image_y);
  emit_word(m_image_x);
  emit_byte(m_num_components);
  for (int i = 0; i < m_num_components; i++)
  {
	emit_byte(static_cast<uint8>(i + 1));                                   /* component ID     */
	emit_byte((m_comp_h_samp[i] << 4) + m_comp_v_samp[i]);  /* h and v sampling */
	emit_byte(i > 0);                                   /* quant. table num */
  }
}

// Emit Huffman table.
void jpeg_encoder::emit_dht(uint8 *bits, uint8 *val, int index, bool ac_flag)
{
  emit_marker(M_DHT);

  int length = 0;
  for (int i = 1; i <= 16; i++)
	length += bits[i];

  emit_word(length + 2 + 1 + 16);
  emit_byte(static_cast<uint8>(index + (ac_flag << 4)));

  for (int i = 1; i <= 16; i++)
	emit_byte(bits[i]);

  for (int i = 0; i < length; i++)
	emit_byte(val[i]);
}

// Emit all Huffman tables.
void jpeg_encoder::emit_dhts()
{
  emit_dht(m_huff_bits[0+0], m_huff_val[0+0], 0, false);
  emit_dht(m_huff_bits[2+0], m_huff_val[2+0], 0, true);
  if (m_num_components == 3)
  {
	emit_dht(m_huff_bits[0+1], m_huff_val[0+1], 1, false);
	emit_dht(m_huff_bits[2+1], m_huff_val[2+1], 1, true);
  }
}

// emit start of scan
void jpeg_encoder::emit_sos()
{
  emit_marker(M_SOS);
  emit_word(2 * m_num_components + 2 + 1 + 3);
  emit_byte(m_num_components);
  for (int i = 0; i < m_num_components; i++)
  {
	emit_byte(static_cast<uint8>(i + 1));
	if (i == 0)
	  emit_byte((0 << 4) + 0);
	else
	  emit_byte((1 << 4) + 1);
  }
  emit_byte(0);     /* spectral selection */
  emit_byte(63);
  emit_byte(0);
}

// Emit all markers at beginning of image file.
void jpeg_encoder::emit_markers()
{
  emit_marker(M_SOI);
  emit_jfif_app0();
  emit_dqt();
  emit_sof();
  emit_dhts();
  emit_sos();
}

// Compute the actual canonical Huffman codes/code sizes given the JPEG huff bits and val arrays.
void jpeg_encoder::compute_huffman_table(uint *codes, uint8 *code_sizes, uint8 *bits, uint8 *val)
{
  int i, l, last_p, si;
  uint8 huff_size[257];
  uint huff_code[257];
  uint code;

  int p = 0;
  for (l = 1; l <= 16; l++)
	for (i = 1; i <= bits[l]; i++)
	  huff_size[p++] = (char)l;

  huff_size[p] = 0; last_p = p; // write sentinel

  code = 0; si = huff_size[0]; p = 0;

  while (huff_size[p])
  {
	while (huff_size[p] == si)
	  huff_code[p++] = code++;
	code <<= 1;
	si++;
  }

  memset(codes, 0, sizeof(codes[0])*256);
  memset(code_sizes, 0, sizeof(code_sizes[0])*256);
  for (p = 0; p < last_p; p++)
  {
	codes[val[p]]      = huff_code[p];
	code_sizes[val[p]] = huff_size[p];
  }
}

// Quantization table generation.
void jpeg_encoder::compute_quant_table(int32 *pDst, int16 *pSrc)
{
  int32 q;
  if (m_params.m_quality < 50)
	q = 5000 / m_params.m_quality;
  else
	q = 200 - m_params.m_quality * 2;
  for (int i = 0; i < 64; i++)
  {
	int32 j = *pSrc++; j = (j * q + 50L) / 100L;
	*pDst++ = JPGE_MIN(JPGE_MAX(j, 1), 255);
  }
}

// Higher-level methods.
void jpeg_encoder::first_pass_init()
{
  m_bit_buffer = 0; m_bits_in = 0;
  memset(m_last_dc_val, 0, 3 * sizeof(m_last_dc_val[0]));
  m_mcu_y_ofs = 0;
  m_pass_num = 1;
}

bool jpeg_encoder::second_pass_init()
{
  compute_huffman_table(&m_huff_codes[0+0][0], &m_huff_code_sizes[0+0][0], m_huff_bits[0+0], m_huff_val[0+0]);
  compute_huffman_table(&m_huff_codes[2+0][0], &m_huff_code_sizes[2+0][0], m_huff_bits[2+0], m_huff_val[2+0]);
  if (m_num_components > 1)
  {
	compute_huffman_table(&m_huff_codes[0+1][0], &m_huff_code_sizes[0+1][0], m_huff_bits[0+1], m_huff_val[0+1]);
	compute_huffman_table(&m_huff_codes[2+1][0], &m_huff_code_sizes[2+1][0], m_huff_bits[2+1], m_huff_val[2+1]);
  }
  first_pass_init();
  emit_markers();
  m_pass_num = 2;
  return true;
}

bool jpeg_encoder::jpg_open(int p_x_res, int p_y_res, int src_channels)
{
  m_num_components = 3;
  switch (m_params.m_subsampling)
  {
	case Y_ONLY:
	{
	  m_num_components = 1;
	  m_comp_h_samp[0] = 1; m_comp_v_samp[0] = 1;
	  m_mcu_x          = 8; m_mcu_y          = 8;
	  break;
	}
	case H1V1:
	{
	  m_comp_h_samp[0] = 1; m_comp_v_samp[0] = 1;
	  m_comp_h_samp[1] = 1; m_comp_v_samp[1] = 1;
	  m_comp_h_samp[2] = 1; m_comp_v_samp[2] = 1;
	  m_mcu_x          = 8; m_mcu_y          = 8;
	  break;
	}
	case H2V1:
	{
	  m_comp_h_samp[0] = 2; m_comp_v_samp[0] = 1;
	  m_comp_h_samp[1] = 1; m_comp_v_samp[1] = 1;
	  m_comp_h_samp[2] = 1; m_comp_v_samp[2] = 1;
	  m_mcu_x          = 16; m_mcu_y         = 8;
	  break;
	}
	case H2V2:
	{
	  m_comp_h_samp[0] = 2; m_comp_v_samp[0] = 2;
	  m_comp_h_samp[1] = 1; m_comp_v_samp[1] = 1;
	  m_comp_h_samp[2] = 1; m_comp_v_samp[2] = 1;
	  m_mcu_x          = 16; m_mcu_y         = 16;
	}
  }

  m_image_x        = p_x_res; m_image_y = p_y_res;
  m_image_bpp      = src_channels;
  m_image_bpl      = m_image_x * src_channels;
  m_image_x_mcu    = (m_image_x + m_mcu_x - 1) & (~(m_mcu_x - 1));
  m_image_y_mcu    = (m_image_y + m_mcu_y - 1) & (~(m_mcu_y - 1));
  m_image_bpl_xlt  = m_image_x * m_num_components;
  m_image_bpl_mcu  = m_image_x_mcu * m_num_components;
  m_mcus_per_row   = m_image_x_mcu / m_mcu_x;

  if ((m_mcu_lines[0] = static_cast<uint8*>(jpge_malloc(m_image_bpl_mcu * m_mcu_y))) == NULL) return false;
  for (int i = 1; i < m_mcu_y; i++)
	m_mcu_lines[i] = m_mcu_lines[i-1] + m_image_bpl_mcu;

  compute_quant_table(m_quantization_tables[0], s_std_lum_quant);
  compute_quant_table(m_quantization_tables[1], m_params.m_no_chroma_discrim_flag ? s_std_lum_quant : s_std_croma_quant);

  m_out_buf_left = JPGE_OUT_BUF_SIZE;
  m_pOut_buf = m_out_buf;

  if (m_params.m_two_pass_flag)
  {
	clear_obj(m_huff_count);
	first_pass_init();
  }
  else
  {
	memcpy(m_huff_bits[0+0], s_dc_lum_bits, 17);    memcpy(m_huff_val [0+0], s_dc_lum_val, DC_LUM_CODES);
	memcpy(m_huff_bits[2+0], s_ac_lum_bits, 17);    memcpy(m_huff_val [2+0], s_ac_lum_val, AC_LUM_CODES);
	memcpy(m_huff_bits[0+1], s_dc_chroma_bits, 17); memcpy(m_huff_val [0+1], s_dc_chroma_val, DC_CHROMA_CODES);
	memcpy(m_huff_bits[2+1], s_ac_chroma_bits, 17); memcpy(m_huff_val [2+1], s_ac_chroma_val, AC_CHROMA_CODES);
	if (!second_pass_init()) return false;   // in effect, skip over the first pass
  }
  return m_all_stream_writes_succeeded;
}

void jpeg_encoder::load_block_8_8_grey(int x)
{
  uint8 *pSrc;
  sample_array_t *pDst = m_sample_array;
  x <<= 3;
  for (int i = 0; i < 8; i++, pDst += 8)
  {
	pSrc = m_mcu_lines[i] + x;
	pDst[0] = pSrc[0] - 128; pDst[1] = pSrc[1] - 128; pDst[2] = pSrc[2] - 128; pDst[3] = pSrc[3] - 128;
	pDst[4] = pSrc[4] - 128; pDst[5] = pSrc[5] - 128; pDst[6] = pSrc[6] - 128; pDst[7] = pSrc[7] - 128;
  }
}

void jpeg_encoder::load_block_8_8(int x, int y, int c)
{
  uint8 *pSrc;
  sample_array_t *pDst = m_sample_array;
  x = (x * (8 * 3)) + c;
  y <<= 3;
  for (int i = 0; i < 8; i++, pDst += 8)
  {
	pSrc = m_mcu_lines[y + i] + x;
	pDst[0] = pSrc[0 * 3] - 128; pDst[1] = pSrc[1 * 3] - 128; pDst[2] = pSrc[2 * 3] - 128; pDst[3] = pSrc[3 * 3] - 128;
	pDst[4] = pSrc[4 * 3] - 128; pDst[5] = pSrc[5 * 3] - 128; pDst[6] = pSrc[6 * 3] - 128; pDst[7] = pSrc[7 * 3] - 128;
  }
}

void jpeg_encoder::load_block_16_8(int x, int c)
{
  uint8 *pSrc1, *pSrc2;
  sample_array_t *pDst = m_sample_array;
  x = (x * (16 * 3)) + c;
  int a = 0, b = 2;
  for (int i = 0; i < 16; i += 2, pDst += 8)
  {
	pSrc1 = m_mcu_lines[i + 0] + x;
	pSrc2 = m_mcu_lines[i + 1] + x;
	pDst[0] = ((pSrc1[ 0 * 3] + pSrc1[ 1 * 3] + pSrc2[ 0 * 3] + pSrc2[ 1 * 3] + a) >> 2) - 128; pDst[1] = ((pSrc1[ 2 * 3] + pSrc1[ 3 * 3] + pSrc2[ 2 * 3] + pSrc2[ 3 * 3] + b) >> 2) - 128;
	pDst[2] = ((pSrc1[ 4 * 3] + pSrc1[ 5 * 3] + pSrc2[ 4 * 3] + pSrc2[ 5 * 3] + a) >> 2) - 128; pDst[3] = ((pSrc1[ 6 * 3] + pSrc1[ 7 * 3] + pSrc2[ 6 * 3] + pSrc2[ 7 * 3] + b) >> 2) - 128;
	pDst[4] = ((pSrc1[ 8 * 3] + pSrc1[ 9 * 3] + pSrc2[ 8 * 3] + pSrc2[ 9 * 3] + a) >> 2) - 128; pDst[5] = ((pSrc1[10 * 3] + pSrc1[11 * 3] + pSrc2[10 * 3] + pSrc2[11 * 3] + b) >> 2) - 128;
	pDst[6] = ((pSrc1[12 * 3] + pSrc1[13 * 3] + pSrc2[12 * 3] + pSrc2[13 * 3] + a) >> 2) - 128; pDst[7] = ((pSrc1[14 * 3] + pSrc1[15 * 3] + pSrc2[14 * 3] + pSrc2[15 * 3] + b) >> 2) - 128;
	int temp = a; a = b; b = temp;
  }
}

void jpeg_encoder::load_block_16_8_8(int x, int c)
{
  uint8 *pSrc1;
  sample_array_t *pDst = m_sample_array;
  x = (x * (16 * 3)) + c;
  for (int i = 0; i < 8; i++, pDst += 8)
  {
	pSrc1 = m_mcu_lines[i + 0] + x;
	pDst[0] = ((pSrc1[ 0 * 3] + pSrc1[ 1 * 3]) >> 1) - 128; pDst[1] = ((pSrc1[ 2 * 3] + pSrc1[ 3 * 3]) >> 1) - 128;
	pDst[2] = ((pSrc1[ 4 * 3] + pSrc1[ 5 * 3]) >> 1) - 128; pDst[3] = ((pSrc1[ 6 * 3] + pSrc1[ 7 * 3]) >> 1) - 128;
	pDst[4] = ((pSrc1[ 8 * 3] + pSrc1[ 9 * 3]) >> 1) - 128; pDst[5] = ((pSrc1[10 * 3] + pSrc1[11 * 3]) >> 1) - 128;
	pDst[6] = ((pSrc1[12 * 3] + pSrc1[13 * 3]) >> 1) - 128; pDst[7] = ((pSrc1[14 * 3] + pSrc1[15 * 3]) >> 1) - 128;
  }
}

void jpeg_encoder::load_quantized_coefficients(int component_num)
{
  int32 *q = m_quantization_tables[component_num > 0];
  int16 *pDst = m_coefficient_array;
  for (int i = 0; i < 64; i++)
  {
	sample_array_t j = m_sample_array[s_zag[i]];
	if (j < 0)
	{
	  if ((j = -j + (*q >> 1)) < *q)
		*pDst++ = 0;
	  else
		*pDst++ = static_cast<int16>(-(j / *q));
	}
	else
	{
	  if ((j = j + (*q >> 1)) < *q)
		*pDst++ = 0;
	  else
		*pDst++ = static_cast<int16>((j / *q));
	}
	q++;
  }
}

void jpeg_encoder::flush_output_buffer()
{
  if (m_out_buf_left != JPGE_OUT_BUF_SIZE)
	m_all_stream_writes_succeeded = m_all_stream_writes_succeeded && m_pStream->put_buf(m_out_buf, JPGE_OUT_BUF_SIZE - m_out_buf_left);
  m_pOut_buf = m_out_buf;
  m_out_buf_left = JPGE_OUT_BUF_SIZE;
}

void jpeg_encoder::put_bits(uint bits, uint len)
{
  m_bit_buffer |= ((uint32)bits << (24 - (m_bits_in += len)));
  while (m_bits_in >= 8)
  {
	uint8 c;
	#define JPGE_PUT_BYTE(c) { *m_pOut_buf++ = (c); if (--m_out_buf_left == 0) flush_output_buffer(); }
	JPGE_PUT_BYTE(c = (uint8)((m_bit_buffer >> 16) & 0xFF));
	if (c == 0xFF) JPGE_PUT_BYTE(0);
	m_bit_buffer <<= 8;
	m_bits_in -= 8;
  }
}

void jpeg_encoder::code_coefficients_pass_one(int component_num)
{
  if (component_num >= 3) return; // just to shut up static analysis
  int i, run_len, nbits, temp1;
  int16 *src = m_coefficient_array;
  uint32 *dc_count = component_num ? m_huff_count[0 + 1] : m_huff_count[0 + 0], *ac_count = component_num ? m_huff_count[2 + 1] : m_huff_count[2 + 0];

  temp1 = src[0] - m_last_dc_val[component_num];
  m_last_dc_val[component_num] = src[0];
  if (temp1 < 0) temp1 = -temp1;

  nbits = 0;
  while (temp1)
  {
	nbits++; temp1 >>= 1;
  }

  dc_count[nbits]++;
  for (run_len = 0, i = 1; i < 64; i++)
  {
	if ((temp1 = m_coefficient_array[i]) == 0)
	  run_len++;
	else
	{
	  while (run_len >= 16)
	  {
		ac_count[0xF0]++;
		run_len -= 16;
	  }
	  if (temp1 < 0) temp1 = -temp1;
	  nbits = 1;
	  while (temp1 >>= 1) nbits++;
	  ac_count[(run_len << 4) + nbits]++;
	  run_len = 0;
	}
  }
  if (run_len) ac_count[0]++;
}

void jpeg_encoder::code_coefficients_pass_two(int component_num)
{
  int i, j, run_len, nbits, temp1, temp2;
  int16 *pSrc = m_coefficient_array;
  uint *codes[2];
  uint8 *code_sizes[2];

  if (component_num == 0)
  {
	codes[0] = m_huff_codes[0 + 0]; codes[1] = m_huff_codes[2 + 0];
	code_sizes[0] = m_huff_code_sizes[0 + 0]; code_sizes[1] = m_huff_code_sizes[2 + 0];
  }
  else
  {
	codes[0] = m_huff_codes[0 + 1]; codes[1] = m_huff_codes[2 + 1];
	code_sizes[0] = m_huff_code_sizes[0 + 1]; code_sizes[1] = m_huff_code_sizes[2 + 1];
  }

  temp1 = temp2 = pSrc[0] - m_last_dc_val[component_num];
  m_last_dc_val[component_num] = pSrc[0];

  if (temp1 < 0)
  {
	temp1 = -temp1; temp2--;
  }

  nbits = 0;
  while (temp1)
  {
	nbits++; temp1 >>= 1;
  }

  put_bits(codes[0][nbits], code_sizes[0][nbits]);
  if (nbits) put_bits(temp2 & ((1 << nbits) - 1), nbits);

  for (run_len = 0, i = 1; i < 64; i++)
  {
	if ((temp1 = m_coefficient_array[i]) == 0)
	  run_len++;
	else
	{
	  while (run_len >= 16)
	  {
		put_bits(codes[1][0xF0], code_sizes[1][0xF0]);
		run_len -= 16;
	  }
	  if ((temp2 = temp1) < 0)
	  {
		temp1 = -temp1;
		temp2--;
	  }
	  nbits = 1;
	  while (temp1 >>= 1)
		nbits++;
	  j = (run_len << 4) + nbits;
	  put_bits(codes[1][j], code_sizes[1][j]);
	  put_bits(temp2 & ((1 << nbits) - 1), nbits);
	  run_len = 0;
	}
  }
  if (run_len)
	put_bits(codes[1][0], code_sizes[1][0]);
}

void jpeg_encoder::code_block(int component_num)
{
  DCT2D(m_sample_array);
  load_quantized_coefficients(component_num);
  if (m_pass_num == 1)
	code_coefficients_pass_one(component_num);
  else
	code_coefficients_pass_two(component_num);
}

void jpeg_encoder::process_mcu_row()
{
  if (m_num_components == 1)
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8_grey(i); code_block(0);
	}
  }
  else if ((m_comp_h_samp[0] == 1) && (m_comp_v_samp[0] == 1))
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8(i, 0, 0); code_block(0); load_block_8_8(i, 0, 1); code_block(1); load_block_8_8(i, 0, 2); code_block(2);
	}
  }
  else if ((m_comp_h_samp[0] == 2) && (m_comp_v_samp[0] == 1))
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8(i * 2 + 0, 0, 0); code_block(0); load_block_8_8(i * 2 + 1, 0, 0); code_block(0);
	  load_block_16_8_8(i, 1); code_block(1); load_block_16_8_8(i, 2); code_block(2);
	}
  }
  else if ((m_comp_h_samp[0] == 2) && (m_comp_v_samp[0] == 2))
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8(i * 2 + 0, 0, 0); code_block(0); load_block_8_8(i * 2 + 1, 0, 0); code_block(0);
	  load_block_8_8(i * 2 + 0, 1, 0); code_block(0); load_block_8_8(i * 2 + 1, 1, 0); code_block(0);
	  load_block_16_8(i, 1); code_block(1); load_block_16_8(i, 2); code_block(2);
	}
  }
}

bool jpeg_encoder::terminate_pass_one()
{
  optimize_huffman_table(0+0, DC_LUM_CODES); optimize_huffman_table(2+0, AC_LUM_CODES);
  if (m_num_components > 1)
  {
	optimize_huffman_table(0+1, DC_CHROMA_CODES); optimize_huffman_table(2+1, AC_CHROMA_CODES);
  }
  return second_pass_init();
}

bool jpeg_encoder::terminate_pass_two()
{
  put_bits(0x7F, 7);
  flush_output_buffer();
  emit_marker(M_EOI);
  m_pass_num++; // purposely bump up m_pass_num, for debugging
  return true;
}

bool jpeg_encoder::process_end_of_image()
{
  if (m_mcu_y_ofs)
  {
	if (m_mcu_y_ofs < 16) // check here just to shut up static analysis
	{
	  for (int i = m_mcu_y_ofs; i < m_mcu_y; i++)
		memcpy(m_mcu_lines[i], m_mcu_lines[m_mcu_y_ofs - 1], m_image_bpl_mcu);
	}

	process_mcu_row();
  }

  if (m_pass_num == 1)
	return terminate_pass_one();
  else
	return terminate_pass_two();
}

void jpeg_encoder::load_mcu(const void *pSrc)
{
  const uint8* Psrc = reinterpret_cast<const uint8*>(pSrc);

  uint8* pDst = m_mcu_lines[m_mcu_y_ofs]; // OK to write up to m_image_bpl_xlt bytes to pDst

  if (m_num_components == 1)
  {
	if (m_image_bpp == 4)
	  RGBA_to_Y(pDst, Psrc, m_image_x);
	else if (m_image_bpp == 3)
	  RGB_to_Y(pDst, Psrc, m_image_x);
	else
	  memcpy(pDst, Psrc, m_image_x);
  }
  else
  {
	if (m_image_bpp == 4)
	  RGBA_to_YCC(pDst, Psrc, m_image_x);
	else if (m_image_bpp == 3)
	  RGB_to_YCC(pDst, Psrc, m_image_x);
	else
	  Y_to_YCC(pDst, Psrc, m_image_x);
  }

  // Possibly duplicate pixels at end of scanline if not a multiple of 8 or 16
  if (m_num_components == 1)
	memset(m_mcu_lines[m_mcu_y_ofs] + m_image_bpl_xlt, pDst[m_image_bpl_xlt - 1], m_image_x_mcu - m_image_x);
  else
  {
	const uint8 y = pDst[m_image_bpl_xlt - 3 + 0], cb = pDst[m_image_bpl_xlt - 3 + 1], cr = pDst[m_image_bpl_xlt - 3 + 2];
	uint8 *q = m_mcu_lines[m_mcu_y_ofs] + m_image_bpl_xlt;
	for (int i = m_image_x; i < m_image_x_mcu; i++)
	{
	  *q++ = y; *q++ = cb; *q++ = cr;
	}
  }

  if (++m_mcu_y_ofs == m_mcu_y)
  {
	process_mcu_row();
	m_mcu_y_ofs = 0;
  }
}

void jpeg_encoder::clear()
{
  m_mcu_lines[0] = NULL;
  m_pass_num = 0;
  m_all_stream_writes_succeeded = true;
}

jpeg_encoder::jpeg_encoder()
{
  clear();
}

jpeg_encoder::~jpeg_encoder()
{
  deinit();
}

bool jpeg_encoder::init(output_stream *pStream, int width, int height, int src_channels, const params &comp_params)
{
  deinit();
  if (((!pStream) || (width < 1) || (height < 1)) || ((src_channels != 1) && (src_channels != 3) && (src_channels != 4)) || (!comp_params.check())) return false;
  m_pStream = pStream;
  m_params = comp_params;
  return jpg_open(width, height, src_channels);
}

void jpeg_encoder::deinit()
{
  jpge_free(m_mcu_lines[0]);
  clear();
}

bool jpeg_encoder::process_scanline(const void* pScanline)
{
  if ((m_pass_num < 1) || (m_pass_num > 2)) return false;
  if (m_all_stream_writes_succeeded)
  {
	if (!pScanline)
	{
	  if (!process_end_of_image()) return false;
	}
	else
	{
	  load_mcu(pScanline);
	}
  }
  return m_all_stream_writes_succeeded;
}

// Higher level wrappers/examples (optional).
#include <stdio.h>

class cfile_stream : public output_stream
{
   cfile_stream(const cfile_stream &);
   cfile_stream &operator= (const cfile_stream &);

   FILE* m_pFile;
   bool m_bStatus;

public:
   cfile_stream() : m_pFile(NULL), m_bStatus(false) { }

   virtual ~cfile_stream()
   {
	  close();
   }

   bool open(const char *pFilename)
   {
	  close();
	  m_pFile = fopen(pFilename, "wb");
	  m_bStatus = (m_pFile != NULL);
	  return m_bStatus;
   }

   bool close()
   {
	  if (m_pFile)
	  {
		 if (fclose(m_pFile) == EOF)
		 {
			m_bStatus = false;
		 }
		 m_pFile = NULL;
	  }
	  return m_bStatus;
   }

   virtual bool put_buf(const void* pBuf, int len)
   {
	  m_bStatus = m_bStatus && (fwrite(pBuf, len, 1, m_pFile) == 1);
	  return m_bStatus;
   }

   uint get_size() const
   {
	  return m_pFile ? ftell(m_pFile) : 0;
   }
};

// Writes JPEG image to file.
bool compress_image_to_jpeg_file(const char *pFilename, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params)
{
  cfile_stream dst_stream;
  if (!dst_stream.open(pFilename))
	return false;

  jpge::jpeg_encoder dst_image;
  if (!dst_image.init(&dst_stream, width, height, num_channels, comp_params))
	return false;

  for (uint pass_index = 0; pass_index < dst_image.get_total_passes(); pass_index++)
  {
	for (int i = 0; i < height; i++)
	{
	   const uint8* pBuf = pImage_data + i * width * num_channels;
	   if (!dst_image.process_scanline(pBuf))
		  return false;
	}
	if (!dst_image.process_scanline(NULL))
	   return false;
  }

  dst_image.deinit();

  return dst_stream.close();
}

class memory_stream : public output_stream
{
   memory_stream(const memory_stream &);
   memory_stream &operator= (const memory_stream &);

   uint8 *m_pBuf;
   uint m_buf_size, m_buf_ofs;

public:
   memory_stream(void *pBuf, uint buf_size) : m_pBuf(static_cast<uint8*>(pBuf)), m_buf_size(buf_size), m_buf_ofs(0) { }

   virtual ~memory_stream() { }

   virtual bool put_buf(const void* pBuf, int len)
   {
	  uint buf_remaining = m_buf_size - m_buf_ofs;
	  if ((uint)len > buf_remaining)
		 return false;
	  memcpy(m_pBuf + m_buf_ofs, pBuf, len);
	  m_buf_ofs += len;
	  return true;
   }

   uint get_size() const
   {
	  return m_buf_ofs;
   }
};

bool compress_image_to_jpeg_file_in_memory(void *pDstBuf, int &buf_size, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params)
{
   if ((!pDstBuf) || (!buf_size))
	  return false;

   memory_stream dst_stream(pDstBuf, buf_size);

   buf_size = 0;

   jpge::jpeg_encoder dst_image;
   if (!dst_image.init(&dst_stream, width, height, num_channels, comp_params))
	  return false;

   for (uint pass_index = 0; pass_index < dst_image.get_total_passes(); pass_index++)
   {
	 for (int i = 0; i < height; i++)
	 {
		const uint8* pScanline = pImage_data + i * width * num_channels;
		if (!dst_image.process_scanline(pScanline))
		   return false;
	 }
	 if (!dst_image.process_scanline(NULL))
		return false;
   }

   dst_image.deinit();

   buf_size = dst_stream.get_size();
   return true;
}

} // namespace jpge


//#line 1 "lodepng.h"
#ifndef LODEPNG_H
#define LODEPNG_H

#include <string.h> /*for size_t*/

#ifdef __cplusplus
#include <vector>
#include <string>
#endif /*__cplusplus*/

#define LODEPNG_VERSION_STRING "20141130"

/*
The following #defines are used to create code sections. They can be disabled
to disable code sections, which can give faster compile time and smaller binary.
The "NO_COMPILE" defines are designed to be used to pass as defines to the
compiler command to disable them without modifying this header, e.g.
-DLODEPNG_NO_COMPILE_ZLIB for gcc.
*/
/*deflate & zlib. If disabled, you must specify alternative zlib functions in
the custom_zlib field of the compress and decompress settings*/
#ifndef LODEPNG_NO_COMPILE_ZLIB
#define LODEPNG_COMPILE_ZLIB
#endif
/*png encoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_PNG
#define LODEPNG_COMPILE_PNG
#endif
/*deflate&zlib decoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_DECODER
#define LODEPNG_COMPILE_DECODER
#endif
/*deflate&zlib encoder and png encoder*/
#ifndef LODEPNG_NO_COMPILE_ENCODER
#define LODEPNG_COMPILE_ENCODER
#endif
/*the optional built in harddisk file loading and saving functions*/
#ifndef LODEPNG_NO_COMPILE_DISK
#define LODEPNG_COMPILE_DISK
#endif
/*support for chunks other than IHDR, IDAT, PLTE, tRNS, IEND: ancillary and unknown chunks*/
#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS
#define LODEPNG_COMPILE_ANCILLARY_CHUNKS
#endif
/*ability to convert error numerical codes to English text string*/
#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT
#define LODEPNG_COMPILE_ERROR_TEXT
#endif
/*Compile the default allocators (C's free, malloc and realloc). If you disable this,
you can define the functions lodepng_free, lodepng_malloc and lodepng_realloc in your
source files with custom allocators.*/
#ifndef LODEPNG_NO_COMPILE_ALLOCATORS
#define LODEPNG_COMPILE_ALLOCATORS
#endif
/*compile the C++ version (you can disable the C++ wrapper here even when compiling for C++)*/
#ifdef __cplusplus
#ifndef LODEPNG_NO_COMPILE_CPP
#define LODEPNG_COMPILE_CPP
#endif
#endif

#ifdef LODEPNG_COMPILE_PNG
/*The PNG color types (also used for raw).*/
typedef enum LodePNGColorType
{
  LCT_GREY = 0, /*greyscale: 1,2,4,8,16 bit*/
  LCT_RGB = 2, /*RGB: 8,16 bit*/
  LCT_PALETTE = 3, /*palette: 1,2,4,8 bit*/
  LCT_GREY_ALPHA = 4, /*greyscale with alpha: 8,16 bit*/
  LCT_RGBA = 6 /*RGB with alpha: 8,16 bit*/
} LodePNGColorType;

#ifdef LODEPNG_COMPILE_DECODER
/*
Converts PNG data in memory to raw pixel data.
out: Output parameter. Pointer to buffer that will contain the raw pixel data.
	 After decoding, its size is w * h * (bytes per pixel) bytes larger than
	 initially. Bytes per pixel depends on colortype and bitdepth.
	 Must be freed after usage with free(*out).
	 Note: for 16-bit per channel colors, uses big endian format like PNG does.
w: Output parameter. Pointer to width of pixel data.
h: Output parameter. Pointer to height of pixel data.
in: Memory buffer with the PNG file.
insize: size of the in buffer.
colortype: the desired color type for the raw output image. See explanation on PNG color types.
bitdepth: the desired bit depth for the raw output image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h,
							   const unsigned char* in, size_t insize,
							   LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_memory, but always decodes to 32-bit RGBA raw image*/
unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h,
						  const unsigned char* in, size_t insize);

/*Same as lodepng_decode_memory, but always decodes to 24-bit RGB raw image*/
unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h,
						  const unsigned char* in, size_t insize);

#ifdef LODEPNG_COMPILE_DISK
/*
Load PNG from disk, from file with given name.
Same as the other decode functions, but instead takes a filename as input.
*/
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h,
							 const char* filename,
							 LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_file, but always decodes to 32-bit RGBA raw image.*/
unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h,
							   const char* filename);

/*Same as lodepng_decode_file, but always decodes to 24-bit RGB raw image.*/
unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h,
							   const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Converts raw pixel data into a PNG image in memory. The colortype and bitdepth
  of the output PNG image cannot be chosen, they are automatically determined
  by the colortype, bitdepth and content of the input pixel data.
  Note: for 16-bit per channel colors, needs big endian format like PNG does.
out: Output parameter. Pointer to buffer that will contain the PNG image data.
	 Must be freed after usage with free(*out).
outsize: Output parameter. Pointer to the size in bytes of the out buffer.
image: The raw pixel data to encode. The size of this buffer should be
	   w * h * (bytes per pixel), bytes per pixel depends on colortype and bitdepth.
w: width of the raw pixel data in pixels.
h: height of the raw pixel data in pixels.
colortype: the color type of the raw input image. See explanation on PNG color types.
bitdepth: the bit depth of the raw input image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize,
							   const unsigned char* image, unsigned w, unsigned h,
							   LodePNGColorType colortype, unsigned bitdepth);

/* @r-lyeh { */
unsigned lodepng_encode_memory_std(unsigned char** out, size_t* outsize,
							   const unsigned char* image, unsigned w, unsigned h,
							   unsigned colortype, unsigned bitdepth);
/* } */

/*Same as lodepng_encode_memory, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32(unsigned char** out, size_t* outsize,
						  const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_memory, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24(unsigned char** out, size_t* outsize,
						  const unsigned char* image, unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DISK
/*
Converts raw pixel data into a PNG file on disk.
Same as the other encode functions, but instead takes a filename as output.
NOTE: This overwrites existing files without warning!
*/
unsigned lodepng_encode_file(const char* filename,
							 const unsigned char* image, unsigned w, unsigned h,
							 LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_encode_file, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32_file(const char* filename,
							   const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_file, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24_file(const char* filename,
							   const unsigned char* image, unsigned w, unsigned h);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_CPP
namespace lodepng
{
#ifdef LODEPNG_COMPILE_DECODER
/*Same as lodepng_decode_memory, but decodes to an std::vector. The colortype
is the format to output the pixels to. Default is RGBA 8-bit per channel.*/
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const unsigned char* in, size_t insize,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const std::vector<unsigned char>& in,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
/*
Converts PNG file from disk to raw pixel data in memory.
Same as the other decode functions, but instead takes a filename as input.
*/
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const std::string& filename,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_DECODER

#ifdef LODEPNG_COMPILE_ENCODER
/*Same as lodepng_encode_memory, but encodes to an std::vector. colortype
is that of the raw input data. The output PNG color type will be auto chosen.*/
unsigned encode(std::vector<unsigned char>& out,
				const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
/*
Converts 32-bit RGBA raw pixel data into a PNG file on disk.
Same as the other encode functions, but instead takes a filename as output.
NOTE: This overwrites existing files without warning!
*/
unsigned encode(const std::string& filename,
				const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned encode(const std::string& filename,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_ENCODER
} //namespace lodepng
#endif /*LODEPNG_COMPILE_CPP*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*Returns an English description of the numerical error code.*/
const char* lodepng_error_text(unsigned code);
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/

#ifdef LODEPNG_COMPILE_DECODER
/*Settings for zlib decompression*/
typedef struct LodePNGDecompressSettings LodePNGDecompressSettings;
struct LodePNGDecompressSettings
{
  unsigned ignore_adler32; /*if 1, continue and don't give an error message if the Adler32 checksum is corrupted*/

  /*use custom zlib decoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
						  const unsigned char*, size_t,
						  const LodePNGDecompressSettings*);
  /*use custom deflate decoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_inflate)(unsigned char**, size_t*,
							 const unsigned char*, size_t,
							 const LodePNGDecompressSettings*);

  const void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGDecompressSettings lodepng_default_decompress_settings;
void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Settings for zlib compression. Tweaking these settings tweaks the balance
between speed and compression ratio.
*/
typedef struct LodePNGCompressSettings LodePNGCompressSettings;
struct LodePNGCompressSettings /*deflate = compress*/
{
  /*LZ77 related settings*/
  unsigned btype; /*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*/
  unsigned use_lz77; /*whether or not to use LZ77. Should be 1 for proper compression.*/
  unsigned windowsize; /*must be a power of two <= 32768. higher compresses more but is slower. Default value: 2048.*/
  unsigned minmatch; /*mininum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*/
  unsigned nicematch; /*stop searching if >= this length found. Set to 258 for best compression. Default: 128*/
  unsigned lazymatching; /*use lazy matching: better compression but a bit slower. Default: true*/

  /*use custom zlib encoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
						  const unsigned char*, size_t,
						  const LodePNGCompressSettings*);
  /*use custom deflate encoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_deflate)(unsigned char**, size_t*,
							 const unsigned char*, size_t,
							 const LodePNGCompressSettings*);

  const void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGCompressSettings lodepng_default_compress_settings;
void lodepng_compress_settings_init(LodePNGCompressSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_PNG
/*
Color mode of an image. Contains all information required to decode the pixel
bits to RGBA colors. This information is the same as used in the PNG file
format, and is used both for PNG and raw image data in LodePNG.
*/
typedef struct LodePNGColorMode
{
  /*header (IHDR)*/
  LodePNGColorType colortype; /*color type, see PNG standard or documentation further in this header file*/
  unsigned bitdepth;  /*bits per sample, see PNG standard or documentation further in this header file*/

  /*
  palette (PLTE and tRNS)

  Dynamically allocated with the colors of the palette, including alpha.
  When encoding a PNG, to store your colors in the palette of the LodePNGColorMode, first use
  lodepng_palette_clear, then for each color use lodepng_palette_add.
  If you encode an image without alpha with palette, don't forget to put value 255 in each A byte of the palette.

  When decoding, by default you can ignore this palette, since LodePNG already
  fills the palette colors in the pixels of the raw RGBA output.

  The palette is only supported for color type 3.
  */
  unsigned char* palette; /*palette in RGBARGBA... order. When allocated, must be either 0, or have size 1024*/
  size_t palettesize; /*palette size in number of colors (amount of bytes is 4 * palettesize)*/

  /*
  transparent color key (tRNS)

  This color uses the same bit depth as the bitdepth value in this struct, which can be 1-bit to 16-bit.
  For greyscale PNGs, r, g and b will all 3 be set to the same.

  When decoding, by default you can ignore this information, since LodePNG sets
  pixels with this key to transparent already in the raw RGBA output.

  The color key is only supported for color types 0 and 2.
  */
  unsigned key_defined; /*is a transparent color key given? 0 = false, 1 = true*/
  unsigned key_r;       /*red/greyscale component of color key*/
  unsigned key_g;       /*green component of color key*/
  unsigned key_b;       /*blue component of color key*/
} LodePNGColorMode;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_color_mode_init(LodePNGColorMode* info);
void lodepng_color_mode_cleanup(LodePNGColorMode* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source);

void lodepng_palette_clear(LodePNGColorMode* info);
/*add 1 color to the palette*/
unsigned lodepng_palette_add(LodePNGColorMode* info,
							 unsigned char r, unsigned char g, unsigned char b, unsigned char a);

/*get the total amount of bits per pixel, based on colortype and bitdepth in the struct*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info);
/*get the amount of color channels used, based on colortype in the struct.
If a palette is used, it counts as 1 channel.*/
unsigned lodepng_get_channels(const LodePNGColorMode* info);
/*is it a greyscale type? (only colortype 0 or 4)*/
unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info);
/*has it got an alpha channel? (only colortype 2 or 6)*/
unsigned lodepng_is_alpha_type(const LodePNGColorMode* info);
/*has it got a palette? (only colortype 3)*/
unsigned lodepng_is_palette_type(const LodePNGColorMode* info);
/*only returns true if there is a palette and there is a value in the palette with alpha < 255.
Loops through the palette to check this.*/
unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info);
/*
Check if the given color info indicates the possibility of having non-opaque pixels in the PNG image.
Returns true if the image can have translucent or invisible pixels (it still be opaque if it doesn't use such pixels).
Returns false if the image can only have opaque pixels.
In detail, it returns true only if it's a color type with alpha, or has a palette with non-opaque values,
or if "key_defined" is true.
*/
unsigned lodepng_can_have_alpha(const LodePNGColorMode* info);
/*Returns the byte size of a raw image buffer with given width, height and color mode*/
size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*The information of a Time chunk in PNG.*/
typedef struct LodePNGTime
{
  unsigned year;    /*2 bytes used (0-65535)*/
  unsigned month;   /*1-12*/
  unsigned day;     /*1-31*/
  unsigned hour;    /*0-23*/
  unsigned minute;  /*0-59*/
  unsigned second;  /*0-60 (to allow for leap seconds)*/
} LodePNGTime;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*Information about the PNG image, except pixels, width and height.*/
typedef struct LodePNGInfo
{
  /*header (IHDR), palette (PLTE) and transparency (tRNS) chunks*/
  unsigned compression_method;/*compression method of the original file. Always 0.*/
  unsigned filter_method;     /*filter method of the original file*/
  unsigned interlace_method;  /*interlace method of the original file*/
  LodePNGColorMode color;     /*color type and bits, palette and transparency of the PNG file*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*
  suggested background color chunk (bKGD)
  This color uses the same color mode as the PNG (except alpha channel), which can be 1-bit to 16-bit.

  For greyscale PNGs, r, g and b will all 3 be set to the same. When encoding
  the encoder writes the red one. For palette PNGs: When decoding, the RGB value
  will be stored, not a palette index. But when encoding, specify the index of
  the palette in background_r, the other two are then ignored.

  The decoder does not use this background color to edit the color of pixels.
  */
  unsigned background_defined; /*is a suggested background color given?*/
  unsigned background_r;       /*red component of suggested background color*/
  unsigned background_g;       /*green component of suggested background color*/
  unsigned background_b;       /*blue component of suggested background color*/

  /*
  non-international text chunks (tEXt and zTXt)

  The char** arrays each contain num strings. The actual messages are in
  text_strings, while text_keys are keywords that give a short description what
  the actual text represents, e.g. Title, Author, Description, or anything else.

  A keyword is minimum 1 character and maximum 79 characters long. It's
  discouraged to use a single line length longer than 79 characters for texts.

  Don't allocate these text buffers yourself. Use the init/cleanup functions
  correctly and use lodepng_add_text and lodepng_clear_text.
  */
  size_t text_num; /*the amount of texts in these char** buffers (there may be more texts in itext)*/
  char** text_keys; /*the keyword of a text chunk (e.g. "Comment")*/
  char** text_strings; /*the actual text*/

  /*
  international text chunks (iTXt)
  Similar to the non-international text chunks, but with additional strings
  "langtags" and "transkeys".
  */
  size_t itext_num; /*the amount of international texts in this PNG*/
  char** itext_keys; /*the English keyword of the text chunk (e.g. "Comment")*/
  char** itext_langtags; /*language tag for this text's language, ISO/IEC 646 string, e.g. ISO 639 language tag*/
  char** itext_transkeys; /*keyword translated to the international language - UTF-8 string*/
  char** itext_strings; /*the actual international text - UTF-8 string*/

  /*time chunk (tIME)*/
  unsigned time_defined; /*set to 1 to make the encoder generate a tIME chunk*/
  LodePNGTime time;

  /*phys chunk (pHYs)*/
  unsigned phys_defined; /*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/
  unsigned phys_x; /*pixels per unit in x direction*/
  unsigned phys_y; /*pixels per unit in y direction*/
  unsigned phys_unit; /*may be 0 (unknown unit) or 1 (metre)*/

  /*
  unknown chunks
  There are 3 buffers, one for each position in the PNG where unknown chunks can appear
  each buffer contains all unknown chunks for that position consecutively
  The 3 buffers are the unknown chunks between certain critical chunks:
  0: IHDR-PLTE, 1: PLTE-IDAT, 2: IDAT-IEND
  Do not allocate or traverse this data yourself. Use the chunk traversing functions declared
  later, such as lodepng_chunk_next and lodepng_chunk_append, to read/write this struct.
  */
  unsigned char* unknown_chunks_data[3];
  size_t unknown_chunks_size[3]; /*size in bytes of the unknown chunks, given for protection*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGInfo;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_info_init(LodePNGInfo* info);
void lodepng_info_cleanup(LodePNGInfo* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
void lodepng_clear_text(LodePNGInfo* info); /*use this to clear the texts again after you filled them in*/
unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str); /*push back both texts at once*/

void lodepng_clear_itext(LodePNGInfo* info); /*use this to clear the itexts again after you filled them in*/
unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
						   const char* transkey, const char* str); /*push back the 4 texts of 1 chunk at once*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*
Converts raw buffer from one color type to another color type, based on
LodePNGColorMode structs to describe the input and output color type.
See the reference manual at the end of this header file to see which color conversions are supported.
return value = LodePNG error code (0 if all went ok, an error if the conversion isn't supported)
The out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel
of the output color type (lodepng_get_bpp).
For < 8 bpp images, there should not be padding bits at the end of scanlines.
For 16-bit per channel colors, uses big endian format like PNG does.
Return value is LodePNG error code
*/
unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
						 LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
						 unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DECODER
/*
Settings for the decoder. This contains settings for the PNG and the Zlib
decoder, but not the Info settings from the Info structs.
*/
typedef struct LodePNGDecoderSettings
{
  LodePNGDecompressSettings zlibsettings; /*in here is the setting to ignore Adler32 checksums*/

  unsigned ignore_crc; /*ignore CRC checksums*/

  unsigned color_convert; /*whether to convert the PNG to the color type you want. Default: yes*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned read_text_chunks; /*if false but remember_unknown_chunks is true, they're stored in the unknown chunks*/
  /*store all bytes from unknown chunks in the LodePNGInfo (off by default, useful for a png editor)*/
  unsigned remember_unknown_chunks;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGDecoderSettings;

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*automatically use color type with less bits per pixel if losslessly possible. Default: AUTO*/
typedef enum LodePNGFilterStrategy
{
  /*every filter at zero*/
  LFS_ZERO,
  /*Use filter that gives minumum sum, as described in the official PNG filter heuristic.*/
  LFS_MINSUM,
  /*Use the filter type that gives smallest Shannon entropy for this scanline. Depending
  on the image, this is better or worse than minsum.*/
  LFS_ENTROPY,
  /*
  Brute-force-search PNG filters by compressing each filter for each scanline.
  Experimental, very slow, and only rarely gives better compression than MINSUM.
  */
  LFS_BRUTE_FORCE,
  /*use predefined_filters buffer: you specify the filter type for each scanline*/
  LFS_PREDEFINED
} LodePNGFilterStrategy;

/*Gives characteristics about the colors of the image, which helps decide which color model to use for encoding.
Used internally by default if "auto_convert" is enabled. Public because it's useful for custom algorithms.*/
typedef struct LodePNGColorProfile
{
  unsigned colored; /*not greyscale*/
  unsigned key; /*if true, image is not opaque. Only if true and alpha is false, color key is possible.*/
  unsigned short key_r; /*these values are always in 16-bit bitdepth in the profile*/
  unsigned short key_g;
  unsigned short key_b;
  unsigned alpha; /*alpha channel or alpha palette required*/
  unsigned numcolors; /*amount of colors, up to 257. Not valid if bits == 16.*/
  unsigned char palette[1024]; /*Remembers up to the first 256 RGBA colors, in no particular order*/
  unsigned bits; /*bits per channel (not for palette). 1,2 or 4 for greyscale only. 16 if 16-bit per channel required.*/
} LodePNGColorProfile;

void lodepng_color_profile_init(LodePNGColorProfile* profile);

/*Get a LodePNGColorProfile of the image.*/
unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,
								   const unsigned char* image, unsigned w, unsigned h,
								   const LodePNGColorMode* mode_in);
/*The function LodePNG uses internally to decide the PNG color with auto_convert.
Chooses an optimal color model, e.g. grey if only grey pixels, palette if < 256 colors, ...*/
unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,
								   const unsigned char* image, unsigned w, unsigned h,
								   const LodePNGColorMode* mode_in);

/*Settings for the encoder.*/
typedef struct LodePNGEncoderSettings
{
  LodePNGCompressSettings zlibsettings; /*settings for the zlib encoder, such as window size, ...*/

  unsigned auto_convert; /*automatically choose output PNG color type. Default: true*/

  /*If true, follows the official PNG heuristic: if the PNG uses a palette or lower than
  8 bit depth, set all filters to zero. Otherwise use the filter_strategy. Note that to
  completely follow the official PNG heuristic, filter_palette_zero must be true and
  filter_strategy must be LFS_MINSUM*/
  unsigned filter_palette_zero;
  /*Which filter strategy to use when not using zeroes due to filter_palette_zero.
  Set filter_palette_zero to 0 to ensure always using your chosen strategy. Default: LFS_MINSUM*/
  LodePNGFilterStrategy filter_strategy;
  /*used if filter_strategy is LFS_PREDEFINED. In that case, this must point to a buffer with
  the same length as the amount of scanlines in the image, and each value must <= 5. You
  have to cleanup this buffer, LodePNG will never free it. Don't forget that filter_palette_zero
  must be set to 0 to ensure this is also used on palette or low bitdepth images.*/
  const unsigned char* predefined_filters;

  /*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette).
  If colortype is 3, PLTE is _always_ created.*/
  unsigned force_palette;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*add LodePNG identifier and version as a text chunk, for debugging*/
  unsigned add_id;
  /*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/
  unsigned text_compression;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGEncoderSettings;

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)
/*The settings, state and information for extended encoding and decoding.*/
typedef struct LodePNGState
{
#ifdef LODEPNG_COMPILE_DECODER
  LodePNGDecoderSettings decoder; /*the decoding settings*/
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  LodePNGEncoderSettings encoder; /*the encoding settings*/
#endif /*LODEPNG_COMPILE_ENCODER*/
  LodePNGColorMode info_raw; /*specifies the format in which you would like to get the raw pixel buffer*/
  LodePNGInfo info_png; /*info of the PNG image obtained after decoding*/
  unsigned error;
#ifdef LODEPNG_COMPILE_CPP
  //For the lodepng::State subclass.
  virtual ~LodePNGState(){}
#endif
} LodePNGState;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_state_init(LodePNGState* state);
void lodepng_state_cleanup(LodePNGState* state);
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source);
#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_DECODER
/*
Same as lodepng_decode_memory, but uses a LodePNGState to allow custom settings and
getting much more information about the PNG image and color mode.
*/
unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
						LodePNGState* state,
						const unsigned char* in, size_t insize);

/*
Read the PNG header, but not the actual data. This returns only the information
that is in the header chunk of the PNG, such as width, height and color type. The
information is placed in the info_png field of the LodePNGState.
*/
unsigned lodepng_inspect(unsigned* w, unsigned* h,
						 LodePNGState* state,
						 const unsigned char* in, size_t insize);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/
unsigned lodepng_encode(unsigned char** out, size_t* outsize,
						const unsigned char* image, unsigned w, unsigned h,
						LodePNGState* state);
#endif /*LODEPNG_COMPILE_ENCODER*/

/*
The lodepng_chunk functions are normally not needed, except to traverse the
unknown chunks stored in the LodePNGInfo struct, or add new ones to it.
It also allows traversing the chunks of an encoded PNG file yourself.

PNG standard chunk naming conventions:
First byte: uppercase = critical, lowercase = ancillary
Second byte: uppercase = public, lowercase = private
Third byte: must be uppercase
Fourth byte: uppercase = unsafe to copy, lowercase = safe to copy
*/

/*
Gets the length of the data of the chunk. Total chunk length has 12 bytes more.
There must be at least 4 bytes to read from. If the result value is too large,
it may be corrupt data.
*/
unsigned lodepng_chunk_length(const unsigned char* chunk);

/*puts the 4-byte type in null terminated string*/
void lodepng_chunk_type(char type[5], const unsigned char* chunk);

/*check if the type is the given type*/
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type);

/*0: it's one of the critical chunk types, 1: it's an ancillary chunk (see PNG standard)*/
unsigned char lodepng_chunk_ancillary(const unsigned char* chunk);

/*0: public, 1: private (see PNG standard)*/
unsigned char lodepng_chunk_private(const unsigned char* chunk);

/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy (see PNG standard)*/
unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk);

/*get pointer to the data of the chunk, where the input points to the header of the chunk*/
unsigned char* lodepng_chunk_data(unsigned char* chunk);
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk);

/*returns 0 if the crc is correct, 1 if it's incorrect (0 for OK as usual!)*/
unsigned lodepng_chunk_check_crc(const unsigned char* chunk);

/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/
void lodepng_chunk_generate_crc(unsigned char* chunk);

/*iterate to next chunks. don't use on IEND chunk, as there is no next chunk then*/
unsigned char* lodepng_chunk_next(unsigned char* chunk);
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk);

/*
Appends chunk to the data in out. The given chunk should already have its chunk header.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returns error code (0 if it went ok)
*/
unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk);

/*
Appends new chunk to out. The chunk to append is given by giving its length, type
and data separately. The type is a 4-letter string.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returne error code (0 if it went ok)
*/
unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
							  const char* type, const unsigned char* data);

/*Calculate CRC32 of buffer*/
unsigned lodepng_crc32(const unsigned char* buf, size_t len);
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ZLIB
/*
This zlib part can be used independently to zlib compress and decompress a
buffer. It cannot be used to create gzip files however, and it only supports the
part of zlib that is required for PNG, it does not support dictionaries.
*/

#ifdef LODEPNG_COMPILE_DECODER
/*Inflate a buffer. Inflate is the decompression step of deflate. Out buffer must be freed after use.*/
unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGDecompressSettings* settings);

/*
Decompresses Zlib data. Reallocates the out buffer and appends the data. The
data must be according to the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize,
								 const unsigned char* in, size_t insize,
								 const LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Compresses data with Zlib. Reallocates the out buffer and appends the data.
Zlib adds a small header and trailer around the deflate data.
The data is output in the format of the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize,
							   const unsigned char* in, size_t insize,
							   const LodePNGCompressSettings* settings);

/*
Find length-limited Huffman code for given frequencies. This function is in the
public interface only for tests, it's used internally by lodepng_deflate.
*/
unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
									  size_t numcodes, unsigned maxbitlen);

/*Compress a buffer with deflate. See RFC 1951. Out buffer must be freed after use.*/
unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGCompressSettings* settings);

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DISK
/*
Load a file from disk into buffer. The function allocates the out buffer, and
after usage you should free it.
out: output parameter, contains pointer to loaded buffer.
outsize: output parameter, size of the allocated out buffer
filename: the path to the file to load
return value: error code (0 means ok)
*/
unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename);

/*
Save a file from buffer to disk. Warning, if it exists, this function overwrites
the file without warning!
buffer: the buffer to write
buffersize: size of the buffer to write
filename: the path to the file to save to
return value: error code (0 means ok)
*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/

#ifdef LODEPNG_COMPILE_CPP
//The LodePNG C++ wrapper uses std::vectors instead of manually allocated memory buffers.
namespace lodepng
{
#ifdef LODEPNG_COMPILE_PNG
class State : public LodePNGState
{
  public:
	State();
	State(const State& other);
	virtual ~State();
	State& operator=(const State& other);
};

#ifdef LODEPNG_COMPILE_DECODER
//Same as other lodepng::decode, but using a State for more settings and information.
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const unsigned char* in, size_t insize);
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const std::vector<unsigned char>& in);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
//Same as other lodepng::encode, but using a State for more settings and information.
unsigned encode(std::vector<unsigned char>& out,
				const unsigned char* in, unsigned w, unsigned h,
				State& state);
unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				State& state);
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DISK
/*
Load a file from disk into an std::vector. If the vector is empty, then either
the file doesn't exist or is an empty file.
*/
void load_file(std::vector<unsigned char>& buffer, const std::string& filename);

/*
Save the binary data in an std::vector to a file on disk. The file is overwritten
without warning.
*/
void save_file(const std::vector<unsigned char>& buffer, const std::string& filename);
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_PNG

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_DECODER
//Zlib-decompress an unsigned char buffer
unsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
					const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);

//Zlib-decompress an std::vector
unsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
					const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);
#endif //LODEPNG_COMPILE_DECODER

#ifdef LODEPNG_COMPILE_ENCODER
//Zlib-compress an unsigned char buffer
unsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
				  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);

//Zlib-compress an std::vector
unsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
				  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);
#endif //LODEPNG_COMPILE_ENCODER
#endif //LODEPNG_COMPILE_ZLIB
} //namespace lodepng
#endif /*LODEPNG_COMPILE_CPP*/

/*
TODO:
[.] test if there are no memory leaks or security exploits - done a lot but needs to be checked often
[.] check compatibility with vareous compilers  - done but needs to be redone for every newer version
[X] converting color to 16-bit per channel types
[ ] read all public PNG chunk types (but never let the color profile and gamma ones touch RGB values)
[ ] make sure encoder generates no chunks with size > (2^31)-1
[ ] partial decoding (stream processing)
[X] let the "isFullyOpaque" function check color keys and transparent palettes too
[X] better name for the variables "codes", "codesD", "codelengthcodes", "clcl" and "lldl"
[ ] don't stop decoding on errors like 69, 57, 58 (make warnings)
[ ] let the C++ wrapper catch exceptions coming from the standard library and return LodePNG error codes
[ ] allow user to provide custom color conversion functions, e.g. for premultiplied alpha, padding bits or not, ...
*/

#endif /*LODEPNG_H inclusion guard*/

/*
LodePNG Documentation
---------------------

0. table of contents
--------------------

  1. about
   1.1. supported features
   1.2. features not supported
  2. C and C++ version
  3. security
  4. decoding
  5. encoding
  6. color conversions
	6.1. PNG color types
	6.2. color conversions
	6.3. padding bits
	6.4. A note about 16-bits per channel and endianness
  7. error values
  8. chunks and PNG editing
  9. compiler support
  10. examples
   10.1. decoder C++ example
   10.2. decoder C example
  11. changes
  12. contact information

1. about
--------

PNG is a file format to store raster images losslessly with good compression,
supporting different color types and alpha channel.

LodePNG is a PNG codec according to the Portable Network Graphics (PNG)
Specification (Second Edition) - W3C Recommendation 10 November 2003.

The specifications used are:

*) Portable Network Graphics (PNG) Specification (Second Edition):
	 http://www.w3.org/TR/2003/REC-PNG-20031110
*) RFC 1950 ZLIB Compressed Data Format version 3.3:
	 http://www.gzip.org/zlib/rfc-zlib.html
*) RFC 1951 DEFLATE Compressed Data Format Specification ver 1.3:
	 http://www.gzip.org/zlib/rfc-deflate.html

The most recent version of LodePNG can currently be found at
http://lodev.org/lodepng/

LodePNG works both in C (ISO C90) and C++, with a C++ wrapper that adds
extra functionality.

LodePNG exists out of two files:
-lodepng.h: the header file for both C and C++
-lodepng.c(pp): give it the name lodepng.c or lodepng.cpp (or .cc) depending on your usage

If you want to start using LodePNG right away without reading this doc, get the
examples from the LodePNG website to see how to use it in code, or check the
smaller examples in chapter 13 here.

LodePNG is simple but only supports the basic requirements. To achieve
simplicity, the following design choices were made: There are no dependencies
on any external library. There are functions to decode and encode a PNG with
a single function call, and extended versions of these functions taking a
LodePNGState struct allowing to specify or get more information. By default
the colors of the raw image are always RGB or RGBA, no matter what color type
the PNG file uses. To read and write files, there are simple functions to
convert the files to/from buffers in memory.

This all makes LodePNG suitable for loading textures in games, demos and small
programs, ... It's less suitable for full fledged image editors, loading PNGs
over network (it requires all the image data to be available before decoding can
begin), life-critical systems, ...

1.1. supported features
-----------------------

The following features are supported by the decoder:

*) decoding of PNGs with any color type, bit depth and interlace mode, to a 24- or 32-bit color raw image,
   or the same color type as the PNG
*) encoding of PNGs, from any raw image to 24- or 32-bit color, or the same color type as the raw image
*) Adam7 interlace and deinterlace for any color type
*) loading the image from harddisk or decoding it from a buffer from other sources than harddisk
*) support for alpha channels, including RGBA color model, translucent palettes and color keying
*) zlib decompression (inflate)
*) zlib compression (deflate)
*) CRC32 and ADLER32 checksums
*) handling of unknown chunks, allowing making a PNG editor that stores custom and unknown chunks.
*) the following chunks are supported (generated/interpreted) by both encoder and decoder:
	IHDR: header information
	PLTE: color palette
	IDAT: pixel data
	IEND: the final chunk
	tRNS: transparency for palettized images
	tEXt: textual information
	zTXt: compressed textual information
	iTXt: international textual information
	bKGD: suggested background color
	pHYs: physical dimensions
	tIME: modification time

1.2. features not supported
---------------------------

The following features are _not_ supported:

*) some features needed to make a conformant PNG-Editor might be still missing.
*) partial loading/stream processing. All data must be available and is processed in one call.
*) The following public chunks are not supported but treated as unknown chunks by LodePNG
	cHRM, gAMA, iCCP, sRGB, sBIT, hIST, sPLT
   Some of these are not supported on purpose: LodePNG wants to provide the RGB values
   stored in the pixels, not values modified by system dependent gamma or color models.

2. C and C++ version
--------------------

The C version uses buffers allocated with alloc that you need to free()
yourself. You need to use init and cleanup functions for each struct whenever
using a struct from the C version to avoid exploits and memory leaks.

The C++ version has extra functions with std::vectors in the interface and the
lodepng::State class which is a LodePNGState with constructor and destructor.

These files work without modification for both C and C++ compilers because all
the additional C++ code is in "#ifdef __cplusplus" blocks that make C-compilers
ignore it, and the C code is made to compile both with strict ISO C90 and C++.

To use the C++ version, you need to rename the source file to lodepng.cpp
(instead of lodepng.c), and compile it with a C++ compiler.

To use the C version, you need to rename the source file to lodepng.c (instead
of lodepng.cpp), and compile it with a C compiler.

3. Security
-----------

Even if carefully designed, it's always possible that LodePNG contains possible
exploits. If you discover one, please let me know, and it will be fixed.

When using LodePNG, care has to be taken with the C version of LodePNG, as well
as the C-style structs when working with C++. The following conventions are used
for all C-style structs:

-if a struct has a corresponding init function, always call the init function when making a new one
-if a struct has a corresponding cleanup function, call it before the struct disappears to avoid memory leaks
-if a struct has a corresponding copy function, use the copy function instead of "=".
 The destination must also be inited already.

4. Decoding
-----------

Decoding converts a PNG compressed image to a raw pixel buffer.

Most documentation on using the decoder is at its declarations in the header
above. For C, simple decoding can be done with functions such as
lodepng_decode32, and more advanced decoding can be done with the struct
LodePNGState and lodepng_decode. For C++, all decoding can be done with the
various lodepng::decode functions, and lodepng::State can be used for advanced
features.

When using the LodePNGState, it uses the following fields for decoding:
*) LodePNGInfo info_png: it stores extra information about the PNG (the input) in here
*) LodePNGColorMode info_raw: here you can say what color mode of the raw image (the output) you want to get
*) LodePNGDecoderSettings decoder: you can specify a few extra settings for the decoder to use

LodePNGInfo info_png
--------------------

After decoding, this contains extra information of the PNG image, except the actual
pixels, width and height because these are already gotten directly from the decoder
functions.

It contains for example the original color type of the PNG image, text comments,
suggested background color, etc... More details about the LodePNGInfo struct are
at its declaration documentation.

LodePNGColorMode info_raw
-------------------------

When decoding, here you can specify which color type you want
the resulting raw image to be. If this is different from the colortype of the
PNG, then the decoder will automatically convert the result. This conversion
always works, except if you want it to convert a color PNG to greyscale or to
a palette with missing colors.

By default, 32-bit color is used for the result.

LodePNGDecoderSettings decoder
------------------------------

The settings can be used to ignore the errors created by invalid CRC and Adler32
chunks, and to disable the decoding of tEXt chunks.

There's also a setting color_convert, true by default. If false, no conversion
is done, the resulting data will be as it was in the PNG (after decompression)
and you'll have to puzzle the colors of the pixels together yourself using the
color type information in the LodePNGInfo.

5. Encoding
-----------

Encoding converts a raw pixel buffer to a PNG compressed image.

Most documentation on using the encoder is at its declarations in the header
above. For C, simple encoding can be done with functions such as
lodepng_encode32, and more advanced decoding can be done with the struct
LodePNGState and lodepng_encode. For C++, all encoding can be done with the
various lodepng::encode functions, and lodepng::State can be used for advanced
features.

Like the decoder, the encoder can also give errors. However it gives less errors
since the encoder input is trusted, the decoder input (a PNG image that could
be forged by anyone) is not trusted.

When using the LodePNGState, it uses the following fields for encoding:
*) LodePNGInfo info_png: here you specify how you want the PNG (the output) to be.
*) LodePNGColorMode info_raw: here you say what color type of the raw image (the input) has
*) LodePNGEncoderSettings encoder: you can specify a few settings for the encoder to use

LodePNGInfo info_png
--------------------

When encoding, you use this the opposite way as when decoding: for encoding,
you fill in the values you want the PNG to have before encoding. By default it's
not needed to specify a color type for the PNG since it's automatically chosen,
but it's possible to choose it yourself given the right settings.

The encoder will not always exactly match the LodePNGInfo struct you give,
it tries as close as possible. Some things are ignored by the encoder. The
encoder uses, for example, the following settings from it when applicable:
colortype and bitdepth, text chunks, time chunk, the color key, the palette, the
background color, the interlace method, unknown chunks, ...

When encoding to a PNG with colortype 3, the encoder will generate a PLTE chunk.
If the palette contains any colors for which the alpha channel is not 255 (so
there are translucent colors in the palette), it'll add a tRNS chunk.

LodePNGColorMode info_raw
-------------------------

You specify the color type of the raw image that you give to the input here,
including a possible transparent color key and palette you happen to be using in
your raw image data.

By default, 32-bit color is assumed, meaning your input has to be in RGBA
format with 4 bytes (unsigned chars) per pixel.

LodePNGEncoderSettings encoder
------------------------------

The following settings are supported (some are in sub-structs):
*) auto_convert: when this option is enabled, the encoder will
automatically choose the smallest possible color mode (including color key) that
can encode the colors of all pixels without information loss.
*) btype: the block type for LZ77. 0 = uncompressed, 1 = fixed huffman tree,
   2 = dynamic huffman tree (best compression). Should be 2 for proper
   compression.
*) use_lz77: whether or not to use LZ77 for compressed block types. Should be
   true for proper compression.
*) windowsize: the window size used by the LZ77 encoder (1 - 32768). Has value
   2048 by default, but can be set to 32768 for better, but slow, compression.
*) force_palette: if colortype is 2 or 6, you can make the encoder write a PLTE
   chunk if force_palette is true. This can used as suggested palette to convert
   to by viewers that don't support more than 256 colors (if those still exist)
*) add_id: add text chunk "Encoder: LodePNG <version>" to the image.
*) text_compression: default 1. If 1, it'll store texts as zTXt instead of tEXt chunks.
  zTXt chunks use zlib compression on the text. This gives a smaller result on
  large texts but a larger result on small texts (such as a single program name).
  It's all tEXt or all zTXt though, there's no separate setting per text yet.

6. color conversions
--------------------

An important thing to note about LodePNG, is that the color type of the PNG, and
the color type of the raw image, are completely independent. By default, when
you decode a PNG, you get the result as a raw image in the color type you want,
no matter whether the PNG was encoded with a palette, greyscale or RGBA color.
And if you encode an image, by default LodePNG will automatically choose the PNG
color type that gives good compression based on the values of colors and amount
of colors in the image. It can be configured to let you control it instead as
well, though.

To be able to do this, LodePNG does conversions from one color mode to another.
It can convert from almost any color type to any other color type, except the
following conversions: RGB to greyscale is not supported, and converting to a
palette when the palette doesn't have a required color is not supported. This is
not supported on purpose: this is information loss which requires a color
reduction algorithm that is beyong the scope of a PNG encoder (yes, RGB to grey
is easy, but there are multiple ways if you want to give some channels more
weight).

By default, when decoding, you get the raw image in 32-bit RGBA or 24-bit RGB
color, no matter what color type the PNG has. And by default when encoding,
LodePNG automatically picks the best color model for the output PNG, and expects
the input image to be 32-bit RGBA or 24-bit RGB. So, unless you want to control
the color format of the images yourself, you can skip this chapter.

6.1. PNG color types
--------------------

A PNG image can have many color types, ranging from 1-bit color to 64-bit color,
as well as palettized color modes. After the zlib decompression and unfiltering
in the PNG image is done, the raw pixel data will have that color type and thus
a certain amount of bits per pixel. If you want the output raw image after
decoding to have another color type, a conversion is done by LodePNG.

The PNG specification gives the following color types:

0: greyscale, bit depths 1, 2, 4, 8, 16
2: RGB, bit depths 8 and 16
3: palette, bit depths 1, 2, 4 and 8
4: greyscale with alpha, bit depths 8 and 16
6: RGBA, bit depths 8 and 16

Bit depth is the amount of bits per pixel per color channel. So the total amount
of bits per pixel is: amount of channels * bitdepth.

6.2. color conversions
----------------------

As explained in the sections about the encoder and decoder, you can specify
color types and bit depths in info_png and info_raw to change the default
behaviour.

If, when decoding, you want the raw image to be something else than the default,
you need to set the color type and bit depth you want in the LodePNGColorMode,
or the parameters colortype and bitdepth of the simple decoding function.

If, when encoding, you use another color type than the default in the raw input
image, you need to specify its color type and bit depth in the LodePNGColorMode
of the raw image, or use the parameters colortype and bitdepth of the simple
encoding function.

If, when encoding, you don't want LodePNG to choose the output PNG color type
but control it yourself, you need to set auto_convert in the encoder settings
to false, and specify the color type you want in the LodePNGInfo of the
encoder (including palette: it can generate a palette if auto_convert is true,
otherwise not).

If the input and output color type differ (whether user chosen or auto chosen),
LodePNG will do a color conversion, which follows the rules below, and may
sometimes result in an error.

To avoid some confusion:
-the decoder converts from PNG to raw image
-the encoder converts from raw image to PNG
-the colortype and bitdepth in LodePNGColorMode info_raw, are those of the raw image
-the colortype and bitdepth in the color field of LodePNGInfo info_png, are those of the PNG
-when encoding, the color type in LodePNGInfo is ignored if auto_convert
 is enabled, it is automatically generated instead
-when decoding, the color type in LodePNGInfo is set by the decoder to that of the original
 PNG image, but it can be ignored since the raw image has the color type you requested instead
-if the color type of the LodePNGColorMode and PNG image aren't the same, a conversion
 between the color types is done if the color types are supported. If it is not
 supported, an error is returned. If the types are the same, no conversion is done.
-even though some conversions aren't supported, LodePNG supports loading PNGs from any
 colortype and saving PNGs to any colortype, sometimes it just requires preparing
 the raw image correctly before encoding.
-both encoder and decoder use the same color converter.

Non supported color conversions:
-color to greyscale: no error is thrown, but the result will look ugly because
only the red channel is taken
-anything to palette when that palette does not have that color in it: in this
case an error is thrown

Supported color conversions:
-anything to 8-bit RGB, 8-bit RGBA, 16-bit RGB, 16-bit RGBA
-any grey or grey+alpha, to grey or grey+alpha
-anything to a palette, as long as the palette has the requested colors in it
-removing alpha channel
-higher to smaller bitdepth, and vice versa

If you want no color conversion to be done (e.g. for speed or control):
-In the encoder, you can make it save a PNG with any color type by giving the
raw color mode and LodePNGInfo the same color mode, and setting auto_convert to
false.
-In the decoder, you can make it store the pixel data in the same color type
as the PNG has, by setting the color_convert setting to false. Settings in
info_raw are then ignored.

The function lodepng_convert does the color conversion. It is available in the
interface but normally isn't needed since the encoder and decoder already call
it.

6.3. padding bits
-----------------

In the PNG file format, if a less than 8-bit per pixel color type is used and the scanlines
have a bit amount that isn't a multiple of 8, then padding bits are used so that each
scanline starts at a fresh byte. But that is NOT true for the LodePNG raw input and output.
The raw input image you give to the encoder, and the raw output image you get from the decoder
will NOT have these padding bits, e.g. in the case of a 1-bit image with a width
of 7 pixels, the first pixel of the second scanline will the the 8th bit of the first byte,
not the first bit of a new byte.

6.4. A note about 16-bits per channel and endianness
----------------------------------------------------

LodePNG uses unsigned char arrays for 16-bit per channel colors too, just like
for any other color format. The 16-bit values are stored in big endian (most
significant byte first) in these arrays. This is the opposite order of the
little endian used by x86 CPU's.

LodePNG always uses big endian because the PNG file format does so internally.
Conversions to other formats than PNG uses internally are not supported by
LodePNG on purpose, there are myriads of formats, including endianness of 16-bit
colors, the order in which you store R, G, B and A, and so on. Supporting and
converting to/from all that is outside the scope of LodePNG.

This may mean that, depending on your use case, you may want to convert the big
endian output of LodePNG to little endian with a for loop. This is certainly not
always needed, many applications and libraries support big endian 16-bit colors
anyway, but it means you cannot simply cast the unsigned char* buffer to an
unsigned short* buffer on x86 CPUs.

7. error values
---------------

All functions in LodePNG that return an error code, return 0 if everything went
OK, or a non-zero code if there was an error.

The meaning of the LodePNG error values can be retrieved with the function
lodepng_error_text: given the numerical error code, it returns a description
of the error in English as a string.

Check the implementation of lodepng_error_text to see the meaning of each code.

8. chunks and PNG editing
-------------------------

If you want to add extra chunks to a PNG you encode, or use LodePNG for a PNG
editor that should follow the rules about handling of unknown chunks, or if your
program is able to read other types of chunks than the ones handled by LodePNG,
then that's possible with the chunk functions of LodePNG.

A PNG chunk has the following layout:

4 bytes length
4 bytes type name
length bytes data
4 bytes CRC

8.1. iterating through chunks
-----------------------------

If you have a buffer containing the PNG image data, then the first chunk (the
IHDR chunk) starts at byte number 8 of that buffer. The first 8 bytes are the
signature of the PNG and are not part of a chunk. But if you start at byte 8
then you have a chunk, and can check the following things of it.

NOTE: none of these functions check for memory buffer boundaries. To avoid
exploits, always make sure the buffer contains all the data of the chunks.
When using lodepng_chunk_next, make sure the returned value is within the
allocated memory.

unsigned lodepng_chunk_length(const unsigned char* chunk):

Get the length of the chunk's data. The total chunk length is this length + 12.

void lodepng_chunk_type(char type[5], const unsigned char* chunk):
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type):

Get the type of the chunk or compare if it's a certain type

unsigned char lodepng_chunk_critical(const unsigned char* chunk):
unsigned char lodepng_chunk_private(const unsigned char* chunk):
unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk):

Check if the chunk is critical in the PNG standard (only IHDR, PLTE, IDAT and IEND are).
Check if the chunk is private (public chunks are part of the standard, private ones not).
Check if the chunk is safe to copy. If it's not, then, when modifying data in a critical
chunk, unsafe to copy chunks of the old image may NOT be saved in the new one if your
program doesn't handle that type of unknown chunk.

unsigned char* lodepng_chunk_data(unsigned char* chunk):
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk):

Get a pointer to the start of the data of the chunk.

unsigned lodepng_chunk_check_crc(const unsigned char* chunk):
void lodepng_chunk_generate_crc(unsigned char* chunk):

Check if the crc is correct or generate a correct one.

unsigned char* lodepng_chunk_next(unsigned char* chunk):
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk):

Iterate to the next chunk. This works if you have a buffer with consecutive chunks. Note that these
functions do no boundary checking of the allocated data whatsoever, so make sure there is enough
data available in the buffer to be able to go to the next chunk.

unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk):
unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
							  const char* type, const unsigned char* data):

These functions are used to create new chunks that are appended to the data in *out that has
length *outlength. The append function appends an existing chunk to the new data. The create
function creates a new chunk with the given parameters and appends it. Type is the 4-letter
name of the chunk.

8.2. chunks in info_png
-----------------------

The LodePNGInfo struct contains fields with the unknown chunk in it. It has 3
buffers (each with size) to contain 3 types of unknown chunks:
the ones that come before the PLTE chunk, the ones that come between the PLTE
and the IDAT chunks, and the ones that come after the IDAT chunks.
It's necessary to make the distionction between these 3 cases because the PNG
standard forces to keep the ordering of unknown chunks compared to the critical
chunks, but does not force any other ordering rules.

info_png.unknown_chunks_data[0] is the chunks before PLTE
info_png.unknown_chunks_data[1] is the chunks after PLTE, before IDAT
info_png.unknown_chunks_data[2] is the chunks after IDAT

The chunks in these 3 buffers can be iterated through and read by using the same
way described in the previous subchapter.

When using the decoder to decode a PNG, you can make it store all unknown chunks
if you set the option settings.remember_unknown_chunks to 1. By default, this
option is off (0).

The encoder will always encode unknown chunks that are stored in the info_png.
If you need it to add a particular chunk that isn't known by LodePNG, you can
use lodepng_chunk_append or lodepng_chunk_create to the chunk data in
info_png.unknown_chunks_data[x].

Chunks that are known by LodePNG should not be added in that way. E.g. to make
LodePNG add a bKGD chunk, set background_defined to true and add the correct
parameters there instead.

9. compiler support
-------------------

No libraries other than the current standard C library are needed to compile
LodePNG. For the C++ version, only the standard C++ library is needed on top.
Add the files lodepng.c(pp) and lodepng.h to your project, include
lodepng.h where needed, and your program can read/write PNG files.

It is compatible with C90 and up, and C++03 and up.

If performance is important, use optimization when compiling! For both the
encoder and decoder, this makes a large difference.

Make sure that LodePNG is compiled with the same compiler of the same version
and with the same settings as the rest of the program, or the interfaces with
std::vectors and std::strings in C++ can be incompatible.

CHAR_BITS must be 8 or higher, because LodePNG uses unsigned chars for octets.

*) gcc and g++

LodePNG is developed in gcc so this compiler is natively supported. It gives no
warnings with compiler options "-Wall -Wextra -pedantic -ansi", with gcc and g++
version 4.7.1 on Linux, 32-bit and 64-bit.

*) Clang

Fully supported and warning-free.

*) Mingw

The Mingw compiler (a port of gcc for Windows) should be fully supported by
LodePNG.

*) Visual Studio and Visual C++ Express Edition

LodePNG should be warning-free with warning level W4. Two warnings were disabled
with pragmas though: warning 4244 about implicit conversions, and warning 4996
where it wants to use a non-standard function fopen_s instead of the standard C
fopen.

Visual Studio may want "stdafx.h" files to be included in each source file and
give an error "unexpected end of file while looking for precompiled header".
This is not standard C++ and will not be added to the stock LodePNG. You can
disable it for lodepng.cpp only by right clicking it, Properties, C/C++,
Precompiled Headers, and set it to Not Using Precompiled Headers there.

NOTE: Modern versions of VS should be fully supported, but old versions, e.g.
VS6, are not guaranteed to work.

*) Compilers on Macintosh

LodePNG has been reported to work both with gcc and LLVM for Macintosh, both for
C and C++.

*) Other Compilers

If you encounter problems on any compilers, feel free to let me know and I may
try to fix it if the compiler is modern and standards complient.

10. examples
------------

This decoder example shows the most basic usage of LodePNG. More complex
examples can be found on the LodePNG website.

10.1. decoder C++ example
-------------------------

#include <iostream>

int main(int argc, char *argv[])
{
  const char* filename = argc > 1 ? argv[1] : "test.png";

  //load and decode
  std::vector<unsigned char> image;
  unsigned width, height;
  unsigned error = lodepng::decode(image, width, height, filename);

  //if there's an error, display it
  if(error) std::cout << "decoder error " << error << ": " << lodepng_error_text(error) << std::endl;

  //the pixels are now in the vector "image", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...
}

10.2. decoder C example
-----------------------

int main(int argc, char *argv[])
{
  unsigned error;
  unsigned char* image;
  size_t width, height;
  const char* filename = argc > 1 ? argv[1] : "test.png";

  error = lodepng_decode32_file(&image, &width, &height, filename);

  if(error) printf("decoder error %u: %s\n", error, lodepng_error_text(error));

  / * use image here * /

  free(image);
  return 0;
}

11. changes
-----------

The version number of LodePNG is the date of the change given in the format
yyyymmdd.

Some changes aren't backwards compatible. Those are indicated with a (!)
symbol.

*) 23 aug 2014: Reduced needless memory usage of decoder.
*) 28 jun 2014: Removed fix_png setting, always support palette OOB for
	simplicity. Made ColorProfile public.
*) 09 jun 2014: Faster encoder by fixing hash bug and more zeros optimization.
*) 22 dec 2013: Power of two windowsize required for optimization.
*) 15 apr 2013: Fixed bug with LAC_ALPHA and color key.
*) 25 mar 2013: Added an optional feature to ignore some PNG errors (fix_png).
*) 11 mar 2013 (!): Bugfix with custom free. Changed from "my" to "lodepng_"
	prefix for the custom allocators and made it possible with a new #define to
	use custom ones in your project without needing to change lodepng's code.
*) 28 jan 2013: Bugfix with color key.
*) 27 okt 2012: Tweaks in text chunk keyword length error handling.
*) 8 okt 2012 (!): Added new filter strategy (entropy) and new auto color mode.
	(no palette). Better deflate tree encoding. New compression tweak settings.
	Faster color conversions while decoding. Some internal cleanups.
*) 23 sep 2012: Reduced warnings in Visual Studio a little bit.
*) 1 sep 2012 (!): Removed #define's for giving custom (de)compression functions
	and made it work with function pointers instead.
*) 23 jun 2012: Added more filter strategies. Made it easier to use custom alloc
	and free functions and toggle #defines from compiler flags. Small fixes.
*) 6 may 2012 (!): Made plugging in custom zlib/deflate functions more flexible.
*) 22 apr 2012 (!): Made interface more consistent, renaming a lot. Removed
	redundant C++ codec classes. Reduced amount of structs. Everything changed,
	but it is cleaner now imho and functionality remains the same. Also fixed
	several bugs and shrinked the implementation code. Made new samples.
*) 6 nov 2011 (!): By default, the encoder now automatically chooses the best
	PNG color model and bit depth, based on the amount and type of colors of the
	raw image. For this, autoLeaveOutAlphaChannel replaced by auto_choose_color.
*) 9 okt 2011: simpler hash chain implementation for the encoder.
*) 8 sep 2011: lz77 encoder lazy matching instead of greedy matching.
*) 23 aug 2011: tweaked the zlib compression parameters after benchmarking.
	A bug with the PNG filtertype heuristic was fixed, so that it chooses much
	better ones (it's quite significant). A setting to do an experimental, slow,
	brute force search for PNG filter types is added.
*) 17 aug 2011 (!): changed some C zlib related function names.
*) 16 aug 2011: made the code less wide (max 120 characters per line).
*) 17 apr 2011: code cleanup. Bugfixes. Convert low to 16-bit per sample colors.
*) 21 feb 2011: fixed compiling for C90. Fixed compiling with sections disabled.
*) 11 dec 2010: encoding is made faster, based on suggestion by Peter Eastman
	to optimize long sequences of zeros.
*) 13 nov 2010: added LodePNG_InfoColor_hasPaletteAlpha and
	LodePNG_InfoColor_canHaveAlpha functions for convenience.
*) 7 nov 2010: added LodePNG_error_text function to get error code description.
*) 30 okt 2010: made decoding slightly faster
*) 26 okt 2010: (!) changed some C function and struct names (more consistent).
	 Reorganized the documentation and the declaration order in the header.
*) 08 aug 2010: only changed some comments and external samples.
*) 05 jul 2010: fixed bug thanks to warnings in the new gcc version.
*) 14 mar 2010: fixed bug where too much memory was allocated for char buffers.
*) 02 sep 2008: fixed bug where it could create empty tree that linux apps could
	read by ignoring the problem but windows apps couldn't.
*) 06 jun 2008: added more error checks for out of memory cases.
*) 26 apr 2008: added a few more checks here and there to ensure more safety.
*) 06 mar 2008: crash with encoding of strings fixed
*) 02 feb 2008: support for international text chunks added (iTXt)
*) 23 jan 2008: small cleanups, and #defines to divide code in sections
*) 20 jan 2008: support for unknown chunks allowing using LodePNG for an editor.
*) 18 jan 2008: support for tIME and pHYs chunks added to encoder and decoder.
*) 17 jan 2008: ability to encode and decode compressed zTXt chunks added
	Also vareous fixes, such as in the deflate and the padding bits code.
*) 13 jan 2008: Added ability to encode Adam7-interlaced images. Improved
	filtering code of encoder.
*) 07 jan 2008: (!) changed LodePNG to use ISO C90 instead of C++. A
	C++ wrapper around this provides an interface almost identical to before.
	Having LodePNG be pure ISO C90 makes it more portable. The C and C++ code
	are together in these files but it works both for C and C++ compilers.
*) 29 dec 2007: (!) changed most integer types to unsigned int + other tweaks
*) 30 aug 2007: bug fixed which makes this Borland C++ compatible
*) 09 aug 2007: some VS2005 warnings removed again
*) 21 jul 2007: deflate code placed in new namespace separate from zlib code
*) 08 jun 2007: fixed bug with 2- and 4-bit color, and small interlaced images
*) 04 jun 2007: improved support for Visual Studio 2005: crash with accessing
	invalid std::vector element [0] fixed, and level 3 and 4 warnings removed
*) 02 jun 2007: made the encoder add a tag with version by default
*) 27 may 2007: zlib and png code separated (but still in the same file),
	simple encoder/decoder functions added for more simple usage cases
*) 19 may 2007: minor fixes, some code cleaning, new error added (error 69),
	moved some examples from here to lodepng_examples.cpp
*) 12 may 2007: palette decoding bug fixed
*) 24 apr 2007: changed the license from BSD to the zlib license
*) 11 mar 2007: very simple addition: ability to encode bKGD chunks.
*) 04 mar 2007: (!) tEXt chunk related fixes, and support for encoding
	palettized PNG images. Plus little interface change with palette and texts.
*) 03 mar 2007: Made it encode dynamic Huffman shorter with repeat codes.
	Fixed a bug where the end code of a block had length 0 in the Huffman tree.
*) 26 feb 2007: Huffman compression with dynamic trees (BTYPE 2) now implemented
	and supported by the encoder, resulting in smaller PNGs at the output.
*) 27 jan 2007: Made the Adler-32 test faster so that a timewaste is gone.
*) 24 jan 2007: gave encoder an error interface. Added color conversion from any
	greyscale type to 8-bit greyscale with or without alpha.
*) 21 jan 2007: (!) Totally changed the interface. It allows more color types
	to convert to and is more uniform. See the manual for how it works now.
*) 07 jan 2007: Some cleanup & fixes, and a few changes over the last days:
	encode/decode custom tEXt chunks, separate classes for zlib & deflate, and
	at last made the decoder give errors for incorrect Adler32 or Crc.
*) 01 jan 2007: Fixed bug with encoding PNGs with less than 8 bits per channel.
*) 29 dec 2006: Added support for encoding images without alpha channel, and
	cleaned out code as well as making certain parts faster.
*) 28 dec 2006: Added "Settings" to the encoder.
*) 26 dec 2006: The encoder now does LZ77 encoding and produces much smaller files now.
	Removed some code duplication in the decoder. Fixed little bug in an example.
*) 09 dec 2006: (!) Placed output parameters of public functions as first parameter.
	Fixed a bug of the decoder with 16-bit per color.
*) 15 okt 2006: Changed documentation structure
*) 09 okt 2006: Encoder class added. It encodes a valid PNG image from the
	given image buffer, however for now it's not compressed.
*) 08 sep 2006: (!) Changed to interface with a Decoder class
*) 30 jul 2006: (!) LodePNG_InfoPng , width and height are now retrieved in different
	way. Renamed decodePNG to decodePNGGeneric.
*) 29 jul 2006: (!) Changed the interface: image info is now returned as a
	struct of type LodePNG::LodePNG_Info, instead of a vector, which was a bit clumsy.
*) 28 jul 2006: Cleaned the code and added new error checks.
	Corrected terminology "deflate" into "inflate".
*) 23 jun 2006: Added SDL example in the documentation in the header, this
	example allows easy debugging by displaying the PNG and its transparency.
*) 22 jun 2006: (!) Changed way to obtain error value. Added
	loadFile function for convenience. Made decodePNG32 faster.
*) 21 jun 2006: (!) Changed type of info vector to unsigned.
	Changed position of palette in info vector. Fixed an important bug that
	happened on PNGs with an uncompressed block.
*) 16 jun 2006: Internally changed unsigned into unsigned where
	needed, and performed some optimizations.
*) 07 jun 2006: (!) Renamed functions to decodePNG and placed them
	in LodePNG namespace. Changed the order of the parameters. Rewrote the
	documentation in the header. Renamed files to lodepng.cpp and lodepng.h
*) 22 apr 2006: Optimized and improved some code
*) 07 sep 2005: (!) Changed to std::vector interface
*) 12 aug 2005: Initial release (C++, decoder only)

12. contact information
-----------------------

Feel free to contact me with suggestions, problems, comments, ... concerning
LodePNG. If you encounter a PNG image that doesn't work properly with this
decoder, feel free to send it and I'll use it to find and fix the problem.

My email address is (puzzle the account and domain together with an @ symbol):
Domain: gmail dot com.
Account: lode dot vandevenne.

Copyright (c) 2005-2014 Lode Vandevenne
*/


//#line 1 "lodepng.cpp"
/*
The manual and changelog are in the header file "lodepng.h"
Rename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.
*/

#include <stdio.h>
#include <stdlib.h>

#ifdef LODEPNG_COMPILE_CPP
#include <fstream>
#endif /*LODEPNG_COMPILE_CPP*/

#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/
#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/
#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/
#endif /*_MSC_VER */

/*
This source file is built up in the following large parts. The code sections
with the "LODEPNG_COMPILE_" #defines divide this up further in an intermixed way.
-Tools for C and common code for PNG and Zlib
-C Code for Zlib (huffman, deflate, ...)
-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)
-The C++ wrapper around all of the above
*/

/*The malloc, realloc and free functions defined here with "lodepng_" in front
of the name, so that you can easily change them to others related to your
platform if needed. Everything else in the code calls these. Pass
-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out
#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size)
{
  return malloc(size);
}

static void* lodepng_realloc(void* ptr, size_t new_size)
{
  return realloc(ptr, new_size);
}

static void lodepng_free(void* ptr)
{
  free(ptr);
}
#else /*LODEPNG_COMPILE_ALLOCATORS*/
void* lodepng_malloc(size_t size);
void* lodepng_realloc(void* ptr, size_t new_size);
void lodepng_free(void* ptr);
#endif /*LODEPNG_COMPILE_ALLOCATORS*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // Tools for C, and common code for PNG and Zlib.                       // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

/*
Often in case of an error a value is assigned to a variable and then it breaks
out of a loop (to go to the cleanup phase of a function). This macro does that.
It makes the error handling code shorter and more readable.

Example: if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83);
*/
#define CERROR_BREAK(errorvar, code)\
{\
  errorvar = code;\
  break;\
}

/*version of CERROR_BREAK that assumes the common case where the error variable is named "error"*/
#define ERROR_BREAK(code) CERROR_BREAK(error, code)

/*Set error var to the error code, and return it.*/
#define CERROR_RETURN_ERROR(errorvar, code)\
{\
  errorvar = code;\
  return code;\
}

/*Try the code, if it returns error, also return the error.*/
#define CERROR_TRY_RETURN(call)\
{\
  unsigned error = call;\
  if(error) return error;\
}

/*Set error var to the error code, and return from the void function.*/
#define CERROR_RETURN(errorvar, code)\
{\
  errorvar = code;\
  return;\
}

/*
About uivector, ucvector and string:
-All of them wrap dynamic arrays or text strings in a similar way.
-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.
-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.
-They're not used in the interface, only internally in this file as static functions.
-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.
*/

#ifdef LODEPNG_COMPILE_ZLIB
/*dynamic vector of unsigned ints*/
typedef struct uivector
{
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p)
{
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
  lodepng_free(((uivector*)p)->data);
  ((uivector*)p)->data = NULL;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_reserve(uivector* p, size_t allocsize)
{
  if(allocsize > p->allocsize)
  {
	size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);
	void* data = lodepng_realloc(p->data, newsize);
	if(data)
	{
	  p->allocsize = newsize;
	  p->data = (unsigned*)data;
	}
	else return 0; /*error: not enough memory*/
  }
  return 1;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size)
{
  if(!uivector_reserve(p, size * sizeof(unsigned))) return 0;
  p->size = size;
  return 1; /*success*/
}

/*resize and give all new elements the value*/
static unsigned uivector_resizev(uivector* p, size_t size, unsigned value)
{
  size_t oldsize = p->size, i;
  if(!uivector_resize(p, size)) return 0;
  for(i = oldsize; i < size; ++i) p->data[i] = value;
  return 1;
}

static void uivector_init(uivector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}

#ifdef LODEPNG_COMPILE_ENCODER
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c)
{
  if(!uivector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}

/*copy q to p, returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_copy(uivector* p, const uivector* q)
{
  size_t i;
  if(!uivector_resize(p, q->size)) return 0;
  for(i = 0; i != q->size; ++i) p->data[i] = q->data[i];
  return 1;
}
#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

/* /////////////////////////////////////////////////////////////////////////// */

/*dynamic vector of unsigned chars*/
typedef struct ucvector
{
  unsigned char* data;
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_reserve(ucvector* p, size_t allocsize)
{
  if(allocsize > p->allocsize)
  {
	size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);
	void* data = lodepng_realloc(p->data, newsize);
	if(data)
	{
	  p->allocsize = newsize;
	  p->data = (unsigned char*)data;
	}
	else return 0; /*error: not enough memory*/
  }
  return 1;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size)
{
  if(!ucvector_reserve(p, size * sizeof(unsigned char))) return 0;
  p->size = size;
  return 1; /*success*/
}

#ifdef LODEPNG_COMPILE_PNG

static void ucvector_cleanup(void* p)
{
  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
  lodepng_free(((ucvector*)p)->data);
  ((ucvector*)p)->data = NULL;
}

static void ucvector_init(ucvector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}

#ifdef LODEPNG_COMPILE_DECODER
/*resize and give all new elements the value*/
static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value)
{
  size_t oldsize = p->size, i;
  if(!ucvector_resize(p, size)) return 0;
  for(i = oldsize; i < size; ++i) p->data[i] = value;
  return 1;
}
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ZLIB
/*you can both convert from vector to buffer&size and vica versa. If you use
init_buffer to take over a buffer and size, it is not needed to use cleanup*/
static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
{
  p->data = buffer;
  p->allocsize = p->size = size;
}
#endif /*LODEPNG_COMPILE_ZLIB*/

#if (defined(LODEPNG_COMPILE_PNG) && defined(LODEPNG_COMPILE_ANCILLARY_CHUNKS)) || defined(LODEPNG_COMPILE_ENCODER)
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_push_back(ucvector* p, unsigned char c)
{
  if(!ucvector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/

/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned string_resize(char** out, size_t size)
{
  char* data = (char*)lodepng_realloc(*out, size + 1);
  if(data)
  {
	data[size] = 0; /*null termination char*/
	*out = data;
  }
  return data != 0;
}

/*init a {char*, size_t} pair for use as string*/
static void string_init(char** out)
{
  *out = NULL;
  string_resize(out, 0);
}

/*free the above pair again*/
static void string_cleanup(char** out)
{
  lodepng_free(*out);
  *out = NULL;
}

static void string_set(char** out, const char* in)
{
  size_t insize = strlen(in), i;
  if(string_resize(out, insize))
  {
	for(i = 0; i != insize; ++i)
	{
	  (*out)[i] = in[i];
	}
  }
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_read32bitInt(const unsigned char* buffer)
{
  return (unsigned)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
}

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value)
{
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
  buffer[3] = (unsigned char)((value      ) & 0xff);
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/

#ifdef LODEPNG_COMPILE_ENCODER
static void lodepng_add32bitInt(ucvector* buffer, unsigned value)
{
  ucvector_resize(buffer, buffer->size + 4); /*todo: give error if resize failed*/
  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / File IO                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename)
{
  FILE* file;
  long size;

  /*provide some proper output values if error will happen*/
  *out = 0;
  *outsize = 0;

  file = fopen(filename, "rb");
  if(!file) return 78;

  /*get filesize:*/
  fseek(file , 0 , SEEK_END);
  size = ftell(file);
  rewind(file);

  /*read contents of the file into the vector*/
  *outsize = 0;
  *out = (unsigned char*)lodepng_malloc((size_t)size);
  if(size && (*out)) (*outsize) = fread(*out, 1, (size_t)size, file);

  fclose(file);
  if(!(*out) && size) return 83; /*the above malloc failed*/
  return 0;
}

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)
{
  FILE* file;
  file = fopen(filename, "wb" );
  if(!file) return 79;
  fwrite((char*)buffer , 1 , buffersize, file);
  fclose(file);
  return 0;
}

#endif /*LODEPNG_COMPILE_DISK*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of common code and tools. Begin of Zlib related code.            // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_ENCODER
/*TODO: this ignores potential out of memory errors*/
#define addBitToStream(/*size_t**/ bitpointer, /*ucvector**/ bitstream, /*unsigned char*/ bit)\
{\
  /*add a new byte at the end*/\
  if(((*bitpointer) & 7) == 0) ucvector_push_back(bitstream, (unsigned char)0);\
  /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\
  (bitstream->data[bitstream->size - 1]) |= (bit << ((*bitpointer) & 0x7));\
  ++(*bitpointer);\
}

static void addBitsToStream(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> i) & 1));
}

static void addBitsToStreamReversed(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> (nbits - 1 - i)) & 1));
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

#define READBIT(bitpointer, bitstream) ((bitstream[bitpointer >> 3] >> (bitpointer & 0x7)) & (unsigned char)1)

static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)(READBIT(*bitpointer, bitstream));
  ++(*bitpointer);
  return result;
}

static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0, i;
  for(i = 0; i != nbits; ++i)
  {
	result += ((unsigned)READBIT(*bitpointer, bitstream)) << i;
	++(*bitpointer);
  }
  return result;
}
#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflate - Huffman                                                      / */
/* ////////////////////////////////////////////////////////////////////////// */

#define FIRST_LENGTH_CODE_INDEX 257
#define LAST_LENGTH_CODE_INDEX 285
/*256 literals, the end code, some length codes, and 2 unused codes*/
#define NUM_DEFLATE_CODE_SYMBOLS 288
/*the distance codes have their own symbols, 30 used, 2 unused*/
#define NUM_DISTANCE_SYMBOLS 32
/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/
#define NUM_CODE_LENGTH_CODES 19

/*the base lengths represented by codes 257-285*/
static const unsigned LENGTHBASE[29]
  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
	 67, 83, 99, 115, 131, 163, 195, 227, 258};

/*the extra bits used by codes 257-285 (added to base length)*/
static const unsigned LENGTHEXTRA[29]
  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
	  4,  4,  4,   4,   5,   5,   5,   5,   0};

/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/
static const unsigned DISTANCEBASE[30]
  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
	 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};

/*the extra bits of backwards distances (added to base)*/
static const unsigned DISTANCEEXTRA[30]
  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,
	   8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};

/*the order in which "code length alphabet code lengths" are stored, out of this
the huffman tree of the dynamic huffman tree lengths is generated*/
static const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]
  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/* ////////////////////////////////////////////////////////////////////////// */

/*
Huffman tree struct, containing multiple representations of the tree
*/
typedef struct HuffmanTree
{
  unsigned* tree2d;
  unsigned* tree1d;
  unsigned* lengths; /*the lengths of the codes of the 1d-tree*/
  unsigned maxbitlen; /*maximum number of bits a single code can get*/
  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/
} HuffmanTree;

/*function used for debug purposes to draw the tree in ascii art with C++*/
/*
static void HuffmanTree_draw(HuffmanTree* tree)
{
  std::cout << "tree. length: " << tree->numcodes << " maxbitlen: " << tree->maxbitlen << std::endl;
  for(size_t i = 0; i != tree->tree1d.size; ++i)
  {
	if(tree->lengths.data[i])
	  std::cout << i << " " << tree->tree1d.data[i] << " " << tree->lengths.data[i] << std::endl;
  }
  std::cout << std::endl;
}*/

static void HuffmanTree_init(HuffmanTree* tree)
{
  tree->tree2d = 0;
  tree->tree1d = 0;
  tree->lengths = 0;
}

static void HuffmanTree_cleanup(HuffmanTree* tree)
{
  lodepng_free(tree->tree2d);
  lodepng_free(tree->tree1d);
  lodepng_free(tree->lengths);
}

/*the tree representation used by the decoder. return value is error*/
static unsigned HuffmanTree_make2DTree(HuffmanTree* tree)
{
  unsigned nodefilled = 0; /*up to which node it is filled*/
  unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/
  unsigned n, i;

  tree->tree2d = (unsigned*)lodepng_malloc(tree->numcodes * 2 * sizeof(unsigned));
  if(!tree->tree2d) return 83; /*alloc fail*/

  /*
  convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means
  uninited, a value >= numcodes is an address to another bit, a value < numcodes
  is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as
  many columns as codes - 1.
  A good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
  Here, the internal nodes are stored (what their 0 and 1 option point to).
  There is only memory for such good tree currently, if there are more nodes
  (due to too long length codes), error 55 will happen
  */
  for(n = 0; n < tree->numcodes * 2; ++n)
  {
	tree->tree2d[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
  }

  for(n = 0; n < tree->numcodes; ++n) /*the codes*/
  {
	for(i = 0; i != tree->lengths[n]; ++i) /*the bits for this code*/
	{
	  unsigned char bit = (unsigned char)((tree->tree1d[n] >> (tree->lengths[n] - i - 1)) & 1);
	  /*oversubscribed, see comment in lodepng_error_text*/
	  if(treepos > 2147483647 || treepos + 2 > tree->numcodes) return 55;
	  if(tree->tree2d[2 * treepos + bit] == 32767) /*not yet filled in*/
	  {
		if(i + 1 == tree->lengths[n]) /*last bit*/
		{
		  tree->tree2d[2 * treepos + bit] = n; /*put the current code in it*/
		  treepos = 0;
		}
		else
		{
		  /*put address of the next step in here, first that address has to be found of course
		  (it's just nodefilled + 1)...*/
		  ++nodefilled;
		  /*addresses encoded with numcodes added to it*/
		  tree->tree2d[2 * treepos + bit] = nodefilled + tree->numcodes;
		  treepos = nodefilled;
		}
	  }
	  else treepos = tree->tree2d[2 * treepos + bit] - tree->numcodes;
	}
  }

  for(n = 0; n < tree->numcodes * 2; ++n)
  {
	if(tree->tree2d[n] == 32767) tree->tree2d[n] = 0; /*remove possible remaining 32767's*/
  }

  return 0;
}

/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree)
{
  uivector blcount;
  uivector nextcode;
  unsigned error = 0;
  unsigned bits, n;

  uivector_init(&blcount);
  uivector_init(&nextcode);

  tree->tree1d = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
  if(!tree->tree1d) error = 83; /*alloc fail*/

  if(!uivector_resizev(&blcount, tree->maxbitlen + 1, 0)
  || !uivector_resizev(&nextcode, tree->maxbitlen + 1, 0))
	error = 83; /*alloc fail*/

  if(!error)
  {
	/*step 1: count number of instances of each code length*/
	for(bits = 0; bits != tree->numcodes; ++bits) ++blcount.data[tree->lengths[bits]];
	/*step 2: generate the nextcode values*/
	for(bits = 1; bits <= tree->maxbitlen; ++bits)
	{
	  nextcode.data[bits] = (nextcode.data[bits - 1] + blcount.data[bits - 1]) << 1;
	}
	/*step 3: generate all the codes*/
	for(n = 0; n != tree->numcodes; ++n)
	{
	  if(tree->lengths[n] != 0) tree->tree1d[n] = nextcode.data[tree->lengths[n]]++;
	}
  }

  uivector_cleanup(&blcount);
  uivector_cleanup(&nextcode);

  if(!error) return HuffmanTree_make2DTree(tree);
  else return error;
}

/*
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
											size_t numcodes, unsigned maxbitlen)
{
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->maxbitlen = maxbitlen;
  return HuffmanTree_makeFromLengths2(tree);
}

#ifdef LODEPNG_COMPILE_ENCODER

/*
A coin, this is the terminology used for the package-merge algorithm and the
coin collector's problem. This is used to generate the huffman tree.
A coin can be multiple coins (when they're merged)
*/
typedef struct Coin
{
  uivector symbols;
  float weight; /*the sum of all weights in this coin*/
} Coin;

static void coin_init(Coin* c)
{
  uivector_init(&c->symbols);
}

/*argument c is void* so that this dtor can be given as function pointer to the vector resize function*/
static void coin_cleanup(void* c)
{
  uivector_cleanup(&((Coin*)c)->symbols);
}

static void coin_copy(Coin* c1, const Coin* c2)
{
  c1->weight = c2->weight;
  uivector_copy(&c1->symbols, &c2->symbols);
}

static void add_coins(Coin* c1, const Coin* c2)
{
  size_t i;
  for(i = 0; i != c2->symbols.size; ++i) uivector_push_back(&c1->symbols, c2->symbols.data[i]);
  c1->weight += c2->weight;
}

static void init_coins(Coin* coins, size_t num)
{
  size_t i;
  for(i = 0; i != num; ++i) coin_init(&coins[i]);
}

static void cleanup_coins(Coin* coins, size_t num)
{
  size_t i;
  for(i = 0; i != num; ++i) coin_cleanup(&coins[i]);
}

static int coin_compare(const void* a, const void* b) {
  float wa = ((const Coin*)a)->weight;
  float wb = ((const Coin*)b)->weight;
  return wa > wb ? 1 : wa < wb ? -1 : 0;
}

static unsigned append_symbol_coins(Coin* coins, const unsigned* frequencies, unsigned numcodes, size_t sum)
{
  unsigned i;
  unsigned j = 0; /*index of present symbols*/
  for(i = 0; i != numcodes; ++i)
  {
	if(frequencies[i] != 0) /*only include symbols that are present*/
	{
	  coins[j].weight = frequencies[i] / (float)sum;
	  uivector_push_back(&coins[j].symbols, i);
	  ++j;
	}
  }
  return 0;
}

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
									  size_t numcodes, unsigned maxbitlen)
{
  unsigned i, j;
  size_t sum = 0, numpresent = 0;
  unsigned error = 0;
  Coin* coins; /*the coins of the currently calculated row*/
  Coin* prev_row; /*the previous row of coins*/
  size_t numcoins;
  size_t coinmem;

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/

  for(i = 0; i != numcodes; ++i)
  {
	if(frequencies[i] > 0)
	{
	  ++numpresent;
	  sum += frequencies[i];
	}
  }

  for(i = 0; i != numcodes; ++i) lengths[i] = 0;

  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. To decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoritical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0)
  {
	lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
  }
  else if(numpresent == 1)
  {
	for(i = 0; i != numcodes; ++i)
	{
	  if(frequencies[i])
	  {
		lengths[i] = 1;
		lengths[i == 0 ? 1 : 0] = 1;
		break;
	  }
	}
  }
  else
  {
	/*Package-Merge algorithm represented by coin collector's problem
	For every symbol, maxbitlen coins will be created*/

	coinmem = numpresent * 2; /*max amount of coins needed with the current algo*/
	coins = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);
	prev_row = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);
	if(!coins || !prev_row)
	{
	  lodepng_free(coins);
	  lodepng_free(prev_row);
	  return 83; /*alloc fail*/
	}
	init_coins(coins, coinmem);
	init_coins(prev_row, coinmem);

	/*first row, lowest denominator*/
	error = append_symbol_coins(coins, frequencies, numcodes, sum);
	numcoins = numpresent;
	qsort(coins, numcoins, sizeof(Coin), coin_compare);
	if(!error)
	{
	  unsigned numprev = 0;
	  for(j = 1; j <= maxbitlen && !error; ++j) /*each of the remaining rows*/
	  {
		unsigned tempnum;
		Coin* tempcoins;
		/*swap prev_row and coins, and their amounts*/
		tempcoins = prev_row; prev_row = coins; coins = tempcoins;
		tempnum = numprev; numprev = numcoins; numcoins = tempnum;

		cleanup_coins(coins, numcoins);
		init_coins(coins, numcoins);

		numcoins = 0;

		/*fill in the merged coins of the previous row*/
		for(i = 0; i + 1 < numprev; i += 2)
		{
		  /*merge prev_row[i] and prev_row[i + 1] into new coin*/
		  Coin* coin = &coins[numcoins++];
		  coin_copy(coin, &prev_row[i]);
		  add_coins(coin, &prev_row[i + 1]);
		}
		/*fill in all the original symbols again*/
		if(j < maxbitlen)
		{
		  error = append_symbol_coins(coins + numcoins, frequencies, numcodes, sum);
		  numcoins += numpresent;
		}
		qsort(coins, numcoins, sizeof(Coin), coin_compare);
	  }
	}

	if(!error)
	{
	  /*calculate the lengths of each symbol, as the amount of times a coin of each symbol is used*/
	  for(i = 0; i + 1 < numpresent; ++i)
	  {
		Coin* coin = &coins[i];
		for(j = 0; j < coin->symbols.size; ++j) ++lengths[coin->symbols.data[j]];
	  }
	}

	cleanup_coins(coins, coinmem);
	lodepng_free(coins);
	cleanup_coins(prev_row, coinmem);
	lodepng_free(prev_row);
  }

  return error;
}

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
												size_t mincodes, size_t numcodes, unsigned maxbitlen)
{
  unsigned error = 0;
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
  tree->maxbitlen = maxbitlen;
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->lengths = (unsigned*)lodepng_realloc(tree->lengths, numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  /*initialize all lengths to 0*/
  memset(tree->lengths, 0, numcodes * sizeof(unsigned));

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
  return error;
}

static unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)
{
  return tree->tree1d[index];
}

static unsigned HuffmanTree_getLength(const HuffmanTree* tree, unsigned index)
{
  return tree->lengths[index];
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code, or (unsigned)(-1) if error happened
inbitlength is the length of the complete buffer, in bits (so its byte length times 8)
*/
static unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,
									const HuffmanTree* codetree, size_t inbitlength)
{
  unsigned treepos = 0, ct;
  for(;;)
  {
	if(*bp >= inbitlength) return (unsigned)(-1); /*error: end of input memory reached without endcode*/
	/*
	decode the symbol from the tree. The "readBitFromStream" code is inlined in
	the expression below because this is the biggest bottleneck while decoding
	*/
	ct = codetree->tree2d[(treepos << 1) + READBIT(*bp, in)];
	++(*bp);
	if(ct < codetree->numcodes) return ct; /*the symbol is decoded, return it*/
	else treepos = ct - codetree->numcodes; /*symbol not yet decoded, instead move tree position*/

	if(treepos >= codetree->numcodes) return (unsigned)(-1); /*error: it appeared outside the codetree*/
  }
}
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/
static void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)
{
  /*TODO: check for out of memory errors*/
  generateFixedLitLenTree(tree_ll);
  generateFixedDistanceTree(tree_d);
}

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
									  const unsigned char* in, size_t* bp, size_t inlength)
{
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
  unsigned n, HLIT, HDIST, HCLEN, i;
  size_t inbitlength = inlength * 8;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
  unsigned* bitlen_d = 0; /*dist code lengths*/
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if((*bp) + 14 > (inlength << 3)) return 49; /*error: the bit pointer is or will go past the memory*/

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBitsFromStream(bp, in, 5) + 257;
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBitsFromStream(bp, in, 5) + 1;
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBitsFromStream(bp, in, 4) + 4;

  if((*bp) + HCLEN * 3 > (inlength << 3)) return 50; /*error: the bit pointer is or will go past the memory*/

  HuffmanTree_init(&tree_cl);

  while(!error)
  {
	/*read the code length codes out of 3 * (amount of code length codes) bits*/

	bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
	if(!bitlen_cl) ERROR_BREAK(83 /*alloc fail*/);

	for(i = 0; i != NUM_CODE_LENGTH_CODES; ++i)
	{
	  if(i < HCLEN) bitlen_cl[CLCL_ORDER[i]] = readBitsFromStream(bp, in, 3);
	  else bitlen_cl[CLCL_ORDER[i]] = 0; /*if not, it must stay 0*/
	}

	error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
	if(error) break;

	/*now we can use this tree to read the lengths for the tree that this function will return*/
	bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
	bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
	if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
	for(i = 0; i != NUM_DEFLATE_CODE_SYMBOLS; ++i) bitlen_ll[i] = 0;
	for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen_d[i] = 0;

	/*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
	i = 0;
	while(i < HLIT + HDIST)
	{
	  unsigned code = huffmanDecodeSymbol(in, bp, &tree_cl, inbitlength);
	  if(code <= 15) /*a length code*/
	  {
		if(i < HLIT) bitlen_ll[i] = code;
		else bitlen_d[i - HLIT] = code;
		++i;
	  }
	  else if(code == 16) /*repeat previous*/
	  {
		unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
		unsigned value; /*set value to the previous code*/

		if (i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/

		if((*bp + 2) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
		replength += readBitsFromStream(bp, in, 2);

		if(i < HLIT + 1) value = bitlen_ll[i - 1];
		else value = bitlen_d[i - HLIT - 1];
		/*repeat this value in the next lengths*/
		for(n = 0; n < replength; ++n)
		{
		  if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
		  if(i < HLIT) bitlen_ll[i] = value;
		  else bitlen_d[i - HLIT] = value;
		  ++i;
		}
	  }
	  else if(code == 17) /*repeat "0" 3-10 times*/
	  {
		unsigned replength = 3; /*read in the bits that indicate repeat length*/
		if((*bp + 3) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
		replength += readBitsFromStream(bp, in, 3);

		/*repeat this value in the next lengths*/
		for(n = 0; n < replength; ++n)
		{
		  if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/

		  if(i < HLIT) bitlen_ll[i] = 0;
		  else bitlen_d[i - HLIT] = 0;
		  ++i;
		}
	  }
	  else if(code == 18) /*repeat "0" 11-138 times*/
	  {
		unsigned replength = 11; /*read in the bits that indicate repeat length*/
		if((*bp + 7) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
		replength += readBitsFromStream(bp, in, 7);

		/*repeat this value in the next lengths*/
		for(n = 0; n < replength; ++n)
		{
		  if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/

		  if(i < HLIT) bitlen_ll[i] = 0;
		  else bitlen_d[i - HLIT] = 0;
		  ++i;
		}
	  }
	  else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
	  {
		if(code == (unsigned)(-1))
		{
		  /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
		  (10=no endcode, 11=wrong jump outside of tree)*/
		  error = (*bp) > inbitlength ? 10 : 11;
		}
		else error = 16; /*unexisting code, this can never happen*/
		break;
	  }
	}
	if(error) break;

	if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

	/*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
	error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
	if(error) break;
	error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

	break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
  lodepng_free(bitlen_ll);
  lodepng_free(bitlen_d);
  HuffmanTree_cleanup(&tree_cl);

  return error;
}

/*inflate a block with dynamic of fixed Huffman tree*/
static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,
									size_t* pos, size_t inlength, unsigned btype)
{
  unsigned error = 0;
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/
  size_t inbitlength = inlength * 8;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  if(btype == 1) getTreeInflateFixed(&tree_ll, &tree_d);
  else if(btype == 2) error = getTreeInflateDynamic(&tree_ll, &tree_d, in, bp, inlength);

  while(!error) /*decode all symbols until end reached, breaks at end code*/
  {
	/*code_ll is literal, length or end code*/
	unsigned code_ll = huffmanDecodeSymbol(in, bp, &tree_ll, inbitlength);
	if(code_ll <= 255) /*literal symbol*/
	{
	  /*ucvector_push_back would do the same, but for some reason the two lines below run 10% faster*/
	  if(!ucvector_resize(out, (*pos) + 1)) ERROR_BREAK(83 /*alloc fail*/);
	  out->data[*pos] = (unsigned char)code_ll;
	  ++(*pos);
	}
	else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/
	{
	  unsigned code_d, distance;
	  unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
	  size_t start, forward, backward, length;

	  /*part 1: get length base*/
	  length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];

	  /*part 2: get extra bits and add the value of that to length*/
	  numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
	  if((*bp + numextrabits_l) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/
	  length += readBitsFromStream(bp, in, numextrabits_l);

	  /*part 3: get distance code*/
	  code_d = huffmanDecodeSymbol(in, bp, &tree_d, inbitlength);
	  if(code_d > 29)
	  {
		if(code_ll == (unsigned)(-1)) /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
		{
		  /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
		  (10=no endcode, 11=wrong jump outside of tree)*/
		  error = (*bp) > inlength * 8 ? 10 : 11;
		}
		else error = 18; /*error: invalid distance code (30-31 are never used)*/
		break;
	  }
	  distance = DISTANCEBASE[code_d];

	  /*part 4: get extra bits from distance*/
	  numextrabits_d = DISTANCEEXTRA[code_d];
	  if((*bp + numextrabits_d) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/
	  distance += readBitsFromStream(bp, in, numextrabits_d);

	  /*part 5: fill in all the out[n] values based on the length and dist*/
	  start = (*pos);
	  if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
	  backward = start - distance;

	  if(!ucvector_resize(out, (*pos) + length)) ERROR_BREAK(83 /*alloc fail*/);
	  for(forward = 0; forward < length; ++forward)
	  {
		out->data[(*pos)] = out->data[backward];
		++(*pos);
		++backward;
		if(backward >= start) backward = start - distance;
	  }
	}
	else if(code_ll == 256)
	{
	  break; /*end code, break the loop*/
	}
	else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
	{
	  /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
	  (10=no endcode, 11=wrong jump outside of tree)*/
	  error = ((*bp) > inlength * 8) ? 10 : 11;
	  break;
	}
  }

  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)
{
  size_t p;
  unsigned LEN, NLEN, n, error = 0;

  /*go to first boundary of byte*/
  while(((*bp) & 0x7) != 0) ++(*bp);
  p = (*bp) / 8; /*byte position*/

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(p + 4 >= inlength) return 52; /*error, bit pointer will jump past memory*/
  LEN = in[p] + 256u * in[p + 1]; p += 2;
  NLEN = in[p] + 256u * in[p + 1]; p += 2;

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/

  if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/
  for(n = 0; n < LEN; ++n) out->data[(*pos)++] = in[p++];

  (*bp) = p * 8;

  return error;
}

static unsigned lodepng_inflatev(ucvector* out,
								 const unsigned char* in, size_t insize,
								 const LodePNGDecompressSettings* settings)
{
  /*bit pointer in the "in" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/
  size_t bp = 0;
  unsigned BFINAL = 0;
  size_t pos = 0; /*byte position in the out buffer*/
  unsigned error = 0;

  (void)settings;

  while(!BFINAL)
  {
	unsigned BTYPE;
	if(bp + 2 >= insize * 8) return 52; /*error, bit pointer will jump past memory*/
	BFINAL = readBitFromStream(&bp, in);
	BTYPE = 1u * readBitFromStream(&bp, in);
	BTYPE += 2u * readBitFromStream(&bp, in);

	if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
	else if(BTYPE == 0) error = inflateNoCompression(out, in, &bp, &pos, insize); /*no compression*/
	else error = inflateHuffmanBlock(out, in, &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/

	if(error) return error;
  }

  return error;
}

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGDecompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_inflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned inflate(unsigned char** out, size_t* outsize,
						const unsigned char* in, size_t insize,
						const LodePNGDecompressSettings* settings)
{
  if(settings->custom_inflate)
  {
	return settings->custom_inflate(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_inflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflator (Compressor)                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*bitlen is the size in bits of the code*/
static void addHuffmanSymbol(size_t* bp, ucvector* compressed, unsigned code, unsigned bitlen)
{
  addBitsToStreamReversed(bp, compressed, code, bitlen);
}

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value)
{
  /*linear search implementation*/
  /*for(size_t i = 1; i < array_size; ++i) if(array[i] > value) return i - 1;
  return array_size - 1;*/

  /*binary search implementation (not that much faster) (precondition: array_size > 0)*/
  size_t left  = 1;
  size_t right = array_size - 1;
  while(left <= right)
  {
	size_t mid = (left + right) / 2;
	if(array[mid] <= value) left = mid + 1; /*the value to find is more to the right*/
	else if(array[mid - 1] > value) right = mid - 1; /*the value to find is more to the left*/
	else return mid - 1;
  }
  return array_size - 1;
}

static void addLengthDistance(uivector* values, size_t length, size_t distance)
{
  /*values in encoded vector are those used by deflate:
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);

  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);
  uivector_push_back(values, extra_length);
  uivector_push_back(values, dist_code);
  uivector_push_back(values, extra_distance);
}

/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3
bytes as input because 3 is the minimum match length for deflate*/
static const unsigned HASH_NUM_VALUES = 65536;
static const unsigned HASH_BIT_MASK = 65535; /*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/

typedef struct Hash
{
  int* head; /*hash value to head circular pos - can be outdated if went around window*/
  /*circular pos to prev circular pos*/
  unsigned short* chain;
  int* val; /*circular pos to hash value*/

  /*TODO: do this not only for zeros but for any repeated byte. However for PNG
  it's always going to be the zeros that dominate, so not important for PNG*/
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize)
{
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros)
  {
	return 83; /*alloc fail*/
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/

  return 0;
}

static void hash_cleanup(Hash* hash)
{
  lodepng_free(hash->head);
  lodepng_free(hash->val);
  lodepng_free(hash->chain);

  lodepng_free(hash->zeros);
  lodepng_free(hash->headz);
  lodepng_free(hash->chainz);
}

static unsigned getHash(const unsigned char* data, size_t size, size_t pos)
{
  unsigned result = 0;
  if (pos + 2 < size)
  {
	/*A simple shift and xor hash is used. Since the data of PNGs is dominated
	by zeroes due to the filters, a better hash does not have a significant
	effect on speed in traversing the chain, and causes more time spend on
	calculating the hash.*/
	result ^= (unsigned)(data[pos + 0] << 0u);
	result ^= (unsigned)(data[pos + 1] << 4u);
	result ^= (unsigned)(data[pos + 2] << 8u);
  } else {
	size_t amount, i;
	if(pos >= size) return 0;
	amount = size - pos;
	for(i = 0; i != amount; ++i) result ^= (unsigned)(data[pos + i] << (i * 8u));
  }
  return result & HASH_BIT_MASK;
}

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos)
{
  const unsigned char* start = data + pos;
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
  if(end > data + size) end = data + size;
  data = start;
  while (data != end && *data == 0) ++data;
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
}

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros)
{
  hash->val[wpos] = (int)hashval;
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
  hash->head[hashval] = wpos;

  hash->zeros[wpos] = numzeros;
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
  hash->headz[numzeros] = wpos;
}

/*
LZ77-encode the data. Return value is error code. The input are raw bytes, the output
is in the form of unsigned integers with codes representing for example literal bytes, or
length/distance pairs.
It uses a hash table technique to let it encode faster. When doing LZ77 encoding, a
sliding window (of windowsize) is used, and all past bytes in that window can be used as
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
						   const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
						   unsigned minmatch, unsigned nicematch, unsigned lazymatching)
{
  size_t pos;
  unsigned i, error = 0;
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8;
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
  unsigned numzeros = 0;

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
  unsigned lazylength = 0, lazyoffset = 0;
  unsigned hashval;
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos)
  {
	size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
	unsigned chainlength = 0;

	hashval = getHash(in, insize, pos);

	if(usezeros && hashval == 0)
	{
	  if (numzeros == 0) numzeros = countZeros(in, insize, pos);
	  else if (pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
	}
	else
	{
	  numzeros = 0;
	}

	updateHashChain(hash, wpos, hashval, numzeros);

	/*the length and offset found for the current position*/
	length = 0;
	offset = 0;

	hashpos = hash->chain[wpos];

	lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

	/*search for the longest string*/
	prev_offset = 0;
	for(;;)
	{
	  if(chainlength++ >= maxchainlength) break;
	  current_offset = hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize;

	  if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
	  prev_offset = current_offset;
	  if(current_offset > 0)
	  {
		/*test the next characters*/
		foreptr = &in[pos];
		backptr = &in[pos - current_offset];

		/*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
		if(numzeros >= 3)
		{
		  unsigned skip = hash->zeros[hashpos];
		  if(skip > numzeros) skip = numzeros;
		  backptr += skip;
		  foreptr += skip;
		}

		while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/
		{
		  ++backptr;
		  ++foreptr;
		}
		current_length = (unsigned)(foreptr - &in[pos]);

		if(current_length > length)
		{
		  length = current_length; /*the longest length*/
		  offset = current_offset; /*the offset that is related to this longest length*/
		  /*jump out once a length of max length is found (speed gain). This also jumps
		  out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
		  if(current_length >= nicematch) break;
		}
	  }

	  if(hashpos == hash->chain[hashpos]) break;

	  if(numzeros >= 3 && length > numzeros) {
		hashpos = hash->chainz[hashpos];
		if(hash->zeros[hashpos] != numzeros) break;
	  } else {
		hashpos = hash->chain[hashpos];
		/*outdated hash value, happens if particular value was not encountered in whole last window*/
		if(hash->val[hashpos] != (int)hashval) break;
	  }
	}

	if(lazymatching)
	{
	  if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH)
	  {
		lazy = 1;
		lazylength = length;
		lazyoffset = offset;
		continue; /*try the next byte*/
	  }
	  if(lazy)
	  {
		lazy = 0;
		if(pos == 0) ERROR_BREAK(81);
		if(length > lazylength + 1)
		{
		  /*push the previous character as literal*/
		  if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
		}
		else
		{
		  length = lazylength;
		  offset = lazyoffset;
		  hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
		  hash->headz[numzeros] = -1; /*idem*/
		  --pos;
		}
	  }
	}
	if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);

	/*encode it as length/distance pair or literal value*/
	if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/
	{
	  if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
	}
	else if(length < minmatch || (length == 3 && offset > 4096))
	{
	  /*compensate for the fact that longer offsets have more extra bits, a
	  length of only 3 may be not worth it then*/
	  if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
	}
	else
	{
	  addLengthDistance(out, length, offset);
	  for(i = 1; i < length; ++i)
	  {
		++pos;
		wpos = pos & (windowsize - 1);
		hashval = getHash(in, insize, pos);
		if(usezeros && hashval == 0)
		{
		  if (numzeros == 0) numzeros = countZeros(in, insize, pos);
		  else if (pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
		}
		else
		{
		  numzeros = 0;
		}
		updateHashChain(hash, wpos, hashval, numzeros);
	  }
	}
  } /*end of the loop through each character of input*/

  return error;
}

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)
{
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, j, numdeflateblocks = (datasize + 65534) / 65535;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i)
  {
	unsigned BFINAL, BTYPE, LEN, NLEN;
	unsigned char firstbyte;

	BFINAL = (i == numdeflateblocks - 1);
	BTYPE = 0;

	firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1) << 1) + ((BTYPE & 2) << 1));
	ucvector_push_back(out, firstbyte);

	LEN = 65535;
	if(datasize - datapos < 65535) LEN = (unsigned)datasize - datapos;
	NLEN = 65535 - LEN;

	ucvector_push_back(out, (unsigned char)(LEN % 256));
	ucvector_push_back(out, (unsigned char)(LEN / 256));
	ucvector_push_back(out, (unsigned char)(NLEN % 256));
	ucvector_push_back(out, (unsigned char)(NLEN / 256));

	/*Decompressed data*/
	for(j = 0; j < 65535 && datapos < datasize; ++j)
	{
	  ucvector_push_back(out, data[datapos++]);
	}
  }

  return 0;
}

/*
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(size_t* bp, ucvector* out, const uivector* lz77_encoded,
						  const HuffmanTree* tree_ll, const HuffmanTree* tree_d)
{
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i)
  {
	unsigned val = lz77_encoded->data[i];
	addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_ll, val), HuffmanTree_getLength(tree_ll, val));
	if(val > 256) /*for a length code, 3 more things have to be added*/
	{
	  unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
	  unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
	  unsigned length_extra_bits = lz77_encoded->data[++i];

	  unsigned distance_code = lz77_encoded->data[++i];

	  unsigned distance_index = distance_code;
	  unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
	  unsigned distance_extra_bits = lz77_encoded->data[++i];

	  addBitsToStream(bp, out, length_extra_bits, n_length_extra_bits);
	  addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_d, distance_code),
					   HuffmanTree_getLength(tree_d, distance_code));
	  addBitsToStream(bp, out, distance_extra_bits, n_distance_extra_bits);
	}
  }
}

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(ucvector* out, size_t* bp, Hash* hash,
							   const unsigned char* data, size_t datapos, size_t dataend,
							   const LodePNGCompressSettings* settings, unsigned final)
{
  unsigned error = 0;

  /*
  A block is compressed as follows: The PNG data is lz77 encoded, resulting in
  literal bytes and length/distance pairs. This is then huffman compressed with
  two huffman trees. One huffman tree is used for the lit and len values ("ll"),
  another huffman tree is used for the dist values ("d"). These two trees are
  stored using their code lengths, and to compress even more these code lengths
  are also run-length encoded and huffman compressed. This gives a huffman tree
  of code lengths "cl". The code lenghts used to describe this third tree are
  the code length code lengths ("clcl").
  */

  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  uivector frequencies_ll; /*frequency of lit,len codes*/
  uivector frequencies_d; /*frequency of dist codes*/
  uivector frequencies_cl; /*frequency of code length codes*/
  uivector bitlen_lld; /*lit,len,dist code lenghts (int bits), literally (without repeat codes).*/
  uivector bitlen_lld_e; /*bitlen_lld encoded with repeat codes (this is a rudemtary run length compression)*/
  /*bitlen_cl is the code length code lengths ("clcl"). The bit lengths of codes to represent tree_cl
  (these are written as is in the file, it would be crazy to compress these using yet another huffman
  tree that needs to be represented by yet another set of code lengths)*/
  uivector bitlen_cl;
  size_t datasize = dataend - datapos;

  /*
  Due to the huffman compression of huffman tree representations ("two levels"), there are some anologies:
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
  size_t numcodes_ll, numcodes_d, i;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);
  HuffmanTree_init(&tree_cl);
  uivector_init(&frequencies_ll);
  uivector_init(&frequencies_d);
  uivector_init(&frequencies_cl);
  uivector_init(&bitlen_lld);
  uivector_init(&bitlen_lld_e);
  uivector_init(&bitlen_cl);

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error)
  {
	if(settings->use_lz77)
	{
	  error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
						 settings->minmatch, settings->nicematch, settings->lazymatching);
	  if(error) break;
	}
	else
	{
	  if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
	  for(i = datapos; i < dataend; ++i) lz77_encoded.data[i] = data[i]; /*no LZ77, but still will be Huffman compressed*/
	}

	if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83 /*alloc fail*/);
	if(!uivector_resizev(&frequencies_d, 30, 0)) ERROR_BREAK(83 /*alloc fail*/);

	/*Count the frequencies of lit, len and dist codes*/
	for(i = 0; i != lz77_encoded.size; ++i)
	{
	  unsigned symbol = lz77_encoded.data[i];
	  ++frequencies_ll.data[symbol];
	  if(symbol > 256)
	  {
		unsigned dist = lz77_encoded.data[i + 2];
		++frequencies_d.data[dist];
		i += 3;
	  }
	}
	frequencies_ll.data[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

	/*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
	error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll.data, 257, frequencies_ll.size, 15);
	if(error) break;
	/*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
	error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d.data, 2, frequencies_d.size, 15);
	if(error) break;

	numcodes_ll = tree_ll.numcodes; if(numcodes_ll > 286) numcodes_ll = 286;
	numcodes_d = tree_d.numcodes; if(numcodes_d > 30) numcodes_d = 30;
	/*store the code lengths of both generated trees in bitlen_lld*/
	for(i = 0; i != numcodes_ll; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_ll, (unsigned)i));
	for(i = 0; i != numcodes_d; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_d, (unsigned)i));

	/*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
	17 (3-10 zeroes), 18 (11-138 zeroes)*/
	for(i = 0; i != (unsigned)bitlen_lld.size; ++i)
	{
	  unsigned j = 0; /*amount of repititions*/
	  while(i + j + 1 < (unsigned)bitlen_lld.size && bitlen_lld.data[i + j + 1] == bitlen_lld.data[i]) ++j;

	  if(bitlen_lld.data[i] == 0 && j >= 2) /*repeat code for zeroes*/
	  {
		++j; /*include the first zero*/
		if(j <= 10) /*repeat code 17 supports max 10 zeroes*/
		{
		  uivector_push_back(&bitlen_lld_e, 17);
		  uivector_push_back(&bitlen_lld_e, j - 3);
		}
		else /*repeat code 18 supports max 138 zeroes*/
		{
		  if(j > 138) j = 138;
		  uivector_push_back(&bitlen_lld_e, 18);
		  uivector_push_back(&bitlen_lld_e, j - 11);
		}
		i += (j - 1);
	  }
	  else if(j >= 3) /*repeat code for value other than zero*/
	  {
		size_t k;
		unsigned num = j / 6, rest = j % 6;
		uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
		for(k = 0; k < num; ++k)
		{
		  uivector_push_back(&bitlen_lld_e, 16);
		  uivector_push_back(&bitlen_lld_e, 6 - 3);
		}
		if(rest >= 3)
		{
		  uivector_push_back(&bitlen_lld_e, 16);
		  uivector_push_back(&bitlen_lld_e, rest - 3);
		}
		else j -= rest;
		i += j;
	  }
	  else /*too short to benefit from repeat code*/
	  {
		uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
	  }
	}

	/*generate tree_cl, the huffmantree of huffmantrees*/

	if(!uivector_resizev(&frequencies_cl, NUM_CODE_LENGTH_CODES, 0)) ERROR_BREAK(83 /*alloc fail*/);
	for(i = 0; i != bitlen_lld_e.size; ++i)
	{
	  ++frequencies_cl.data[bitlen_lld_e.data[i]];
	  /*after a repeat code come the bits that specify the number of repetitions,
	  those don't need to be in the frequencies_cl calculation*/
	  if(bitlen_lld_e.data[i] >= 16) ++i;
	}

	error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl.data,
											frequencies_cl.size, frequencies_cl.size, 7);
	if(error) break;

	if(!uivector_resize(&bitlen_cl, tree_cl.numcodes)) ERROR_BREAK(83 /*alloc fail*/);
	for(i = 0; i != tree_cl.numcodes; ++i)
	{
	  /*lenghts of code length tree is in the order as specified by deflate*/
	  bitlen_cl.data[i] = HuffmanTree_getLength(&tree_cl, CLCL_ORDER[i]);
	}
	while(bitlen_cl.data[bitlen_cl.size - 1] == 0 && bitlen_cl.size > 4)
	{
	  /*remove zeros at the end, but minimum size must be 4*/
	  if(!uivector_resize(&bitlen_cl, bitlen_cl.size - 1)) ERROR_BREAK(83 /*alloc fail*/);
	}
	if(error) break;

	/*
	Write everything into the output

	After the BFINAL and BTYPE, the dynamic block consists out of the following:
	- 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN
	- (HCLEN+4)*3 bits code lengths of code length alphabet
	- HLIT + 257 code lenghts of lit/length alphabet (encoded using the code length
	  alphabet, + possible repetition codes 16, 17, 18)
	- HDIST + 1 code lengths of distance alphabet (encoded using the code length
	  alphabet, + possible repetition codes 16, 17, 18)
	- compressed data
	- 256 (end code)
	*/

	/*Write block type*/
	addBitToStream(bp, out, BFINAL);
	addBitToStream(bp, out, 0); /*first bit of BTYPE "dynamic"*/
	addBitToStream(bp, out, 1); /*second bit of BTYPE "dynamic"*/

	/*write the HLIT, HDIST and HCLEN values*/
	HLIT = (unsigned)(numcodes_ll - 257);
	HDIST = (unsigned)(numcodes_d - 1);
	HCLEN = (unsigned)bitlen_cl.size - 4;
	/*trim zeroes for HCLEN. HLIT and HDIST were already trimmed at tree creation*/
	while(!bitlen_cl.data[HCLEN + 4 - 1] && HCLEN > 0) --HCLEN;
	addBitsToStream(bp, out, HLIT, 5);
	addBitsToStream(bp, out, HDIST, 5);
	addBitsToStream(bp, out, HCLEN, 4);

	/*write the code lenghts of the code length alphabet*/
	for(i = 0; i != HCLEN + 4; ++i) addBitsToStream(bp, out, bitlen_cl.data[i], 3);

	/*write the lenghts of the lit/len AND the dist alphabet*/
	for(i = 0; i != bitlen_lld_e.size; ++i)
	{
	  addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_cl, bitlen_lld_e.data[i]),
					   HuffmanTree_getLength(&tree_cl, bitlen_lld_e.data[i]));
	  /*extra bits of repeat codes*/
	  if(bitlen_lld_e.data[i] == 16) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 2);
	  else if(bitlen_lld_e.data[i] == 17) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 3);
	  else if(bitlen_lld_e.data[i] == 18) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 7);
	}

	/*write the compressed data symbols*/
	writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
	/*error: the length of the end code 256 must be larger than 0*/
	if(HuffmanTree_getLength(&tree_ll, 256) == 0) ERROR_BREAK(64);

	/*write the end code*/
	addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

	break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);
  HuffmanTree_cleanup(&tree_cl);
  uivector_cleanup(&frequencies_ll);
  uivector_cleanup(&frequencies_d);
  uivector_cleanup(&frequencies_cl);
  uivector_cleanup(&bitlen_lld_e);
  uivector_cleanup(&bitlen_lld);
  uivector_cleanup(&bitlen_cl);

  return error;
}

static unsigned deflateFixed(ucvector* out, size_t* bp, Hash* hash,
							 const unsigned char* data,
							 size_t datapos, size_t dataend,
							 const LodePNGCompressSettings* settings, unsigned final)
{
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
  unsigned error = 0;
  size_t i;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  generateFixedLitLenTree(&tree_ll);
  generateFixedDistanceTree(&tree_d);

  addBitToStream(bp, out, BFINAL);
  addBitToStream(bp, out, 1); /*first bit of BTYPE*/
  addBitToStream(bp, out, 0); /*second bit of BTYPE*/

  if(settings->use_lz77) /*LZ77 encoded*/
  {
	uivector lz77_encoded;
	uivector_init(&lz77_encoded);
	error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
					   settings->minmatch, settings->nicematch, settings->lazymatching);
	if(!error) writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
	uivector_cleanup(&lz77_encoded);
  }
  else /*no LZ77, but still will be Huffman compressed*/
  {
	for(i = datapos; i < dataend; ++i)
	{
	  addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, data[i]), HuffmanTree_getLength(&tree_ll, data[i]));
	}
  }
  /*add END code*/
  if(!error) addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
								 const LodePNGCompressSettings* settings)
{
  unsigned error = 0;
  size_t i, blocksize, numdeflateblocks;
  size_t bp = 0; /*the bit pointer*/
  Hash hash;

  if(settings->btype > 2) return 61;
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
  else if(settings->btype == 1) blocksize = insize;
  else /*if(settings->btype == 2)*/
  {
	blocksize = insize / 8 + 8;
	if(blocksize < 65535) blocksize = 65535;
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);
  if(error) return error;

  for(i = 0; i != numdeflateblocks && !error; ++i)
  {
	unsigned final = (i == numdeflateblocks - 1);
	size_t start = i * blocksize;
	size_t end = start + blocksize;
	if(end > insize) end = insize;

	if(settings->btype == 1) error = deflateFixed(out, &bp, &hash, in, start, end, settings, final);
	else if(settings->btype == 2) error = deflateDynamic(out, &bp, &hash, in, start, end, settings, final);
  }

  hash_cleanup(&hash);

  return error;
}

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGCompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_deflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned deflate(unsigned char** out, size_t* outsize,
						const unsigned char* in, size_t insize,
						const LodePNGCompressSettings* settings)
{
  if(settings->custom_deflate)
  {
	return settings->custom_deflate(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_deflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                  */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
	/*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
	unsigned amount = len > 5550 ? 5550 : len;
	len -= amount;
	while(amount > 0)
	{
	  s1 += (*data++);
	  s2 += s1;
	  --amount;
	}
	s1 %= 65521;
	s2 %= 65521;
  }

  return (s2 << 16) | s1;
}

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len)
{
  return update_adler32(1L, data, len);
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Zlib                                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DECODER

unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
								 size_t insize, const LodePNGDecompressSettings* settings)
{
  unsigned error = 0;
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0)
  {
	/*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
	return 24;
  }

  CM = in[0] & 15;
  CINFO = (in[0] >> 4) & 15;
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7)
  {
	/*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
	return 25;
  }
  if(FDICT != 0)
  {
	/*error: the specification of PNG says about the zlib stream:
	  "The additional flags shall not specify a preset dictionary."*/
	return 26;
  }

  error = inflate(out, outsize, in + 2, insize - 2, settings);
  if(error) return error;

  if(!settings->ignore_adler32)
  {
	unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
	unsigned checksum = adler32(*out, (unsigned)(*outsize));
	if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
  }

  return 0; /*no error*/
}

static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
								size_t insize, const LodePNGDecompressSettings* settings)
{
  if(settings->custom_zlib)
  {
	return settings->custom_zlib(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_zlib_decompress(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
							   size_t insize, const LodePNGCompressSettings* settings)
{
  /*initially, *out must be NULL and outsize 0, if you just give some random *out
  that's pointing to a non allocated buffer, this'll crash*/
  ucvector outv;
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
  size_t deflatesize = 0;

  /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
  unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
  unsigned FLEVEL = 0;
  unsigned FDICT = 0;
  unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
  unsigned FCHECK = 31 - CMFFLG % 31;
  CMFFLG += FCHECK;

  /*ucvector-controlled version of the output buffer, for dynamic array*/
  ucvector_init_buffer(&outv, *out, *outsize);

  ucvector_push_back(&outv, (unsigned char)(CMFFLG / 256));
  ucvector_push_back(&outv, (unsigned char)(CMFFLG % 256));

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);

  if(!error)
  {
	unsigned ADLER32 = adler32(in, (unsigned)insize);
	for(i = 0; i != deflatesize; ++i) ucvector_push_back(&outv, deflatedata[i]);
	lodepng_free(deflatedata);
	lodepng_add32bitInt(&outv, ADLER32);
  }

  *out = outv.data;
  *outsize = outv.size;

  return error;
}

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
							  size_t insize, const LodePNGCompressSettings* settings)
{
  if(settings->custom_zlib)
  {
	return settings->custom_zlib(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_zlib_compress(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_ENCODER*/

#else /*no LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DECODER
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
								size_t insize, const LodePNGDecompressSettings* settings)
{
  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
							  size_t insize, const LodePNGCompressSettings* settings)
{
  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#endif /*LODEPNG_COMPILE_ZLIB*/

/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings)
{
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
  settings->use_lz77 = 1;
  settings->windowsize = DEFAULT_WINDOWSIZE;
  settings->minmatch = 3;
  settings->nicematch = 128;
  settings->lazymatching = 1;

  settings->custom_zlib = 0;
  settings->custom_deflate = 0;
  settings->custom_context = 0;
}

const LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings)
{
  settings->ignore_adler32 = 0;

  settings->custom_zlib = 0;
  settings->custom_inflate = 0;
  settings->custom_context = 0;
}

const LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0};

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of Zlib related code. Begin of PNG related code.                 // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG

/* ////////////////////////////////////////////////////////////////////////// */
/* / CRC32                                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */

/* CRC polynomial: 0xedb88320 */
static unsigned lodepng_crc32_table[256] = {
		   0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u, 3915621685u, 2657392035u,
   249268274u, 2044508324u, 3772115230u, 2547177864u,  162941995u, 2125561021u, 3887607047u, 2428444049u,
   498536548u, 1789927666u, 4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,
   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u, 4195302755u, 2366115317u,
   997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u,
   901097722u, 1119000684u, 3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,
   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u, 3485111705u, 3099436303u,
   671266974u, 1594198024u, 3322730930u, 2970347812u,  795835527u, 1483230225u, 3244367275u, 3060149565u,
  1994146192u,   31158534u, 2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,
  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u, 2439277719u, 3865271297u,
  1802195444u,  476864866u, 2238001368u, 4066508878u, 1812370925u,  453092731u, 2181625025u, 4111451223u,
  1706088902u,  314042704u, 2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,
  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u,
  1131014506u,  879679996u, 2909243462u, 3663771856u, 1141124467u,  855842277u, 2852801631u, 3708648649u,
  1342533948u,  654459306u, 3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,
  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u, 3082640443u, 3233442989u,
  3988292384u, 2596254646u,   62317068u, 1957810842u, 3939845945u, 2647816111u,   81470997u, 1943803523u,
  3814918930u, 2489596804u,  225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,
  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,  426522225u, 1852507879u,
  4275313526u, 2312317920u,  282753626u, 1742555852u, 4189708143u, 2394877945u,  397917763u, 1622183637u,
  3604390888u, 2714866558u,  953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,
  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,  829329135u, 1181335161u,
  3412177804u, 3160834842u,  628085408u, 1382605366u, 3423369109u, 3138078467u,  570562233u, 1426400815u,
  3317316542u, 2998733608u,  733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,
  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u, 1913087877u,   83908371u,
  2512341634u, 3803740692u, 2075208622u,  213261112u, 2463272603u, 3855990285u, 2094854071u,  198958881u,
  2262029012u, 4057260610u, 1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,
  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u, 1634467795u,  376229701u,
  2685067896u, 3608007406u, 1308918612u,  956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u,
  2932959818u, 3654703836u, 1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* buf, size_t len)
{
  unsigned c = 0xffffffffL;
  size_t n;

  for(n = 0; n < len; ++n)
  {
	c = lodepng_crc32_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
  }
  return c ^ 0xffffffffL;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
  ++(*bitpointer);
  return result;
}

static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0;
  size_t i;
  for(i = nbits - 1; i < nbits; --i)
  {
	result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
  }
  return result;
}

#ifdef LODEPNG_COMPILE_DECODER
static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream must be 0 for this to work*/
  if(bit)
  {
	/*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
	bitstream[(*bitpointer) >> 3] |= (bit << (7 - ((*bitpointer) & 0x7)));
  }
  ++(*bitpointer);
}
#endif /*LODEPNG_COMPILE_DECODER*/

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
  ++(*bitpointer);
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk)
{
  return lodepng_read32bitInt(&chunk[0]);
}

void lodepng_chunk_type(char type[5], const unsigned char* chunk)
{
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
  type[4] = 0; /*null termination char*/
}

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type)
{
  if(strlen(type) != 4) return 0;
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
}

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk)
{
  return((chunk[4] & 32) != 0);
}

unsigned char lodepng_chunk_private(const unsigned char* chunk)
{
  return((chunk[6] & 32) != 0);
}

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)
{
  return((chunk[7] & 32) != 0);
}

unsigned char* lodepng_chunk_data(unsigned char* chunk)
{
  return &chunk[8];
}

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk)
{
  return &chunk[8];
}

unsigned lodepng_chunk_check_crc(const unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
  if(CRC != checksum) return 1;
  else return 0;
}

void lodepng_chunk_generate_crc(unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
  lodepng_set32bitInt(chunk + 8 + length, CRC);
}

unsigned char* lodepng_chunk_next(unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk)
{
  unsigned i;
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  unsigned char *chunk_start, *new_buffer;
  size_t new_length = (*outlength) + total_chunk_length;
  if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk_start = &(*out)[new_length - total_chunk_length];

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];

  return 0;
}

unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
							  const char* type, const unsigned char* data)
{
  unsigned i;
  unsigned char *chunk, *new_buffer;
  size_t new_length = (*outlength) + length + 12;
  if(new_length < length + 12 || new_length < (*outlength)) return 77; /*integer overflow happened*/
  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk = &(*out)[(*outlength) - length - 12];

  /*1: length*/
  lodepng_set32bitInt(chunk, (unsigned)length);

  /*2: chunk name (4 letters)*/
  chunk[4] = (unsigned char)type[0];
  chunk[5] = (unsigned char)type[1];
  chunk[6] = (unsigned char)type[2];
  chunk[7] = (unsigned char)type[3];

  /*3: the data*/
  for(i = 0; i != length; ++i) chunk[8 + i] = data[i];

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);

  return 0;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Color types and such                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

/*return type is a LodePNG error code*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) /*bd = bitdepth*/
{
  switch(colortype)
  {
	case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/
	case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/
	case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/
	case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/
	case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/
	default: return 31;
  }
  return 0; /*allowed color type / bits combination*/
}

static unsigned getNumColorChannels(LodePNGColorType colortype)
{
  switch(colortype)
  {
	case 0: return 1; /*grey*/
	case 2: return 3; /*RGB*/
	case 3: return 1; /*palette*/
	case 4: return 2; /*grey + alpha*/
	case 6: return 4; /*RGBA*/
  }
  return 0; /*unexisting color type*/
}

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)
{
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
}

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info)
{
  info->key_defined = 0;
  info->key_r = info->key_g = info->key_b = 0;
  info->colortype = LCT_RGBA;
  info->bitdepth = 8;
  info->palette = 0;
  info->palettesize = 0;
}

void lodepng_color_mode_cleanup(LodePNGColorMode* info)
{
  lodepng_palette_clear(info);
}

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source)
{
  size_t i;
  lodepng_color_mode_cleanup(dest);
  *dest = *source;
  if(source->palette)
  {
	dest->palette = (unsigned char*)lodepng_malloc(1024);
	if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
	for(i = 0; i != source->palettesize * 4; ++i) dest->palette[i] = source->palette[i];
  }
  return 0;
}

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b)
{
  size_t i;
  if(a->colortype != b->colortype) return 0;
  if(a->bitdepth != b->bitdepth) return 0;
  if(a->key_defined != b->key_defined) return 0;
  if(a->key_defined)
  {
	if(a->key_r != b->key_r) return 0;
	if(a->key_g != b->key_g) return 0;
	if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i)
  {
	if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
}

void lodepng_palette_clear(LodePNGColorMode* info)
{
  if(info->palette) lodepng_free(info->palette);
  info->palette = 0;
  info->palettesize = 0;
}

unsigned lodepng_palette_add(LodePNGColorMode* info,
							 unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  unsigned char* data;
  /*the same resize technique as C++ std::vectors is used, and here it's made so that for a palette with
  the max of 256 colors, it'll have the exact alloc size*/
  if(!info->palette) /*allocate palette if empty*/
  {
	/*room for 256 colors with 4 bytes each*/
	data = (unsigned char*)lodepng_realloc(info->palette, 1024);
	if(!data) return 83; /*alloc fail*/
	else info->palette = data;
  }
  info->palette[4 * info->palettesize + 0] = r;
  info->palette[4 * info->palettesize + 1] = g;
  info->palette[4 * info->palettesize + 2] = b;
  info->palette[4 * info->palettesize + 3] = a;
  ++info->palettesize;
  return 0;
}

unsigned lodepng_get_bpp(const LodePNGColorMode* info)
{
  /*calculate bits per pixel out of colortype and bitdepth*/
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
}

unsigned lodepng_get_channels(const LodePNGColorMode* info)
{
  return getNumColorChannels(info->colortype);
}

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
}

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info)
{
  return (info->colortype & 4) != 0; /*4 or 6*/
}

unsigned lodepng_is_palette_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info)
{
  size_t i;
  for(i = 0; i != info->palettesize; ++i)
  {
	if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info)
{
  return info->key_defined
	  || lodepng_is_alpha_type(info)
	  || lodepng_has_palette_alpha(info);
}

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return (w * h * lodepng_get_bpp(color) + 7) / 8;
}

size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  return (w * h * lodepng_get_bpp_lct(colortype, bitdepth) + 7) / 8;
}

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_DECODER
/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer*/
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
}

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
}

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src)
{
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i)
  {
	size_t j;
	dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
	dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
	if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
	for(j = 0; j < src->unknown_chunks_size[i]; ++j)
	{
	  dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
	}
  }

  return 0;
}

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info)
{
  info->text_num = 0;
  info->text_keys = NULL;
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i != info->text_num; ++i)
  {
	string_cleanup(&info->text_keys[i]);
	string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
  lodepng_free(info->text_strings);
}

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->text_keys = 0;
  dest->text_strings = 0;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i)
  {
	CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
}

void lodepng_clear_text(LodePNGInfo* info)
{
  LodePNGText_cleanup(info);
}

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
  if(!new_keys || !new_strings)
  {
	lodepng_free(new_keys);
	lodepng_free(new_strings);
	return 83; /*alloc fail*/
  }

  ++info->text_num;
  info->text_keys = new_keys;
  info->text_strings = new_strings;

  string_init(&info->text_keys[info->text_num - 1]);
  string_set(&info->text_keys[info->text_num - 1], key);

  string_init(&info->text_strings[info->text_num - 1]);
  string_set(&info->text_strings[info->text_num - 1], str);

  return 0;
}

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info)
{
  info->itext_num = 0;
  info->itext_keys = NULL;
  info->itext_langtags = NULL;
  info->itext_transkeys = NULL;
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i != info->itext_num; ++i)
  {
	string_cleanup(&info->itext_keys[i]);
	string_cleanup(&info->itext_langtags[i]);
	string_cleanup(&info->itext_transkeys[i]);
	string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
  lodepng_free(info->itext_langtags);
  lodepng_free(info->itext_transkeys);
  lodepng_free(info->itext_strings);
}

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->itext_keys = 0;
  dest->itext_langtags = 0;
  dest->itext_transkeys = 0;
  dest->itext_strings = 0;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i)
  {
	CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
										source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
}

void lodepng_clear_itext(LodePNGInfo* info)
{
  LodePNGIText_cleanup(info);
}

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
						   const char* transkey, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
  if(!new_keys || !new_langtags || !new_transkeys || !new_strings)
  {
	lodepng_free(new_keys);
	lodepng_free(new_langtags);
	lodepng_free(new_transkeys);
	lodepng_free(new_strings);
	return 83; /*alloc fail*/
  }

  ++info->itext_num;
  info->itext_keys = new_keys;
  info->itext_langtags = new_langtags;
  info->itext_transkeys = new_transkeys;
  info->itext_strings = new_strings;

  string_init(&info->itext_keys[info->itext_num - 1]);
  string_set(&info->itext_keys[info->itext_num - 1], key);

  string_init(&info->itext_langtags[info->itext_num - 1]);
  string_set(&info->itext_langtags[info->itext_num - 1], langtag);

  string_init(&info->itext_transkeys[info->itext_num - 1]);
  string_set(&info->itext_transkeys[info->itext_num - 1], transkey);

  string_init(&info->itext_strings[info->itext_num - 1]);
  string_set(&info->itext_strings[info->itext_num - 1], str);

  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info)
{
  lodepng_color_mode_init(&info->color);
  info->interlace_method = 0;
  info->compression_method = 0;
  info->filter_method = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
  info->background_r = info->background_g = info->background_b = 0;

  LodePNGText_init(info);
  LodePNGIText_init(info);

  info->time_defined = 0;
  info->phys_defined = 0;

  LodePNGUnknownChunks_init(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

void lodepng_info_cleanup(LodePNGInfo* info)
{
  lodepng_color_mode_cleanup(&info->color);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
  LodePNGIText_cleanup(info);

  LodePNGUnknownChunks_cleanup(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  lodepng_info_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->color);
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));

  LodePNGUnknownChunks_init(dest);
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
}

void lodepng_info_swap(LodePNGInfo* a, LodePNGInfo* b)
{
  LodePNGInfo temp = *a;
  *a = *b;
  *b = temp;
}

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)
{
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8] = in;
  else out[index * bits / 8] |= in;
}

typedef struct ColorTree ColorTree;

/*
One node of a color tree
This is the data structure used to count the number of unique colors and to get a palette
index for a color. It's like an octree, but because the alpha channel is used too, each
node has 16 instead of 8 children.
*/
struct ColorTree
{
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree)
{
  int i;
  for(i = 0; i != 16; ++i) tree->children[i] = 0;
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree)
{
  int i;
  for(i = 0; i != 16; ++i)
  {
	if(tree->children[i])
	{
	  color_tree_cleanup(tree->children[i]);
	  lodepng_free(tree->children[i]);
	}
  }
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  int bit = 0;
  for(bit = 0; bit < 8; ++bit)
  {
	int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
	if(!tree->children[i]) return -1;
	else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
}

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  return color_tree_get(tree, r, g, b, a) >= 0;
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")*/
static void color_tree_add(ColorTree* tree,
						   unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)
{
  int bit;
  for(bit = 0; bit < 8; ++bit)
  {
	int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
	if(!tree->children[i])
	{
	  tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
	  color_tree_init(tree->children[i]);
	}
	tree = tree->children[i];
  }
  tree->index = (int)index;
}

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
							 const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
							 unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  if(mode->colortype == LCT_GREY)
  {
	unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
	if(mode->bitdepth == 8) out[i] = grey;
	else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = grey;
	else
	{
	  /*take the most significant bits of grey*/
	  grey = (grey >> (8 - mode->bitdepth)) & ((1 << mode->bitdepth) - 1);
	  addColorBits(out, i, mode->bitdepth, grey);
	}
  }
  else if(mode->colortype == LCT_RGB)
  {
	if(mode->bitdepth == 8)
	{
	  out[i * 3 + 0] = r;
	  out[i * 3 + 1] = g;
	  out[i * 3 + 2] = b;
	}
	else
	{
	  out[i * 6 + 0] = out[i * 6 + 1] = r;
	  out[i * 6 + 2] = out[i * 6 + 3] = g;
	  out[i * 6 + 4] = out[i * 6 + 5] = b;
	}
  }
  else if(mode->colortype == LCT_PALETTE)
  {
	int index = color_tree_get(tree, r, g, b, a);
	if(index < 0) return 82; /*color not in palette*/
	if(mode->bitdepth == 8) out[i] = index;
	else addColorBits(out, i, mode->bitdepth, (unsigned)index);
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
	if(mode->bitdepth == 8)
	{
	  out[i * 2 + 0] = grey;
	  out[i * 2 + 1] = a;
	}
	else if(mode->bitdepth == 16)
	{
	  out[i * 4 + 0] = out[i * 4 + 1] = grey;
	  out[i * 4 + 2] = out[i * 4 + 3] = a;
	}
  }
  else if(mode->colortype == LCT_RGBA)
  {
	if(mode->bitdepth == 8)
	{
	  out[i * 4 + 0] = r;
	  out[i * 4 + 1] = g;
	  out[i * 4 + 2] = b;
	  out[i * 4 + 3] = a;
	}
	else
	{
	  out[i * 8 + 0] = out[i * 8 + 1] = r;
	  out[i * 8 + 2] = out[i * 8 + 3] = g;
	  out[i * 8 + 4] = out[i * 8 + 5] = b;
	  out[i * 8 + 6] = out[i * 8 + 7] = a;
	}
  }

  return 0; /*no error*/
}

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
						 const LodePNGColorMode* mode,
						 unsigned short r, unsigned short g, unsigned short b, unsigned short a)
{
  if(mode->colortype == LCT_GREY)
  {
	unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
	out[i * 2 + 0] = (grey >> 8) & 255;
	out[i * 2 + 1] = grey & 255;
  }
  else if(mode->colortype == LCT_RGB)
  {
	out[i * 6 + 0] = (r >> 8) & 255;
	out[i * 6 + 1] = r & 255;
	out[i * 6 + 2] = (g >> 8) & 255;
	out[i * 6 + 3] = g & 255;
	out[i * 6 + 4] = (b >> 8) & 255;
	out[i * 6 + 5] = b & 255;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
	out[i * 4 + 0] = (grey >> 8) & 255;
	out[i * 4 + 1] = grey & 255;
	out[i * 4 + 2] = (a >> 8) & 255;
	out[i * 4 + 3] = a & 255;
  }
  else if(mode->colortype == LCT_RGBA)
  {
	out[i * 8 + 0] = (r >> 8) & 255;
	out[i * 8 + 1] = r & 255;
	out[i * 8 + 2] = (g >> 8) & 255;
	out[i * 8 + 3] = g & 255;
	out[i * 8 + 4] = (b >> 8) & 255;
	out[i * 8 + 5] = b & 255;
	out[i * 8 + 6] = (a >> 8) & 255;
	out[i * 8 + 7] = a & 255;
  }
}

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
							   unsigned char* b, unsigned char* a,
							   const unsigned char* in, size_t i,
							   const LodePNGColorMode* mode)
{
  if(mode->colortype == LCT_GREY)
  {
	if(mode->bitdepth == 8)
	{
	  *r = *g = *b = in[i];
	  if(mode->key_defined && *r == mode->key_r) *a = 0;
	  else *a = 255;
	}
	else if(mode->bitdepth == 16)
	{
	  *r = *g = *b = in[i * 2 + 0];
	  if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
	  else *a = 255;
	}
	else
	{
	  unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
	  size_t j = i * mode->bitdepth;
	  unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
	  *r = *g = *b = (value * 255) / highest;
	  if(mode->key_defined && value == mode->key_r) *a = 0;
	  else *a = 255;
	}
  }
  else if(mode->colortype == LCT_RGB)
  {
	if(mode->bitdepth == 8)
	{
	  *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
	  if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
	  else *a = 255;
	}
	else
	{
	  *r = in[i * 6 + 0];
	  *g = in[i * 6 + 2];
	  *b = in[i * 6 + 4];
	  if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
		 && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
		 && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
	  else *a = 255;
	}
  }
  else if(mode->colortype == LCT_PALETTE)
  {
	unsigned index;
	if(mode->bitdepth == 8) index = in[i];
	else
	{
	  size_t j = i * mode->bitdepth;
	  index = readBitsFromReversedStream(&j, in, mode->bitdepth);
	}

	if(index >= mode->palettesize)
	{
	  /*This is an error according to the PNG spec, but common PNG decoders make it black instead.
	  Done here too, slightly faster due to no error handling needed.*/
	  *r = *g = *b = 0;
	  *a = 255;
	}
	else
	{
	  *r = mode->palette[index * 4 + 0];
	  *g = mode->palette[index * 4 + 1];
	  *b = mode->palette[index * 4 + 2];
	  *a = mode->palette[index * 4 + 3];
	}
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	if(mode->bitdepth == 8)
	{
	  *r = *g = *b = in[i * 2 + 0];
	  *a = in[i * 2 + 1];
	}
	else
	{
	  *r = *g = *b = in[i * 4 + 0];
	  *a = in[i * 4 + 2];
	}
  }
  else if(mode->colortype == LCT_RGBA)
  {
	if(mode->bitdepth == 8)
	{
	  *r = in[i * 4 + 0];
	  *g = in[i * 4 + 1];
	  *b = in[i * 4 + 2];
	  *a = in[i * 4 + 3];
	}
	else
	{
	  *r = in[i * 8 + 0];
	  *g = in[i * 8 + 2];
	  *b = in[i * 8 + 4];
	  *a = in[i * 8 + 6];
	}
  }
}

/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color
mode test cases, optimized to convert the colors much faster, when converting
to RGBA or RGB with 8 bit per cannel. buffer must be RGBA or RGB output with
enough memory, if has_alpha is true the output is RGBA. mode has the color mode
of the input buffer.*/
static void getPixelColorsRGBA8(unsigned char* buffer, size_t numpixels,
								unsigned has_alpha, const unsigned char* in,
								const LodePNGColorMode* mode)
{
  unsigned num_channels = has_alpha ? 4 : 3;
  size_t i;
  if(mode->colortype == LCT_GREY)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i];
		if(has_alpha) buffer[3] = mode->key_defined && in[i] == mode->key_r ? 0 : 255;
	  }
	}
	else if(mode->bitdepth == 16)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i * 2];
		if(has_alpha) buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
	  }
	}
	else
	{
	  unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
	  size_t j = 0;
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
		buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
		if(has_alpha) buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
	  }
	}
  }
  else if(mode->colortype == LCT_RGB)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 3 + 0];
		buffer[1] = in[i * 3 + 1];
		buffer[2] = in[i * 3 + 2];
		if(has_alpha) buffer[3] = mode->key_defined && buffer[0] == mode->key_r
		   && buffer[1]== mode->key_g && buffer[2] == mode->key_b ? 0 : 255;
	  }
	}
	else
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 6 + 0];
		buffer[1] = in[i * 6 + 2];
		buffer[2] = in[i * 6 + 4];
		if(has_alpha) buffer[3] = mode->key_defined
		   && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
		   && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
		   && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
	  }
	}
  }
  else if(mode->colortype == LCT_PALETTE)
  {
	unsigned index;
	size_t j = 0;
	for(i = 0; i != numpixels; ++i, buffer += num_channels)
	{
	  if(mode->bitdepth == 8) index = in[i];
	  else index = readBitsFromReversedStream(&j, in, mode->bitdepth);

	  if(index >= mode->palettesize)
	  {
		/*This is an error according to the PNG spec, but most PNG decoders make it black instead.
		Done here too, slightly faster due to no error handling needed.*/
		buffer[0] = buffer[1] = buffer[2] = 0;
		if(has_alpha) buffer[3] = 255;
	  }
	  else
	  {
		buffer[0] = mode->palette[index * 4 + 0];
		buffer[1] = mode->palette[index * 4 + 1];
		buffer[2] = mode->palette[index * 4 + 2];
		if(has_alpha) buffer[3] = mode->palette[index * 4 + 3];
	  }
	}
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
		if(has_alpha) buffer[3] = in[i * 2 + 1];
	  }
	}
	else
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
		if(has_alpha) buffer[3] = in[i * 4 + 2];
	  }
	}
  }
  else if(mode->colortype == LCT_RGBA)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 4 + 0];
		buffer[1] = in[i * 4 + 1];
		buffer[2] = in[i * 4 + 2];
		if(has_alpha) buffer[3] = in[i * 4 + 3];
	  }
	}
	else
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 8 + 0];
		buffer[1] = in[i * 8 + 2];
		buffer[2] = in[i * 8 + 4];
		if(has_alpha) buffer[3] = in[i * 8 + 6];
	  }
	}
  }
}

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
								const unsigned char* in, size_t i, const LodePNGColorMode* mode)
{
  if(mode->colortype == LCT_GREY)
  {
	*r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
	if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
	else *a = 65535;
  }
  else if(mode->colortype == LCT_RGB)
  {
	*r = 256 * in[i * 6 + 0] + in[i * 6 + 1];
	*g = 256 * in[i * 6 + 2] + in[i * 6 + 3];
	*b = 256 * in[i * 6 + 4] + in[i * 6 + 5];
	if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
	   && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
	   && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
	else *a = 65535;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	*r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];
	*a = 256 * in[i * 4 + 2] + in[i * 4 + 3];
  }
  else if(mode->colortype == LCT_RGBA)
  {
	*r = 256 * in[i * 8 + 0] + in[i * 8 + 1];
	*g = 256 * in[i * 8 + 2] + in[i * 8 + 3];
	*b = 256 * in[i * 8 + 4] + in[i * 8 + 5];
	*a = 256 * in[i * 8 + 6] + in[i * 8 + 7];
  }
}

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
						 LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
						 unsigned w, unsigned h)
{
  size_t i;
  ColorTree tree;
  size_t numpixels = w * h;

  if(lodepng_color_mode_equal(mode_out, mode_in))
  {
	size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
	for(i = 0; i != numbytes; ++i) out[i] = in[i];
	return 0;
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
	size_t palsize = 1u << mode_out->bitdepth;
	if(mode_out->palettesize < palsize) palsize = mode_out->palettesize;
	color_tree_init(&tree);
	for(i = 0; i != palsize; ++i)
	{
	  unsigned char* p = &mode_out->palette[i * 4];
	  color_tree_add(&tree, p[0], p[1], p[2], p[3], i);
	}
  }

  if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16)
  {
	for(i = 0; i != numpixels; ++i)
	{
	  unsigned short r = 0, g = 0, b = 0, a = 0;
	  getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
	  rgba16ToPixel(out, i, mode_out, r, g, b, a);
	}
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA)
  {
	getPixelColorsRGBA8(out, numpixels, 1, in, mode_in);
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB)
  {
	getPixelColorsRGBA8(out, numpixels, 0, in, mode_in);
  }
  else
  {
	unsigned char r = 0, g = 0, b = 0, a = 0;
	for(i = 0; i != numpixels; ++i)
	{
	  getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
	  rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
	}
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
	color_tree_cleanup(&tree);
  }

  return 0; /*no error (this function currently never has one, but maybe OOM detection added later.)*/
}

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_profile_init(LodePNGColorProfile* profile)
{
  profile->colored = 0;
  profile->key = 0;
  profile->alpha = 0;
  profile->key_r = profile->key_g = profile->key_b = 0;
  profile->numcolors = 0;
  profile->bits = 1;
}

/*function used for debug purposes with C++*/
/*void printColorProfile(LodePNGColorProfile* p)
{
  std::cout << "colored: " << (int)p->colored << ", ";
  std::cout << "key: " << (int)p->key << ", ";
  std::cout << "key_r: " << (int)p->key_r << ", ";
  std::cout << "key_g: " << (int)p->key_g << ", ";
  std::cout << "key_b: " << (int)p->key_b << ", ";
  std::cout << "alpha: " << (int)p->alpha << ", ";
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value)
{
  if(value == 0 || value == 255) return 1;
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
  return 8;
}

/*profile must already have been inited with mode.
It's ok to set some parameters of profile to done already.*/
unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,
								   const unsigned char* in, unsigned w, unsigned h,
								   const LodePNGColorMode* mode)
{
  unsigned error = 0;
  size_t i;
  ColorTree tree;
  size_t numpixels = w * h;

  unsigned colored_done = lodepng_is_greyscale_type(mode) ? 1 : 0;
  unsigned alpha_done = lodepng_can_have_alpha(mode) ? 0 : 1;
  unsigned numcolors_done = 0;
  unsigned bpp = lodepng_get_bpp(mode);
  unsigned bits_done = bpp == 1 ? 1 : 0;
  unsigned maxnumcolors = 257;
  unsigned sixteen = 0;
  if(bpp <= 8) maxnumcolors = bpp == 1 ? 2 : (bpp == 2 ? 4 : (bpp == 4 ? 16 : 256));

  color_tree_init(&tree);

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode->bitdepth == 16)
  {
	unsigned short r, g, b, a;
	for(i = 0; i != numpixels; ++i)
	{
	  getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);
	  if((r & 255u) != ((r >> 8) & 255u) || (g & 255u) != ((g >> 8) & 255u) ||
		 (b & 255u) != ((b >> 8) & 255u) || (a & 255u) != ((a >> 8) & 255u)) /*first and second byte differ*/
	  {
		sixteen = 1;
		break;
	  }
	}
  }

  if(sixteen)
  {
	unsigned short r = 0, g = 0, b = 0, a = 0;
	profile->bits = 16;
	bits_done = numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/

	for(i = 0; i != numpixels; ++i)
	{
	  getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);

	  if(!colored_done && (r != g || r != b))
	  {
		profile->colored = 1;
		colored_done = 1;
	  }

	  if(!alpha_done)
	  {
		unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);
		if(a != 65535 && (a != 0 || (profile->key && !matchkey)))
		{
		  profile->alpha = 1;
		  alpha_done = 1;
		  if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
		}
		else if(a == 0 && !profile->alpha && !profile->key)
		{
		  profile->key = 1;
		  profile->key_r = r;
		  profile->key_g = g;
		  profile->key_b = b;
		}
		else if(a == 65535 && profile->key && matchkey)
		{
		  /* Color key cannot be used if an opaque pixel also has that RGB color. */
		  profile->alpha = 1;
		  alpha_done = 1;
		}
	  }

	  if(alpha_done && numcolors_done && colored_done && bits_done) break;
	}
  }
  else /* < 16-bit */
  {
	for(i = 0; i != numpixels; ++i)
	{
	  unsigned char r = 0, g = 0, b = 0, a = 0;
	  getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);

	  if(!bits_done && profile->bits < 8)
	  {
		/*only r is checked, < 8 bits is only relevant for greyscale*/
		unsigned bits = getValueRequiredBits(r);
		if(bits > profile->bits) profile->bits = bits;
	  }
	  bits_done = (profile->bits >= bpp);

	  if(!colored_done && (r != g || r != b))
	  {
		profile->colored = 1;
		colored_done = 1;
		if(profile->bits < 8) profile->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
	  }

	  if(!alpha_done)
	  {
		unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);
		if(a != 255 && (a != 0 || (profile->key && !matchkey)))
		{
		  profile->alpha = 1;
		  alpha_done = 1;
		  if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
		}
		else if(a == 0 && !profile->alpha && !profile->key)
		{
		  profile->key = 1;
		  profile->key_r = r;
		  profile->key_g = g;
		  profile->key_b = b;
		}
		else if(a == 255 && profile->key && matchkey)
		{
		  /* Color key cannot be used if an opaque pixel also has that RGB color. */
		  profile->alpha = 1;
		  alpha_done = 1;
		  if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
		}
	  }

	  if(!numcolors_done)
	  {
		if(!color_tree_has(&tree, r, g, b, a))
		{
		  color_tree_add(&tree, r, g, b, a, profile->numcolors);
		  if(profile->numcolors < 256)
		  {
			unsigned char* p = profile->palette;
			unsigned n = profile->numcolors;
			p[n * 4 + 0] = r;
			p[n * 4 + 1] = g;
			p[n * 4 + 2] = b;
			p[n * 4 + 3] = a;
		  }
		  ++profile->numcolors;
		  numcolors_done = profile->numcolors >= maxnumcolors;
		}
	  }

	  if(alpha_done && numcolors_done && colored_done && bits_done) break;
	}

	/*make the profile's key always 16-bit for consistency - repeat each byte twice*/
	profile->key_r += (profile->key_r << 8);
	profile->key_g += (profile->key_g << 8);
	profile->key_b += (profile->key_b << 8);
  }

  color_tree_cleanup(&tree);
  return error;
}

/*Automatically chooses color type that gives smallest amount of bits in the
output image, e.g. grey if there are only greyscale pixels, palette if there
are less than 256 colors, ...
Updates values of mode with a potentially smaller color model. mode_out should
contain the user chosen color model, but will be overwritten with the new chosen one.*/
unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,
								   const unsigned char* image, unsigned w, unsigned h,
								   const LodePNGColorMode* mode_in)
{
  LodePNGColorProfile prof;
  unsigned error = 0;
  unsigned i, n, palettebits, grey_ok, palette_ok;

  lodepng_color_profile_init(&prof);
  error = lodepng_get_color_profile(&prof, image, w, h, mode_in);
  if(error) return error;
  mode_out->key_defined = 0;

  if(prof.key && w * h <= 16) {
	prof.alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
	if(prof.bits < 8) prof.bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
  }
  grey_ok = !prof.colored && !prof.alpha; /*grey without alpha, with potentially low bits*/
  n = prof.numcolors;
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;
  if(w * h < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; /*grey is less overhead*/

  if(palette_ok)
  {
	unsigned char* p = prof.palette;
	lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
	for(i = 0; i != prof.numcolors; ++i)
	{
	  error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
	  if(error) break;
	}

	mode_out->colortype = LCT_PALETTE;
	mode_out->bitdepth = palettebits;

	if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
		&& mode_in->bitdepth == mode_out->bitdepth)
	{
	  /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
	  lodepng_color_mode_cleanup(mode_out);
	  lodepng_color_mode_copy(mode_out, mode_in);
	}
  }
  else /*8-bit or 16-bit per channel*/
  {
	mode_out->bitdepth = prof.bits;
	mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)
									 : (prof.colored ? LCT_RGB : LCT_GREY);

	if(prof.key && !prof.alpha)
	{
	  unsigned mask = (1u << mode_out->bitdepth) - 1u; /*profile always uses 16-bit, mask converts it*/
	  mode_out->key_r = prof.key_r & mask;
	  mode_out->key_g = prof.key_g & mask;
	  mode_out->key_b = prof.key_b & mask;
	  mode_out->key_defined = 1;
	}
  }

  return error;
}

#endif /* #ifdef LODEPNG_COMPILE_ENCODER */

/*
Paeth predicter, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c)
{
  short pa = abs(b - c);
  short pb = abs(a - c);
  short pc = abs(a + b - c - c);

  if(pc < pa && pc < pb) return (unsigned char)c;
  else if(pb < pa) return (unsigned char)b;
  else return (unsigned char)a;
}

/*shared values used by multiple Adam7 related functions*/

static const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/
static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/

/*
Outputs various dimensions and positions in the image related to the Adam7 reduced images.
passw: output containing the width of the 7 passes
passh: output containing the height of the 7 passes
filter_passstart: output containing the index of the start and end of each
 reduced image with filter bytes
padded_passstart output containing the index of the start and end of each
 reduced image when without filter bytes but with padded scanlines
passstart: output containing the index of the start and end of each reduced
 image without padding between scanlines, but still padding between the images
w, h: width and height of non-interlaced image
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
								size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
{
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i)
  {
	passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
	passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
	if(passw[i] == 0) passh[i] = 0;
	if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i)
  {
	/*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
	filter_passstart[i + 1] = filter_passstart[i]
							+ ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0);
	/*bits padded if needed to fill full byte at end of each scanline*/
	padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8);
	/*only padded at end of reduced image*/
	passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8;
  }
}

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
						 const unsigned char* in, size_t insize)
{
  LodePNGInfo* info = &state->info_png;
  if(insize == 0 || in == 0)
  {
	CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
  }
  if(insize < 33)
  {
	CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  lodepng_info_cleanup(info);
  lodepng_info_init(info);

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
	 || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10)
  {
	CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
  }
  if(in[12] != 'I' || in[13] != 'H' || in[14] != 'D' || in[15] != 'R')
  {
	CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
  }

  /*read the values given in the header*/
  *w = lodepng_read32bitInt(&in[16]);
  *h = lodepng_read32bitInt(&in[20]);
  info->color.bitdepth = in[24];
  info->color.colortype = (LodePNGColorType)in[25];
  info->compression_method = in[26];
  info->filter_method = in[27];
  info->interlace_method = in[28];

  if(*w == 0 || *h == 0)
  {
	CERROR_RETURN_ERROR(state->error, 93);
  }

  if(!state->decoder.ignore_crc)
  {
	unsigned CRC = lodepng_read32bitInt(&in[29]);
	unsigned checksum = lodepng_crc32(&in[12], 17);
	if(CRC != checksum)
	{
	  CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
	}
  }

  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);

  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
  return state->error;
}

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
								 size_t bytewidth, unsigned char filterType, size_t length)
{
  /*
  For PNG filter method 0
  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,
  the filter works byte per byte (bytewidth = 1)
  precon is the previous unfiltered scanline, recon the result, scanline the current one
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType)
  {
	case 0:
	  for(i = 0; i != length; ++i) recon[i] = scanline[i];
	  break;
	case 1:
	  for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
	  for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
	  break;
	case 2:
	  if(precon)
	  {
		for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
	  }
	  else
	  {
		for(i = 0; i != length; ++i) recon[i] = scanline[i];
	  }
	  break;
	case 3:
	  if(precon)
	  {
		for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + precon[i] / 2;
		for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
		for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth] / 2;
	  }
	  break;
	case 4:
	  if(precon)
	  {
		for(i = 0; i != bytewidth; ++i)
		{
		  recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
		}
		for(i = bytewidth; i < length; ++i)
		{
		  recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
		}
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i)
		{
		  recon[i] = scanline[i];
		}
		for(i = bytewidth; i < length; ++i)
		{
		  /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
		  recon[i] = (scanline[i] + recon[i - bytewidth]);
		}
	  }
	  break;
	default: return 36; /*error: unexisting filter type given*/
  }
  return 0;
}

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  /*
  For PNG filter method 0
  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)
  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  size_t linebytes = (w * bpp + 7) / 8;

  for(y = 0; y < h; ++y)
  {
	size_t outindex = linebytes * y;
	size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
	unsigned char filterType = in[inindex];

	CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

	prevline = &out[outindex];
  }

  return 0;
}

/*
in: Adam7 interlaced image, with no padding bits between scanlines, but between
 reduced images so that each reduced image starts at a byte.
out: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h
bpp: bits per pixel
out has the following size in bits: w * h * bpp.
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  size_t bytewidth = bpp / 8;
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
		size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
		for(b = 0; b < bytewidth; ++b)
		{
		  out[pixeloutstart + b] = in[pixelinstart + b];
		}
	  }
	}
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  unsigned ilinebits = bpp * passw[i];
	  unsigned olinebits = bpp * w;
	  size_t obp, ibp; /*bit pointers (for out and in buffer)*/
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
		obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
		for(b = 0; b < bpp; ++b)
		{
		  unsigned char bit = readBitFromReversedStream(&ibp, in);
		  /*note that this function assumes the out buffer is completely 0, use setBitOfReversedStream otherwise*/
		  setBitOfReversedStream0(&obp, out, bit);
		}
	  }
	}
  }
}

static void removePaddingBits(unsigned char* out, const unsigned char* in,
							  size_t olinebits, size_t ilinebits, unsigned h)
{
  /*
  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need
  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers
  for the Adam7 code, the color convert code and the output to the user.
  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y)
  {
	size_t x;
	for(x = 0; x < olinebits; ++x)
	{
	  unsigned char bit = readBitFromReversedStream(&ibp, in);
	  setBitOfReversedStream(&obp, out, bit);
	}
	ibp += diff;
  }
}

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
									 unsigned w, unsigned h, const LodePNGInfo* info_png)
{
  /*
  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= posible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  if(bpp == 0) return 31; /*error: invalid colortype*/

  if(info_png->interlace_method == 0)
  {
	if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
	{
	  CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
	  removePaddingBits(out, in, w * bpp, ((w * bpp + 7) / 8) * 8, h);
	}
	/*we can immediatly filter into the out buffer, no other steps needed*/
	else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
  }
  else /*interlace_method is 1 (Adam7)*/
  {
	unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
	unsigned i;

	Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

	for(i = 0; i != 7; ++i)
	{
	  CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
	  /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
	  move bytes instead of bits or move not at all*/
	  if(bpp < 8)
	  {
		/*remove padding bits in scanlines; after this there still may be padding
		bits between the different reduced images: each reduced image still starts nicely at a byte*/
		removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
						  ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
	  }
	}

	Adam7_deinterlace(out, in, w, h, bpp);
  }

  return 0;
}

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned pos = 0, i;
  if(color->palette) lodepng_free(color->palette);
  color->palettesize = chunkLength / 3;
  color->palette = (unsigned char*)lodepng_malloc(4 * color->palettesize);
  if(!color->palette && color->palettesize)
  {
	color->palettesize = 0;
	return 83; /*alloc fail*/
  }
  if(color->palettesize > 256) return 38; /*error: palette too big*/

  for(i = 0; i != color->palettesize; ++i)
  {
	color->palette[4 * i + 0] = data[pos++]; /*R*/
	color->palette[4 * i + 1] = data[pos++]; /*G*/
	color->palette[4 * i + 2] = data[pos++]; /*B*/
	color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
}

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned i;
  if(color->colortype == LCT_PALETTE)
  {
	/*error: more alpha values given than there are palette entries*/
	if(chunkLength > color->palettesize) return 38;

	for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
  }
  else if(color->colortype == LCT_GREY)
  {
	/*error: this chunk must be 2 bytes for greyscale image*/
	if(chunkLength != 2) return 30;

	color->key_defined = 1;
	color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
  }
  else if(color->colortype == LCT_RGB)
  {
	/*error: this chunk must be 6 bytes for RGB image*/
	if(chunkLength != 6) return 41;

	color->key_defined = 1;
	color->key_r = 256u * data[0] + data[1];
	color->key_g = 256u * data[2] + data[3];
	color->key_b = 256u * data[4] + data[5];
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/

  return 0; /* OK */
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(info->color.colortype == LCT_PALETTE)
  {
	/*error: this chunk must be 1 byte for indexed color image*/
	if(chunkLength != 1) return 43;

	info->background_defined = 1;
	info->background_r = info->background_g = info->background_b = data[0];
  }
  else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
	/*error: this chunk must be 2 bytes for greyscale image*/
	if(chunkLength != 2) return 44;

	info->background_defined = 1;
	info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
	/*error: this chunk must be 6 bytes for greyscale image*/
	if(chunkLength != 6) return 45;

	info->background_defined = 1;
	info->background_r = 256u * data[0] + data[1];
	info->background_g = 256u * data[2] + data[3];
	info->background_b = 256u * data[4] + data[5];
  }

  return 0; /* OK */
}

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  char *key = 0, *str = 0;
  unsigned i;

  while(!error) /*not really a while loop, only used to break on error*/
  {
	unsigned length, string2_begin;

	length = 0;
	while(length < chunkLength && data[length] != 0) ++length;
	/*even though it's not allowed by the standard, no error is thrown if
	there's no null termination char, if the text is empty*/
	if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

	key = (char*)lodepng_malloc(length + 1);
	if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

	key[length] = 0;
	for(i = 0; i != length; ++i) key[i] = (char)data[i];

	string2_begin = length + 1; /*skip keyword null terminator*/

	length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;
	str = (char*)lodepng_malloc(length + 1);
	if(!str) CERROR_BREAK(error, 83); /*alloc fail*/

	str[length] = 0;
	for(i = 0; i != length; ++i) str[i] = (char)data[string2_begin + i];

	error = lodepng_add_text(info, key, str);

	break;
  }

  lodepng_free(key);
  lodepng_free(str);

  return error;
}

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
							   const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, string2_begin;
  char *key = 0;
  ucvector decoded;

  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
	for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
	if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
	if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

	key = (char*)lodepng_malloc(length + 1);
	if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

	key[length] = 0;
	for(i = 0; i != length; ++i) key[i] = (char)data[i];

	if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

	string2_begin = length + 2;
	if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/

	length = chunkLength - string2_begin;
	/*will fail if zlib error, e.g. if length is too small*/
	error = zlib_decompress(&decoded.data, &decoded.size,
							(unsigned char*)(&data[string2_begin]),
							length, zlibsettings);
	if(error) break;
	ucvector_push_back(&decoded, 0);

	error = lodepng_add_text(info, key, (char*)decoded.data);

	break;
  }

  lodepng_free(key);
  ucvector_cleanup(&decoded);

  return error;
}

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
							   const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
  ucvector decoded;
  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
	/*Quick check if the chunk length isn't too small. Even without check
	it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
	if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/

	/*read the key*/
	for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
	if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
	if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

	key = (char*)lodepng_malloc(length + 1);
	if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

	key[length] = 0;
	for(i = 0; i != length; ++i) key[i] = (char)data[i];

	/*read the compression method*/
	compressed = data[length + 1];
	if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

	/*even though it's not allowed by the standard, no error is thrown if
	there's no null termination char, if the text is empty for the next 3 texts*/

	/*read the langtag*/
	begin = length + 3;
	length = 0;
	for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;

	langtag = (char*)lodepng_malloc(length + 1);
	if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/

	langtag[length] = 0;
	for(i = 0; i != length; ++i) langtag[i] = (char)data[begin + i];

	/*read the transkey*/
	begin += length + 1;
	length = 0;
	for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;

	transkey = (char*)lodepng_malloc(length + 1);
	if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/

	transkey[length] = 0;
	for(i = 0; i != length; ++i) transkey[i] = (char)data[begin + i];

	/*read the actual text*/
	begin += length + 1;

	length = chunkLength < begin ? 0 : chunkLength - begin;

	if(compressed)
	{
	  /*will fail if zlib error, e.g. if length is too small*/
	  error = zlib_decompress(&decoded.data, &decoded.size,
							  (unsigned char*)(&data[begin]),
							  length, zlibsettings);
	  if(error) break;
	  if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;
	  ucvector_push_back(&decoded, 0);
	}
	else
	{
	  if(!ucvector_resize(&decoded, length + 1)) CERROR_BREAK(error, 83 /*alloc fail*/);

	  decoded.data[length] = 0;
	  for(i = 0; i != length; ++i) decoded.data[i] = data[begin + i];
	}

	error = lodepng_add_itext(info, key, langtag, transkey, (char*)decoded.data);

	break;
  }

  lodepng_free(key);
  lodepng_free(langtag);
  lodepng_free(transkey);
  ucvector_cleanup(&decoded);

  return error;
}

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/

  info->time_defined = 1;
  info->time.year = 256u * data[0] + data[1];
  info->time.month = data[2];
  info->time.day = data[3];
  info->time.hour = data[4];
  info->time.minute = data[5];
  info->time.second = data[6];

  return 0; /* OK */
}

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/

  info->phys_defined = 1;
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
  info->phys_unit = data[8];

  return 0; /* OK */
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
						  LodePNGState* state,
						  const unsigned char* in, size_t insize)
{
  unsigned char IEND = 0;
  const unsigned char* chunk;
  size_t i;
  ucvector idat; /*the data from idat chunks*/
  ucvector scanlines;
  size_t predict;
  size_t numpixels;

  /*for unknown chunk order*/
  unsigned unknown = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

  /*provide some proper output values if error will happen*/
  *out = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;

  numpixels = *w * *h;

  /*multiplication overflow*/
  if(*h != 0 && numpixels / *h != *w) CERROR_RETURN(state->error, 92);
  /*multiplication overflow possible further below. Allows up to 2^31-1 pixel
  bytes with 16-bit RGBA, the rest is room for filter bytes.*/
  if(numpixels > 268435455) CERROR_RETURN(state->error, 92);

  ucvector_init(&idat);
  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error)
  {
	unsigned chunkLength;
	const unsigned char* data; /*the data in the chunk*/

	/*error: size of the in buffer too small to contain next chunk*/
	if((size_t)((chunk - in) + 12) > insize || chunk < in) CERROR_BREAK(state->error, 30);

	/*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
	chunkLength = lodepng_chunk_length(chunk);
	/*error: chunk length larger than the max PNG chunk size*/
	if(chunkLength > 2147483647) CERROR_BREAK(state->error, 63);

	if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in)
	{
	  CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
	}

	data = lodepng_chunk_data_const(chunk);

	/*IDAT chunk, containing compressed image data*/
	if(lodepng_chunk_type_equals(chunk, "IDAT"))
	{
	  size_t oldsize = idat.size;
	  if(!ucvector_resize(&idat, oldsize + chunkLength)) CERROR_BREAK(state->error, 83 /*alloc fail*/);
	  for(i = 0; i != chunkLength; ++i) idat.data[oldsize + i] = data[i];
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	  critical_pos = 3;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	}
	/*IEND chunk*/
	else if(lodepng_chunk_type_equals(chunk, "IEND"))
	{
	  IEND = 1;
	}
	/*palette chunk (PLTE)*/
	else if(lodepng_chunk_type_equals(chunk, "PLTE"))
	{
	  state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
	  if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	  critical_pos = 2;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	}
	/*palette transparency chunk (tRNS)*/
	else if(lodepng_chunk_type_equals(chunk, "tRNS"))
	{
	  state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
	  if(state->error) break;
	}
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*background color chunk (bKGD)*/
	else if(lodepng_chunk_type_equals(chunk, "bKGD"))
	{
	  state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
	  if(state->error) break;
	}
	/*text chunk (tEXt)*/
	else if(lodepng_chunk_type_equals(chunk, "tEXt"))
	{
	  if(state->decoder.read_text_chunks)
	  {
		state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
		if(state->error) break;
	  }
	}
	/*compressed text chunk (zTXt)*/
	else if(lodepng_chunk_type_equals(chunk, "zTXt"))
	{
	  if(state->decoder.read_text_chunks)
	  {
		state->error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
		if(state->error) break;
	  }
	}
	/*international text chunk (iTXt)*/
	else if(lodepng_chunk_type_equals(chunk, "iTXt"))
	{
	  if(state->decoder.read_text_chunks)
	  {
		state->error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
		if(state->error) break;
	  }
	}
	else if(lodepng_chunk_type_equals(chunk, "tIME"))
	{
	  state->error = readChunk_tIME(&state->info_png, data, chunkLength);
	  if(state->error) break;
	}
	else if(lodepng_chunk_type_equals(chunk, "pHYs"))
	{
	  state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	else /*it's not an implemented chunk type, so ignore it: skip over the data*/
	{
	  /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
	  if(!lodepng_chunk_ancillary(chunk)) CERROR_BREAK(state->error, 69);

	  unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	  if(state->decoder.remember_unknown_chunks)
	  {
		state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
											&state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
		if(state->error) break;
	  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	}

	if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/
	{
	  if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
	}

	if(!IEND) chunk = lodepng_chunk_next_const(chunk);
  }

  ucvector_init(&scanlines);
  /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
  If the decompressed size does not match the prediction, the image must be corrupt.*/
  if(state->info_png.interlace_method == 0)
  {
	/*The extra *h is added because this are the filter bytes every scanline starts with*/
	predict = lodepng_get_raw_size_idat(*w, *h, &state->info_png.color) + *h;
  }
  else
  {
	/*Adam-7 interlaced: predicted size is the sum of the 7 sub-images sizes*/
	const LodePNGColorMode* color = &state->info_png.color;
	predict = 0;
	predict += lodepng_get_raw_size_idat((*w + 7) / 8, (*h + 7) / 8, color) + (*h + 7) / 8;
	if(*w > 4) predict += lodepng_get_raw_size_idat((*w + 3) / 8, (*h + 7) / 8, color) + (*h + 7) / 8;
	predict += lodepng_get_raw_size_idat((*w + 3) / 4, (*h + 3) / 8, color) + (*h + 3) / 8;
	if(*w > 2) predict += lodepng_get_raw_size_idat((*w + 1) / 4, (*h + 3) / 4, color) + (*h + 3) / 4;
	predict += lodepng_get_raw_size_idat((*w + 1) / 2, (*h + 1) / 4, color) + (*h + 1) / 4;
	if(*w > 1) predict += lodepng_get_raw_size_idat((*w + 0) / 2, (*h + 1) / 2, color) + (*h + 1) / 2;
	predict += lodepng_get_raw_size_idat((*w + 0) / 1, (*h + 0) / 2, color) + (*h + 0) / 2;
  }
  if(!state->error && !ucvector_reserve(&scanlines, predict)) state->error = 83; /*alloc fail*/
  if(!state->error)
  {
	state->error = zlib_decompress(&scanlines.data, &scanlines.size, idat.data,
								   idat.size, &state->decoder.zlibsettings);
	if(!state->error && scanlines.size != predict) state->error = 91; /*decompressed size doesn't match prediction*/
  }
  ucvector_cleanup(&idat);

  if(!state->error)
  {
	size_t outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
	ucvector outv;
	ucvector_init(&outv);
	if(!ucvector_resizev(&outv, outsize, 0)) state->error = 83; /*alloc fail*/
	if(!state->error) state->error = postProcessScanlines(outv.data, scanlines.data, *w, *h, &state->info_png);
	*out = outv.data;
  }
  ucvector_cleanup(&scanlines);
}

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
						LodePNGState* state,
						const unsigned char* in, size_t insize)
{
  *out = 0;
  decodeGeneric(out, w, h, state, in, insize);
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color))
  {
	/*same color type, no copying or converting of data needed*/
	/*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
	the raw image has to the end user*/
	if(!state->decoder.color_convert)
	{
	  state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
	  if(state->error) return state->error;
	}
  }
  else
  {
	/*color conversion needed; sort of copy of the data*/
	unsigned char* data = *out;
	size_t outsize;

	/*TODO: check if this works according to the statement in the documentation: "The converter can convert
	from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
	if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
	   && !(state->info_raw.bitdepth == 8))
	{
	  return 56; /*unsupported color mode conversion*/
	}

	outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
	*out = (unsigned char*)lodepng_malloc(outsize);
	if(!(*out))
	{
	  state->error = 83; /*alloc fail*/
	}
	else state->error = lodepng_convert(*out, data, &state->info_raw,
										&state->info_png.color, *w, *h);
	lodepng_free(data);
  }
  return state->error;
}

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
							   size_t insize, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  error = lodepng_decode(out, w, h, &state, in, insize);
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
}

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
							 LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error;
  error = lodepng_load_file(&buffer, &buffersize, filename);
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
}

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)
{
  settings->color_convert = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
  settings->remember_unknown_chunks = 0;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
  lodepng_decompress_settings_init(&settings->zlibsettings);
}

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state)
{
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
  lodepng_info_init(&state->info_png);
  state->error = 1;
}

void lodepng_state_cleanup(LodePNGState* state)
{
  lodepng_color_mode_cleanup(&state->info_raw);
  lodepng_info_cleanup(&state->info_png);
}

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source)
{
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}

#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*chunkName must be string of 4 characters*/
static unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length)
{
  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));
  out->allocsize = out->size; /*fix the allocsize again*/
  return 0;
}

static void writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  ucvector_push_back(out, 137);
  ucvector_push_back(out, 80);
  ucvector_push_back(out, 78);
  ucvector_push_back(out, 71);
  ucvector_push_back(out, 13);
  ucvector_push_back(out, 10);
  ucvector_push_back(out, 26);
  ucvector_push_back(out, 10);
}

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
							  LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method)
{
  unsigned error = 0;
  ucvector header;
  ucvector_init(&header);

  lodepng_add32bitInt(&header, w); /*width*/
  lodepng_add32bitInt(&header, h); /*height*/
  ucvector_push_back(&header, (unsigned char)bitdepth); /*bit depth*/
  ucvector_push_back(&header, (unsigned char)colortype); /*color type*/
  ucvector_push_back(&header, 0); /*compression method*/
  ucvector_push_back(&header, 0); /*filter method*/
  ucvector_push_back(&header, interlace_method); /*interlace method*/

  error = addChunk(out, "IHDR", header.data, header.size);
  ucvector_cleanup(&header);

  return error;
}

static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector PLTE;
  ucvector_init(&PLTE);
  for(i = 0; i != info->palettesize * 4; ++i)
  {
	/*add all channels except alpha channel*/
	if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);
  }
  error = addChunk(out, "PLTE", PLTE.data, PLTE.size);
  ucvector_cleanup(&PLTE);

  return error;
}

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector tRNS;
  ucvector_init(&tRNS);
  if(info->colortype == LCT_PALETTE)
  {
	size_t amount = info->palettesize;
	/*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
	for(i = info->palettesize; i != 0; --i)
	{
	  if(info->palette[4 * (i - 1) + 3] == 255) --amount;
	  else break;
	}
	/*add only alpha channel*/
	for(i = 0; i != amount; ++i) ucvector_push_back(&tRNS, info->palette[4 * i + 3]);
  }
  else if(info->colortype == LCT_GREY)
  {
	if(info->key_defined)
	{
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));
	}
  }
  else if(info->colortype == LCT_RGB)
  {
	if(info->key_defined)
	{
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_g / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_g % 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_b / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_b % 256));
	}
  }

  error = addChunk(out, "tRNS", tRNS.data, tRNS.size);
  ucvector_cleanup(&tRNS);

  return error;
}

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
							  LodePNGCompressSettings* zlibsettings)
{
  ucvector zlibdata;
  unsigned error = 0;

  /*compress with the Zlib compressor*/
  ucvector_init(&zlibdata);
  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);
  if(!error) error = addChunk(out, "IDAT", zlibdata.data, zlibdata.size);
  ucvector_cleanup(&zlibdata);

  return error;
}

static unsigned addChunk_IEND(ucvector* out)
{
  unsigned error = 0;
  error = addChunk(out, "IEND", 0, 0);
  return error;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring)
{
  unsigned error = 0;
  size_t i;
  ucvector text;
  ucvector_init(&text);
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&text, 0); /*0 termination char*/
  for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)textstring[i]);
  error = addChunk(out, "tEXt", text.data, text.size);
  ucvector_cleanup(&text);

  return error;
}

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
							  LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data, compressed;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);
  ucvector_init(&compressed);
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*0 termination char*/
  ucvector_push_back(&data, 0); /*compression method: 0*/

  error = zlib_compress(&compressed.data, &compressed.size,
						(unsigned char*)textstring, textsize, zlibsettings);
  if(!error)
  {
	for(i = 0; i != compressed.size; ++i) ucvector_push_back(&data, compressed.data[i]);
	error = addChunk(out, "zTXt", data.data, data.size);
  }

  ucvector_cleanup(&compressed);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,
							  const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);

  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*null termination char*/
  ucvector_push_back(&data, compressed ? 1 : 0); /*compression flag*/
  ucvector_push_back(&data, 0); /*compression method*/
  for(i = 0; langtag[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)langtag[i]);
  ucvector_push_back(&data, 0); /*null termination char*/
  for(i = 0; transkey[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)transkey[i]);
  ucvector_push_back(&data, 0); /*null termination char*/

  if(compressed)
  {
	ucvector compressed_data;
	ucvector_init(&compressed_data);
	error = zlib_compress(&compressed_data.data, &compressed_data.size,
						  (unsigned char*)textstring, textsize, zlibsettings);
	if(!error)
	{
	  for(i = 0; i != compressed_data.size; ++i) ucvector_push_back(&data, compressed_data.data[i]);
	}
	ucvector_cleanup(&compressed_data);
  }
  else /*not compressed*/
  {
	for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)textstring[i]);
  }

  if(!error) error = addChunk(out, "iTXt", data.data, data.size);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector bKGD;
  ucvector_init(&bKGD);
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_g / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_g % 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_b / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_b % 256));
  }
  else if(info->color.colortype == LCT_PALETTE)
  {
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256)); /*palette index*/
  }

  error = addChunk(out, "bKGD", bKGD.data, bKGD.size);
  ucvector_cleanup(&bKGD);

  return error;
}

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time)
{
  unsigned error = 0;
  unsigned char* data = (unsigned char*)lodepng_malloc(7);
  if(!data) return 83; /*alloc fail*/
  data[0] = (unsigned char)(time->year / 256);
  data[1] = (unsigned char)(time->year % 256);
  data[2] = (unsigned char)time->month;
  data[3] = (unsigned char)time->day;
  data[4] = (unsigned char)time->hour;
  data[5] = (unsigned char)time->minute;
  data[6] = (unsigned char)time->second;
  error = addChunk(out, "tIME", data, 7);
  lodepng_free(data);
  return error;
}

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector data;
  ucvector_init(&data);

  lodepng_add32bitInt(&data, info->phys_x);
  lodepng_add32bitInt(&data, info->phys_y);
  ucvector_push_back(&data, info->phys_unit);

  error = addChunk(out, "pHYs", data.data, data.size);
  ucvector_cleanup(&data);

  return error;
}

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
						   size_t length, size_t bytewidth, unsigned char filterType)
{
  size_t i;
  switch(filterType)
  {
	case 0: /*None*/
	  for(i = 0; i != length; ++i) out[i] = scanline[i];
	  break;
	case 1: /*Sub*/
	  for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
	  for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
	  break;
	case 2: /*Up*/
	  if(prevline)
	  {
		for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
	  }
	  else
	  {
		for(i = 0; i != length; ++i) out[i] = scanline[i];
	  }
	  break;
	case 3: /*Average*/
	  if(prevline)
	  {
		for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - prevline[i] / 2;
		for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) / 2);
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
		for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth] / 2;
	  }
	  break;
	case 4: /*Paeth*/
	  if(prevline)
	  {
		/*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
		for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
		for(i = bytewidth; i < length; ++i)
		{
		  out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
		}
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
		/*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
		for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
	  }
	  break;
	default: return; /*unexisting filter type given*/
  }
}

/* log2 approximation. A slight bit faster than std::log. */
static float flog2(float f)
{
  float result = 0;
  while(f > 32) { result += 4; f /= 16; }
  while(f > 2) { ++result; f /= 2; }
  return result + 1.442695f * (f * f * f / 3 - 3 * f * f / 2 + 3 * f - 1.83333f);
}

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
					   const LodePNGColorMode* info, const LodePNGEncoderSettings* settings)
{
  /*
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7) / 8, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(info);
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = (w * bpp + 7) / 8;
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  const unsigned char* prevline = 0;
  unsigned x, y;
  unsigned error = 0;
  LodePNGFilterStrategy strategy = settings->filter_strategy;

  /*
  There is a heuristic called the minimum sum of absolute differences heuristic, suggested by the PNG standard:
   *  If the image type is Palette, or the bit depth is smaller than 8, then do not filter the image (i.e.
	  use fixed filtering, with the filter None).
   * (The other case) If the image type is Grayscale or RGB (with or without Alpha), and the bit depth is
	 not smaller than 8, then use adaptive filtering heuristic as follows: independently for each row, apply
	 all five filters and select the filter that produces the smallest sum of absolute values per row.
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.

  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
	 (info->colortype == LCT_PALETTE || info->bitdepth < 8)) strategy = LFS_ZERO;

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy == LFS_ZERO)
  {
	for(y = 0; y != h; ++y)
	{
	  size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
	  size_t inindex = linebytes * y;
	  out[outindex] = 0; /*filter type byte*/
	  filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, 0);
	  prevline = &in[inindex];
	}
  }
  else if(strategy == LFS_MINSUM)
  {
	/*adaptive filtering*/
	size_t sum[5];
	ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
	size_t smallest = 0;
	unsigned char type, bestType = 0;

	for(type = 0; type != 5; ++type)
	{
	  ucvector_init(&attempt[type]);
	  if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/
	}

	if(!error)
	{
	  for(y = 0; y != h; ++y)
	  {
		/*try the 5 filter types*/
		for(type = 0; type != 5; ++type)
		{
		  filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);

		  /*calculate the sum of the result*/
		  sum[type] = 0;
		  if(type == 0)
		  {
			for(x = 0; x != linebytes; ++x) sum[type] += (unsigned char)(attempt[type].data[x]);
		  }
		  else
		  {
			for(x = 0; x != linebytes; ++x)
			{
			  /*For differences, each byte should be treated as signed, values above 127 are negative
			  (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
			  This means filtertype 0 is almost never chosen, but that is justified.*/
			  unsigned char s = attempt[type].data[x];
			  sum[type] += s < 128 ? s : (255U - s);
			}
		  }

		  /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
		  if(type == 0 || sum[type] < smallest)
		  {
			bestType = type;
			smallest = sum[type];
		  }
		}

		prevline = &in[y * linebytes];

		/*now fill the out values*/
		out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
		for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
	  }
	}

	for(type = 0; type != 5; ++type) ucvector_cleanup(&attempt[type]);
  }
  else if(strategy == LFS_ENTROPY)
  {
	float sum[5];
	ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
	float smallest = 0;
	unsigned type, bestType = 0;
	unsigned count[256];

	for(type = 0; type != 5; ++type)
	{
	  ucvector_init(&attempt[type]);
	  if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/
	}

	for(y = 0; y != h; ++y)
	{
	  /*try the 5 filter types*/
	  for(type = 0; type != 5; ++type)
	  {
		filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);
		for(x = 0; x != 256; ++x) count[x] = 0;
		for(x = 0; x != linebytes; ++x) ++count[attempt[type].data[x]];
		++count[type]; /*the filter type itself is part of the scanline*/
		sum[type] = 0;
		for(x = 0; x != 256; ++x)
		{
		  float p = count[x] / (float)(linebytes + 1);
		  sum[type] += count[x] == 0 ? 0 : flog2(1 / p) * p;
		}
		/*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
		if(type == 0 || sum[type] < smallest)
		{
		  bestType = type;
		  smallest = sum[type];
		}
	  }

	  prevline = &in[y * linebytes];

	  /*now fill the out values*/
	  out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
	  for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
	}

	for(type = 0; type != 5; ++type) ucvector_cleanup(&attempt[type]);
  }
  else if(strategy == LFS_PREDEFINED)
  {
	for(y = 0; y != h; ++y)
	{
	  size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
	  size_t inindex = linebytes * y;
	  unsigned char type = settings->predefined_filters[y];
	  out[outindex] = type; /*filter type byte*/
	  filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
	  prevline = &in[inindex];
	}
  }
  else if(strategy == LFS_BRUTE_FORCE)
  {
	/*brute force filter chooser.
	deflate the scanline after every filter attempt to see which one deflates best.
	This is very slow and gives only slightly smaller, sometimes even larger, result*/
	size_t size[5];
	ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
	size_t smallest = 0;
	unsigned type = 0, bestType = 0;
	unsigned char* dummy;
	LodePNGCompressSettings zlibsettings = settings->zlibsettings;
	/*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
	to simulate the true case where the tree is the same for the whole image. Sometimes it gives
	better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
	cases better compression. It does make this a bit less slow, so it's worth doing this.*/
	zlibsettings.btype = 1;
	/*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
	images only, so disable it*/
	zlibsettings.custom_zlib = 0;
	zlibsettings.custom_deflate = 0;
	for(type = 0; type != 5; ++type)
	{
	  ucvector_init(&attempt[type]);
	  ucvector_resize(&attempt[type], linebytes); /*todo: give error if resize failed*/
	}
	for(y = 0; y != h; ++y) /*try the 5 filter types*/
	{
	  for(type = 0; type != 5; ++type)
	  {
		unsigned testsize = attempt[type].size;
		/*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

		filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);
		size[type] = 0;
		dummy = 0;
		zlib_compress(&dummy, &size[type], attempt[type].data, testsize, &zlibsettings);
		lodepng_free(dummy);
		/*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
		if(type == 0 || size[type] < smallest)
		{
		  bestType = type;
		  smallest = size[type];
		}
	  }
	  prevline = &in[y * linebytes];
	  out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
	  for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
	}
	for(type = 0; type != 5; ++type) ucvector_cleanup(&attempt[type]);
  }
  else return 88; /* unknown filter strategy */

  return error;
}

static void addPaddingBits(unsigned char* out, const unsigned char* in,
						   size_t olinebits, size_t ilinebits, unsigned h)
{
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y)
  {
	size_t x;
	for(x = 0; x < ilinebits; ++x)
	{
	  unsigned char bit = readBitFromReversedStream(&ibp, in);
	  setBitOfReversedStream(&obp, out, bit);
	}
	/*obp += diff; --> no, fill in some value in the padding bits too, to avoid
	"Use of uninitialised value of size ###" warning from valgrind*/
	for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}

/*
in: non-interlaced image with size w*h
out: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with
 no padding bits between scanlines, but between reduced images so that each
 reduced image starts at a byte.
bpp: bits per pixel
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  size_t bytewidth = bpp / 8;
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
		size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
		for(b = 0; b < bytewidth; ++b)
		{
		  out[pixeloutstart + b] = in[pixelinstart + b];
		}
	  }
	}
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  unsigned ilinebits = bpp * passw[i];
	  unsigned olinebits = bpp * w;
	  size_t obp, ibp; /*bit pointers (for out and in buffer)*/
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
		obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
		for(b = 0; b < bpp; ++b)
		{
		  unsigned char bit = readBitFromReversedStream(&ibp, in);
		  setBitOfReversedStream(&obp, out, bit);
		}
	  }
	}
  }
}

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
									unsigned w, unsigned h,
									const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings)
{
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= posible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  unsigned error = 0;

  if(info_png->interlace_method == 0)
  {
	*outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/
	*out = (unsigned char*)lodepng_malloc(*outsize);
	if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

	if(!error)
	{
	  /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
	  if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
	  {
		unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7) / 8));
		if(!padded) error = 83; /*alloc fail*/
		if(!error)
		{
		  addPaddingBits(padded, in, ((w * bpp + 7) / 8) * 8, w * bpp, h);
		  error = filter(*out, padded, w, h, &info_png->color, settings);
		}
		lodepng_free(padded);
	  }
	  else
	  {
		/*we can immediatly filter into the out buffer, no other steps needed*/
		error = filter(*out, in, w, h, &info_png->color, settings);
	  }
	}
  }
  else /*interlace_method is 1 (Adam7)*/
  {
	unsigned passw[7], passh[7];
	size_t filter_passstart[8], padded_passstart[8], passstart[8];
	unsigned char* adam7;

	Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

	*outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
	*out = (unsigned char*)lodepng_malloc(*outsize);
	if(!(*out)) error = 83; /*alloc fail*/

	adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
	if(!adam7 && passstart[7]) error = 83; /*alloc fail*/

	if(!error)
	{
	  unsigned i;

	  Adam7_interlace(adam7, in, w, h, bpp);
	  for(i = 0; i != 7; ++i)
	  {
		if(bpp < 8)
		{
		  unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
		  if(!padded) ERROR_BREAK(83); /*alloc fail*/
		  addPaddingBits(padded, &adam7[passstart[i]],
						 ((passw[i] * bpp + 7) / 8) * 8, passw[i] * bpp, passh[i]);
		  error = filter(&(*out)[filter_passstart[i]], padded,
						 passw[i], passh[i], &info_png->color, settings);
		  lodepng_free(padded);
		}
		else
		{
		  error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
						 passw[i], passh[i], &info_png->color, settings);
		}

		if(error) break;
	  }
	}

	lodepng_free(adam7);
  }

  return error;
}

/*
palette must have 4 * palettesize bytes allocated, and given in format RGBARGBARGBARGBA...
returns 0 if the palette is opaque,
returns 1 if the palette has a single color with alpha 0 ==> color key
returns 2 if the palette is semi-translucent.
*/
static unsigned getPaletteTranslucency(const unsigned char* palette, size_t palettesize)
{
  size_t i;
  unsigned key = 0;
  unsigned r = 0, g = 0, b = 0; /*the value of the color with alpha 0, so long as color keying is possible*/
  for(i = 0; i != palettesize; ++i)
  {
	if(!key && palette[4 * i + 3] == 0)
	{
	  r = palette[4 * i + 0]; g = palette[4 * i + 1]; b = palette[4 * i + 2];
	  key = 1;
	  i = (size_t)(-1); /*restart from beginning, to detect earlier opaque colors with key's value*/
	}
	else if(palette[4 * i + 3] != 255) return 2;
	/*when key, no opaque RGB may have key's RGB*/
	else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;
  }
  return key;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize)
{
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize)
  {
	CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
	out->allocsize = out->size; /*fix the allocsize again*/
	inchunk = lodepng_chunk_next(inchunk);
  }
  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
						const unsigned char* image, unsigned w, unsigned h,
						LodePNGState* state)
{
  LodePNGInfo info;
  ucvector outv;
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
  size_t datasize = 0;

  /*provide some proper output values if error will happen*/
  *out = 0;
  *outsize = 0;
  state->error = 0;

  lodepng_info_init(&info);
  lodepng_info_copy(&info, &state->info_png);

  if((info.color.colortype == LCT_PALETTE || state->encoder.force_palette)
	  && (info.color.palettesize == 0 || info.color.palettesize > 256))
  {
	state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
	return state->error;
  }

  if(state->encoder.auto_convert)
  {
	state->error = lodepng_auto_choose_color(&info.color, image, w, h, &state->info_raw);
  }
  if(state->error) return state->error;

  if(state->encoder.zlibsettings.btype > 2)
  {
	CERROR_RETURN_ERROR(state->error, 61); /*error: unexisting btype*/
  }
  if(state->info_png.interlace_method > 1)
  {
	CERROR_RETURN_ERROR(state->error, 71); /*error: unexisting interlace mode*/
  }

  state->error = checkColorValidity(info.color.colortype, info.color.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/

  if(!lodepng_color_mode_equal(&state->info_raw, &info.color))
  {
	unsigned char* converted;
	size_t size = (w * h * lodepng_get_bpp(&info.color) + 7) / 8;

	converted = (unsigned char*)lodepng_malloc(size);
	if(!converted && size) state->error = 83; /*alloc fail*/
	if(!state->error)
	{
	  state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
	}
	if(!state->error) preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
	lodepng_free(converted);
  }
  else preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);

  ucvector_init(&outv);
  while(!state->error) /*while only executed once, to break on error*/
  {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	/*write signature and chunks*/
	writeSignature(&outv);
	/*IHDR*/
	addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*unknown chunks between IHDR and PLTE*/
	if(info.unknown_chunks_data[0])
	{
	  state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	/*PLTE*/
	if(info.color.colortype == LCT_PALETTE)
	{
	  addChunk_PLTE(&outv, &info.color);
	}
	if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA))
	{
	  addChunk_PLTE(&outv, &info.color);
	}
	/*tRNS*/
	if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0)
	{
	  addChunk_tRNS(&outv, &info.color);
	}
	if((info.color.colortype == LCT_GREY || info.color.colortype == LCT_RGB) && info.color.key_defined)
	{
	  addChunk_tRNS(&outv, &info.color);
	}
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*bKGD (must come between PLTE and the IDAt chunks*/
	if(info.background_defined) addChunk_bKGD(&outv, &info);
	/*pHYs (must come before the IDAT chunks)*/
	if(info.phys_defined) addChunk_pHYs(&outv, &info);

	/*unknown chunks between PLTE and IDAT*/
	if(info.unknown_chunks_data[1])
	{
	  state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	/*IDAT (multiple IDAT chunks must be consecutive)*/
	state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
	if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*tIME*/
	if(info.time_defined) addChunk_tIME(&outv, &info.time);
	/*tEXt and/or zTXt*/
	for(i = 0; i != info.text_num; ++i)
	{
	  if(strlen(info.text_keys[i]) > 79)
	  {
		state->error = 66; /*text chunk too large*/
		break;
	  }
	  if(strlen(info.text_keys[i]) < 1)
	  {
		state->error = 67; /*text chunk too small*/
		break;
	  }
	  if(state->encoder.text_compression)
	  {
		addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
	  }
	  else
	  {
		addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
	  }
	}
	/*LodePNG version id in text chunk*/
	if(state->encoder.add_id)
	{
	  unsigned alread_added_id_text = 0;
	  for(i = 0; i != info.text_num; ++i)
	  {
		if(!strcmp(info.text_keys[i], "LodePNG"))
		{
		  alread_added_id_text = 1;
		  break;
		}
	  }
	  if(alread_added_id_text == 0)
	  {
		addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
	  }
	}
	/*iTXt*/
	for(i = 0; i != info.itext_num; ++i)
	{
	  if(strlen(info.itext_keys[i]) > 79)
	  {
		state->error = 66; /*text chunk too large*/
		break;
	  }
	  if(strlen(info.itext_keys[i]) < 1)
	  {
		state->error = 67; /*text chunk too small*/
		break;
	  }
	  addChunk_iTXt(&outv, state->encoder.text_compression,
					info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
					&state->encoder.zlibsettings);
	}

	/*unknown chunks between IDAT and IEND*/
	if(info.unknown_chunks_data[2])
	{
	  state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	addChunk_IEND(&outv);

	break; /*this isn't really a while loop; no error happened so break out now!*/
  }

  lodepng_info_cleanup(&info);
  lodepng_free(data);
  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
  *outsize = outv.size;

  return state->error;
}

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
							   unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  state.info_png.color.colortype = colortype;
  state.info_png.color.bitdepth = bitdepth;
  lodepng_encode(out, outsize, image, w, h, &state);
  error = state.error;
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_encode_memory_std(unsigned char** out, size_t* outsize, const unsigned char* image,
							   unsigned w, unsigned h, unsigned colortype, unsigned bitdepth)
{
  return lodepng_encode_memory(out,outsize,image,w,h,(LodePNGColorType)colortype,bitdepth);
}

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
							 LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings)
{
  lodepng_compress_settings_init(&settings->zlibsettings);
  settings->filter_palette_zero = 1;
  settings->filter_strategy = LFS_MINSUM;
  settings->auto_convert = 1;
  settings->force_palette = 0;
  settings->predefined_filters = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
  settings->text_compression = 1;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code)
{
  switch(code)
  {
	case 0: return "no error, everything went ok";
	case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
	case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
	case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
	case 13: return "problem while processing dynamic deflate block";
	case 14: return "problem while processing dynamic deflate block";
	case 15: return "problem while processing dynamic deflate block";
	case 16: return "unexisting code while processing dynamic deflate block";
	case 17: return "end of out buffer memory reached while inflating";
	case 18: return "invalid distance code while inflating";
	case 19: return "end of out buffer memory reached while inflating";
	case 20: return "invalid deflate block BTYPE encountered while decoding";
	case 21: return "NLEN is not ones complement of LEN in a deflate block";
	 /*end of out buffer memory reached while inflating:
	 This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
	 all the pixels of the image, given the color depth and image dimensions. Something that doesn't
	 happen in a normal, well encoded, PNG image.*/
	case 22: return "end of out buffer memory reached while inflating";
	case 23: return "end of in buffer memory reached while inflating";
	case 24: return "invalid FCHECK in zlib header";
	case 25: return "invalid compression method in zlib header";
	case 26: return "FDICT encountered in zlib header while it's not used for PNG";
	case 27: return "PNG file is smaller than a PNG header";
	/*Checks the magic file header, the first 8 bytes of the PNG file*/
	case 28: return "incorrect PNG signature, it's no PNG or corrupted";
	case 29: return "first chunk is not the header chunk";
	case 30: return "chunk length too large, chunk broken off at end of file";
	case 31: return "illegal PNG color type or bpp";
	case 32: return "illegal PNG compression method";
	case 33: return "illegal PNG filter method";
	case 34: return "illegal PNG interlace method";
	case 35: return "chunk length of a chunk is too large or the chunk too small";
	case 36: return "illegal PNG filter type encountered";
	case 37: return "illegal bit depth for this color type given";
	case 38: return "the palette is too big"; /*more than 256 colors*/
	case 39: return "more palette alpha values given in tRNS chunk than there are colors in the palette";
	case 40: return "tRNS chunk has wrong size for greyscale image";
	case 41: return "tRNS chunk has wrong size for RGB image";
	case 42: return "tRNS chunk appeared while it was not allowed for this color type";
	case 43: return "bKGD chunk has wrong size for palette image";
	case 44: return "bKGD chunk has wrong size for greyscale image";
	case 45: return "bKGD chunk has wrong size for RGB image";
	/*the input data is empty, maybe a PNG file doesn't exist or is in the wrong path*/
	case 48: return "empty input or file doesn't exist";
	case 49: return "jumped past memory while generating dynamic huffman tree";
	case 50: return "jumped past memory while generating dynamic huffman tree";
	case 51: return "jumped past memory while inflating huffman block";
	case 52: return "jumped past memory while inflating";
	case 53: return "size of zlib data too small";
	case 54: return "repeat symbol in tree while there was no value symbol yet";
	/*jumped past tree while generating huffman tree, this could be when the
	tree will have more leaves than symbols after generating it out of the
	given lenghts. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
	case 55: return "jumped past tree while generating huffman tree";
	case 56: return "given output image colortype or bitdepth not supported for color conversion";
	case 57: return "invalid CRC encountered (checking CRC can be disabled)";
	case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
	case 59: return "requested color conversion not supported";
	case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
	case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
	/*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/
	case 62: return "conversion from color to greyscale not supported";
	case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk"; /*(2^31-1)*/
	/*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
	case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
	case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
	case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
	case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
	case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
	case 71: return "unexisting interlace mode given to encoder (must be 0 or 1)";
	case 72: return "while decoding, unexisting compression method encountering in zTXt or iTXt chunk (it must be 0)";
	case 73: return "invalid tIME chunk size";
	case 74: return "invalid pHYs chunk size";
	/*length could be wrong, or data chopped off*/
	case 75: return "no null termination char found while decoding text chunk";
	case 76: return "iTXt chunk too short to contain required bytes";
	case 77: return "integer overflow in buffer size";
	case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
	case 79: return "failed to open file for writing";
	case 80: return "tried creating a tree of 0 symbols";
	case 81: return "lazy matching at pos 0 is impossible";
	case 82: return "color conversion to palette requested while a color isn't in palette";
	case 83: return "memory allocation failed";
	case 84: return "given image too small to contain all pixels to be encoded";
	case 86: return "impossible offset in lz77 encoding (internal bug)";
	case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
	case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
	case 89: return "text chunk keyword too short or long: must have size 1-79";
	/*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
	case 90: return "windowsize must be a power of two";
	case 91: return "invalid decompressed idat size";
	case 92: return "too many pixels, not supported";
	case 93: return "zero width or height is invalid";
  }
  return "unknown error code";
}
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // C++ Wrapper                                                          // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_CPP
namespace lodepng
{

#ifdef LODEPNG_COMPILE_DISK
void load_file(std::vector<unsigned char>& buffer, const std::string& filename)
{
  std::ifstream file(filename.c_str(), std::ios::in|std::ios::binary|std::ios::ate);

  /*get filesize*/
  std::streamsize size = 0;
  if(file.seekg(0, std::ios::end).good()) size = file.tellg();
  if(file.seekg(0, std::ios::beg).good()) size -= file.tellg();

  /*read contents of the file into the vector*/
  buffer.resize(size_t(size));
  if(size > 0) file.read((char*)(&buffer[0]), size);
}

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
void save_file(const std::vector<unsigned char>& buffer, const std::string& filename)
{
  std::ofstream file(filename.c_str(), std::ios::out|std::ios::binary);
  file.write(buffer.empty() ? 0 : (char*)&buffer[0], std::streamsize(buffer.size()));
}
#endif //LODEPNG_COMPILE_DISK

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_DECODER
unsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
					const LodePNGDecompressSettings& settings)
{
  unsigned char* buffer = 0;
  size_t buffersize = 0;
  unsigned error = zlib_decompress(&buffer, &buffersize, in, insize, &settings);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
					const LodePNGDecompressSettings& settings)
{
  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);
}
#endif //LODEPNG_COMPILE_DECODER

#ifdef LODEPNG_COMPILE_ENCODER
unsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
				  const LodePNGCompressSettings& settings)
{
  unsigned char* buffer = 0;
  size_t buffersize = 0;
  unsigned error = zlib_compress(&buffer, &buffersize, in, insize, &settings);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
				  const LodePNGCompressSettings& settings)
{
  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);
}
#endif //LODEPNG_COMPILE_ENCODER
#endif //LODEPNG_COMPILE_ZLIB

#ifdef LODEPNG_COMPILE_PNG

State::State()
{
  lodepng_state_init(this);
}

State::State(const State& other)
{
  lodepng_state_init(this);
  lodepng_state_copy(this, &other);
}

State::~State()
{
  lodepng_state_cleanup(this);
}

State& State::operator=(const State& other)
{
  lodepng_state_copy(this, &other);
  return *this;
}

#ifdef LODEPNG_COMPILE_DECODER

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,
				size_t insize, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  unsigned error = lodepng_decode_memory(&buffer, &w, &h, in, insize, colortype, bitdepth);
  if(buffer && !error)
  {
	State state;
	state.info_raw.colortype = colortype;
	state.info_raw.bitdepth = bitdepth;
	size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const std::vector<unsigned char>& in, LodePNGColorType colortype, unsigned bitdepth)
{
  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const unsigned char* in, size_t insize)
{
  unsigned char* buffer = NULL;
  unsigned error = lodepng_decode(&buffer, &w, &h, &state, in, insize);
  if(buffer && !error)
  {
	size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
  }
  lodepng_free(buffer);
  return error;
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const std::vector<unsigned char>& in)
{
  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());
}

#ifdef LODEPNG_COMPILE_DISK
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,
				LodePNGColorType colortype, unsigned bitdepth)
{
  std::vector<unsigned char> buffer;
  load_file(buffer, filename);
  return decode(out, w, h, buffer, colortype, bitdepth);
}
#endif //LODEPNG_COMPILE_DECODER
#endif //LODEPNG_COMPILE_DISK

#ifdef LODEPNG_COMPILE_ENCODER
unsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, in, w, h, colortype, bitdepth);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
  return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);
}

unsigned encode(std::vector<unsigned char>& out,
				const unsigned char* in, unsigned w, unsigned h,
				State& state)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode(&buffer, &buffersize, in, w, h, &state);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				State& state)
{
  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;
  return encode(out, in.empty() ? 0 : &in[0], w, h, state);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned encode(const std::string& filename,
				const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  std::vector<unsigned char> buffer;
  unsigned error = encode(buffer, in, w, h, colortype, bitdepth);
  if(!error) save_file(buffer, filename);
  return error;
}

unsigned encode(const std::string& filename,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
  return encode(filename, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);
}
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_ENCODER
#endif //LODEPNG_COMPILE_PNG
} //namespace lodepng
#endif /*LODEPNG_COMPILE_CPP*/


//#line 1 "crn2dds.hpp"
// crn2dds, based on code by SpartanJ and Evan Parker.
// - rlyeh, public domain

#ifndef CRN2DDS_INCLUDE
#define CRN2DDS_INCLUDE
#include <string>

// returns a pure dxt stream (can be uploaded to a GPU directly)
bool crn2dxt( std::string &out, const void *src, size_t len, unsigned reserved = 0 );
bool crn2dxt( std::string &out, const std::string &in, unsigned reserved = 0 );

// returns a cooked dds header + pure dxt stream (can be saved or processed somewhere else)
bool crn2dds( std::string &out, const void *src, size_t len );
bool crn2dds( std::string &out, const std::string &in );

#endif

#undef DDS_header
#define DDS_header DDS_header3

//#line 1 "crn2dds.cpp"
// crn2dds, based on code by SpartanJ and Evan Parker.
// - rlyeh, public domain

#ifdef _WIN32
#ifndef WIN32
#define WIN32
#endif
#endif

#include <stddef.h> // For NULL, size_t
#include <cstring> // for malloc etc

#ifndef USE_MALLOC_USABLE_SIZE
// Define HAVE_MALLOC_USABLE_SIZE to 1 to indicate that the current
// system has malloc_usable_size(). Which takes the address of a malloc-ed
// pointer, and return the size of the underlying storage block.
// This is useful to optimize heap memory usage.
// Including at least one C library header is required to define symbols
// like __GLIBC__. Choose carefully because some headers like <stddef.h>
// are actually provided by the compiler, not the C library and do not
// define the macros we need.
#include <stdint.h>
#if defined(__GLIBC__)
#  include <malloc.h>
#  define USE_MALLOC_USABLE_SIZE  1
#elif defined(__APPLE__) || defined(__FreeBSD__)
#  include <malloc/malloc.h>
#  define malloc_usable_size  malloc_size
#  define USE_MALLOC_USABLE_SIZE  1
#elif defined(__ANDROID_API__)
#  include <malloc.h>
extern "C" size_t dlmalloc_usable_size(void*);
#  define malloc_usable_size dlmalloc_usable_size
#  define USE_MALLOC_USABLE_SIZE  1
#elif defined(_WIN32)
#  include <malloc.h>
#  define malloc_usable_size _msize
#  define USE_MALLOC_USABLE_SIZE  1
#else
#  define USE_MALLOC_USABLE_SIZE  0
#endif
#endif // USE_MALLOC_USABLE_SIZE


//#line 1 "crn_decomp.h"
// File: crn_decomp.h - Fast CRN->DXTc texture transcoder header file library
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
// See Copyright Notice and license at the end of this file.
//
// This single header file contains *all* of the code necessary to unpack .CRN files to raw DXTn bits.
// It does NOT depend on the crn compression library.
//
// Note: This is a single file, stand-alone C++ library which is controlled by the use of two macros:
//   If CRND_INCLUDE_CRND_H is NOT defined, the header is included.
//   If CRND_HEADER_FILE_ONLY is NOT defined, the implementation is included.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
//
#ifndef CRND_INCLUDE_CRND_H
#define CRND_INCLUDE_CRND_H

// Include crnlib.h (only to bring in some basic CRN-related types).
#include <stdint.h>

//#line 1 "crnlib.h"
// File: crnlib.h - Advanced DXTn texture compression library.
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
// See copyright notice and license at the end of this file.
//
// This header file contains the public crnlib declarations for DXTn,
// clustered DXTn, and CRN compression/decompression.
//
// Note: This library does NOT need to be linked into your game executable if
// all you want to do is transcode .CRN files to raw DXTn bits at run-time.
// The crn_decomp.h header file library contains all the code necessary for
// decompression.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
#ifndef CRNLIB_H
#define CRNLIB_H

#ifdef _MSC_VER
#pragma warning (disable: 4127) //  conditional expression is constant
#endif

#define CRNLIB_VERSION 104

#define CRNLIB_SUPPORT_ATI_COMPRESS 0
#define CRNLIB_SUPPORT_SQUISH 0

typedef unsigned char   crn_uint8;
typedef unsigned short  crn_uint16;
typedef unsigned int    crn_uint32;
typedef signed char     crn_int8;
typedef signed short    crn_int16;
typedef signed int      crn_int32;
typedef unsigned int    crn_bool;

// crnlib can compress to these file types.
enum crn_file_type
{
   // .CRN
   cCRNFileTypeCRN = 0,

   // .DDS using regular DXT or clustered DXT
   cCRNFileTypeDDS,

   cCRNFileTypeForceDWORD = 0xFFFFFFFF
};

// Supported compressed pixel formats.
// Basically all the standard DX9 formats, with some swizzled DXT5 formats
// (most of them supported by ATI's Compressonator), along with some ATI/X360 GPU specific formats.
enum crn_format
{
   cCRNFmtInvalid = -1,

   cCRNFmtDXT1 = 0,

   cCRNFmtFirstValid = cCRNFmtDXT1,

   // cCRNFmtDXT3 is not currently supported when writing to CRN - only DDS.
   cCRNFmtDXT3,

   cCRNFmtDXT5,

   // Various DXT5 derivatives
   cCRNFmtDXT5_CCxY,    // Luma-chroma
   cCRNFmtDXT5_xGxR,    // Swizzled 2-component
   cCRNFmtDXT5_xGBR,    // Swizzled 3-component
   cCRNFmtDXT5_AGBR,    // Swizzled 4-component

   // ATI 3DC and X360 DXN
   cCRNFmtDXN_XY,
   cCRNFmtDXN_YX,

   // DXT5 alpha blocks only
   cCRNFmtDXT5A,

   cCRNFmtETC1,

   cCRNFmtTotal,

   cCRNFmtForceDWORD = 0xFFFFFFFF
};

// Various library/file format limits.
enum crn_limits
{
   // Max. mipmap level resolution on any axis.
   cCRNMaxLevelResolution     = 4096,

   cCRNMinPaletteSize         = 8,
   cCRNMaxPaletteSize         = 8192,

   cCRNMaxFaces               = 6,
   cCRNMaxLevels              = 16,

   cCRNMaxHelperThreads       = 16,

   cCRNMinQualityLevel        = 0,
   cCRNMaxQualityLevel        = 255
};

// CRN/DDS compression flags.
// See the m_flags member in the crn_comp_params struct, below.
enum crn_comp_flags
{
   // Enables perceptual colorspace distance metrics if set.
   // Important: Be sure to disable this when compressing non-sRGB colorspace images, like normal maps!
   // Default: Set
   cCRNCompFlagPerceptual = 1,

   // Enables (up to) 8x8 macroblock usage if set. If disabled, only 4x4 blocks are allowed.
   // Compression ratio will be lower when disabled, but may cut down on blocky artifacts because the process used to determine
   // where large macroblocks can be used without artifacts isn't perfect.
   // Default: Set.
   cCRNCompFlagHierarchical = 2,

   // cCRNCompFlagQuick disables several output file optimizations - intended for things like quicker previews.
   // Default: Not set.
   cCRNCompFlagQuick = 4,

   // DXT1: OK to use DXT1 alpha blocks for better quality or DXT1A transparency.
   // DXT5: OK to use both DXT5 block types.
   // Currently only used when writing to .DDS files, as .CRN uses only a subset of the possible DXTn block types.
   // Default: Set.
   cCRNCompFlagUseBothBlockTypes = 8,

   // OK to use DXT1A transparent indices to encode black (assumes pixel shader ignores fetched alpha).
   // Currently only used when writing to .DDS files, .CRN never uses alpha blocks.
   // Default: Not set.
   cCRNCompFlagUseTransparentIndicesForBlack = 16,

   // Disables endpoint caching, for more deterministic output.
   // Currently only used when writing to .DDS files.
   // Default: Not set.
   cCRNCompFlagDisableEndpointCaching = 32,

   // If enabled, use the cCRNColorEndpointPaletteSize, etc. params to control the CRN palette sizes. Only useful when writing to .CRN files.
   // Default: Not set.
   cCRNCompFlagManualPaletteSizes = 64,

   // If enabled, DXT1A alpha blocks are used to encode single bit transparency.
   // Default: Not set.
   cCRNCompFlagDXT1AForTransparency = 128,

   // If enabled, the DXT1 compressor's color distance metric assumes the pixel shader will be converting the fetched RGB results to luma (Y part of YCbCr).
   // This increases quality when compressing grayscale images, because the compressor can spread the luma error amoung all three channels (i.e. it can generate blocks
   // with some chroma present if doing so will ultimately lead to lower luma error).
   // Only enable on grayscale source images.
   // Default: Not set.
   cCRNCompFlagGrayscaleSampling = 256,

   // If enabled, debug information will be output during compression.
   // Default: Not set.
   cCRNCompFlagDebugging = 0x80000000,

   cCRNCompFlagForceDWORD = 0xFFFFFFFF
};

// Controls DXTn quality vs. speed control - only used when compressing to .DDS.
enum crn_dxt_quality
{
   cCRNDXTQualitySuperFast,
   cCRNDXTQualityFast,
   cCRNDXTQualityNormal,
   cCRNDXTQualityBetter,
   cCRNDXTQualityUber,

   cCRNDXTQualityTotal,

   cCRNDXTQualityForceDWORD = 0xFFFFFFFF
};

// Which DXTn compressor to use when compressing to plain (non-clustered) .DDS.
enum crn_dxt_compressor_type
{
   cCRNDXTCompressorCRN,      // Use crnlib's ETC1 or DXTc block compressor (default, highest quality, comparable or better than ati_compress or squish, and crnlib's ETC1 is a lot fasterw with similiar quality to Erricson's)
   cCRNDXTCompressorCRNF,     // Use crnlib's "fast" DXTc block compressor
   cCRNDXTCompressorRYG,      // Use RYG's DXTc block compressor (low quality, but very fast)

#if CRNLIB_SUPPORT_ATI_COMPRESS
   cCRNDXTCompressorATI,
#endif

#if CRNLIB_SUPPORT_SQUISH
   cCRNDXTCompressorSquish,
#endif

   cCRNTotalDXTCompressors,

   cCRNDXTCompressorForceDWORD = 0xFFFFFFFF
};

// Progress callback function.
// Processing will stop prematurely (and fail) if the callback returns false.
// phase_index, total_phases - high level progress
// subphase_index, total_subphases - progress within current phase
typedef crn_bool (*crn_progress_callback_func)(crn_uint32 phase_index, crn_uint32 total_phases, crn_uint32 subphase_index, crn_uint32 total_subphases, void* pUser_data_ptr);

// CRN/DDS compression parameters struct.
struct crn_comp_params
{
   inline crn_comp_params() { clear(); }

   // Clear struct to default parameters.
   inline void clear()
   {
	  m_size_of_obj = sizeof(*this);
	  m_file_type = cCRNFileTypeCRN;
	  m_faces = 1;
	  m_width = 0;
	  m_height = 0;
	  m_levels = 1;
	  m_format = cCRNFmtDXT1;
	  m_flags = cCRNCompFlagPerceptual | cCRNCompFlagHierarchical | cCRNCompFlagUseBothBlockTypes;

	  for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
		 for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
			m_pImages[f][l] = NULL;

	  m_target_bitrate = 0.0f;
	  m_quality_level = cCRNMaxQualityLevel;
	  m_dxt1a_alpha_threshold = 128;
	  m_dxt_quality = cCRNDXTQualityUber;
	  m_dxt_compressor_type = cCRNDXTCompressorCRN;
	  m_alpha_component = 3;

	  m_crn_adaptive_tile_color_psnr_derating = 2.0f;
	  m_crn_adaptive_tile_alpha_psnr_derating = 2.0f;
	  m_crn_color_endpoint_palette_size = 0;
	  m_crn_color_selector_palette_size = 0;
	  m_crn_alpha_endpoint_palette_size = 0;
	  m_crn_alpha_selector_palette_size = 0;

	  m_num_helper_threads = 0;
	  m_userdata0 = 0;
	  m_userdata1 = 0;
	  m_pProgress_func = NULL;
	  m_pProgress_func_data = NULL;
   }

   inline bool operator== (const crn_comp_params& rhs) const
   {
#define CRNLIB_COMP(x) do { if ((x) != (rhs.x)) return false; } while(0)
	  CRNLIB_COMP(m_size_of_obj);
	  CRNLIB_COMP(m_file_type);
	  CRNLIB_COMP(m_faces);
	  CRNLIB_COMP(m_width);
	  CRNLIB_COMP(m_height);
	  CRNLIB_COMP(m_levels);
	  CRNLIB_COMP(m_format);
	  CRNLIB_COMP(m_flags);
	  CRNLIB_COMP(m_target_bitrate);
	  CRNLIB_COMP(m_quality_level);
	  CRNLIB_COMP(m_dxt1a_alpha_threshold);
	  CRNLIB_COMP(m_dxt_quality);
	  CRNLIB_COMP(m_dxt_compressor_type);
	  CRNLIB_COMP(m_alpha_component);
	  CRNLIB_COMP(m_crn_adaptive_tile_color_psnr_derating);
	  CRNLIB_COMP(m_crn_adaptive_tile_alpha_psnr_derating);
	  CRNLIB_COMP(m_crn_color_endpoint_palette_size);
	  CRNLIB_COMP(m_crn_color_selector_palette_size);
	  CRNLIB_COMP(m_crn_alpha_endpoint_palette_size);
	  CRNLIB_COMP(m_crn_alpha_selector_palette_size);
	  CRNLIB_COMP(m_num_helper_threads);
	  CRNLIB_COMP(m_userdata0);
	  CRNLIB_COMP(m_userdata1);
	  CRNLIB_COMP(m_pProgress_func);
	  CRNLIB_COMP(m_pProgress_func_data);

	  for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
		 for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
			CRNLIB_COMP(m_pImages[f][l]);

#undef CRNLIB_COMP
	  return true;
   }

   // Returns true if the input parameters are reasonable.
   inline bool check() const
   {
	  if ( (m_file_type > cCRNFileTypeDDS) ||
		 (((int)m_quality_level < (int)cCRNMinQualityLevel) || ((int)m_quality_level > (int)cCRNMaxQualityLevel)) ||
		 (m_dxt1a_alpha_threshold > 255) ||
		 ((m_faces != 1) && (m_faces != 6)) ||
		 ((m_width < 1) || (m_width > cCRNMaxLevelResolution)) ||
		 ((m_height < 1) || (m_height > cCRNMaxLevelResolution)) ||
		 ((m_levels < 1) || (m_levels > cCRNMaxLevels)) ||
		 ((m_format < cCRNFmtDXT1) || (m_format >= cCRNFmtTotal)) ||
		 ((m_crn_color_endpoint_palette_size) && ((m_crn_color_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_color_endpoint_palette_size > cCRNMaxPaletteSize))) ||
		 ((m_crn_color_selector_palette_size) && ((m_crn_color_selector_palette_size < cCRNMinPaletteSize) || (m_crn_color_selector_palette_size > cCRNMaxPaletteSize))) ||
		 ((m_crn_alpha_endpoint_palette_size) && ((m_crn_alpha_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_endpoint_palette_size > cCRNMaxPaletteSize))) ||
		 ((m_crn_alpha_selector_palette_size) && ((m_crn_alpha_selector_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_selector_palette_size > cCRNMaxPaletteSize))) ||
		 (m_alpha_component > 3) ||
		 (m_num_helper_threads > cCRNMaxHelperThreads) ||
		 (m_dxt_quality > cCRNDXTQualityUber) ||
		 (m_dxt_compressor_type >= cCRNTotalDXTCompressors) )
	  {
		 return false;
	  }
	  return true;
   }

   // Helper to set/get flags from m_flags member.
   inline bool get_flag(crn_comp_flags flag) const { return (m_flags & flag) != 0; }
   inline void set_flag(crn_comp_flags flag, bool val) { m_flags &= ~flag; if (val) m_flags |= flag; }

   crn_uint32                 m_size_of_obj;

   crn_file_type              m_file_type;               // Output file type: cCRNFileTypeCRN or cCRNFileTypeDDS.

   crn_uint32                 m_faces;                   // 1 (2D map) or 6 (cubemap)
   crn_uint32                 m_width;                   // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
   crn_uint32                 m_height;                  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
   crn_uint32                 m_levels;                  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK

   crn_format                 m_format;                  // Output pixel format.

   crn_uint32                 m_flags;                   // see crn_comp_flags enum

   // Array of pointers to 32bpp input images.
   const crn_uint32*          m_pImages[cCRNMaxFaces][cCRNMaxLevels];

   // Target bitrate - if non-zero, the compressor will use an interpolative search to find the
   // highest quality level that is <= the target bitrate. If it fails to find a bitrate high enough, it'll
   // try disabling adaptive block sizes (cCRNCompFlagHierarchical flag) and redo the search. This process can be pretty slow.
   float                      m_target_bitrate;

   // Desired quality level.
   // Currently, CRN and DDS quality levels are not compatible with eachother from an image quality standpoint.
   crn_uint32                 m_quality_level;           // [cCRNMinQualityLevel, cCRNMaxQualityLevel]

   // DXTn compression parameters.
   crn_uint32                 m_dxt1a_alpha_threshold;
   crn_dxt_quality            m_dxt_quality;
   crn_dxt_compressor_type    m_dxt_compressor_type;

   // Alpha channel's component. Defaults to 3.
   crn_uint32                 m_alpha_component;

   // Various low-level CRN specific parameters.
   float                      m_crn_adaptive_tile_color_psnr_derating;
   float                      m_crn_adaptive_tile_alpha_psnr_derating;

   crn_uint32                 m_crn_color_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
   crn_uint32                 m_crn_color_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

   crn_uint32                 m_crn_alpha_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
   crn_uint32                 m_crn_alpha_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

   // Number of helper threads to create during compression. 0=no threading.
   crn_uint32                 m_num_helper_threads;

   // CRN userdata0 and userdata1 members, which are written directly to the header of the output file.
   crn_uint32                 m_userdata0;
   crn_uint32                 m_userdata1;

   // User provided progress callback.
   crn_progress_callback_func m_pProgress_func;
   void*                      m_pProgress_func_data;
};

// Mipmap generator's mode.
enum crn_mip_mode
{
   cCRNMipModeUseSourceOrGenerateMips,       // Use source texture's mipmaps if it has any, otherwise generate new mipmaps
   cCRNMipModeUseSourceMips,                 // Use source texture's mipmaps if it has any, otherwise the output has no mipmaps
   cCRNMipModeGenerateMips,                  // Always generate new mipmaps
   cCRNMipModeNoMips,                        // Output texture has no mipmaps

   cCRNMipModeTotal,

   cCRNModeForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_mode_desc(crn_mip_mode m);
const char* crn_get_mip_mode_name(crn_mip_mode m);

// Mipmap generator's filter kernel.
enum crn_mip_filter
{
   cCRNMipFilterBox,
   cCRNMipFilterTent,
   cCRNMipFilterLanczos4,
   cCRNMipFilterMitchell,
   cCRNMipFilterKaiser,                      // Kaiser=default mipmap filter

   cCRNMipFilterTotal,

   cCRNMipFilterForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_filter_name(crn_mip_filter f);

// Mipmap generator's scale mode.
enum crn_scale_mode
{
   cCRNSMDisabled,
   cCRNSMAbsolute,
   cCRNSMRelative,
   cCRNSMLowerPow2,
   cCRNSMNearestPow2,
   cCRNSMNextPow2,

   cCRNSMTotal,

   cCRNSMForceDWORD = 0xFFFFFFFF
};

const char* crn_get_scale_mode_desc(crn_scale_mode sm);

// Mipmap generator parameters.
struct crn_mipmap_params
{
   inline crn_mipmap_params() { clear(); }

   inline void clear()
   {
	  m_size_of_obj = sizeof(*this);
	  m_mode = cCRNMipModeUseSourceOrGenerateMips;
	  m_filter = cCRNMipFilterKaiser;
	  m_gamma_filtering = true;
	  m_gamma = 2.2f;
	  // Default "blurriness" factor of .9 actually sharpens the output a little.
	  m_blurriness = .9f;
	  m_renormalize = false;
	  m_tiled = false;
	  m_max_levels = cCRNMaxLevels;
	  m_min_mip_size = 1;

	  m_scale_mode = cCRNSMDisabled;
	  m_scale_x = 1.0f;
	  m_scale_y = 1.0f;

	  m_window_left = 0;
	  m_window_top = 0;
	  m_window_right = 0;
	  m_window_bottom = 0;

	  m_clamp_scale = false;
	  m_clamp_width = 0;
	  m_clamp_height = 0;
   }

   inline bool check() const { return true; }

   inline bool operator== (const crn_mipmap_params& rhs) const
   {
#define CRNLIB_COMP(x) do { if ((x) != (rhs.x)) return false; } while(0)
	  CRNLIB_COMP(m_size_of_obj);
	  CRNLIB_COMP(m_mode);
	  CRNLIB_COMP(m_filter);
	  CRNLIB_COMP(m_gamma_filtering);
	  CRNLIB_COMP(m_gamma);
	  CRNLIB_COMP(m_blurriness);
	  CRNLIB_COMP(m_renormalize);
	  CRNLIB_COMP(m_tiled);
	  CRNLIB_COMP(m_max_levels);
	  CRNLIB_COMP(m_min_mip_size);
	  CRNLIB_COMP(m_scale_mode);
	  CRNLIB_COMP(m_scale_x);
	  CRNLIB_COMP(m_scale_y);
	  CRNLIB_COMP(m_window_left);
	  CRNLIB_COMP(m_window_top);
	  CRNLIB_COMP(m_window_right);
	  CRNLIB_COMP(m_window_bottom);
	  CRNLIB_COMP(m_clamp_scale);
	  CRNLIB_COMP(m_clamp_width);
	  CRNLIB_COMP(m_clamp_height);
	  return true;
#undef CRNLIB_COMP
   }
   crn_uint32     m_size_of_obj;

   crn_mip_mode   m_mode;
   crn_mip_filter m_filter;

   crn_bool       m_gamma_filtering;
   float          m_gamma;

   float          m_blurriness;

   crn_uint32     m_max_levels;
   crn_uint32     m_min_mip_size;

   crn_bool       m_renormalize;
   crn_bool       m_tiled;

   crn_scale_mode m_scale_mode;
   float          m_scale_x;
   float          m_scale_y;

   crn_uint32     m_window_left;
   crn_uint32     m_window_top;
   crn_uint32     m_window_right;
   crn_uint32     m_window_bottom;

   crn_bool       m_clamp_scale;
   crn_uint32     m_clamp_width;
   crn_uint32     m_clamp_height;
};

// -------- High-level helper function definitions for CDN/DDS compression.

#ifndef CRNLIB_MIN_ALLOC_ALIGNMENT
#define CRNLIB_MIN_ALLOC_ALIGNMENT sizeof(size_t) * 2
#endif

// Function to set an optional user provided memory allocation/reallocation/msize routines.
// By default, crnlib just uses malloc(), free(), etc. for all allocations.
typedef void*  (*crn_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);
typedef size_t (*crn_msize_func)(void* p, void* pUser_data);
void crn_set_memory_callbacks(crn_realloc_func pRealloc, crn_msize_func pMSize, void* pUser_data);

// Frees memory blocks allocated by crn_compress(), crn_decompress_crn_to_dds(), or crn_decompress_dds_to_images().
void crn_free_block(void *pBlock);

// Compresses a 32-bit/pixel texture to either: a regular DX9 DDS file, a "clustered" (or reduced entropy) DX9 DDS file, or a CRN file in memory.
// Input parameters:
//  comp_params is the compression parameters struct, defined above.
//  compressed_size will be set to the size of the returned memory block containing the output file.
//  The returned block must be freed by calling crn_free_block().
//  *pActual_quality_level will be set to the actual quality level used to compress the image. May be NULL.
//  *pActual_bitrate will be set to the output file's effective bitrate, possibly taking into account LZMA compression. May be NULL.
// Return value:
//  The compressed file data, or NULL on failure.
//  compressed_size will be set to the size of the returned memory buffer.
// Notes:
//  A "regular" DDS file is compressed using normal DXTn compression at the specified DXT quality level.
//  A "clustered" DDS file is compressed using clustered DXTn compression to either the target bitrate or the specified integer quality factor.
//  The output file is a standard DX9 format DDS file, except the compressor assumes you will be later losslessly compressing the DDS output file using the LZMA algorithm.
//  A texture is defined as an array of 1 or 6 "faces" (6 faces=cubemap), where each "face" consists of between [1,cCRNMaxLevels] mipmap levels.
//  Mipmap levels are simple 32-bit 2D images with a pitch of width*sizeof(uint32), arranged in the usual raster order (top scanline first).
//  The image pixels may be grayscale (YYYX bytes in memory), grayscale/alpha (YYYA in memory), 24-bit (RGBX in memory), or 32-bit (RGBA) colors (where "X"=don't care).
//  RGB color data is generally assumed to be in the sRGB colorspace. If not, be sure to clear the "cCRNCompFlagPerceptual" in the crn_comp_params struct!
void *crn_compress(const crn_comp_params &comp_params, crn_uint32 &compressed_size, crn_uint32 *pActual_quality_level = NULL, float *pActual_bitrate = NULL);

// Like the above function, except this function can also do things like generate mipmaps, and resize or crop the input texture before compression.
// The actual operations performed are controlled by the crn_mipmap_params struct members.
// Be sure to set the "m_gamma_filtering" member of crn_mipmap_params to false if the input texture is not sRGB.
void *crn_compress(const crn_comp_params &comp_params, const crn_mipmap_params &mip_params, crn_uint32 &compressed_size, crn_uint32 *pActual_quality_level = NULL, float *pActual_bitrate = NULL);

// Transcodes an entire CRN file to DDS using the crn_decomp.h header file library to do most of the heavy lifting.
// The output DDS file's format is guaranteed to be one of the DXTn formats in the crn_format enum.
// This is a fast operation, because the CRN format is explicitly designed to be efficiently transcodable to DXTn.
// For more control over decompression, see the lower-level helper functions in crn_decomp.h, which do not depend at all on crnlib.
void *crn_decompress_crn_to_dds(const void *pCRN_file_data, crn_uint32 &file_size);

// Decompresses an entire DDS file in any supported format to uncompressed 32-bit/pixel image(s).
// See the crnlib::pixel_format enum in inc/dds_defs.h for a list of the supported DDS formats.
// You are responsible for freeing each image block, either by calling crn_free_all_images() or manually calling crn_free_block() on each image pointer.
struct crn_texture_desc
{
   crn_uint32 m_faces;
   crn_uint32 m_width;
   crn_uint32 m_height;
   crn_uint32 m_levels;
   crn_uint32 m_fmt_fourcc; // Same as crnlib::pixel_format
};
bool crn_decompress_dds_to_images(const void *pDDS_file_data, crn_uint32 dds_file_size, crn_uint32 **ppImages, crn_texture_desc &tex_desc);

// Frees all images allocated by crn_decompress_dds_to_images().
void crn_free_all_images(crn_uint32 **ppImages, const crn_texture_desc &desc);

// -------- crn_format related helpers functions.

// Returns the FOURCC format equivalent to the specified crn_format.
crn_uint32 crn_get_format_fourcc(crn_format fmt);

// Returns the crn_format's bits per texel.
crn_uint32 crn_get_format_bits_per_texel(crn_format fmt);

// Returns the crn_format's number of bytes per block.
crn_uint32 crn_get_bytes_per_dxt_block(crn_format fmt);

// Returns the non-swizzled, basic DXTn version of the specified crn_format.
// This is the format you would supply D3D or OpenGL.
crn_format crn_get_fundamental_dxt_format(crn_format fmt);

// -------- String helpers.

// Converts a crn_file_type to a string.
const char* crn_get_file_type_ext(crn_file_type file_type);

// Converts a crn_format to a string.
const char* crn_get_format_string(crn_format fmt);

// Converts a crn_dxt_quality to a string.
const char* crn_get_dxt_quality_string(crn_dxt_quality q);

// -------- Low-level DXTn 4x4 block compressor API

// crnlib's DXTn endpoint optimizer actually supports any number of source pixels (i.e. from 1 to thousands, not just 16),
// but for simplicity this API only supports 4x4 texel blocks.
typedef void *crn_block_compressor_context_t;

// Create a DXTn block compressor.
// This function only supports the basic/nonswizzled "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// Avoid calling this multiple times if you intend on compressing many blocks, because it allocates some memory.
crn_block_compressor_context_t crn_create_block_compressor(const crn_comp_params &params);

// Compresses a block of 16 pixels to the destination DXTn block.
// pDst_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pPixels should be an array of 16 crn_uint32's. Each crn_uint32 must be r,g,b,a (r is always first) in memory.
void crn_compress_block(crn_block_compressor_context_t pContext, const crn_uint32 *pPixels, void *pDst_block);

// Frees a DXTn block compressor.
void crn_free_block_compressor(crn_block_compressor_context_t pContext);

// Unpacks a compressed block to pDst_pixels.
// pSrc_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pDst_pixel should be an array of 16 crn_uint32's. Each uint32 will be r,g,b,a (r is always first) in memory.
// crn_fmt should be one of the "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// The various swizzled DXT5 formats (such as cCRNFmtDXT5_xGBR, etc.) will be unpacked as if they where plain DXT5.
// Returns false if the crn_fmt is invalid.
bool crn_decompress_block(const void *pSrc_block, crn_uint32 *pDst_pixels, crn_format crn_fmt);

#endif // CRNLIB_H

//------------------------------------------------------------------------------
//
// crnlib uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------


// changelog:
// v1.05 - bugfixed errors and warnings on (g++/mingw) (@r-lyeh)
//         using stdint.h types now (@r-lyeh)
// v1.04 - svn checkout
#define CRND_LIB_VERSION 105
#define CRND_VERSION_STRING "01.05"

#ifdef _DEBUG
#define CRND_BUILD_DEBUG
#else
#define CRND_BUILD_RELEASE
#endif

// CRN decompression API
namespace crnd
{
   typedef uint8_t            uint8;
   typedef int8_t             int8;
   typedef uint16_t           uint16;
   typedef int16_t            int16;
   typedef uint32_t           uint32;
   typedef int32_t            int32;
   typedef unsigned int       uint;
   typedef uint64_t           uint64;
   typedef int64_t            int64;

   // The crnd library assumes all allocation blocks have at least CRND_MIN_ALLOC_ALIGNMENT alignment.
   const uint32 CRND_MIN_ALLOC_ALIGNMENT = sizeof(uint32) * 2U;

   // realloc callback:
   // Used to allocate, resize, or free memory blocks.
   // If p is NULL, the realloc function attempts to allocate a block of at least size bytes. Returns NULL on out of memory.
   // *pActual_size must be set to the actual size of the allocated block, which must be greater than or equal to the requested size.
   // If p is not NULL, and size is 0, the realloc function frees the specified block, and always returns NULL. *pActual_size should be set to 0.
   // If p is not NULL, and size is non-zero, the realloc function attempts to resize the specified block:
   //    If movable is false, the realloc function attempts to shrink or expand the block in-place. NULL is returned if the block cannot be resized in place, or if the
   //    underlying heap implementation doesn't support in-place resizing. Otherwise, the pointer to the original block is returned.
   //    If movable is true, it is permissible to move the block's contents if it cannot be resized in place. NULL is returned if the block cannot be resized in place, and there
   //    is not enough memory to relocate the block.
   //    In all cases, *pActual_size must be set to the actual size of the allocated block, whether it was successfully resized or not.
   typedef void*  (*crnd_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);

   // msize callback: Returns the size of the memory block in bytes, or 0 if the pointer or block is invalid.
   typedef size_t (*crnd_msize_func)(void* p, void* pUser_data);

   // crnd_set_memory_callbacks() - Use to override the crnd library's memory allocation functions.
   // If any input parameters are NULL, the memory callback functions are reset to the default functions.
   // The default functions call malloc(), free(),  _msize(), _expand(), etc.
   void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data);

   struct crn_file_info
   {
	  inline crn_file_info() : m_struct_size(sizeof(crn_file_info)) { }

	  uint32 m_struct_size;
	  uint32 m_actual_data_size;
	  uint32 m_header_size;
	  uint32 m_total_palette_size;
	  uint32 m_tables_size;
	  uint32 m_levels;
	  uint32 m_level_compressed_size[cCRNMaxLevels];
	  uint32 m_color_endpoint_palette_entries;
	  uint32 m_color_selector_palette_entries;
	  uint32 m_alpha_endpoint_palette_entries;
	  uint32 m_alpha_selector_palette_entries;
   };

   struct crn_texture_info
   {
	  inline crn_texture_info() : m_struct_size(sizeof(crn_texture_info)) { }

	  uint32      m_struct_size;
	  uint32      m_width;
	  uint32      m_height;
	  uint32      m_levels;
	  uint32      m_faces;
	  uint32      m_bytes_per_block;
	  uint32      m_userdata0;
	  uint32      m_userdata1;
	  crn_format  m_format;
   };

   struct crn_level_info
   {
	  inline crn_level_info() : m_struct_size(sizeof(crn_level_info)) { }

	  uint32      m_struct_size;
	  uint32      m_width;
	  uint32      m_height;
	  uint32      m_faces;
	  uint32      m_blocks_x;
	  uint32      m_blocks_y;
	  uint32      m_bytes_per_block;
	  crn_format  m_format;
   };

   // Returns the FOURCC format code corresponding to the specified CRN format.
   uint32 crnd_crn_format_to_fourcc(crn_format fmt);

   // Returns the fundamental GPU format given a potentially swizzled DXT5 crn_format.
   crn_format crnd_get_fundamental_dxt_format(crn_format fmt);

   // Returns the size of the crn_format in bits/texel (either 4 or 8).
   uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt);

   // Returns the number of bytes per DXTn block (8 or 16).
   uint32 crnd_get_bytes_per_dxt_block(crn_format fmt);

   // Validates the entire file by checking the header and data CRC's.
   // This is not something you want to be doing much!
   // The crn_file_info.m_struct_size field must be set before calling this function.
   bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info);

   // Retrieves texture information from the CRN file.
   // The crn_texture_info.m_struct_size field must be set before calling this function.
   bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pTexture_info);

   // Retrieves mipmap level specific information from the CRN file.
   // The crn_level_info.m_struct_size field must be set before calling this function.
   bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info);

   // Transcode/unpack context handle.
   typedef void* crnd_unpack_context;

   // crnd_unpack_begin() - Decompresses the texture's decoder tables and endpoint/selector palettes.
   // Once you call this function, you may call crnd_unpack_level() to unpack one or more mip levels.
   // Don't call this once per mip level (unless you absolutely must)!
   // This function allocates enough memory to hold: Huffman decompression tables, and the endpoint/selector palettes (color and/or alpha).
   // Worst case allocation is approx. 200k, assuming all palettes contain 8192 entries.
   // pData must point to a buffer holding all of the compressed .CRN file data.
   // This buffer must be stable until crnd_unpack_end() is called.
   // Returns NULL if out of memory, or if any of the input parameters are invalid.
   crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size);

   // Returns a pointer to the compressed .CRN data associated with a crnd_unpack_context.
   // Returns false if any of the input parameters are invalid.
   bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size);

   // crnd_unpack_level() - Transcodes the specified mipmap level to a destination buffer in cached or write combined memory.
   // pContext - Context created by a call to crnd_unpack_begin().
   // ppDst - A pointer to an array of 1 or 6 destination buffer pointers. Cubemaps require an array of 6 pointers, 2D textures require an array of 1 pointer.
   // dst_size_in_bytes - Optional size of each destination buffer. Only used for debugging - OK to set to UINT32_MAX.
   // row_pitch_in_bytes - The pitch in bytes from one row of DXT blocks to the next. Must be a multiple of 4.
   // level_index - mipmap level index, where 0 is the largest/first level.
   // Returns false if any of the input parameters, or the compressed stream, are invalid.
   // This function does not allocate any memory.
   bool crnd_unpack_level(
	  crnd_unpack_context pContext,
	  void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index);

   // crnd_unpack_level_segmented() - Unpacks the specified mipmap level from a "segmented" CRN file.
   // See the crnd_create_segmented_file() API below.
   // Segmented files allow the user to control where the compressed mipmap data is stored.
   bool crnd_unpack_level_segmented(
	  crnd_unpack_context pContext,
	  const void* pSrc, uint32 src_size_in_bytes,
	  void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index);

   // crnd_unpack_end() - Frees the decompress tables and unpacked palettes associated with the specified unpack context.
   // Returns false if the context is NULL, or if it points to an invalid context.
   // This function frees all memory associated with the context.
   bool crnd_unpack_end(crnd_unpack_context pContext);

   // The following API's allow the user to create "segmented" CRN files. A segmented file contains multiple pieces:
   // - Base data: Header + compression tables
   // - Level data: Individual mipmap levels
   // This allows mipmap levels from multiple CRN files to be tightly packed together into single files.

   // Returns a pointer to the level's compressed data, and optionally returns the level's compressed data size if pSize is not NULL.
   const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize);

   // Returns the compressed size of the texture's header and compression tables (but no levels).
   uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size);

   // Creates a "segmented" CRN texture from a normal CRN texture. The new texture will be created at pBase_data, and will be crnd_get_base_data_size() bytes long.
   // base_data_size must be >= crnd_get_base_data_size().
   // The base data will contain the CRN header and compression tables, but no mipmap data.
   bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size);

} // namespace crnd

// Low-level CRN file header cracking.
namespace crnd
{
   template<unsigned int N>
   struct crn_packed_uint
   {
	  inline crn_packed_uint() { }

	  inline crn_packed_uint(unsigned int val) { *this = val; }

	  inline crn_packed_uint(const crn_packed_uint& other) { *this = other; }

	  inline crn_packed_uint& operator= (const crn_packed_uint& rhs)
	  {
		 if (this != &rhs)
			memcpy(m_buf, rhs.m_buf, sizeof(m_buf));
		 return *this;
	  }

	  inline crn_packed_uint& operator= (unsigned int val)
	  {
		 //CRND_ASSERT((N == 4U) || (val < (1U << (N * 8U))));

		 val <<= (8U * (4U - N));

		 for (unsigned int i = 0; i < N; i++)
		 {
			m_buf[i] = static_cast<unsigned char>(val >> 24U);
			val <<= 8U;
		 }

		 return *this;
	  }

	  inline operator unsigned int() const
	  {
		 switch (N)
		 {
		 case 1:  return  m_buf[0];
		 case 2:  return (m_buf[0] <<  8U) |  m_buf[1];
		 case 3:  return (m_buf[0] << 16U) | (m_buf[1] <<  8U) | (m_buf[2]);
		 default: return (m_buf[0] << 24U) | (m_buf[1] << 16U) | (m_buf[2] << 8U) | (m_buf[3]);
		 }
	  }

	  unsigned char m_buf[N];
   };

#pragma pack(push)
#pragma pack(1)
   struct crn_palette
   {
	  crn_packed_uint<3> m_ofs;
	  crn_packed_uint<3> m_size;
	  crn_packed_uint<2> m_num;
   };

   enum crn_header_flags
   {
	  // If set, the compressed mipmap level data is not located after the file's base data - it will be separately managed by the user instead.
	  cCRNHeaderFlagSegmented = 1
   };

   struct crn_header
   {
	  enum { cCRNSigValue = ('H' << 8) | 'x' };

	  crn_packed_uint<2>    m_sig;
	  crn_packed_uint<2>    m_header_size;
	  crn_packed_uint<2>    m_header_crc16;

	  crn_packed_uint<4>    m_data_size;
	  crn_packed_uint<2>    m_data_crc16;

	  crn_packed_uint<2>    m_width;
	  crn_packed_uint<2>    m_height;

	  crn_packed_uint<1>    m_levels;
	  crn_packed_uint<1>    m_faces;

	  crn_packed_uint<1>    m_format;
	  crn_packed_uint<2>    m_flags;

	  crn_packed_uint<4>    m_reserved;
	  crn_packed_uint<4>    m_userdata0;
	  crn_packed_uint<4>    m_userdata1;

	  crn_palette           m_color_endpoints;
	  crn_palette           m_color_selectors;

	  crn_palette           m_alpha_endpoints;
	  crn_palette           m_alpha_selectors;

	  crn_packed_uint<2>    m_tables_size;
	  crn_packed_uint<3>    m_tables_ofs;

	  // m_level_ofs[] is actually an array of offsets: m_level_ofs[m_levels]
	  crn_packed_uint<4>    m_level_ofs[1];
   };

   const unsigned int cCRNHeaderMinSize = 62U;

#pragma pack(pop)

} // namespace crnd

#endif // CRND_INCLUDE_CRND_H

// Internal library source follows this line.

#ifndef CRND_HEADER_FILE_ONLY

#include <stdlib.h>
#include <stdio.h>
#ifdef WIN32
#include <memory.h>
#else
#include <malloc.h>
#endif
#include <stdarg.h>
#include <new> // needed for placement new, _msize, _expand

#define CRND_RESTRICT __restrict

#ifdef _MSC_VER
#include <intrin.h>
#pragma intrinsic(_WriteBarrier)
#pragma intrinsic(_ReadWriteBarrier)
#define CRND_WRITE_BARRIER _WriteBarrier();
#define CRND_FULL_BARRIER _ReadWriteBarrier();
#else
#define CRND_WRITE_BARRIER
#define CRND_FULL_BARRIER
#endif

#ifdef _MSC_VER
#pragma warning(disable:4127) // warning C4127: conditional expression is constant
#endif

#ifdef CRND_DEVEL
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x500
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef
#define NOMINMAX
#endif
#include "windows.h" // only for IsDebuggerPresent(), DebugBreak(), and OutputDebugStringA()
#endif

// File: crnd_types.h
namespace crnd
{
   const crn_uint8 cUINT8_MIN  = 0;
   const crn_uint8 cUINT8_MAX  = 0xFFU;
   const uint16 cUINT16_MIN = 0;
   const uint16 cUINT16_MAX = 0xFFFFU;
   const uint32 cUINT32_MIN = 0;
   const uint32 cUINT32_MAX = 0xFFFFFFFFU;

   const int8  cINT8_MIN  = -128;
   const int8  cINT8_MAX  = 127;
   const int16 cINT16_MIN = -32768;
   const int16 cINT16_MAX = 32767;
   const int32 cINT32_MIN = (-2147483647 - 1);
   const int32 cINT32_MAX = 2147483647;

   enum eClear { cClear };

   const uint32 cIntBits = 32U;

#ifdef _WIN64
   typedef uint64 ptr_bits;
#else
   typedef uint32 ptr_bits;
#endif

   template<typename T> struct int_traits { enum { cMin = crnd::cINT32_MIN, cMax = crnd::cINT32_MAX, cSigned = true }; };

   template<> struct int_traits<int8> { enum { cMin = crnd::cINT8_MIN, cMax = crnd::cINT8_MAX, cSigned = true }; };
   template<> struct int_traits<int16> { enum { cMin = crnd::cINT16_MIN, cMax = crnd::cINT16_MAX, cSigned = true }; };
   template<> struct int_traits<int32> { enum { cMin = crnd::cINT32_MIN, cMax = crnd::cINT32_MAX, cSigned = true }; };

   template<> struct int_traits<uint8> { enum { cMin = 0, cMax = crnd::cUINT8_MAX, cSigned = false }; };
   template<> struct int_traits<uint16> { enum { cMin = 0, cMax = crnd::cUINT16_MAX, cSigned = false }; };
   template<> struct int_traits<uint32> { enum { cMin = 0, cMax = crnd::cUINT32_MAX, cSigned = false }; };

   struct empty_type { };

} // namespace crnd

// File: crnd_platform.h
namespace crnd
{
#ifdef _XBOX
   const bool c_crnd_little_endian_platform = false;
   const bool c_crnd_big_endian_platform = true;
#define CRND_BIG_ENDIAN_PLATFORM 1
#else
   const bool c_crnd_little_endian_platform = true;
   const bool c_crnd_big_endian_platform = false;
#endif

   bool crnd_is_debugger_present();
   void crnd_debug_break();
   void crnd_output_debug_string(const char* p);

   // actually in crnd_assert.cpp
   void crnd_assert(const char* pExp, const char* pFile, unsigned line);
   void crnd_fail(const char* pExp, const char* pFile, unsigned line);

} // namespace crnd

// File: crnd_assert.h
namespace crnd
{
   void crnd_assert(const char* pExp, const char* pFile, unsigned line);

#ifdef NDEBUG
#define CRND_ASSERT(x) ((void)0)
#undef  CRND_ASSERTS_ENABLED
#else
#define CRND_ASSERT(_exp) (void)( (!!(_exp)) || (crnd::crnd_assert(#_exp, __FILE__, __LINE__), 0) )
#define CRND_ASSERTS_ENABLED
#endif

   void crnd_trace(const char* pFmt, va_list args);
   void crnd_trace(const char* pFmt, ...);

} // namespace crnd

// File: crnd_helpers.h
namespace crnd
{
   namespace helpers
   {
	  template<typename T> struct rel_ops
	  {
		 friend bool operator!= (const T& x, const T& y) { return (!(x == y)); }
		 friend bool operator>  (const T& x, const T& y) { return (y < x); }
		 friend bool operator<= (const T& x, const T& y) { return (!(y < x)); }
		 friend bool operator>= (const T& x, const T& y) { return (!(x < y)); }
	  };

	  template <typename T>
	  inline T* construct(T* p)
	  {
		 return new (static_cast<void*>(p)) T;
	  }

	  template <typename T, typename U>
	  inline T* construct(T* p, const U& init)
	  {
		 return new (static_cast<void*>(p)) T(init);
	  }

	  template <typename T>
	  void construct_array(T* p, uint32 n)
	  {
		 T* q = p + n;
		 for ( ; p != q; ++p)
			new (static_cast<void*>(p)) T;
	  }

	  template <typename T, typename U>
	  void construct_array(T* p, uint32 n, const U& init)
	  {
		 T* q = p + n;
		 for ( ; p != q; ++p)
			new (static_cast<void*>(p)) T(init);
	  }

	  template <typename T>
	  inline void destruct(T* p)
	  {
		 p;
		 p->~T();
	  }

	  template <typename T> inline void destruct_array(T* p, uint32 n)
	  {
		 T* q = p + n;
		 for ( ; p != q; ++p)
			p->~T();
	  }

   }  // namespace helpers

}  // namespace crnd

// File: crnd_traits.h
namespace crnd
{
   template<typename T>
   struct scalar_type
   {
	  enum { cFlag = false };
	  static inline void construct(T* p) { helpers::construct(p); }
	  static inline void construct(T* p, const T& init) { helpers::construct(p, init); }
	  static inline void construct_array(T* p, uint32 n) { helpers::construct_array(p, n); }
	  static inline void destruct(T* p) { helpers::destruct(p); }
	  static inline void destruct_array(T* p, uint32 n) { helpers::destruct_array(p, n); }
   };

   template<typename T> struct scalar_type<T*>
   {
	  enum { cFlag = true };
	  static inline void construct(T** p) { memset(p, 0, sizeof(T*)); }
	  static inline void construct(T** p, T* init) { *p = init; }
	  static inline void construct_array(T** p, uint32 n) { memset(p, 0, sizeof(T*) * n); }
	  static inline void destruct(T** p) { p; }
	  static inline void destruct_array(T** p, uint32 n) { p, n; }
   };

#define CRND_DEFINE_BUILT_IN_TYPE(X) \
   template<> struct scalar_type<X> { \
   enum { cFlag = true }; \
   static inline void construct(X* p) { memset(p, 0, sizeof(X)); } \
   static inline void construct(X* p, const X& init) { memcpy(p, &init, sizeof(X)); } \
   static inline void construct_array(X* p, uint32 n) { memset(p, 0, sizeof(X) * n); } \
   static inline void destruct(X* p) { p; } \
   static inline void destruct_array(X* p, uint32 n) { p, n; } };

   CRND_DEFINE_BUILT_IN_TYPE(bool)
   CRND_DEFINE_BUILT_IN_TYPE(int8_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint8_t)
   CRND_DEFINE_BUILT_IN_TYPE(int16_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint16_t)
   CRND_DEFINE_BUILT_IN_TYPE(int32_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint32_t)
   CRND_DEFINE_BUILT_IN_TYPE(int64_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint64_t)
   CRND_DEFINE_BUILT_IN_TYPE(float)
   CRND_DEFINE_BUILT_IN_TYPE(double)
   CRND_DEFINE_BUILT_IN_TYPE(long double)

#undef CRND_DEFINE_BUILT_IN_TYPE

   // See: http://erdani.org/publications/cuj-2004-06.pdf

   template<typename T>
   struct bitwise_movable { enum { cFlag = false }; };

   // Defines type Q as bitwise movable.
#define CRND_DEFINE_BITWISE_MOVABLE(Q) template<> struct bitwise_movable<Q> { enum { cFlag = true }; };

   // From yasli_traits.h:
   // Credit goes to Boost;
   // also found in the C++ Templates book by Vandevoorde and Josuttis

   typedef char (&yes_t)[1];
   typedef char (&no_t)[2];

   template <class U> yes_t class_test(int U::*);
   template <class U> no_t class_test(...);

   template <class T> struct is_class
   {
	  enum { value = (sizeof(class_test<T>(0)) == sizeof(yes_t)) };
   };

   template <typename T> struct is_pointer
   {
	  enum { value = false };
   };

   template <typename T> struct is_pointer<T*>
   {
	  enum { value = true };
   };

#define CRND_IS_POD(T) __is_pod(T)

} // namespace crnd

// File: crnd_mem.h
namespace crnd
{
   void*    crnd_malloc(size_t size, size_t* pActual_size = NULL);
   void*    crnd_realloc(void* p, size_t size, size_t* pActual_size = NULL, bool movable = true);
   void     crnd_free(void* p);
   size_t   crnd_msize(void* p);

   template<typename T>
   inline T* crnd_new()
   {
	  T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
	  if (!p)
		 return NULL;

	  return helpers::construct(p);
   }

   template<typename T>
   inline T* crnd_new(const T& init)
   {
	  T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
	  if (!p)
		 return NULL;

	  return helpers::construct(p, init);
   }

   template<typename T>
   inline T* crnd_new_array(uint32 num)
   {
	  if (!num) num = 1;

	  uint8* q = static_cast<uint8*>(crnd_malloc(CRND_MIN_ALLOC_ALIGNMENT + sizeof(T) * num));
	  if (!q)
		 return NULL;

	  T* p = reinterpret_cast<T*>(q + CRND_MIN_ALLOC_ALIGNMENT);

	  reinterpret_cast<uint32*>(p)[-1] = num;
	  reinterpret_cast<uint32*>(p)[-2] = ~num;

	  helpers::construct_array(p, num);
	  return p;
   }

   template<typename T>
   inline void crnd_delete(T* p)
   {
	  if (p)
	  {
		 helpers::destruct(p);
		 crnd_free(p);
	  }
   }

   template<typename T>
   inline void crnd_delete_array(T* p)
   {
	  if (p)
	  {
		 const uint32 num = reinterpret_cast<uint32*>(p)[-1];
		 const uint32 num_check = reinterpret_cast<uint32*>(p)[-2];
		 num_check;
		 CRND_ASSERT(num && (num == ~num_check));

		 helpers::destruct_array(p, num);

		 crnd_free(reinterpret_cast<uint8*>(p) - CRND_MIN_ALLOC_ALIGNMENT);
	  }
   }

} // namespace crnd

// File: crnd_math.h
namespace crnd
{
   namespace math
   {
	  const float cNearlyInfinite = 1.0e+37f;

	  const float cDegToRad = 0.01745329252f;
	  const float cRadToDeg = 57.29577951f;

	  extern uint32 g_bitmasks[32];

	  // Yes I know these should probably be pass by ref, not val:
	  // http://www.stepanovpapers.com/notes.pdf
	  // Just don't use them on non-simple (non built-in) types!
	  template<typename T> inline T minimum(T a, T b)
	  {
		 return (a < b) ? a : b;
	  }

	  template<typename T> inline T minimum(T a, T b, T c)
	  {
		 return minimum(minimum(a, b), c);
	  }

	  template<typename T> inline T maximum(T a, T b)
	  {
		 return (a > b) ? a : b;
	  }

	  template<typename T> inline T maximum(T a, T b, T c)
	  {
		 return maximum(maximum(a, b), c);
	  }

	  template<typename T> inline T clamp(T value, T low, T high)
	  {
		 return (value < low) ? low : ((value > high) ? high : value);
	  }

	  template<typename T> inline T square(T value)
	  {
		 return value * value;
	  }

	  inline bool is_power_of_2(uint32 x)
	  {
		 return x && ((x & (x - 1U)) == 0U);
	  }

	  // From "Hackers Delight"
	  inline int next_pow2(uint32 val)
	  {
		 val--;
		 val |= val >> 16;
		 val |= val >> 8;
		 val |= val >> 4;
		 val |= val >> 2;
		 val |= val >> 1;
		 return val + 1;
	  }

	  // Returns the total number of bits needed to encode v.
	  inline uint32 total_bits(uint32 v)
	  {
		 uint32 l = 0;
		 while (v > 0U)
		 {
			v >>= 1;
			l++;
		 }
		 return l;
	  }

	  inline uint floor_log2i(uint v)
	  {
		 uint l = 0;
		 while (v > 1U)
		 {
			v >>= 1;
			l++;
		 }
		 return l;
	  }

	  inline uint ceil_log2i(uint v)
	  {
		 uint l = floor_log2i(v);
		 if ((l != cIntBits) && (v > (1U << l)))
			l++;
		 return l;
	  }
   }
}

// File: crnd_utils.h
namespace crnd
{
   namespace utils
   {
	  template<typename T> inline void zero_object(T& obj)
	  {
		 memset(&obj, 0, sizeof(obj));
	  }

	  template<typename T> inline void zero_this(T* pObj)
	  {
		 memset(pObj, 0, sizeof(*pObj));
	  }

	  template <typename T>
	  inline void swap(T& left, T& right)
	  {
		 T temp(left);
		 left = right;
		 right = temp;
	  }

	  inline void invert_buf(void* pBuf, uint32 size)
	  {
		 uint8* p = static_cast<uint8*>(pBuf);

		 const uint32 half_size = size >> 1;
		 for (uint32 i = 0; i < half_size; i++)
			swap(p[i], p[size - 1U - i]);
	  }

	  static inline uint16 swap16(uint16 x) { return static_cast<uint16>((x << 8) | (x >> 8)); }
	  static inline uint32 swap32(uint32 x) { return ((x << 24) | ((x << 8) & 0x00FF0000) | (( x >> 8) & 0x0000FF00) | (x >> 24)); }

	  uint32 compute_max_mips(uint32 width, uint32 height);

   }   // namespace utils

} // namespace crnd

// File: crnd_vector.h
namespace crnd
{
   struct elemental_vector
   {
	  void* m_p;
	  uint32 m_size;
	  uint32 m_capacity;

	  typedef void (*object_mover)(void* pDst, void* pSrc, uint32 num);

	  bool increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pRelocate);
   };

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4127) //  warning C4127: conditional expression is constant
#endif

   template<typename T>
   class vector : public helpers::rel_ops< vector<T> >
   {
   public:
	  typedef T*              iterator;
	  typedef const T*        const_iterator;
	  typedef T               value_type;
	  typedef T&              reference;
	  typedef const T&        const_reference;
	  typedef T*              pointer;
	  typedef const T*        const_pointer;

	  inline vector() :
		 m_p(NULL),
		 m_size(0),
		 m_capacity(0),
		 m_alloc_failed(false)
	  {
	  }

	  inline vector(const vector& other) :
		 m_p(NULL),
		 m_size(0),
		 m_capacity(0),
		 m_alloc_failed(false)
	  {
		 *this = other;
	  }

	  inline vector(uint32 size) :
		 m_p(NULL),
		 m_size(0),
		 m_capacity(0),
		 m_alloc_failed(false)
	  {
		 resize(size);
	  }

	  inline ~vector()
	  {
		 clear();
	  }

	  // I don't like this. Not at all. But exceptions, or just failing suck worse.
	  inline bool get_alloc_failed() const { return m_alloc_failed; }
	  inline void clear_alloc_failed() { m_alloc_failed = false; }

	  inline bool assign(const vector& other)
	  {
		 if (this == &other)
			return true;

		 if (m_capacity == other.m_size)
			resize(0);
		 else
		 {
			clear();

			if (!increase_capacity(other.m_size, false))
			   return false;
		 }

		 if (scalar_type<T>::cFlag)
			memcpy(m_p, other.m_p, other.m_size * sizeof(T));
		 else
		 {
			T* pDst = m_p;
			const T* pSrc = other.m_p;
			for (uint32 i = other.m_size; i > 0; i--)
			   helpers::construct(pDst++, *pSrc++);
		 }

		 m_size = other.m_size;

		 return true;
	  }

	  inline vector& operator= (const vector& other)
	  {
		 assign(other);
		 return *this;
	  }

	  inline const   T* begin() const  { return m_p; }
	  T* begin()        { return m_p; }

	  inline const   T* end() const  { return m_p + m_size; }
	  T* end()        { return m_p + m_size; }

	  inline bool empty() const { return !m_size; }
	  inline uint32 size() const { return m_size; }
	  inline uint32 capacity() const { return m_capacity; }

	  inline const T& operator[] (uint32 i) const  { CRND_ASSERT(i < m_size); return m_p[i]; }
	  inline       T& operator[] (uint32 i)        { CRND_ASSERT(i < m_size); return m_p[i]; }

	  inline const T& front() const  { CRND_ASSERT(m_size); return m_p[0]; }
	  inline       T& front()        { CRND_ASSERT(m_size); return m_p[0]; }

	  inline const T& back() const  { CRND_ASSERT(m_size); return m_p[m_size - 1]; }
	  inline       T& back()        { CRND_ASSERT(m_size); return m_p[m_size - 1]; }

	  inline void clear()
	  {
		 if (m_p)
		 {
			scalar_type<T>::destruct_array(m_p, m_size);
			crnd_free(m_p);
			m_p = NULL;
			m_size = 0;
			m_capacity = 0;
		 }

		 m_alloc_failed = false;
	  }

	  inline bool reserve(uint32 new_capacity)
	  {
		 if (!increase_capacity(new_capacity, false))
			return false;

		 return true;
	  }

	  inline bool resize(uint32 new_size)
	  {
		 if (m_size != new_size)
		 {
			if (new_size < m_size)
			   scalar_type<T>::destruct_array(m_p + new_size, m_size - new_size);
			else
			{
			   if (new_size > m_capacity)
			   {
				  if (!increase_capacity(new_size, new_size == (m_size + 1)))
					 return false;
			   }

			   scalar_type<T>::construct_array(m_p + m_size, new_size - m_size);
			}

			m_size = new_size;
		 }

		 return true;
	  }

	  inline bool push_back(const T& obj)
	  {
		 CRND_ASSERT(!m_p || (&obj < m_p) || (&obj >= (m_p + m_size)));

		 if (m_size >= m_capacity)
		 {
			if (!increase_capacity(m_size + 1, true))
			   return false;
		 }

		 scalar_type<T>::construct(m_p + m_size, obj);
		 m_size++;

		 return true;
	  }

	  inline void pop_back()
	  {
		 CRND_ASSERT(m_size);

		 if (m_size)
		 {
			m_size--;
			scalar_type<T>::destruct(&m_p[m_size]);
		 }
	  }

	  inline void insert(uint32 index, const T* p, uint32 n)
	  {
		 CRND_ASSERT(index <= m_size);
		 if (!n)
			return;

		 const uint32 orig_size = m_size;
		 resize(m_size + n);

		 const T* pSrc = m_p + orig_size - 1;
		 T* pDst = const_cast<T*>(pSrc) + n;

		 const uint32 num_to_move = orig_size - index;

		 for (uint32 i = 0; i < num_to_move; i++)
		 {
			CRND_ASSERT((pDst - m_p) < (int)m_size);
			*pDst-- = *pSrc--;
		 }

		 pSrc = p;
		 pDst = m_p + index;

		 for (uint32 i = 0; i < n; i++)
		 {
			CRND_ASSERT((pDst - m_p) < (int)m_size);
			*pDst++ = *p++;
		 }
	  }

	  inline void erase(uint32 start, uint32 n)
	  {
		 CRND_ASSERT((start + n) <= m_size);

		 if (!n)
			return;

		 const uint32 num_to_move = m_size - (start + n);

		 T* pDst = m_p + start;
		 T* pDst_end = pDst + num_to_move;
		 const T* pSrc = m_p + start + n;

		 while (pDst != pDst_end)
			*pDst++ = *pSrc++;

		 scalar_type<T>::destruct_array(pDst_end, n);

		 m_size -= n;
	  }

	  inline void erase(uint32 index)
	  {
		 erase(index, 1);
	  }

	  inline void erase(T* p)
	  {
		 CRND_ASSERT((p >= m_p) && (p < (m_p + m_size)));
		 erase(p - m_p);
	  }

	  inline bool operator== (const vector& rhs) const
	  {
		 if (m_size != rhs.m_size)
			return false;
		 else if (m_size)
		 {
			if (scalar_type<T>::cFlag)
			   return memcmp(m_p, rhs.m_p, sizeof(T) * m_size) == 0;
			else
			{
			   const T* pSrc = m_p;
			   const T* pDst = rhs.m_p;
			   for (uint32 i = m_size; i; i--)
				  if (!(*pSrc++ == *pDst++))
					 return false;
			}
		 }

		 return true;
	  }

	  inline bool operator< (const vector& rhs) const
	  {
		 const uint32 min_size = math::minimum(m_size, rhs.m_size);

		 const T* pSrc = m_p;
		 const T* pSrc_end = m_p + min_size;
		 const T* pDst = rhs.m_p;

		 while ((pSrc < pSrc_end) && (*pSrc == *pDst))
		 {
			pSrc++;
			pDst++;
		 }

		 if (pSrc < pSrc_end)
			return *pSrc < *pDst;

		 return m_size < rhs.m_size;
	  }

	  void swap(vector& other)
	  {
		 utils::swap(m_p, other.m_p);
		 utils::swap(m_size, other.m_size);
		 utils::swap(m_capacity, other.m_capacity);
	  }

   private:
	  T*          m_p;
	  uint32      m_size;
	  uint32      m_capacity;
	  bool        m_alloc_failed;

	  template<typename Q> struct is_vector { enum { cFlag = false }; };
	  template<typename Q> struct is_vector< vector<Q> > { enum { cFlag = true }; };

	  static void object_mover(void* pDst_void, void* pSrc_void, uint32 num)
	  {
		 T* pSrc = static_cast<T*>(pSrc_void);
		 T* const pSrc_end = pSrc + num;
		 T* pDst = static_cast<T*>(pDst_void);

		 while (pSrc != pSrc_end)
		 {
			helpers::construct<T>(pDst, *pSrc);
			pSrc->~T();
			pSrc++;
			pDst++;
		 }
	  }

	  inline bool increase_capacity(uint32 min_new_capacity, bool grow_hint)
	  {
		 if (!reinterpret_cast<elemental_vector*>(this)->increase_capacity(
			min_new_capacity, grow_hint, sizeof(T),
			((scalar_type<T>::cFlag) || (is_vector<T>::cFlag) || (bitwise_movable<T>::cFlag) || CRND_IS_POD(T)) ? NULL : object_mover))
		 {
			m_alloc_failed = true;
			return false;
		 }
		 return true;
	  }
   };

#ifdef _MSC_VER
#pragma warning(pop)
#endif

   extern void vector_test();

} // namespace crnd

// File: crnd_private.h
namespace crnd
{
   const crn_header* crnd_get_header(crn_header& header, const void* pData, uint32 data_size);

} // namespace crnd

// File: checksum.h
namespace crnd
{
   // crc16() intended for small buffers - doesn't use an acceleration table.
   const uint16 cInitCRC16 = 0;
   uint16 crc16(const void* pBuf, uint32 len, uint16 crc = cInitCRC16);

}  // namespace crnd

// File: crnd_color.h
namespace crnd
{
   template<typename component_type> struct color_quad_component_traits
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = false,
		 cMin = cUINT8_MIN,
		 cMax = cUINT8_MAX
	  };
   };

   template<> struct color_quad_component_traits<int16>
   {
	  enum
	  {
		 cSigned = true,
		 cFloat = false,
		 cMin = cINT16_MIN,
		 cMax = cINT16_MAX
	  };
   };

   template<> struct color_quad_component_traits<uint16>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = false,
		 cMin = cUINT16_MIN,
		 cMax = cUINT16_MAX
	  };
   };

   template<> struct color_quad_component_traits<int32>
   {
	  enum
	  {
		 cSigned = true,
		 cFloat = false,
		 cMin = cINT32_MIN,
		 cMax = cINT32_MAX
	  };
   };

   template<> struct color_quad_component_traits<uint32>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = false,
		 cMin = cUINT32_MIN,
		 cMax = cUINT32_MAX
	  };
   };

   template<> struct color_quad_component_traits<float>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = true,
		 cMin = cINT32_MIN,
		 cMax = cINT32_MAX
	  };
   };

   template<> struct color_quad_component_traits<double>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = true,
		 cMin = cINT32_MIN,
		 cMax = cINT32_MAX
	  };
   };

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4201) //  warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4127) //  warning C4127: conditional expression is constant
#endif

   template<typename component_type, typename parameter_type>
   class color_quad : public helpers::rel_ops<color_quad<component_type, parameter_type> >
   {
	  static parameter_type clamp(parameter_type v)
	  {
		 if (component_traits::cFloat)
			return v;
		 else
		 {
			if (v < component_traits::cMin)
			   return component_traits::cMin;
			else if (v > component_traits::cMax)
			   return component_traits::cMax;
			return v;
		 }
	  }

   public:
	  typedef component_type component_t;
	  typedef parameter_type parameter_t;
	  typedef color_quad_component_traits<component_type> component_traits;

	  enum { cNumComps = 4 };

	  union
	  {
		 struct
		 {
			component_type r;
			component_type g;
			component_type b;
			component_type a;
		 };

		 component_type c[cNumComps];
	  };

	  inline color_quad()
	  {
	  }

	  inline color_quad(eClear) :
		 r(0), g(0), b(0), a(0)
	  {
	  }

	  inline color_quad(const color_quad& other) :
		 r(other.r), g(other.g), b(other.b), a(other.a)
	  {
	  }

	  inline color_quad(parameter_type y, parameter_type alpha = component_traits::cMax)
	  {
		 set(y, alpha);
	  }

	  inline color_quad(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax)
	  {
		 set(red, green, blue, alpha);
	  }

	  template<typename other_component_type, typename other_parameter_type>
	  inline color_quad(const color_quad<other_component_type, other_parameter_type>& other) :
		 r(clamp(other.r)), g(clamp(other.g)), b(clamp(other.b)), a(clamp(other.a))
	  {
	  }

	  inline void clear()
	  {
		 r = 0;
		 g = 0;
		 b = 0;
		 a = 0;
	  }

	  inline color_quad& operator= (const color_quad& other)
	  {
		 r = other.r;
		 g = other.g;
		 b = other.b;
		 a = other.a;
		 return *this;
	  }

	  template<typename other_component_type, typename other_parameter_type>
	  inline color_quad& operator=(const color_quad<other_component_type, other_parameter_type>& other)
	  {
		 r = clamp(other.r);
		 g = clamp(other.g);
		 b = clamp(other.b);
		 a = clamp(other.a);
		 return *this;
	  }

	  inline color_quad& set(parameter_type y, parameter_type alpha = component_traits::cMax)
	  {
		 y = clamp(y);
		 r = static_cast<component_type>(y);
		 g = static_cast<component_type>(y);
		 b = static_cast<component_type>(y);
		 a = static_cast<component_type>(alpha);
		 return *this;
	  }

	  inline color_quad& set(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax)
	  {
		 r = static_cast<component_type>(clamp(red));
		 g = static_cast<component_type>(clamp(green));
		 b = static_cast<component_type>(clamp(blue));
		 a = static_cast<component_type>(clamp(alpha));
		 return *this;
	  }

	  inline color_quad& set_noclamp_rgba(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha)
	  {
		 r = static_cast<component_type>(red);
		 g = static_cast<component_type>(green);
		 b = static_cast<component_type>(blue);
		 a = static_cast<component_type>(alpha);
		 return *this;
	  }

	  inline color_quad& set_noclamp_rgb(parameter_type red, parameter_type green, parameter_type blue)
	  {
		 r = static_cast<component_type>(red);
		 g = static_cast<component_type>(green);
		 b = static_cast<component_type>(blue);
		 return *this;
	  }

	  static inline parameter_type get_min_comp() { return component_traits::cMin; }
	  static inline parameter_type get_max_comp() { return component_traits::cMax; }
	  static inline bool get_comps_are_signed() { return component_traits::cSigned; }

	  inline component_type operator[] (uint32 i) const { CRND_ASSERT(i < cNumComps); return c[i]; }
	  inline component_type& operator[] (uint32 i) { CRND_ASSERT(i < cNumComps); return c[i]; }

	  inline color_quad& set_component(uint32 i, parameter_type f)
	  {
		 CRND_ASSERT(i < cNumComps);

		 c[i] = static_cast<component_type>(clamp(f));

		 return *this;
	  }

	  inline color_quad& clamp(const color_quad& l, const color_quad& h)
	  {
		 for (uint32 i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l[i], h[i]));
		 return *this;
	  }

	  inline color_quad& clamp(parameter_type l, parameter_type h)
	  {
		 for (uint32 i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l, h));
		 return *this;
	  }

	  // Returns CCIR 601 luma (consistent with color_utils::RGB_To_Y).
	  inline parameter_type get_luma() const
	  {
		 return static_cast<parameter_type>((19595U * r + 38470U * g + 7471U * b + 32768) >> 16U);
	  }

	  // Returns REC 709 luma.
	  inline parameter_type get_luma_rec709() const
	  {
		 return static_cast<parameter_type>((13938U * r + 46869U * g + 4729U * b + 32768U) >> 16U);
	  }

	  inline uint32 squared_distance(const color_quad& c, bool alpha = true) const
	  {
		 return math::square(r - c.r) + math::square(g - c.g) + math::square(b - c.b) + (alpha ? math::square(a - c.a) : 0);
	  }

	  inline bool rgb_equals(const color_quad& rhs) const
	  {
		 return (r == rhs.r) && (g == rhs.g) && (b == rhs.b);
	  }

	  inline bool operator== (const color_quad& rhs) const
	  {
		 return (r == rhs.r) && (g == rhs.g) && (b == rhs.b) && (a == rhs.a);
	  }

	  inline bool operator< (const color_quad& rhs) const
	  {
		 for (uint32 i = 0; i < cNumComps; i++)
		 {
			if (c[i] < rhs.c[i])
			   return true;
			else if (!(c[i] == rhs.c[i]))
			   return false;
		 }
		 return false;
	  }

	  inline color_quad& operator+= (const color_quad& other)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(clamp(c[i] + other.c[i]));
		 return *this;
	  }

	  inline color_quad& operator-= (const color_quad& other)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(clamp(c[i] - other.c[i]));
		 return *this;
	  }

	  inline color_quad& operator*= (parameter_type v)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(clamp(c[i] * v));
		 return *this;
	  }

	  inline color_quad& operator/= (parameter_type v)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(c[i] / v);
		 return *this;
	  }

	  inline color_quad get_swizzled(uint32 x, uint32 y, uint32 z, uint32 w) const
	  {
		 CRND_ASSERT((x | y | z | w) < 4);
		 return color_quad(c[x], c[y], c[z], c[w]);
	  }

	  inline friend color_quad operator+ (const color_quad& lhs, const color_quad& rhs)
	  {
		 color_quad result(lhs);
		 result += rhs;
		 return result;
	  }

	  inline friend color_quad operator- (const color_quad& lhs, const color_quad& rhs)
	  {
		 color_quad result(lhs);
		 result -= rhs;
		 return result;
	  }

	  inline friend color_quad operator* (const color_quad& lhs, parameter_type v)
	  {
		 color_quad result(lhs);
		 result *= v;
		 return result;
	  }

	  friend inline color_quad operator/ (const color_quad& lhs, parameter_type v)
	  {
		 color_quad result(lhs);
		 result /= v;
		 return result;
	  }

	  friend inline color_quad operator* (parameter_type v, const color_quad& rhs)
	  {
		 color_quad result(rhs);
		 result *= v;
		 return result;
	  }

	  inline uint32 get_min_component_index(bool alpha = true) const
	  {
		 uint32 index = 0;
		 uint32 limit = alpha ? cNumComps : (cNumComps - 1);
		 for (uint32 i = 1; i < limit; i++)
			if (c[i] < c[index])
			   index = i;
		 return index;
	  }

	  inline uint32 get_max_component_index(bool alpha = true) const
	  {
		 uint32 index = 0;
		 uint32 limit = alpha ? cNumComps : (cNumComps - 1);
		 for (uint32 i = 1; i < limit; i++)
			if (c[i] > c[index])
			   index = i;
		 return index;
	  }

	  inline void get_float4(float* pDst)
	  {
		 for (uint32 i = 0; i < 4; i++)
			pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
	  }

	  inline void get_float3(float* pDst)
	  {
		 for (uint32 i = 0; i < 3; i++)
			pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
	  }

	  static inline color_quad make_black()
	  {
		 return color_quad(0, 0, 0, component_traits::cMax);
	  }

	  static inline color_quad make_white()
	  {
		 return color_quad(component_traits::cMax, component_traits::cMax, component_traits::cMax, component_traits::cMax);
	  }
   }; // class color_quad

#ifdef _MSC_VER
#pragma warning(pop)
#endif

   template<typename c, typename q>
   struct scalar_type< color_quad<c, q> >
   {
	  enum { cFlag = true };
	  static inline void construct(color_quad<c, q>* p) { }
	  static inline void construct(color_quad<c, q>* p, const color_quad<c, q>& init) { memcpy(p, &init, sizeof(color_quad<c, q>)); }
	  static inline void construct_array(color_quad<c, q>* p, uint32 n) { p, n; }
	  static inline void destruct(color_quad<c, q>* p) { p; }
	  static inline void destruct_array(color_quad<c, q>* p, uint32 n) { p, n; }
   };

   typedef color_quad<uint8, int>      color_quad_u8;
   typedef color_quad<int16, int>      color_quad_i16;
   typedef color_quad<uint16, int>     color_quad_u16;
   typedef color_quad<int32, int>      color_quad_i32;
   typedef color_quad<uint32, uint32>    color_quad_u32;
   typedef color_quad<float, float>    color_quad_f;
   typedef color_quad<double, double>  color_quad_d;

} // namespace crnd

// File: crnd_dxt.h
namespace crnd
{
   enum dxt_format
   {
	  cDXTInvalid = -1,

	  // cDXT1/1A must appear first!
	  cDXT1,
	  cDXT1A,

	  cDXT3,
	  cDXT5,
	  cDXT5A,

	  cDXN_XY,    // inverted relative to standard ATI2, 360's DXN
	  cDXN_YX     // standard ATI2
   };

   enum dxt_constants
   {
	  cDXTBlockShift = 2U,
	  cDXTBlockSize = 1U << cDXTBlockShift,

	  cDXT1BytesPerBlock = 8U,
	  cDXT5NBytesPerBlock = 16U,

	  cDXT1SelectorBits = 2U,
	  cDXT1SelectorValues = 1U << cDXT1SelectorBits,
	  cDXT1SelectorMask = cDXT1SelectorValues - 1U,

	  cDXT5SelectorBits = 3U,
	  cDXT5SelectorValues = 1U << cDXT5SelectorBits,
	  cDXT5SelectorMask = cDXT5SelectorValues - 1U
   };

   const float cDXT1MaxLinearValue = 3.0f;
   const float cDXT1InvMaxLinearValue = 1.0f/3.0f;

   const float cDXT5MaxLinearValue = 7.0f;
   const float cDXT5InvMaxLinearValue = 1.0f/7.0f;

   // Converts DXT1 raw color selector index to a linear value.
   extern const uint8 g_dxt1_to_linear[cDXT1SelectorValues];

   // Converts DXT5 raw alpha selector index to a linear value.
   extern const uint8 g_dxt5_to_linear[cDXT5SelectorValues];

   // Converts DXT1 linear color selector index to a raw value (inverse of g_dxt1_to_linear).
   extern const uint8 g_dxt1_from_linear[cDXT1SelectorValues];

   // Converts DXT5 linear alpha selector index to a raw value (inverse of g_dxt5_to_linear).
   extern const uint8 g_dxt5_from_linear[cDXT5SelectorValues];

   extern const uint8 g_six_alpha_invert_table[cDXT5SelectorValues];
   extern const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues];

   struct dxt1_block
   {
	  uint8 m_low_color[2];
	  uint8 m_high_color[2];

	  enum { cNumSelectorBytes = 4 };
	  uint8 m_selectors[cNumSelectorBytes];

	  inline void clear()
	  {
		 utils::zero_this(this);
	  }

	  // These methods assume the in-memory rep is in LE byte order.
	  inline uint32 get_low_color() const
	  {
		 return m_low_color[0] | (m_low_color[1] << 8U);
	  }

	  inline uint32 get_high_color() const
	  {
		 return m_high_color[0] | (m_high_color[1] << 8U);
	  }

	  inline void set_low_color(uint16 c)
	  {
		 m_low_color[0] = static_cast<uint8>(c & 0xFF);
		 m_low_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
	  }

	  inline void set_high_color(uint16 c)
	  {
		 m_high_color[0] = static_cast<uint8>(c & 0xFF);
		 m_high_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
	  }

	  inline uint32 get_selector(uint32 x, uint32 y) const
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U));
		 return (m_selectors[y] >> (x * cDXT1SelectorBits)) & cDXT1SelectorMask;
	  }

	  inline void set_selector(uint32 x, uint32 y, uint32 val)
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U) && (val < 4U));

		 m_selectors[y] &= (~(cDXT1SelectorMask << (x * cDXT1SelectorBits)));
		 m_selectors[y] |= (val << (x * cDXT1SelectorBits));
	  }

	  static uint16        pack_color(const color_quad_u8& color, bool scaled, uint32 bias = 127U);
	  static uint16        pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias = 127U);

	  static color_quad_u8 unpack_color(uint16 packed_color, bool scaled, uint32 alpha = 255U);
	  static void          unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled);

	  static uint32        get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1);
	  static uint32        get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1);
	  // pDst must point to an array at least cDXT1SelectorValues long.
	  static uint32        get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1);

	  static color_quad_u8 unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha = 255U);
	  static uint32        pack_endpoints(uint32 lo, uint32 hi);
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt1_block);

   struct dxt3_block
   {
	  enum { cNumAlphaBytes = 8 };
	  uint8 m_alpha[cNumAlphaBytes];

	  void set_alpha(uint32 x, uint32 y, uint32 value, bool scaled);
	  uint32 get_alpha(uint32 x, uint32 y, bool scaled) const;
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt3_block);

   struct dxt5_block
   {
	  uint8 m_endpoints[2];

	  enum { cNumSelectorBytes = 6 };
	  uint8 m_selectors[cNumSelectorBytes];

	  inline void clear()
	  {
		 utils::zero_this(this);
	  }

	  inline uint32 get_low_alpha() const
	  {
		 return m_endpoints[0];
	  }

	  inline uint32 get_high_alpha() const
	  {
		 return m_endpoints[1];
	  }

	  inline void set_low_alpha(uint32 i)
	  {
		 CRND_ASSERT(i <= cUINT8_MAX);
		 m_endpoints[0] = static_cast<uint8>(i);
	  }

	  inline void set_high_alpha(uint32 i)
	  {
		 CRND_ASSERT(i <= cUINT8_MAX);
		 m_endpoints[1] = static_cast<uint8>(i);
	  }

	  uint32 get_endpoints_as_word() const { return m_endpoints[0] | (m_endpoints[1] << 8); }

	  uint32 get_selectors_as_word(uint32 index) { CRND_ASSERT(index < 3); return m_selectors[index * 2] | (m_selectors[index * 2 + 1] << 8); }

	  inline uint32 get_selector(uint32 x, uint32 y) const
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U));

		 uint32 selector_index = (y * 4) + x;
		 uint32 bit_index = selector_index * cDXT5SelectorBits;

		 uint32 byte_index = bit_index >> 3;
		 uint32 bit_ofs = bit_index & 7;

		 uint32 v = m_selectors[byte_index];
		 if (byte_index < (cNumSelectorBytes - 1))
			v |= (m_selectors[byte_index + 1] << 8);

		 return (v >> bit_ofs) & 7;
	  }

	  inline void set_selector(uint32 x, uint32 y, uint32 val)
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U) && (val < 8U));

		 uint32 selector_index = (y * 4) + x;
		 uint32 bit_index = selector_index * cDXT5SelectorBits;

		 uint32 byte_index = bit_index >> 3;
		 uint32 bit_ofs = bit_index & 7;

		 uint32 v = m_selectors[byte_index];
		 if (byte_index < (cNumSelectorBytes - 1))
			v |= (m_selectors[byte_index + 1] << 8);

		 v &= (~(7 << bit_ofs));
		 v |= (val << bit_ofs);

		 m_selectors[byte_index] = static_cast<uint8>(v);
		 if (byte_index < (cNumSelectorBytes - 1))
			m_selectors[byte_index + 1] = static_cast<uint8>(v >> 8);
	  }

	  // Results written to alpha channel.
	  static uint32          get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h);
	  static uint32          get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h);
	  static uint32          get_block_values(color_quad_u8* pDst, uint32 l, uint32 h);

	  static uint32          get_block_values6(uint32* pDst, uint32 l, uint32 h);
	  static uint32          get_block_values8(uint32* pDst, uint32 l, uint32 h);
	  // pDst must point to an array at least cDXT5SelectorValues long.
	  static uint32          get_block_values(uint32* pDst, uint32 l, uint32 h);

	  static uint32          unpack_endpoint(uint32 packed, uint32 index);
	  static uint32          pack_endpoints(uint32 lo, uint32 hi);
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt5_block);

} // namespace crnd

// File: crnd_dxt_hc_common.h
namespace crnd
{
   struct chunk_tile_desc
   {
	  // These values are in pixels, and always a multiple of cBlockPixelWidth/cBlockPixelHeight.
	  uint32 m_x_ofs;
	  uint32 m_y_ofs;
	  uint32 m_width;
	  uint32 m_height;
	  uint32 m_layout_index;
   };

   struct chunk_encoding_desc
   {
	  uint32 m_num_tiles;
	  chunk_tile_desc m_tiles[4];
   };

   const uint32 cChunkPixelWidth = 8;
   const uint32 cChunkPixelHeight = 8;
   const uint32 cChunkBlockWidth = 2;
   const uint32 cChunkBlockHeight = 2;

   const uint32 cChunkMaxTiles = 4;

   const uint32 cBlockPixelWidthShift = 2;
   const uint32 cBlockPixelHeightShift = 2;

   const uint32 cBlockPixelWidth = 4;
   const uint32 cBlockPixelHeight = 4;

   const uint32 cNumChunkEncodings = 8;
   extern chunk_encoding_desc g_chunk_encodings[cNumChunkEncodings];

   const uint32 cNumChunkTileLayouts = 9;
   const uint32 cFirst4x4ChunkTileLayout = 5;
   extern chunk_tile_desc g_chunk_tile_layouts[cNumChunkTileLayouts];

} // namespace crnd

// File: crnd_prefix_coding.h
#ifdef _XBOX
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 1
#else
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 0
#endif

namespace crnd
{
   namespace prefix_coding
   {
	  const uint32 cMaxExpectedCodeSize = 16;
	  const uint32 cMaxSupportedSyms = 8192;
	  const uint32 cMaxTableBits = 11;

	  class decoder_tables
	  {
	  public:
		 inline decoder_tables() :
			m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
		 {
		 }

		 inline decoder_tables(const decoder_tables& other) :
			m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
		 {
			*this = other;
		 }

		 decoder_tables& operator= (const decoder_tables& other)
		 {
			if (this == &other)
			   return *this;

			clear();

			memcpy(this, &other, sizeof(*this));

			if (other.m_lookup)
			{
			   m_lookup = crnd_new_array<uint32>(m_cur_lookup_size);
			   if (m_lookup)
				  memcpy(m_lookup, other.m_lookup, sizeof(m_lookup[0]) * m_cur_lookup_size);
			}

			if (other.m_sorted_symbol_order)
			{
			   m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
			   if (m_sorted_symbol_order)
				  memcpy(m_sorted_symbol_order, other.m_sorted_symbol_order, sizeof(m_sorted_symbol_order[0]) * m_cur_sorted_symbol_order_size);
			}

			return *this;
		 }

		 inline void clear()
		 {
			if (m_lookup)
			{
			   crnd_delete_array(m_lookup);
			   m_lookup = 0;
			   m_cur_lookup_size = 0;
			}

			if (m_sorted_symbol_order)
			{
			   crnd_delete_array(m_sorted_symbol_order);
			   m_sorted_symbol_order = NULL;
			   m_cur_sorted_symbol_order_size = 0;
			}
		 }

		 inline ~decoder_tables()
		 {
			if (m_lookup)
			   crnd_delete_array(m_lookup);

			if (m_sorted_symbol_order)
			   crnd_delete_array(m_sorted_symbol_order);
		 }

		 bool init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits);

		 // DO NOT use any complex classes here - it is bitwise copied.

		 uint32                  m_num_syms;
		 uint32                  m_total_used_syms;
		 uint32                  m_table_bits;
		 uint32                  m_table_shift;
		 uint32                  m_table_max_code;
		 uint32                  m_decode_start_code_size;

		 uint8                   m_min_code_size;
		 uint8                   m_max_code_size;

		 uint32                  m_max_codes[cMaxExpectedCodeSize + 1];
		 int32                   m_val_ptrs[cMaxExpectedCodeSize + 1];

		 uint32                  m_cur_lookup_size;
		 uint32*                 m_lookup;

		 uint32                  m_cur_sorted_symbol_order_size;
		 uint16*                 m_sorted_symbol_order;

		 inline uint32 get_unshifted_max_code(uint32 len) const
		 {
			CRND_ASSERT( (len >= 1) && (len <= cMaxExpectedCodeSize) );
			uint32 k = m_max_codes[len - 1];
			if (!k)
			   return crnd::cUINT32_MAX;
			return (k - 1) >> (16 - len);
		 }
	  };

   } // namespace prefix_coding

} // namespace crnd

// File: crnd_symbol_codec.h
namespace crnd
{
   class static_huffman_data_model
   {
   public:
	  static_huffman_data_model();
	  static_huffman_data_model(const static_huffman_data_model& other);
	  ~static_huffman_data_model();

	  static_huffman_data_model& operator= (const static_huffman_data_model& rhs);

	  bool init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit);
	  void clear();

	  inline bool is_valid() const { return m_pDecode_tables != NULL; }

	  inline uint32 get_total_syms() const { return m_total_syms; }

	  inline uint32 get_code_size(uint32 sym) const { return m_code_sizes[sym]; }

	  inline const uint8* get_code_sizes() const { return m_code_sizes.empty() ? NULL : &m_code_sizes[0]; }

   public:
	  uint32                           m_total_syms;
	  crnd::vector<uint8>              m_code_sizes;
	  prefix_coding::decoder_tables*   m_pDecode_tables;

   private:
	  bool prepare_decoder_tables();
	  uint compute_decoder_table_bits() const;

	  friend class symbol_codec;
   };

   class symbol_codec
   {
   public:
	  symbol_codec();

	  bool start_decoding(const uint8* pBuf, uint32 buf_size);
	  bool decode_receive_static_data_model(static_huffman_data_model& model);

	  uint32 decode_bits(uint32 num_bits);
	  uint32 decode(const static_huffman_data_model& model);

	  uint64 stop_decoding();

   public:
	  const uint8*         m_pDecode_buf;
	  const uint8*         m_pDecode_buf_next;
	  const uint8*         m_pDecode_buf_end;
	  uint32               m_decode_buf_size;

	  typedef uint32 bit_buf_type;
	  enum { cBitBufSize = 32U };
	  bit_buf_type         m_bit_buf;

	  int                  m_bit_count;

   private:
	  void get_bits_init();
	  uint32 get_bits(uint32 num_bits);
   };

} // namespace crnd

#define CRND_HUFF_DECODE_BEGIN(x)
#define CRND_HUFF_DECODE_END(x)
#define CRND_HUFF_DECODE(codec, model, symbol) symbol = codec.decode(model);

namespace crnd
{
   void crnd_assert(const char* pExp, const char* pFile, unsigned line)
   {
	  char buf[512];

#if defined(WIN32) && defined(_MSC_VER)
	  sprintf_s(buf, sizeof(buf), "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#else
	  sprintf(buf, "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#endif

	  crnd_output_debug_string(buf);

	  puts(buf);

	  if (crnd_is_debugger_present())
		 crnd_debug_break();
   }

   void crnd_trace(const char* pFmt, va_list args)
   {
	  if (crnd_is_debugger_present())
	  {
		 char buf[512];
#if defined(WIN32) && defined(_MSC_VER)
		 vsprintf_s(buf, sizeof(buf), pFmt, args);
#else
		 vsprintf(buf, pFmt, args);
#endif

		 crnd_output_debug_string(buf);
	  }
   };

   void crnd_trace(const char* pFmt, ...)
   {
	  va_list args;
	  va_start(args, pFmt);
	  crnd_trace(pFmt, args);
	  va_end(args);
   };

} // namespace crnd

// File: checksum.cpp
// From the public domain stb.h header.
namespace crnd
{
   uint16 crc16(const void* pBuf, uint32 len, uint16 crc)
   {
	  crc = ~crc;

	  const uint8* p = reinterpret_cast<const uint8*>(pBuf);
	  while (len)
	  {
		 const uint16 q = *p++ ^ (crc >> 8U);
		 crc <<= 8U;

		 uint16 r = (q >> 4U) ^ q;
		 crc ^= r;
		 r <<= 5U;
		 crc ^= r;
		 r <<= 7U;
		 crc ^= r;

		 len--;
	  }

	  return static_cast<uint16>(~crc);
   }

} // namespace crnd

// File: crnd_vector.cpp
namespace crnd
{
   bool elemental_vector::increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pMover)
   {
	  CRND_ASSERT(m_size <= m_capacity);
	  CRND_ASSERT(min_new_capacity < (0x7FFF0000U / element_size));

	  if (m_capacity >= min_new_capacity)
		 return true;

	  uint32 new_capacity = min_new_capacity;
	  if ((grow_hint) && (!math::is_power_of_2(new_capacity)))
		 new_capacity = math::next_pow2(new_capacity);

	  CRND_ASSERT(new_capacity && (new_capacity > m_capacity));

	  const uint32 desired_size = element_size * new_capacity;
	  size_t actual_size;
	  if (!pMover)
	  {
		 void* new_p = crnd_realloc(m_p, desired_size, &actual_size, true);
		 if (!new_p)
			return false;
		 m_p = new_p;
	  }
	  else
	  {
		 void* new_p = crnd_malloc(desired_size, &actual_size);
		 if (!new_p)
			return false;

		 (*pMover)(new_p, m_p, m_size);

		 if (m_p)
			crnd_free(m_p);

		 m_p = new_p;
	  }

	  if (actual_size > desired_size)
		 m_capacity = static_cast<uint32>(actual_size / element_size);
	  else
		 m_capacity = new_capacity;

	  return true;
   }

} // namespace crnd

// File: crnd_utils.cpp
namespace crnd
{
   namespace utils
   {
	  uint32 compute_max_mips(uint32 width, uint32 height)
	  {
		 if ((width | height) == 0)
			return 0;

		 uint32 num_mips = 1;

		 while ((width > 1U) || (height > 1U))
		 {
			width >>= 1U;
			height >>= 1U;
			num_mips++;
		 }

		 return num_mips;
	  }

   } // namespace utils

} // namespace crnd

// File: crnd_prefix_coding.cpp
namespace crnd
{
   namespace prefix_coding
   {
	  bool decoder_tables::init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits)
	  {
		 uint32 min_codes[cMaxExpectedCodeSize];
		 if ((!num_syms) || (table_bits > cMaxTableBits))
			return false;

		 m_num_syms = num_syms;

		 uint32 num_codes[cMaxExpectedCodeSize + 1];
		 utils::zero_object(num_codes);

		 for (uint32 i = 0; i < num_syms; i++)
		 {
			uint32 c = pCodesizes[i];
			if (c)
			   num_codes[c]++;
		 }

		 uint32 sorted_positions[cMaxExpectedCodeSize + 1];

		 uint32 cur_code = 0;

		 uint32 total_used_syms = 0;
		 uint32 max_code_size = 0;
		 uint32 min_code_size = cUINT32_MAX;
		 for (uint32 i = 1; i <= cMaxExpectedCodeSize; i++)
		 {
			const uint32 n = num_codes[i];

			if (!n)
			   m_max_codes[i - 1] = 0;//UINT_MAX;
			else
			{
			   min_code_size = math::minimum(min_code_size, i);
			   max_code_size = math::maximum(max_code_size, i);

			   min_codes[i - 1] = cur_code;

			   m_max_codes[i - 1] = cur_code + n - 1;
			   m_max_codes[i - 1] = 1 + ((m_max_codes[i - 1] << (16 - i)) | ((1 << (16 - i)) - 1));

			   m_val_ptrs[i - 1] = total_used_syms;

			   sorted_positions[i] = total_used_syms;

			   cur_code += n;
			   total_used_syms += n;
			}

			cur_code <<= 1;
		 }

		 m_total_used_syms = total_used_syms;

		 if (total_used_syms > m_cur_sorted_symbol_order_size)
		 {
			m_cur_sorted_symbol_order_size = total_used_syms;

			if (!math::is_power_of_2(total_used_syms))
			   m_cur_sorted_symbol_order_size = math::minimum<uint32>(num_syms, math::next_pow2(total_used_syms));

			if (m_sorted_symbol_order)
			   crnd_delete_array(m_sorted_symbol_order);

			m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
			if (!m_sorted_symbol_order)
			   return false;
		 }

		 m_min_code_size = static_cast<uint8>(min_code_size);
		 m_max_code_size = static_cast<uint8>(max_code_size);

		 for (uint32 i = 0; i < num_syms; i++)
		 {
			uint32 c = pCodesizes[i];
			if (c)
			{
			   CRND_ASSERT(num_codes[c]);

			   uint32 sorted_pos = sorted_positions[c]++;

			   CRND_ASSERT(sorted_pos < total_used_syms);

			   m_sorted_symbol_order[sorted_pos] = static_cast<uint16>(i);
			}
		 }

		 if (table_bits <= m_min_code_size)
			table_bits = 0;
		 m_table_bits = table_bits;

		 if (table_bits)
		 {
			uint32 table_size = 1 << table_bits;
			if (table_size > m_cur_lookup_size)
			{
			   m_cur_lookup_size = table_size;

			   if (m_lookup)
				  crnd_delete_array(m_lookup);

			   m_lookup = crnd_new_array<uint32>(table_size);
			   if (!m_lookup)
				  return false;
			}

			memset(m_lookup, 0xFF, (uint)sizeof(m_lookup[0]) * (1UL << table_bits));

			for (uint32 codesize = 1; codesize <= table_bits; codesize++)
			{
			   if (!num_codes[codesize])
				  continue;

			   const uint32 fillsize = table_bits - codesize;
			   const uint32 fillnum = 1 << fillsize;

			   const uint32 min_code = min_codes[codesize - 1];
			   const uint32 max_code = get_unshifted_max_code(codesize);
			   const uint32 val_ptr = m_val_ptrs[codesize - 1];

			   for (uint32 code = min_code; code <= max_code; code++)
			   {
				  const uint32 sym_index = m_sorted_symbol_order[ val_ptr + code - min_code ];
				  CRND_ASSERT( pCodesizes[sym_index] == codesize );

				  for (uint32 j = 0; j < fillnum; j++)
				  {
					 const uint32 t = j + (code << fillsize);

					 CRND_ASSERT(t < (1U << table_bits));

					 CRND_ASSERT(m_lookup[t] == cUINT32_MAX);

					 m_lookup[t] = sym_index | (codesize << 16U);
				  }
			   }
			}
		 }

		 for (uint32 i = 0; i < cMaxExpectedCodeSize; i++)
			m_val_ptrs[i] -= min_codes[i];

		 m_table_max_code = 0;
		 m_decode_start_code_size = m_min_code_size;

		 if (table_bits)
		 {
			uint32 i;
			for (i = table_bits; i >= 1; i--)
			{
			   if (num_codes[i])
			   {
				  m_table_max_code = m_max_codes[i - 1];
				  break;
			   }
			}
			if (i >= 1)
			{
			   m_decode_start_code_size = table_bits + 1;
			   for (uint32 j = table_bits + 1; j <= max_code_size; j++)
			   {
				  if (num_codes[j])
				  {
					 m_decode_start_code_size = j;
					 break;
				  }
			   }
			}
		 }

		 // sentinels
		 m_max_codes[cMaxExpectedCodeSize] = cUINT32_MAX;
		 m_val_ptrs[cMaxExpectedCodeSize] = 0xFFFFF;

		 m_table_shift = 32 - m_table_bits;
		 return true;
	  }

   } // namespace prefix_codig

} // namespace crnd

// File: crnd_platform.cpp
namespace crnd
{
   bool crnd_is_debugger_present()
   {
#ifdef CRND_DEVEL
	  return IsDebuggerPresent() != 0;
#else
	  return false;
#endif
   }

   void crnd_debug_break()
   {
#ifdef CRND_DEVEL
	  DebugBreak();
#endif
   }

   void crnd_output_debug_string(const char* p)
   {
	  p;
#ifdef CRND_DEVEL
	  OutputDebugStringA(p);
#endif
   }

} // namespace crnd

// File: crnd_mem.cpp
namespace crnd
{
   const uint32 MAX_POSSIBLE_BLOCK_SIZE = 0x7FFF0000U;

   static void* crnd_default_realloc(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data)
   {
	  pUser_data;

	  void* p_new;

	  if (!p)
	  {
		 p_new = ::malloc(size);

		 if (pActual_size)
		 {
#ifdef WIN32
			*pActual_size = p_new ? ::_msize(p_new) : 0;
#else
			*pActual_size = p_new ? malloc_usable_size(p_new) : 0;
#endif
		 }
	  }
	  else if (!size)
	  {
		 ::free(p);
		 p_new = NULL;

		 if (pActual_size)
			*pActual_size = 0;
	  }
	  else
	  {
		 void* p_final_block = p;
#ifdef WIN32
		 p_new = ::_expand(p, size);
#else
		 p_new = NULL;
#endif

		 if (p_new)
			p_final_block = p_new;
		 else if (movable)
		 {
			p_new = ::realloc(p, size);

			if (p_new)
			   p_final_block = p_new;
		 }

		 if (pActual_size)
		 {
#ifdef WIN32
			*pActual_size = ::_msize(p_final_block);
#else
			*pActual_size = ::malloc_usable_size(p_final_block);
#endif
		 }
	  }

	  return p_new;
   }

   static size_t crnd_default_msize(void* p, void* pUser_data)
   {
	  pUser_data;
#ifdef WIN32
	  return p ? _msize(p) : 0;
#else
	  return p ? malloc_usable_size(p) : 0;
#endif
   }

   static crnd_realloc_func        g_pRealloc = crnd_default_realloc;
   static crnd_msize_func          g_pMSize   = crnd_default_msize;
   static void*                   g_pUser_data;

   void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data)
   {
	  if ((!pRealloc) || (!pMSize))
	  {
		 g_pRealloc = crnd_default_realloc;
		 g_pMSize = crnd_default_msize;
		 g_pUser_data = NULL;
	  }
	  else
	  {
		 g_pRealloc = pRealloc;
		 g_pMSize = pMSize;
		 g_pUser_data = pUser_data;
	  }
   }

   static inline void crnd_mem_error(const char* p_msg)
   {
	  crnd_assert(p_msg, __FILE__, __LINE__);
   }

   void* crnd_malloc(size_t size, size_t* pActual_size)
   {
	  size = (size + sizeof(uint32) - 1U) & ~(sizeof(uint32) - 1U);
	  if (!size)
		 size = sizeof(uint32);

	  if (size > MAX_POSSIBLE_BLOCK_SIZE)
	  {
		 crnd_mem_error("crnd_malloc: size too big");
		 return NULL;
	  }

	  size_t actual_size = size;
	  uint8* p_new = static_cast<uint8*>((*g_pRealloc)(NULL, size, &actual_size, true, g_pUser_data));

	  if (pActual_size)
		 *pActual_size = actual_size;

	  if ((!p_new) || (actual_size < size))
	  {
		 crnd_mem_error("crnd_malloc: out of memory");
		 return NULL;
	  }

	  CRND_ASSERT((reinterpret_cast<uintptr_t>(p_new) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

	  return p_new;
   }

   void* crnd_realloc(void* p, size_t size, size_t* pActual_size, bool movable)
   {
	  if (reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
	  {
		 crnd_mem_error("crnd_realloc: bad ptr");
		 return NULL;
	  }

	  if (size > MAX_POSSIBLE_BLOCK_SIZE)
	  {
		 crnd_mem_error("crnd_malloc: size too big");
		 return NULL;
	  }

	  size_t actual_size = size;
	  void* p_new = (*g_pRealloc)(p, size, &actual_size, movable, g_pUser_data);

	  if (pActual_size)
		 *pActual_size = actual_size;

	  CRND_ASSERT((reinterpret_cast<uintptr_t>(p_new) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

	  return p_new;
   }

   void crnd_free(void* p)
   {
	  if (!p)
		 return;

	  if (reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
	  {
		 crnd_mem_error("crnd_free: bad ptr");
		 return;
	  }

	  (*g_pRealloc)(p, 0, NULL, true, g_pUser_data);
   }

   size_t crnd_msize(void* p)
   {
	  if (!p)
		 return 0;

	  if (reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
	  {
		 crnd_mem_error("crnd_msize: bad ptr");
		 return 0;
	  }

	  return (*g_pMSize)(p, g_pUser_data);
   }

} // namespace crnd

// File: crnd_math.cpp
namespace crnd
{
   namespace math
   {
	  uint32 g_bitmasks[32] =
	  {
		 1U <<  0U,         1U <<  1U,          1U <<  2U,        1U <<  3U,
		 1U <<  4U,         1U <<  5U,          1U <<  6U,        1U <<  7U,
		 1U <<  8U,         1U <<  9U,          1U << 10U,        1U << 11U,
		 1U << 12U,         1U << 13U,          1U << 14U,        1U << 15U,
		 1U << 16U,         1U << 17U,          1U << 18U,        1U << 19U,
		 1U << 20U,         1U << 21U,          1U << 22U,        1U << 23U,
		 1U << 24U,         1U << 25U,          1U << 26U,        1U << 27U,
		 1U << 28U,         1U << 29U,          1U << 30U,        1U << 31U
	  };

   } // namespace math
} // namespace crnd

// File: crnd_info.cpp
namespace crnd
{
#define CRND_FOURCC(a, b, c, d) ((a) | ((b) << 8U) | ((c) << 16U) | ((d) << 24U))

   uint32 crnd_crn_format_to_fourcc(crn_format fmt)
   {
	  switch (fmt)
	  {
		 case cCRNFmtDXT1:        return CRND_FOURCC('D', 'X', 'T', '1');
		 case cCRNFmtDXT3:        return CRND_FOURCC('D', 'X', 'T', '3');
		 case cCRNFmtDXT5:        return CRND_FOURCC('D', 'X', 'T', '5');
		 case cCRNFmtDXN_XY:      return CRND_FOURCC('A', '2', 'X', 'Y');
		 case cCRNFmtDXN_YX:      return CRND_FOURCC('A', 'T', 'I', '2');
		 case cCRNFmtDXT5A:       return CRND_FOURCC('A', 'T', 'I', '1');
		 case cCRNFmtDXT5_CCxY:   return CRND_FOURCC('C', 'C', 'x', 'Y');
		 case cCRNFmtDXT5_xGxR:   return CRND_FOURCC('x', 'G', 'x', 'R');
		 case cCRNFmtDXT5_xGBR:   return CRND_FOURCC('x', 'G', 'B', 'R');
		 case cCRNFmtDXT5_AGBR:   return CRND_FOURCC('A', 'G', 'B', 'R');
		 case cCRNFmtETC1:        return CRND_FOURCC('E', 'T', 'C', '1');
		 default: break;
	  }
	  CRND_ASSERT(false);
	  return 0;
   }

   crn_format crnd_get_fundamental_dxt_format(crn_format fmt)
   {
	  switch (fmt)
	  {
		 case cCRNFmtDXT5_CCxY:
		 case cCRNFmtDXT5_xGxR:
		 case cCRNFmtDXT5_xGBR:
		 case cCRNFmtDXT5_AGBR:
			return cCRNFmtDXT5;
		 default: break;
	  }
	  return fmt;
   }

   uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt)
   {
	  switch (fmt)
	  {
		 case cCRNFmtDXT1:
		 case cCRNFmtDXT5A:
		 case cCRNFmtETC1:
			return 4;
		 case cCRNFmtDXT3:
		 case cCRNFmtDXT5:
		 case cCRNFmtDXN_XY:
		 case cCRNFmtDXN_YX:
		 case cCRNFmtDXT5_CCxY:
		 case cCRNFmtDXT5_xGxR:
		 case cCRNFmtDXT5_xGBR:
		 case cCRNFmtDXT5_AGBR:
			return 8;
		 default: break;
	  }
	  CRND_ASSERT(false);
	  return 0;
   }

   uint32 crnd_get_bytes_per_dxt_block(crn_format fmt)
   {
	  return (crnd_get_crn_format_bits_per_texel(fmt) << 4) >> 3;
   }

   // TODO: tmp_header isn't used/This function is a helper to support old headers.
   const crn_header* crnd_get_header(crn_header& tmp_header, const void* pData, uint32 data_size)
   {
	  tmp_header;

	  if ((!pData) || (data_size < sizeof(crn_header)))
		 return NULL;

	  const crn_header& file_header = *static_cast<const crn_header*>(pData);
	  if (file_header.m_sig != crn_header::cCRNSigValue)
		 return NULL;

	  if ((file_header.m_header_size < sizeof(crn_header)) || (data_size < file_header.m_data_size))
		 return NULL;

	  return &file_header;
   }

   bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info)
   {
	  if (pFile_info)
	  {
		 if (pFile_info->m_struct_size != sizeof(crn_file_info))
			return false;

		 memset(&pFile_info->m_struct_size + 1, 0, sizeof(crn_file_info) - sizeof(pFile_info->m_struct_size));
	  }

	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  const uint32 header_crc = crc16(&pHeader->m_data_size, (uint32)(pHeader->m_header_size - ((const uint8*)&pHeader->m_data_size - (const uint8*)pHeader)));
	  if (header_crc != pHeader->m_header_crc16)
		 return false;

	  const uint32 data_crc = crc16((const uint8*)pData + pHeader->m_header_size, pHeader->m_data_size - pHeader->m_header_size);
	  if (data_crc != pHeader->m_data_crc16)
		 return false;

	  if ((pHeader->m_faces != 1) && (pHeader->m_faces != 6))
		 return false;
	  if ((pHeader->m_width < 1) || (pHeader->m_width > cCRNMaxLevelResolution))
		 return false;
	  if ((pHeader->m_height < 1) || (pHeader->m_height > cCRNMaxLevelResolution))
		 return false;
	  if ((pHeader->m_levels < 1) || (pHeader->m_levels > utils::compute_max_mips(pHeader->m_width, pHeader->m_height)))
		 return false;
	  if (((int)pHeader->m_format < cCRNFmtDXT1) || ((int)pHeader->m_format >= cCRNFmtTotal))
		 return false;

	  if (pFile_info)
	  {
		 pFile_info->m_actual_data_size = pHeader->m_data_size;
		 pFile_info->m_header_size = pHeader->m_header_size;
		 pFile_info->m_total_palette_size = pHeader->m_color_endpoints.m_size + pHeader->m_color_selectors.m_size + pHeader->m_alpha_endpoints.m_size + pHeader->m_alpha_selectors.m_size;
		 pFile_info->m_tables_size = pHeader->m_tables_size;

		 pFile_info->m_levels = pHeader->m_levels;

		 for (uint32 i = 0; i < pHeader->m_levels; i++)
		 {
			uint32 next_ofs = pHeader->m_data_size;

			// assumes the levels are packed together sequentially
			if ((i + 1) < pHeader->m_levels)
			   next_ofs = pHeader->m_level_ofs[i + 1];

			pFile_info->m_level_compressed_size[i] = next_ofs - pHeader->m_level_ofs[i];
		 }

		 pFile_info->m_color_endpoint_palette_entries = pHeader->m_color_endpoints.m_num;
		 pFile_info->m_color_selector_palette_entries = pHeader->m_color_selectors.m_num;;
		 pFile_info->m_alpha_endpoint_palette_entries = pHeader->m_alpha_endpoints.m_num;;
		 pFile_info->m_alpha_selector_palette_entries = pHeader->m_alpha_selectors.m_num;;
	  }

	  return true;
   }

   bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pInfo)
   {
	  if ((!pData) || (data_size < sizeof(crn_header)) || (!pInfo))
		 return false;

	  if (pInfo->m_struct_size != sizeof(crn_texture_info))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  pInfo->m_width = pHeader->m_width;
	  pInfo->m_height = pHeader->m_height;
	  pInfo->m_levels = pHeader->m_levels;
	  pInfo->m_faces = pHeader->m_faces;
	  pInfo->m_format = static_cast<crn_format>((uint32)pHeader->m_format);
	  pInfo->m_bytes_per_block = ((pHeader->m_format == cCRNFmtDXT1) || (pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;
	  pInfo->m_userdata0 = pHeader->m_userdata0;
	  pInfo->m_userdata1 = pHeader->m_userdata1;

	  return true;
   }

   bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize) || (!pLevel_info))
		 return false;

	  if (pLevel_info->m_struct_size != sizeof(crn_level_info))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  if (level_index >= pHeader->m_levels)
		 return false;

	  uint32 width = math::maximum<uint32>(1U, pHeader->m_width >> level_index);
	  uint32 height = math::maximum<uint32>(1U, pHeader->m_height >> level_index);

	  pLevel_info->m_width = width;
	  pLevel_info->m_height = height;
	  pLevel_info->m_faces = pHeader->m_faces;
	  pLevel_info->m_blocks_x = (width + 3) >> 2;
	  pLevel_info->m_blocks_y = (height + 3) >> 2;
	  pLevel_info->m_bytes_per_block = ((pHeader->m_format == cCRNFmtDXT1) || (pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;
	  pLevel_info->m_format = static_cast<crn_format>((uint32)pHeader->m_format);

	  return true;
   }

   const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize)
   {
	  if (pSize)
		 *pSize = 0;

	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return 0;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return 0;

	  if (level_index >= pHeader->m_levels)
		 return 0;

	  uint32 cur_level_ofs = pHeader->m_level_ofs[level_index];

	  if (pSize)
	  {
		 uint32 next_level_ofs = data_size;
		 if ((level_index + 1) < (pHeader->m_levels))
			next_level_ofs = pHeader->m_level_ofs[level_index + 1];

		 *pSize = next_level_ofs - cur_level_ofs;
	  }

	  return static_cast<const uint8*>(pData) + cur_level_ofs;
   }

   uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  uint32 size = pHeader->m_header_size;

	  size = math::maximum(size, pHeader->m_color_endpoints.m_ofs + pHeader->m_color_endpoints.m_size);
	  size = math::maximum(size, pHeader->m_color_selectors.m_ofs + pHeader->m_color_selectors.m_size);
	  size = math::maximum(size, pHeader->m_alpha_endpoints.m_ofs + pHeader->m_alpha_endpoints.m_size);
	  size = math::maximum(size, pHeader->m_alpha_selectors.m_ofs + pHeader->m_alpha_selectors.m_size);
	  size = math::maximum(size, pHeader->m_tables_ofs + pHeader->m_tables_size);

	  return size;
   }

   bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  if (pHeader->m_flags & cCRNHeaderFlagSegmented)
		 return false;

	  const uint actual_base_data_size = crnd_get_segmented_file_size(pData, data_size);
	  if (base_data_size < actual_base_data_size)
		 return false;

	  memcpy(pBase_data, pData, actual_base_data_size);

	  crn_header& new_header = *static_cast<crn_header*>(pBase_data);
	  new_header.m_flags = new_header.m_flags | cCRNHeaderFlagSegmented;
	  new_header.m_data_size = actual_base_data_size;

	  new_header.m_data_crc16 = crc16((const uint8*)pBase_data + new_header.m_header_size, new_header.m_data_size - new_header.m_header_size);

	  new_header.m_header_crc16 = crc16(&new_header.m_data_size, new_header.m_header_size - (uint32)((const uint8*)&new_header.m_data_size - (const uint8*)&new_header));

	  CRND_ASSERT(crnd_validate_file(&new_header, actual_base_data_size, NULL));

	  return true;
   }

} // namespace crnd

// File: symbol_codec.cpp
namespace crnd
{
   static_huffman_data_model::static_huffman_data_model() :
m_total_syms(0),
m_pDecode_tables(NULL)
{
}

static_huffman_data_model::static_huffman_data_model(const static_huffman_data_model& other) :
m_total_syms(0),
m_pDecode_tables(NULL)
{
   *this = other;
}

static_huffman_data_model::~static_huffman_data_model()
{
   if (m_pDecode_tables)
	  crnd_delete(m_pDecode_tables);
}

static_huffman_data_model& static_huffman_data_model::operator=(const static_huffman_data_model& rhs)
{
   if (this == &rhs)
	  return *this;

   m_total_syms = rhs.m_total_syms;
   m_code_sizes = rhs.m_code_sizes;
   if (m_code_sizes.get_alloc_failed())
   {
	  clear();
	  return *this;
   }

   if (rhs.m_pDecode_tables)
   {
	  if (m_pDecode_tables)
		 *m_pDecode_tables = *rhs.m_pDecode_tables;
	  else
		 m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>(*rhs.m_pDecode_tables);
   }
   else
   {
	  crnd_delete(m_pDecode_tables);
	  m_pDecode_tables = NULL;
   }

   return *this;
}

void static_huffman_data_model::clear()
{
   m_total_syms = 0;
   m_code_sizes.clear();
   if (m_pDecode_tables)
   {
	  crnd_delete(m_pDecode_tables);
	  m_pDecode_tables = NULL;
   }
}

bool static_huffman_data_model::init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit)
{
   CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms) && (code_size_limit >= 1));

   code_size_limit = math::minimum(code_size_limit, prefix_coding::cMaxExpectedCodeSize);

   if (!m_code_sizes.resize(total_syms))
	  return false;

   uint32 min_code_size = cUINT32_MAX;
   uint32 max_code_size = 0;

   for (uint32 i = 0; i < total_syms; i++)
   {
	  uint32 s = pCode_sizes[i];
	  m_code_sizes[i] = static_cast<uint8>(s);
	  min_code_size = math::minimum(min_code_size, s);
	  max_code_size = math::maximum(max_code_size, s);
   }

   if ((max_code_size < 1) || (max_code_size > 32) || (min_code_size > code_size_limit))
	  return false;

   if (max_code_size > code_size_limit)
	  return false;

   if (!m_pDecode_tables)
	  m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

   if (!m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits()))
	  return false;

   return true;
}

bool static_huffman_data_model::prepare_decoder_tables()
{
   uint32 total_syms = m_code_sizes.size();

   CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms));

   m_total_syms = total_syms;

   if (!m_pDecode_tables)
	  m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

   return m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits());
}

uint static_huffman_data_model::compute_decoder_table_bits() const
{
#if CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE
   return prefix_coding::cMaxTableBits;
#else
   uint32 decoder_table_bits = 0;
   if (m_total_syms > 16)
	  decoder_table_bits = static_cast<uint8>(math::minimum(1 + math::ceil_log2i(m_total_syms), prefix_coding::cMaxTableBits));
   return decoder_table_bits;
#endif
}

symbol_codec::symbol_codec() :
  m_pDecode_buf(NULL),
  m_pDecode_buf_next(NULL),
  m_pDecode_buf_end(NULL),
  m_decode_buf_size(0),
  m_bit_buf(0),
  m_bit_count(0)
{
}

// Code length encoding symbols:
// 0-16 - actual code lengths
const uint32 cMaxCodelengthCodes      = 21;

const uint32 cSmallZeroRunCode        = 17;
const uint32 cLargeZeroRunCode        = 18;
const uint32 cSmallRepeatCode         = 19;
const uint32 cLargeRepeatCode         = 20;

const uint32 cMinSmallZeroRunSize     = 3;
const uint32 cMaxSmallZeroRunSize     = 10;
const uint32 cMinLargeZeroRunSize     = 11;
const uint32 cMaxLargeZeroRunSize     = 138;

const uint32 cSmallMinNonZeroRunSize  = 3;
const uint32 cSmallMaxNonZeroRunSize  = 6;
const uint32 cLargeMinNonZeroRunSize  = 7;
const uint32 cLargeMaxNonZeroRunSize  = 70;

const uint32 cSmallZeroRunExtraBits   = 3;
const uint32 cLargeZeroRunExtraBits   = 7;
const uint32 cSmallNonZeroRunExtraBits = 2;
const uint32 cLargeNonZeroRunExtraBits = 6;

static const uint8 g_most_probable_codelength_codes[] =
{
   cSmallZeroRunCode, cLargeZeroRunCode,
   cSmallRepeatCode,  cLargeRepeatCode,

   0, 8,
   7, 9,
   6, 10,
   5, 11,
   4, 12,
   3, 13,
   2, 14,
   1, 15,
   16
};
const uint32 cNumMostProbableCodelengthCodes = sizeof(g_most_probable_codelength_codes) / sizeof(g_most_probable_codelength_codes[0]);

bool symbol_codec::decode_receive_static_data_model(static_huffman_data_model& model)
{
   const uint32 total_used_syms = decode_bits(math::total_bits(prefix_coding::cMaxSupportedSyms));

   if (!total_used_syms)
   {
	  model.clear();
	  return true;
   }

   if (!model.m_code_sizes.resize(total_used_syms))
	  return false;

   memset(&model.m_code_sizes[0], 0, sizeof(model.m_code_sizes[0]) * total_used_syms);

   const uint32 num_codelength_codes_to_send = decode_bits(5);
   if ((num_codelength_codes_to_send < 1) || (num_codelength_codes_to_send > cMaxCodelengthCodes))
	  return false;

   static_huffman_data_model dm;
   if (!dm.m_code_sizes.resize(cMaxCodelengthCodes))
	  return false;

   for (uint32 i = 0; i < num_codelength_codes_to_send; i++)
	  dm.m_code_sizes[g_most_probable_codelength_codes[i]] = static_cast<uint8>(decode_bits(3));

   if (!dm.prepare_decoder_tables())
	  return false;

   uint32 ofs = 0;
   while (ofs < total_used_syms)
   {
	  const uint32 num_remaining = total_used_syms - ofs;

	  uint32 code = decode(dm);
	  if (code <= 16)
		 model.m_code_sizes[ofs++] = static_cast<uint8>(code);
	  else if (code == cSmallZeroRunCode)
	  {
		 uint32 len = decode_bits(cSmallZeroRunExtraBits) + cMinSmallZeroRunSize;
		 if (len > num_remaining)
			return false;
		 ofs += len;
	  }
	  else if (code == cLargeZeroRunCode)
	  {
		 uint32 len = decode_bits(cLargeZeroRunExtraBits) + cMinLargeZeroRunSize;
		 if (len > num_remaining)
			return false;
		 ofs += len;
	  }
	  else if ((code == cSmallRepeatCode) || (code == cLargeRepeatCode))
	  {
		 uint32 len;
		 if (code == cSmallRepeatCode)
			len = decode_bits(cSmallNonZeroRunExtraBits) + cSmallMinNonZeroRunSize;
		 else
			len = decode_bits(cLargeNonZeroRunExtraBits) + cLargeMinNonZeroRunSize;

		 if ((!ofs) || (len > num_remaining))
			return false;
		 const uint32 prev = model.m_code_sizes[ofs - 1];
		 if (!prev)
			return false;
		 const uint32 end = ofs + len;
		 while (ofs < end)
			model.m_code_sizes[ofs++] = static_cast<uint8>(prev);
	  }
	  else
	  {
		 CRND_ASSERT(0);
		 return false;
	  }
   }

   if (ofs != total_used_syms)
	  return false;

   return model.prepare_decoder_tables();
}

bool symbol_codec::start_decoding(const uint8* pBuf, uint32 buf_size)
{
   if (!buf_size)
	  return false;

   m_pDecode_buf = pBuf;
   m_pDecode_buf_next = pBuf;
   m_decode_buf_size = buf_size;
   m_pDecode_buf_end = pBuf + buf_size;

   get_bits_init();

   return true;
}

void symbol_codec::get_bits_init()
{
   m_bit_buf = 0;
   m_bit_count = 0;
}

uint32 symbol_codec::decode_bits(uint32 num_bits)
{
   if (!num_bits)
	  return 0;

   if (num_bits > 16)
   {
	  uint32 a = get_bits(num_bits - 16);
	  uint32 b = get_bits(16);

	  return (a << 16) | b;
   }
   else
	  return get_bits(num_bits);
}

uint32 symbol_codec::get_bits(uint32 num_bits)
{
   CRND_ASSERT(num_bits <= 32U);

   while (m_bit_count < (int)num_bits)
   {
	  bit_buf_type c = 0;
	  if (m_pDecode_buf_next != m_pDecode_buf_end)
		 c = *m_pDecode_buf_next++;

	  m_bit_count += 8;
	  CRND_ASSERT(m_bit_count <= cBitBufSize);

	  m_bit_buf |= (c << (cBitBufSize - m_bit_count));
   }

   uint32 result = static_cast<uint32>(m_bit_buf >> (cBitBufSize - num_bits));

   m_bit_buf <<= num_bits;
   m_bit_count -= num_bits;

   return result;
}

uint32 symbol_codec::decode(const static_huffman_data_model& model)
{
   const prefix_coding::decoder_tables* pTables = model.m_pDecode_tables;

   if (m_bit_count < 24)
   {
	  if (m_bit_count < 16)
	  {
		 uint32 c0 = 0, c1 = 0;
		 const uint8* p = m_pDecode_buf_next;
		 if (p < m_pDecode_buf_end) c0 = *p++;
		 if (p < m_pDecode_buf_end) c1 = *p++;
		 m_pDecode_buf_next = p;
		 m_bit_count += 16;
		 uint32 c = (c0 << 8) | c1;
		 m_bit_buf |= (c << (32 - m_bit_count));
	  }
	  else
	  {
		 uint32 c = (m_pDecode_buf_next < m_pDecode_buf_end) ? *m_pDecode_buf_next++ : 0;
		 m_bit_count += 8;
		 m_bit_buf |= (c << (32 - m_bit_count));
	  }
   }

   uint32 k = (m_bit_buf >> 16) + 1;
   uint32 sym, len;

   if (k <= pTables->m_table_max_code)
   {
	  uint32 t = pTables->m_lookup[m_bit_buf >> (32 - pTables->m_table_bits)];

	  CRND_ASSERT(t != cUINT32_MAX);
	  sym = t & cUINT16_MAX;
	  len = t >> 16;

	  CRND_ASSERT(model.m_code_sizes[sym] == len);
   }
   else
   {
	  len = pTables->m_decode_start_code_size;

	  for ( ; ; )
	  {
		 if (k <= pTables->m_max_codes[len - 1])
			break;
		 len++;
	  }

	  int val_ptr = pTables->m_val_ptrs[len - 1] + (m_bit_buf >> (32 - len));

	  if (((uint32)val_ptr >= model.m_total_syms))
	  {
		 // corrupted stream, or a bug
		 CRND_ASSERT(0);
		 return 0;
	  }

	  sym = pTables->m_sorted_symbol_order[val_ptr];
   }

   m_bit_buf <<= len;
   m_bit_count -= len;

   return sym;
}

   uint64 symbol_codec::stop_decoding()
   {
#if 0
	  uint32 i = get_bits(4);
	  uint32 k = get_bits(3);
	  i, k;
	  CRND_ASSERT((i == 15) && (k == 3));
#endif

	  uint64 n = static_cast<uint64>(m_pDecode_buf_next - m_pDecode_buf);

	  return n;
   }

} // namespace crnd

// File: crnd_dxt_hc_common.cpp
namespace crnd
{
   chunk_encoding_desc g_chunk_encodings[cNumChunkEncodings] =
   {
	  { 1, { { 0, 0, 8, 8, 0 } } },

	  { 2, { { 0, 0, 8, 4, 1 }, { 0, 4, 8, 4, 2 } } },
	  { 2, { { 0, 0, 4, 8, 3 }, { 4, 0, 4, 8, 4 } } },

	  { 3, { { 0, 0, 8, 4, 1 }, { 0, 4, 4, 4, 7 }, { 4, 4, 4, 4, 8 } } },
	  { 3, { { 0, 4, 8, 4, 2 }, { 0, 0, 4, 4, 5 }, { 4, 0, 4, 4, 6 } } },

	  { 3, { { 0, 0, 4, 8, 3 }, { 4, 0, 4, 4, 6 }, { 4, 4, 4, 4, 8 } } },
	  { 3, { { 4, 0, 4, 8, 4 }, { 0, 0, 4, 4, 5 }, { 0, 4, 4, 4, 7 } } },

	  { 4, { { 0, 0, 4, 4, 5 }, { 4, 0, 4, 4, 6 }, { 0, 4, 4, 4, 7 }, { 4, 4, 4, 4, 8 } } }
   };

   chunk_tile_desc g_chunk_tile_layouts[cNumChunkTileLayouts] =
   {
	  // 2x2
	  { 0, 0, 8, 8, 0 },

	  // 2x1
	  { 0, 0, 8, 4, 1 },
	  { 0, 4, 8, 4, 2 },

	  // 1x2
	  { 0, 0, 4, 8, 3 },
	  { 4, 0, 4, 8, 4 },

	  // 1x1
	  { 0, 0, 4, 4, 5 },
	  { 4, 0, 4, 4, 6 },
	  { 0, 4, 4, 4, 7 },
	  { 4, 4, 4, 4, 8 }
   };

} // namespace crnd

// File: crnd_dxt.cpp
namespace crnd
{
   const uint8 g_dxt1_to_linear[cDXT1SelectorValues]     = { 0U, 3U, 1U, 2U };
   const uint8 g_dxt1_from_linear[cDXT1SelectorValues]   = { 0U, 2U, 3U, 1U };

   const uint8 g_dxt5_to_linear[cDXT5SelectorValues]     = { 0U, 7U, 1U, 2U, 3U, 4U, 5U, 6U };
   const uint8 g_dxt5_from_linear[cDXT5SelectorValues]   = { 0U, 2U, 3U, 4U, 5U, 6U, 7U, 1U };

   const uint8 g_six_alpha_invert_table[cDXT5SelectorValues] = { 1, 0, 5, 4, 3, 2, 6, 7 };
   const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues] = { 1, 0, 7, 6, 5, 4, 3, 2 };

   uint16 dxt1_block::pack_color(const color_quad_u8& color, bool scaled, uint32 bias)
   {
	  uint32 r = color.r;
	  uint32 g = color.g;
	  uint32 b = color.b;

	  if (scaled)
	  {
		 r = (r * 31U + bias) / 255U;
		 g = (g * 63U + bias) / 255U;
		 b = (b * 31U + bias) / 255U;
	  }

	  r = math::minimum(r, 31U);
	  g = math::minimum(g, 63U);
	  b = math::minimum(b, 31U);

	  return static_cast<uint16>(b | (g << 5U) | (r << 11U));
   }

   uint16 dxt1_block::pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias)
   {
	  return pack_color(color_quad_u8(r, g, b, 0), scaled, bias);
   }

   color_quad_u8 dxt1_block::unpack_color(uint16 packed_color, bool scaled, uint32 alpha)
   {
	  uint32 b = packed_color & 31U;
	  uint32 g = (packed_color >> 5U) & 63U;
	  uint32 r = (packed_color >> 11U) & 31U;

	  if (scaled)
	  {
		 b = (b << 3U) | (b >> 2U);
		 g = (g << 2U) | (g >> 4U);
		 r = (r << 3U) | (r >> 2U);
	  }

	  return color_quad_u8(r, g, b, alpha);
   }

   void dxt1_block::unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled)
   {
	  color_quad_u8 c(unpack_color(packed_color, scaled, 0));
	  r = c.r;
	  g = c.g;
	  b = c.b;
   }

   uint32 dxt1_block::get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
	  color_quad_u8 c0(unpack_color(color0, true));
	  color_quad_u8 c1(unpack_color(color1, true));

	  pDst[0] = c0;
	  pDst[1] = c1;
	  pDst[2].set( (c0.r + c1.r) >> 1U, (c0.g + c1.g) >> 1U, (c0.b + c1.b) >> 1U, 255U);
	  pDst[3].set(0, 0, 0, 0);

	  return 3;
   }

   uint32 dxt1_block::get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
	  color_quad_u8 c0(unpack_color(color0, true));
	  color_quad_u8 c1(unpack_color(color1, true));

	  pDst[0] = c0;
	  pDst[1] = c1;

	  // 12/14/09 - Supposed to round according to DX docs, but this conflicts with the OpenGL S3TC spec. ?
	  // Turns out some GPU's round and some don't. Great.
	  //pDst[2].set( (c0.r * 2 + c1.r + 1) / 3, (c0.g * 2 + c1.g + 1) / 3, (c0.b * 2 + c1.b + 1) / 3, 255U);
	  //pDst[3].set( (c1.r * 2 + c0.r + 1) / 3, (c1.g * 2 + c0.g + 1) / 3, (c1.b * 2 + c0.b + 1) / 3, 255U);

	  pDst[2].set( (c0.r * 2 + c1.r) / 3, (c0.g * 2 + c1.g) / 3, (c0.b * 2 + c1.b) / 3, 255U);
	  pDst[3].set( (c1.r * 2 + c0.r) / 3, (c1.g * 2 + c0.g) / 3, (c1.b * 2 + c0.b) / 3, 255U);

	  return 4;
   }

   uint32 dxt1_block::get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
	  if (color0 > color1)
		 return get_block_colors4(pDst, color0, color1);
	  else
		 return get_block_colors3(pDst, color0, color1);
   }

   color_quad_u8 dxt1_block::unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha)
   {
	  CRND_ASSERT(index < 2);
	  return unpack_color( static_cast<uint16>((endpoints >> (index * 16U)) & 0xFFFFU), scaled, alpha );
   }

   uint32 dxt1_block::pack_endpoints(uint32 lo, uint32 hi)
   {
	  CRND_ASSERT((lo <= 0xFFFFU) && (hi <= 0xFFFFU));
	  return lo | (hi << 16U);
   }

   void dxt3_block::set_alpha(uint32 x, uint32 y, uint32 value, bool scaled)
   {
	  CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

	  if (scaled)
	  {
		 CRND_ASSERT(value <= 0xFF);
		 value = (value * 15U + 128U) / 255U;
	  }
	  else
	  {
		 CRND_ASSERT(value <= 0xF);
	  }

	  uint32 ofs = (y << 1U) + (x >> 1U);
	  uint32 c = m_alpha[ofs];

	  c &= ~(0xF << ((x & 1U) << 2U));
	  c |= (value << ((x & 1U) << 2U));

	  m_alpha[ofs] = static_cast<uint8>(c);
   }

   uint32 dxt3_block::get_alpha(uint32 x, uint32 y, bool scaled) const
   {
	  CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

	  uint32 value = m_alpha[(y << 1U) + (x >> 1U)];
	  if (x & 1)
		 value >>= 4;
	  value &= 0xF;

	  if (scaled)
		 value = (value << 4U) | value;

	  return value;
   }

   uint32 dxt5_block::get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h)
   {
	  pDst[0].a = static_cast<uint8>(l);
	  pDst[1].a = static_cast<uint8>(h);
	  pDst[2].a = static_cast<uint8>((l * 4 + h    ) / 5);
	  pDst[3].a = static_cast<uint8>((l * 3 + h * 2) / 5);
	  pDst[4].a = static_cast<uint8>((l * 2 + h * 3) / 5);
	  pDst[5].a = static_cast<uint8>((l     + h * 4) / 5);
	  pDst[6].a = 0;
	  pDst[7].a = 255;
	  return 6;
   }

   uint32 dxt5_block::get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h)
   {
	  pDst[0].a = static_cast<uint8>(l);
	  pDst[1].a = static_cast<uint8>(h);
	  pDst[2].a = static_cast<uint8>((l * 6 + h    ) / 7);
	  pDst[3].a = static_cast<uint8>((l * 5 + h * 2) / 7);
	  pDst[4].a = static_cast<uint8>((l * 4 + h * 3) / 7);
	  pDst[5].a = static_cast<uint8>((l * 3 + h * 4) / 7);
	  pDst[6].a = static_cast<uint8>((l * 2 + h * 5) / 7);
	  pDst[7].a = static_cast<uint8>((l     + h * 6) / 7);
	  return 8;
   }

   uint32 dxt5_block::get_block_values(color_quad_u8* pDst, uint32 l, uint32 h)
   {
	  if (l > h)
		 return get_block_values8(pDst, l, h);
	  else
		 return get_block_values6(pDst, l, h);
   }

   uint32 dxt5_block::get_block_values6(uint32* pDst, uint32 l, uint32 h)
   {
	  pDst[0] = l;
	  pDst[1] = h;
	  pDst[2] = (l * 4 + h    ) / 5;
	  pDst[3] = (l * 3 + h * 2) / 5;
	  pDst[4] = (l * 2 + h * 3) / 5;
	  pDst[5] = (l     + h * 4) / 5;
	  pDst[6] = 0;
	  pDst[7] = 255;
	  return 6;
   }

   uint32 dxt5_block::get_block_values8(uint32* pDst, uint32 l, uint32 h)
   {
	  pDst[0] = l;
	  pDst[1] = h;
	  pDst[2] = (l * 6 + h    ) / 7;
	  pDst[3] = (l * 5 + h * 2) / 7;
	  pDst[4] = (l * 4 + h * 3) / 7;
	  pDst[5] = (l * 3 + h * 4) / 7;
	  pDst[6] = (l * 2 + h * 5) / 7;
	  pDst[7] = (l     + h * 6) / 7;
	  return 8;
   }

   uint32 dxt5_block::unpack_endpoint(uint32 packed, uint32 index)
   {
	  CRND_ASSERT(index < 2);
	  return (packed >> (8 * index)) & 0xFF;
   }

   uint32 dxt5_block::pack_endpoints(uint32 lo, uint32 hi)
   {
	  CRND_ASSERT((lo <= 0xFF) && (hi <= 0xFF));
	  return lo | (hi << 8U);
   }

   uint32 dxt5_block::get_block_values(uint32* pDst, uint32 l, uint32 h)
   {
	  if (l > h)
		 return get_block_values8(pDst, l, h);
	  else
		 return get_block_values6(pDst, l, h);
   }

} // namespace crnd

// File: crnd_decode.cpp
#define CRND_CREATE_BYTE_STREAMS 0

namespace crnd
{
#if CRND_CREATE_BYTE_STREAMS
   static void write_array_to_file(const char* pFilename, const vector<uint8>& buf)
   {
	  FILE* pFile = fopen(pFilename, "wb");
	  fwrite(&buf[0], buf.size(), 1, pFile);
	  fclose(pFile);
   }
#endif

   struct crnd_chunk_tile_desc
   {
	  // These values are in blocks
	  uint8 m_x_ofs;
	  uint8 m_y_ofs;
	  uint8 m_width;
	  uint8 m_height;
   };

   struct crnd_chunk_encoding_desc
   {
	  uint32 m_num_tiles;
	  chunk_tile_desc m_tiles[4];
   };

#if 0
   static crnd_chunk_encoding_desc g_crnd_chunk_encodings[cNumChunkEncodings] =
   {
	  { 1, { { 0, 0, 2, 2 } } },

	  { 2, { { 0, 0, 2, 1 }, { 0, 1, 2, 1 } } },
	  { 2, { { 0, 0, 1, 2 }, { 1, 0, 1, 2 } } },

	  { 3, { { 0, 0, 2, 1 }, { 0, 1, 1, 1 }, { 1, 1, 1, 1 } } },
	  { 3, { { 0, 1, 2, 1 }, { 0, 0, 1, 1 }, { 1, 0, 1, 1 } } },

	  { 3, { { 0, 0, 1, 2 }, { 1, 0, 1, 1 }, { 1, 1, 1, 1 } } },
	  { 3, { { 1, 0, 1, 2 }, { 0, 0, 1, 1 }, { 0, 1, 1, 1 } } },

	  { 1, { { 0, 0, 1, 1 }, { 1, 0, 1, 1 }, { 0, 1, 1, 1 }, { 1, 1, 1, 1 } } }
   };
#endif

   struct crnd_encoding_tile_indices
   {
	  uint8 m_tiles[4];
   };

   static crnd_encoding_tile_indices g_crnd_chunk_encoding_tiles[cNumChunkEncodings] =
   {
	  { { 0, 0, 0, 0 } },

	  { { 0, 0, 1, 1 } },
	  { { 0, 1, 0, 1 } },

	  { { 0, 0, 1, 2 } },
	  { { 1, 2, 0, 0 } },

	  { { 0, 1, 0, 2 } },
	  { { 1, 0, 2, 0 } },

	  { { 0, 1, 2, 3 } }
   };

   static uint8 g_crnd_chunk_encoding_num_tiles[cNumChunkEncodings] = { 1, 2, 2, 3, 3, 3, 3, 4 };

   class crn_unpacker
   {
   public:
	  inline crn_unpacker() :
		 m_magic(cMagicValue),
		 m_pData(NULL),
		 m_data_size(0),
		 m_pHeader(NULL)
	  {
	  }

	  inline ~crn_unpacker()
	  {
		 m_magic = 0;
	  }

	  inline bool is_valid() const { return m_magic == cMagicValue; }

	  bool init(const void* pData, uint32 data_size)
	  {
		 m_pHeader = crnd_get_header(m_tmp_header, pData, data_size);
		 if (!m_pHeader)
			return false;

		 m_pData = static_cast<const uint8*>(pData);
		 m_data_size = data_size;

		 if (!init_tables())
			return false;

		 if (!decode_palettes())
			return false;

		 return true;
	  }

	  bool unpack_level(
		 void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
		 uint32 level_index)
	  {
		 uint32 cur_level_ofs = m_pHeader->m_level_ofs[level_index];

		 uint32 next_level_ofs = m_data_size;
		 if ((level_index + 1) < (m_pHeader->m_levels))
			next_level_ofs = m_pHeader->m_level_ofs[level_index + 1];

		 CRND_ASSERT(next_level_ofs > cur_level_ofs);

		 return unpack_level(m_pData + cur_level_ofs, next_level_ofs - cur_level_ofs, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
	  }

	  bool unpack_level(
		 const void* pSrc, uint32 src_size_in_bytes,
		 void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
		 uint32 level_index)
	  {
		 dst_size_in_bytes;

#ifdef CRND_BUILD_DEBUG
		 for (uint32 f = 0; f < m_pHeader->m_faces; f++)
			if (!pDst[f])
			   return false;
#endif

		 const uint32 width = math::maximum(m_pHeader->m_width >> level_index, 1U);
		 const uint32 height = math::maximum(m_pHeader->m_height >> level_index, 1U);
		 const uint32 blocks_x = (width + 3U) >> 2U;
		 const uint32 blocks_y = (height + 3U) >> 2U;
		 const uint32 block_size = ((m_pHeader->m_format == cCRNFmtDXT1) || (m_pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;

		 uint32 minimal_row_pitch = block_size * blocks_x;
		 if (!row_pitch_in_bytes)
			row_pitch_in_bytes = minimal_row_pitch;
		 else if ((row_pitch_in_bytes < minimal_row_pitch) || (row_pitch_in_bytes & 3))
			return false;
		 if (dst_size_in_bytes < row_pitch_in_bytes * blocks_y)
			return false;

		 const uint32 chunks_x = (blocks_x + 1) >> 1;
		 const uint32 chunks_y = (blocks_y + 1) >> 1;

#if CRND_CREATE_BYTE_STREAMS
		 crnd_trace("Index stream: %u bytes\n", src_size_in_bytes);
#endif

		 if (!m_codec.start_decoding(static_cast<const crnd::uint8*>(pSrc), src_size_in_bytes))
			return false;

		 bool status = false;
		 switch (m_pHeader->m_format)
		 {
		 case cCRNFmtDXT1:
			status = unpack_dxt1((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 case cCRNFmtDXT5:
		 case cCRNFmtDXT5_CCxY:
		 case cCRNFmtDXT5_xGBR:
		 case cCRNFmtDXT5_AGBR:
		 case cCRNFmtDXT5_xGxR:
			status = unpack_dxt5((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 case cCRNFmtDXT5A:
			status = unpack_dxt5a((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 case cCRNFmtDXN_XY:
		 case cCRNFmtDXN_YX:
			status = unpack_dxn((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 default:
			return false;
		 }
		 if (!status)
			return false;

		 m_codec.stop_decoding();
		 return true;
	  }

	  inline const void* get_data() const { return m_pData; }
	  inline uint32 get_data_size() const { return m_data_size; }

   private:
	  enum { cMagicValue = 0x1EF9CABD };
	  uint32             m_magic;

	  const uint8*       m_pData;
	  uint32             m_data_size;
	  crn_header         m_tmp_header;
	  const crn_header*  m_pHeader;

	  symbol_codec       m_codec;

	  static_huffman_data_model m_chunk_encoding_dm;
	  static_huffman_data_model m_endpoint_delta_dm[2];
	  static_huffman_data_model m_selector_delta_dm[2];

	  crnd::vector<uint32> m_color_endpoints;
	  crnd::vector<uint32> m_color_selectors;

	  crnd::vector<uint16> m_alpha_endpoints;
	  crnd::vector<uint16> m_alpha_selectors;

	  bool init_tables()
	  {
		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_tables_ofs, m_pHeader->m_tables_size))
			return false;

		 if (!m_codec.decode_receive_static_data_model(m_chunk_encoding_dm))
			return false;

		 if ((!m_pHeader->m_color_endpoints.m_num) && (!m_pHeader->m_alpha_endpoints.m_num))
			return false;

		 if (m_pHeader->m_color_endpoints.m_num)
		 {
			if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[0])) return false;
			if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[0])) return false;
		 }

		 if (m_pHeader->m_alpha_endpoints.m_num)
		 {
			if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[1])) return false;
			if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[1])) return false;
		 }

		 m_codec.stop_decoding();

		 return true;
	  }

	  bool decode_palettes()
	  {
		 if (m_pHeader->m_color_endpoints.m_num)
		 {
			if (!decode_color_endpoints()) return false;
			if (!decode_color_selectors()) return false;
		 }

		 if (m_pHeader->m_alpha_endpoints.m_num)
		 {
			if (!decode_alpha_endpoints()) return false;
			if (!decode_alpha_selectors()) return false;
		 }

		 return true;
	  }

	  bool decode_color_endpoints()
	  {
		 const uint32 num_color_endpoints = m_pHeader->m_color_endpoints.m_num;

		 if (!m_color_endpoints.resize(num_color_endpoints))
			return false;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_color_endpoints.m_ofs, m_pHeader->m_color_endpoints.m_size))
			return false;

		 static_huffman_data_model dm[2];
		 for (uint32 i = 0; i < 2; i++)
			if (!m_codec.decode_receive_static_data_model(dm[i]))
			   return false;

		 uint32 a = 0, b = 0, c = 0;
		 uint32 d = 0, e = 0, f = 0;

		 uint32* CRND_RESTRICT pDst = &m_color_endpoints[0];

		 CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 vector<uint8> byte_stream;
#endif

		 for (uint32 i = 0; i < num_color_endpoints; i++)
		 {
			uint32 da, db, dc, dd, de, df;
			CRND_HUFF_DECODE(m_codec, dm[0], da); a = (a + da) & 31;
			CRND_HUFF_DECODE(m_codec, dm[1], db); b = (b + db) & 63;
			CRND_HUFF_DECODE(m_codec, dm[0], dc); c = (c + dc) & 31;

			CRND_HUFF_DECODE(m_codec, dm[0], dd); d = (d + dd) & 31;
			CRND_HUFF_DECODE(m_codec, dm[1], de); e = (e + de) & 63;
			CRND_HUFF_DECODE(m_codec, dm[0], df); f = (f + df) & 31;

#if CRND_CREATE_BYTE_STREAMS
			byte_stream.push_back(da);
			byte_stream.push_back(db);
			byte_stream.push_back(dc);
			byte_stream.push_back(dd);
			byte_stream.push_back(de);
			byte_stream.push_back(df);
#endif

			if (c_crnd_little_endian_platform)
			   *pDst++ = c | (b << 5U) | (a << 11U) | (f << 16U) | (e << 21U) | (d << 27U);
			else
			   *pDst++ = f | (e << 5U) | (d << 11U) | (c << 16U) | (b << 21U) | (a << 27U);
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

#if CRND_CREATE_BYTE_STREAMS
		 write_array_to_file(L"colorendpoints.bin", byte_stream);
		 crnd_trace("color endpoints: %u\n", (uint)m_pHeader->m_color_endpoints.m_size);
#endif

		 return true;
	  }

	  bool decode_color_selectors()
	  {
		 const uint32 cMaxSelectorValue = 3U;
		 const uint32 cMaxUniqueSelectorDeltas = cMaxSelectorValue * 2U + 1U;

		 const uint32 num_color_selectors = m_pHeader->m_color_selectors.m_num;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_color_selectors.m_ofs, m_pHeader->m_color_selectors.m_size))
			return false;

		 static_huffman_data_model dm;
		 if (!m_codec.decode_receive_static_data_model(dm))
			return false;

		 int32 delta0[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 delta1[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 l = -(int32)cMaxSelectorValue, m = -(int32)cMaxSelectorValue;
		 for (uint32 i = 0; i < (cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas); i++)
		 {
			delta0[i] = l;
			delta1[i] = m;

			if (++l > (int32)cMaxSelectorValue)
			{
			   l = -(int32)cMaxSelectorValue;
			   m++;
			}
		 }

		 uint32 cur[16];
		 utils::zero_object(cur);

		 if (!m_color_selectors.resize(num_color_selectors))
			return false;

		 uint32* CRND_RESTRICT pDst = &m_color_selectors[0];

		 const uint8* pFrom_linear = g_dxt1_from_linear;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 vector<uint8> byte_stream;
#endif

		 for (uint32 i = 0; i < num_color_selectors; i++)
		 {
			for (uint32 j = 0; j < 8; j++)
			{
			   int32 sym;
			   CRND_HUFF_DECODE(m_codec, dm, sym);

#if CRND_CREATE_BYTE_STREAMS
			   byte_stream.push_back(sym);
#endif

			   cur[j*2+0] = (delta0[sym] + cur[j*2+0]) & 3;
			   cur[j*2+1] = (delta1[sym] + cur[j*2+1]) & 3;
			}

			if (c_crnd_little_endian_platform)
			{
			   *pDst++ =
				  (pFrom_linear[cur[0 ]]      ) | (pFrom_linear[cur[1 ]] <<  2) | (pFrom_linear[cur[2 ]] <<  4) | (pFrom_linear[cur[3 ]] <<  6) |
				  (pFrom_linear[cur[4 ]] <<  8) | (pFrom_linear[cur[5 ]] << 10) | (pFrom_linear[cur[6 ]] << 12) | (pFrom_linear[cur[7 ]] << 14) |
				  (pFrom_linear[cur[8 ]] << 16) | (pFrom_linear[cur[9 ]] << 18) | (pFrom_linear[cur[10]] << 20) | (pFrom_linear[cur[11]] << 22) |
				  (pFrom_linear[cur[12]] << 24) | (pFrom_linear[cur[13]] << 26) | (pFrom_linear[cur[14]] << 28) | (pFrom_linear[cur[15]] << 30);
			}
			else
			{
			   *pDst++ =
				  (pFrom_linear[cur[8 ]]      ) | (pFrom_linear[cur[9 ]] <<  2) | (pFrom_linear[cur[10]] <<  4) | (pFrom_linear[cur[11]] <<  6) |
				  (pFrom_linear[cur[12]] <<  8) | (pFrom_linear[cur[13]] << 10) | (pFrom_linear[cur[14]] << 12) | (pFrom_linear[cur[15]] << 14) |
				  (pFrom_linear[cur[0 ]] << 16) | (pFrom_linear[cur[1 ]] << 18) | (pFrom_linear[cur[2 ]] << 20) | (pFrom_linear[cur[3 ]] << 22) |
				  (pFrom_linear[cur[4 ]] << 24) | (pFrom_linear[cur[5 ]] << 26) | (pFrom_linear[cur[6 ]] << 28) | (pFrom_linear[cur[7 ]] << 30);
			}
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

#if CRND_CREATE_BYTE_STREAMS
		 write_array_to_file(L"colorselectors.bin", byte_stream);
		 crnd_trace("color selectors: %u\n", (uint)m_pHeader->m_color_selectors.m_size);
#endif

		 return true;
	  }

	  bool decode_alpha_endpoints()
	  {
		 const uint32 num_alpha_endpoints = m_pHeader->m_alpha_endpoints.m_num;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_alpha_endpoints.m_ofs, m_pHeader->m_alpha_endpoints.m_size))
			return false;

		 static_huffman_data_model dm;
		 if (!m_codec.decode_receive_static_data_model(dm))
			return false;

		 if (!m_alpha_endpoints.resize(num_alpha_endpoints))
			return false;

		 uint16* CRND_RESTRICT pDst = &m_alpha_endpoints[0];
		 uint32 a = 0, b = 0;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 i = 0; i < num_alpha_endpoints; i++)
		 {
			uint sa; CRND_HUFF_DECODE(m_codec, dm, sa);
			uint sb; CRND_HUFF_DECODE(m_codec, dm, sb);

			a = (sa + a) & 255;
			b = (sb + b) & 255;

			*pDst++ = (uint16)(a | (b << 8));
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

		 return true;
	  }

	  bool decode_alpha_selectors()
	  {
		 const uint32 cMaxSelectorValue = 7U;
		 const uint32 cMaxUniqueSelectorDeltas = cMaxSelectorValue * 2U + 1U;

		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_alpha_selectors.m_ofs, m_pHeader->m_alpha_selectors.m_size))
			return false;

		 static_huffman_data_model dm;
		 if (!m_codec.decode_receive_static_data_model(dm))
			return false;

		 int32 delta0[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 delta1[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 l = -(int32)cMaxSelectorValue, m = -(int32)cMaxSelectorValue;
		 for (uint32 i = 0; i < (cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas); i++)
		 {
			delta0[i] = l;
			delta1[i] = m;

			if (++l > (int32)cMaxSelectorValue)
			{
			   l = -(int32)cMaxSelectorValue;
			   m++;
			}
		 }

		 uint32 cur[16];
		 utils::zero_object(cur);

		 if (!m_alpha_selectors.resize(num_alpha_selectors * 3))
			return false;

		 uint16* CRND_RESTRICT pDst = &m_alpha_selectors[0];

		 const uint8* pFrom_linear = g_dxt5_from_linear;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 i = 0; i < num_alpha_selectors; i++)
		 {
			for (uint32 j = 0; j < 8; j++)
			{
			   int32 sym;
			   CRND_HUFF_DECODE(m_codec, dm, sym);

			   cur[j*2+0] = (delta0[sym] + cur[j*2+0]) & 7;
			   cur[j*2+1] = (delta1[sym] + cur[j*2+1]) & 7;
			   //cur[j*2+0] = ((sym%15)-7 + cur[j*2+0]) & 7;
			   //cur[j*2+1] = ((sym/15)-7 + cur[j*2+1]) & 7;
			}

#if 0
			dxt5_block blk;
			for (uint32 y = 0; y < 4; y++)
			   for (uint32 x = 0; x < 4; x++)
				  blk.set_selector(x, y, pFrom_linear[cur[x+y*4]]);

			*pDst++ = blk.get_selectors_as_word(0);
			*pDst++ = blk.get_selectors_as_word(1);
			*pDst++ = blk.get_selectors_as_word(2);
#else
			*pDst++ = (uint16)((pFrom_linear[cur[0 ]]      ) | (pFrom_linear[cur[1 ]] <<  3) | (pFrom_linear[cur[2 ]] <<  6) | (pFrom_linear[cur[3 ]] <<  9) |
			   (pFrom_linear[cur[4 ]] << 12) | (pFrom_linear[cur[5 ]] << 15));

			*pDst++ = (uint16)((pFrom_linear[cur[5 ]] >> 1) | (pFrom_linear[cur[6 ]] << 2) | (pFrom_linear[cur[7 ]] << 5) |
			   (pFrom_linear[cur[8 ]] << 8) | (pFrom_linear[cur[9 ]] << 11) | (pFrom_linear[cur[10]] << 14));

			*pDst++ = (uint16)((pFrom_linear[cur[10]] >> 2) | (pFrom_linear[cur[11]] << 1) | (pFrom_linear[cur[12]] << 4) |
			   (pFrom_linear[cur[13]] << 7) | (pFrom_linear[cur[14]] << 10) | (pFrom_linear[cur[15]] << 13));
#endif
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

		 return true;
	  }

	  static inline uint32 tiled_offset_2d_outer(uint32 y, uint32 AlignedWidth, uint32 LogBpp)
	  {
		 uint32 Macro        = ((y >> 5) * (AlignedWidth >> 5)) << (LogBpp + 7);
		 uint32 Micro        = ((y & 6) << 2) << LogBpp;

		 return Macro +
			((Micro & ~15) << 1) +
			(Micro & 15) +
			((y & 8) << (3 + LogBpp)) + ((y & 1) << 4);
	  }

	  static inline uint32 tiled_offset_2d_inner(uint32 x, uint32 y, uint32 LogBpp, uint32 BaseOffset)
	  {
		 uint32 Macro = (x >> 5) << (LogBpp + 7);
		 uint32 Micro = (x & 7) << LogBpp;
		 uint32 Offset  = BaseOffset + Macro + ((Micro & ~15) << 1) + (Micro & 15);

		 return ((Offset & ~511) << 3) + ((Offset & 448) << 2) + (Offset & 63) +
			((y & 16) << 7) +
			(((((y & 8) >> 2) + (x >> 3)) & 3) << 6);
	  }

	  static inline void limit(uint& x, uint n)
	  {
		 int v = x - n;
		 int msk = (v >> 31);
		 x = (x & msk) | (v & ~msk);
	  }

	  bool unpack_dxt1(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_color_endpoints = m_color_endpoints.size();
		 const uint32 num_color_selectors = m_color_selectors.size();

		 uint32 prev_color_endpoint_index = 0;
		 uint32 prev_color_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

		 const int32 cBytesPerBlock = 8;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 vector<uint8> tile_encoding_stream;
		 vector<uint8> endpoint_indices_stream;
		 vector<uint8> selector_indices_stream;
#endif

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 color_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
#if CRND_CREATE_BYTE_STREAMS
					 tile_encoding_stream.push_back(chunk_encoding_bits & 7);
					 tile_encoding_stream.push_back((chunk_encoding_bits >> 3) & 7);
					 tile_encoding_stream.push_back((chunk_encoding_bits >> 6) & 7);
#endif
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta;
					 CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[0], delta);
#if CRND_CREATE_BYTE_STREAMS
					 endpoint_indices_stream.push_back(delta);
#endif
					 prev_color_endpoint_index += delta;
					 limit(prev_color_endpoint_index, num_color_endpoints);
					 color_endpoints[i] = m_color_endpoints[prev_color_endpoint_index];
				  }

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  if ((!skip_bottom_row) && (!skip_right_col))
				  {
					 //CRND_ASSERT( ((uint8*)&pD[4 + row_pitch_in_dwords] - pDst) <= dst_size_in_bytes );

					 pD[0] = color_endpoints[pTile_indices[0]];
					 CRND_WRITE_BARRIER
					 uint32 delta0;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta0);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta0);
#endif
					 prev_color_selector_index += delta0;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[1] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER

					 pD[2] = color_endpoints[pTile_indices[1]];
					 CRND_WRITE_BARRIER
					 uint32 delta1;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta1);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta1);
#endif
					 prev_color_selector_index += delta1;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[3] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER

					 pD[0 + row_pitch_in_dwords] = color_endpoints[pTile_indices[2]];
					 CRND_WRITE_BARRIER
					 uint32 delta2;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta2);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta2);
#endif
					 prev_color_selector_index += delta2;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[1 + row_pitch_in_dwords] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER

					 pD[2 + row_pitch_in_dwords] = color_endpoints[pTile_indices[3]];
					 CRND_WRITE_BARRIER
					 uint32 delta3;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta3);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta3);
#endif
					 prev_color_selector_index += delta3;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[3 + row_pitch_in_dwords] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER
				  }
				  else
				  {
					 for (uint32 by = 0; by < 2; by++)
					 {
						pD = (uint32*)((uint8*)pBlock + row_pitch_in_bytes * by);
						for (uint32 bx = 0; bx < 2; bx++, pD += 2)
						{
						   uint32 delta;
						   CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta);
#if CRND_CREATE_BYTE_STREAMS
						   selector_indices_stream.push_back(delta);
#endif
						   prev_color_selector_index += delta;
						   limit(prev_color_selector_index, num_color_selectors);

						   if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						   {
							  pD[0] = color_endpoints[pTile_indices[bx + by * 2]];
							  CRND_WRITE_BARRIER
							  pD[1] = m_color_selectors[prev_color_selector_index];
							  CRND_WRITE_BARRIER
						   }
						}
					 }
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 write_array_to_file(L"tile_encodings.bin", tile_encoding_stream);
		 write_array_to_file(L"endpoint_indices.bin", endpoint_indices_stream);
		 write_array_to_file(L"selector_indices.bin", selector_indices_stream);
#endif

		 return true;
	  }

	  bool unpack_dxt5(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_color_endpoints = m_color_endpoints.size();
		 const uint32 num_color_selectors = m_color_selectors.size();
		 const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 uint32 prev_color_endpoint_index = 0;
		 uint32 prev_color_selector_index = 0;
		 uint32 prev_alpha_endpoint_index = 0;
		 uint32 prev_alpha_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 //const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

		 const int32 cBytesPerBlock = 16;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 color_endpoints[4];
				  uint32 alpha_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha_endpoint_index += delta;
					 limit(prev_alpha_endpoint_index, num_alpha_endpoints);
					 alpha_endpoints[i] = m_alpha_endpoints[prev_alpha_endpoint_index];
				  }

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[0], delta);
					 prev_color_endpoint_index += delta;
					 limit(prev_color_endpoint_index, num_color_endpoints);
					 color_endpoints[i] = m_color_endpoints[prev_color_endpoint_index];
				  }

				  pD = (uint32*)pBlock;
				  for (uint32 by = 0; by < 2; by++)
				  {
					 for (uint32 bx = 0; bx < 2; bx++, pD += 4)
					 {
						uint32 delta0; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta0);
						prev_alpha_selector_index += delta0;
						limit(prev_alpha_selector_index, num_alpha_selectors);

						uint32 delta1; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta1);
						prev_color_selector_index += delta1;
						limit(prev_color_selector_index, num_color_selectors);

						if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						{
						   const uint32 tile_index = pTile_indices[bx + by * 2];
						   const uint16* pAlpha_selectors = &m_alpha_selectors[prev_alpha_selector_index * 3];

#ifdef CRND_BIG_ENDIAN_PLATFORM
						   pD[0] = (alpha_endpoints[tile_index] << 16) | pAlpha_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[1] = (pAlpha_selectors[1] << 16) | pAlpha_selectors[2];
						   CRND_WRITE_BARRIER
						   pD[2] = color_endpoints[tile_index];
						   CRND_WRITE_BARRIER
						   pD[3] = m_color_selectors[prev_color_selector_index];
						   CRND_WRITE_BARRIER
#else
						   pD[0] = alpha_endpoints[tile_index] | (pAlpha_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[1] = pAlpha_selectors[1] | (pAlpha_selectors[2] << 16);
						   CRND_WRITE_BARRIER
						   pD[2] = color_endpoints[tile_index];
						   CRND_WRITE_BARRIER
						   pD[3] = m_color_selectors[prev_color_selector_index];
						   CRND_WRITE_BARRIER
#endif
						}
					 }

					 pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

		 return true;
	  }

	  bool unpack_dxn(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 uint32 prev_alpha0_endpoint_index = 0;
		 uint32 prev_alpha0_selector_index = 0;
		 uint32 prev_alpha1_endpoint_index = 0;
		 uint32 prev_alpha1_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 //const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

		 const int32 cBytesPerBlock = 16;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 alpha0_endpoints[4];
				  uint32 alpha1_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha0_endpoint_index += delta;
					 limit(prev_alpha0_endpoint_index, num_alpha_endpoints);
					 alpha0_endpoints[i] = m_alpha_endpoints[prev_alpha0_endpoint_index];
				  }

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha1_endpoint_index += delta;
					 limit(prev_alpha1_endpoint_index, num_alpha_endpoints);
					 alpha1_endpoints[i] = m_alpha_endpoints[prev_alpha1_endpoint_index];
				  }

				  pD = (uint32*)pBlock;
				  for (uint32 by = 0; by < 2; by++)
				  {
					 for (uint32 bx = 0; bx < 2; bx++, pD += 4)
					 {
						uint32 delta0; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta0);
						prev_alpha0_selector_index += delta0;
						limit(prev_alpha0_selector_index, num_alpha_selectors);

						uint32 delta1; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta1);
						prev_alpha1_selector_index += delta1;
						limit(prev_alpha1_selector_index, num_alpha_selectors);

						if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						{
						   const uint32 tile_index = pTile_indices[bx + by * 2];
						   const uint16* pAlpha0_selectors = &m_alpha_selectors[prev_alpha0_selector_index * 3];
						   const uint16* pAlpha1_selectors = &m_alpha_selectors[prev_alpha1_selector_index * 3];

#ifdef CRND_BIG_ENDIAN_PLATFORM
						   pD[0] = (alpha0_endpoints[tile_index] << 16) | pAlpha0_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[1] = (pAlpha0_selectors[1] << 16) | pAlpha0_selectors[2];
						   CRND_WRITE_BARRIER
						   pD[2] = (alpha1_endpoints[tile_index] << 16) | pAlpha1_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[3] = (pAlpha1_selectors[1] << 16) | pAlpha1_selectors[2];
						   CRND_WRITE_BARRIER
#else
						   pD[0] = alpha0_endpoints[tile_index] | (pAlpha0_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
						   CRND_WRITE_BARRIER
						   pD[2] = alpha1_endpoints[tile_index] | (pAlpha1_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[3] = pAlpha1_selectors[1] | (pAlpha1_selectors[2] << 16);
						   CRND_WRITE_BARRIER
#endif
						}
					 }

					 pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

		 return true;
	  }

	  bool unpack_dxt5a(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 uint32 prev_alpha0_endpoint_index = 0;
		 uint32 prev_alpha0_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 const int32 cBytesPerBlock = 8;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 alpha0_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha0_endpoint_index += delta;
					 limit(prev_alpha0_endpoint_index, num_alpha_endpoints);
					 alpha0_endpoints[i] = m_alpha_endpoints[prev_alpha0_endpoint_index];
				  }

				  pD = (uint32*)pBlock;
				  for (uint32 by = 0; by < 2; by++)
				  {
					 for (uint32 bx = 0; bx < 2; bx++, pD += 2)
					 {
						uint32 delta; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta);
						prev_alpha0_selector_index += delta;
						limit(prev_alpha0_selector_index, num_alpha_selectors);

						if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						{
						   const uint32 tile_index = pTile_indices[bx + by * 2];
						   const uint16* pAlpha0_selectors = &m_alpha_selectors[prev_alpha0_selector_index * 3];

#if CRND_BIG_ENDIAN_PLATFORM
						   pD[0] = (alpha0_endpoints[tile_index] << 16) | pAlpha0_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[1] = (pAlpha0_selectors[1] << 16) | pAlpha0_selectors[2];
						   CRND_WRITE_BARRIER
#else
						   pD[0] = alpha0_endpoints[tile_index] | (pAlpha0_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
						   CRND_WRITE_BARRIER
#endif
						}
					 }

					 pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

		 return true;
	  }
   };

   crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return NULL;

	  crn_unpacker* p = crnd_new<crn_unpacker>();
	  if (!p)
		 return NULL;

	  if (!p->init(pData, data_size))
	  {
		 crnd_delete(p);
		 return NULL;
	  }

	  return p;
   }

   bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size)
   {
	  if (!pContext)
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  if (ppData)
		 *ppData = pUnpacker->get_data();

	  if (pData_size)
		 *pData_size = pUnpacker->get_data_size();

	  return true;
   }

   bool crnd_unpack_level(
	  crnd_unpack_context pContext,
	  void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index)
   {
	  if ((!pContext) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  return pUnpacker->unpack_level(pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
   }

   bool crnd_unpack_level_segmented(
	  crnd_unpack_context pContext,
	  const void* pSrc, uint32 src_size_in_bytes,
	  void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index)
   {
	  if ((!pContext) || (!pSrc) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  return pUnpacker->unpack_level(pSrc, src_size_in_bytes, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
   }

   bool crnd_unpack_end(crnd_unpack_context pContext)
   {
	  if (!pContext)
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  crnd_delete(pUnpacker);

	  return true;
   }

} // namespace crnd

#endif // CRND_HEADER_FILE_ONLY

//------------------------------------------------------------------------------
//
// crn_decomp.h uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------

extern "C" {
	unsigned int crn_get_width(const void *src, unsigned int src_size);
	unsigned int crn_get_height(const void *src, unsigned int src_size);
	unsigned int crn_get_levels(const void *src, unsigned int src_size);
	unsigned int crn_get_dxt_format(const void *src, unsigned int src_size);
	unsigned int crn_get_uncompressed_size(const void *p, unsigned int size);
	void crn_decompress(const void *src, unsigned int src_size, void *dst, unsigned int dst_size);
}

unsigned int crn_get_width(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_width;
}

unsigned int crn_get_height(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_height;
}

unsigned int crn_get_levels(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_levels;
}

unsigned int crn_get_dxt_format(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_format;
}

unsigned int crn_get_uncompressed_size(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	const crn_uint32 width = tex_info.m_width;
	const crn_uint32 height = tex_info.m_height;
	const crn_uint32 blocks_x = (width + 3) >> 2;
	const crn_uint32 blocks_y = (height + 3) >> 2;
	const crn_uint32 row_pitch = blocks_x * crnd::crnd_get_bytes_per_dxt_block(tex_info.m_format);
	const crn_uint32 total_face_size = row_pitch * blocks_y;
	return total_face_size;
}

void crn_decompress(const void *src, unsigned int src_size, void *dst, unsigned int dst_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	const crn_uint32 width = tex_info.m_width;
	const crn_uint32 height = tex_info.m_height;
	const crn_uint32 blocks_x = (width + 3) >> 2;
	const crn_uint32 blocks_y = (height + 3) >> 2;
	const crn_uint32 row_pitch = blocks_x * crnd::crnd_get_bytes_per_dxt_block(tex_info.m_format);

	crnd::crnd_unpack_context pContext =
	  crnd::crnd_unpack_begin(static_cast<const crn_uint8*>(src), src_size);
	void *pDecomp_images[1];
	pDecomp_images[0] = dst;
	crnd::crnd_unpack_level(pContext, pDecomp_images, dst_size, row_pitch, 0);
	crnd::crnd_unpack_end(pContext);
}

// from soil2

#include <stdint.h>

typedef struct
{
	uint32_t dwMagic;
	uint32_t dwSize;
	uint32_t dwFlags;
	uint32_t dwHeight;
	uint32_t dwWidth;
	uint32_t dwPitchOrLinearSize;
	uint32_t dwDepth;
	uint32_t dwMipMapCount;
	uint32_t dwReserved1[ 11 ];

	/*  DDPIXELFORMAT */
	struct
	{
		uint32_t dwSize;
		uint32_t dwFlags;
		uint32_t dwFourCC;
		uint32_t dwRGBBitCount;
		uint32_t dwRBitMask;
		uint32_t dwGBitMask;
		uint32_t dwBBitMask;
		uint32_t dwAlphaBitMask;
	}
	sPixelFormat;

	/*  DDCAPS2 */
	struct
	{
		uint32_t dwCaps1;
		uint32_t dwCaps2;
		uint32_t dwDDSX;
		uint32_t dwReserved;
	}
	sCaps;
	uint32_t dwReserved2;
}
DDS_header;

/*  the following constants were copied directly off the MSDN website */

/*  The dwFlags member of the original DDSURFACEDESC2 structure
  can be set to one or more of the following values.  */
#define DDSD_CAPS 0x00000001
#define DDSD_HEIGHT 0x00000002
#define DDSD_WIDTH  0x00000004
#define DDSD_PITCH  0x00000008
#define DDSD_PIXELFORMAT  0x00001000
#define DDSD_MIPMAPCOUNT  0x00020000
#define DDSD_LINEARSIZE 0x00080000
#define DDSD_DEPTH  0x00800000

/*  DirectDraw Pixel Format */
#define DDPF_ALPHAPIXELS  0x00000001
#define DDPF_FOURCC 0x00000004
#define DDPF_RGB  0x00000040

/*  The dwCaps1 member of the DDSCAPS2 structure can be
  set to one or more of the following values. */
#define DDSCAPS_COMPLEX 0x00000008
#define DDSCAPS_TEXTURE 0x00001000
#define DDSCAPS_MIPMAP  0x00400000

/*  The dwCaps2 member of the DDSCAPS2 structure can be
  set to one or more of the following values.   */
#define DDSCAPS2_CUBEMAP  0x00000200
#define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400
#define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800
#define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000
#define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000
#define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000
#define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000
#define DDSCAPS2_VOLUME 0x00200000

#include <stdlib.h>
#include <cassert>
#include <string>

// returns a pure dxt stream (can be uploaded to a GPU directly)
bool crn2dxt( std::string &out, const void *src, size_t zlen, unsigned reserved ) {
	if( zlen > 2 && ((const char *)src)[0] == 'H' && ((const char *)src)[1] == 'x' ) {
		unsigned width( crn_get_width(src,zlen) );
		unsigned height( crn_get_height(src,zlen) );
		unsigned len( crn_get_uncompressed_size(src,zlen) );

		out.resize( reserved + len );
		crn_decompress( src, zlen, &out[reserved], len );
		return true;
	}
	return false;
}
bool crn2dxt( std::string &out, const std::string &in, unsigned reserved ) {
	return crn2dxt( out, &in[0], in.size(), reserved );
}

// returns a cooked dds header + pure dxt stream (can be saved or processed somewhere else)
bool crn2dds( std::string &out, const void *src, size_t zlen ) {
	if( crn2dxt( out, src, zlen, 128 ) ) {
		assert( sizeof(DDS_header) == 128 );

		unsigned width( crn_get_width(src,zlen) );
		unsigned height( crn_get_height(src,zlen) );
		unsigned len( crn_get_uncompressed_size(src,zlen) );

		unsigned channels = 3;
		switch( crn_get_dxt_format(src,zlen) ) {
		  default:
		  case cCRNFmtDXT1: channels = 3; break;
		  case cCRNFmtDXT3: channels = 3; break;

		  case cCRNFmtDXT5:
		  // Various DXT5 derivatives
		  case cCRNFmtDXT5_CCxY:    // Luma-chroma
		  case cCRNFmtDXT5_xGxR:    // Swizzled 2-component
		  case cCRNFmtDXT5_xGBR:    // Swizzled 3-component
		  case cCRNFmtDXT5_AGBR:    // Swizzled 4-component
		  // ATI 3DC and X360 DXN
		  case cCRNFmtDXN_XY:
		  case cCRNFmtDXN_YX: channels = 4; break;

		  // DXT5 alpha blocks only
		  case cCRNFmtDXT5A: channels = 1; break;
		  case cCRNFmtETC1: channels = 3; break;
		}

		DDS_header header;
		memset( &header, 0, sizeof( DDS_header ) );
		header.dwMagic = ('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24);
		header.dwSize = 124;
		header.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE;
		header.dwWidth = width;
		header.dwHeight = height;
		header.dwPitchOrLinearSize = len;
		header.sPixelFormat.dwSize = 32;
		header.sPixelFormat.dwFlags = DDPF_FOURCC;
		if( (channels & 1) == 1 ) {
		  header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('1' << 24);
		} else {
		  header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('5' << 24);
		}
		header.sCaps.dwCaps1 = DDSCAPS_TEXTURE;

		memcpy( &out[0], &header, 128 );
		return true;
	}

	return false;
}

bool crn2dds( std::string &out, const std::string &in ) {
	return crn2dds( out, &in[0], in.size() );
}


#if defined(SPOT_OPENGL_HEADER)
#   include SPOT_OPENGL_HEADER

//#line 1 "SOIL2.h"
#ifndef HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY
#define HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY

#ifdef __cplusplus
extern "C" {
#endif

/**
	The format of images that may be loaded (force_channels).
	SOIL_LOAD_AUTO leaves the image in whatever format it was found.
	SOIL_LOAD_L forces the image to load as Luminous (greyscale)
	SOIL_LOAD_LA forces the image to load as Luminous with Alpha
	SOIL_LOAD_RGB forces the image to load as Red Green Blue
	SOIL_LOAD_RGBA forces the image to load as Red Green Blue Alpha
**/
enum
{
	SOIL_LOAD_AUTO = 0,
	SOIL_LOAD_L = 1,
	SOIL_LOAD_LA = 2,
	SOIL_LOAD_RGB = 3,
	SOIL_LOAD_RGBA = 4
};

/**
	Passed in as reuse_texture_ID, will cause SOIL to
	register a new texture ID using glGenTextures().
	If the value passed into reuse_texture_ID > 0 then
	SOIL will just re-use that texture ID (great for
	reloading image assets in-game!)
**/
enum
{
	SOIL_CREATE_NEW_ID = 0
};

/**
	flags you can pass into SOIL_load_OGL_texture()
	and SOIL_create_OGL_texture().
	(note that if SOIL_FLAG_DDS_LOAD_DIRECT is used
	the rest of the flags with the exception of
	SOIL_FLAG_TEXTURE_REPEATS will be ignored while
	loading already-compressed DDS files.)

	SOIL_FLAG_POWER_OF_TWO: force the image to be POT
	SOIL_FLAG_MIPMAPS: generate mipmaps for the texture
	SOIL_FLAG_TEXTURE_REPEATS: otherwise will clamp
	SOIL_FLAG_MULTIPLY_ALPHA: for using (GL_ONE,GL_ONE_MINUS_SRC_ALPHA) blending
	SOIL_FLAG_INVERT_Y: flip the image vertically
	SOIL_FLAG_COMPRESS_TO_DXT: if the card can display them, will convert RGB to DXT1, RGBA to DXT5
	SOIL_FLAG_DDS_LOAD_DIRECT: will load DDS files directly without _ANY_ additional processing ( if supported )
	SOIL_FLAG_NTSC_SAFE_RGB: clamps RGB components to the range [16,235]
	SOIL_FLAG_CoCg_Y: Google YCoCg; RGB=>CoYCg, RGBA=>CoCgAY
	SOIL_FLAG_TEXTURE_RECTANGE: uses ARB_texture_rectangle ; pixel indexed & no repeat or MIPmaps or cubemaps
	SOIL_FLAG_PVR_LOAD_DIRECT: will load PVR files directly without _ANY_ additional processing ( if supported )
**/
enum
{
	SOIL_FLAG_POWER_OF_TWO = 1,
	SOIL_FLAG_MIPMAPS = 2,
	SOIL_FLAG_TEXTURE_REPEATS = 4,
	SOIL_FLAG_MULTIPLY_ALPHA = 8,
	SOIL_FLAG_INVERT_Y = 16,
	SOIL_FLAG_COMPRESS_TO_DXT = 32,
	SOIL_FLAG_DDS_LOAD_DIRECT = 64,
	SOIL_FLAG_NTSC_SAFE_RGB = 128,
	SOIL_FLAG_CoCg_Y = 256,
	SOIL_FLAG_TEXTURE_RECTANGLE = 512,
	SOIL_FLAG_PVR_LOAD_DIRECT = 1024,
	SOIL_FLAG_ETC1_LOAD_DIRECT = 2048,
	SOIL_FLAG_GL_MIPMAPS = 4096
};

/**
	The types of images that may be saved.
	(TGA supports uncompressed RGB / RGBA)
	(BMP supports uncompressed RGB)
	(DDS supports DXT1 and DXT5)
	(PNG supports RGB / RGBA)
**/
enum
{
	SOIL_SAVE_TYPE_TGA = 0,
	SOIL_SAVE_TYPE_BMP = 1,
	SOIL_SAVE_TYPE_PNG = 2,
	SOIL_SAVE_TYPE_DDS = 3
};

/**
	Defines the order of faces in a DDS cubemap.
	I recommend that you use the same order in single
	image cubemap files, so they will be interchangeable
	with DDS cubemaps when using SOIL.
**/
#define SOIL_DDS_CUBEMAP_FACE_ORDER "EWUDNS"

/**
	The types of internal fake HDR representations

	SOIL_HDR_RGBE:		RGB * pow( 2.0, A - 128.0 )
	SOIL_HDR_RGBdivA:	RGB / A
	SOIL_HDR_RGBdivA2:	RGB / (A*A)
**/
enum
{
	SOIL_HDR_RGBE = 0,
	SOIL_HDR_RGBdivA = 1,
	SOIL_HDR_RGBdivA2 = 2
};

/**
	Loads an image from disk into an OpenGL texture.
	\param filename the name of the file to upload as a texture
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_texture
	(
		const char *filename,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 6 images from disk into an OpenGL cubemap texture.
	\param x_pos_file the name of the file to upload as the +x cube face
	\param x_neg_file the name of the file to upload as the -x cube face
	\param y_pos_file the name of the file to upload as the +y cube face
	\param y_neg_file the name of the file to upload as the -y cube face
	\param z_pos_file the name of the file to upload as the +z cube face
	\param z_neg_file the name of the file to upload as the -z cube face
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_cubemap
	(
		const char *x_pos_file,
		const char *x_neg_file,
		const char *y_pos_file,
		const char *y_neg_file,
		const char *z_pos_file,
		const char *z_neg_file,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 1 image from disk and splits it into an OpenGL cubemap texture.
	\param filename the name of the file to upload as a texture
	\param face_order the order of the faces in the file, any combination of NSWEUD, for North, South, Up, etc.
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_single_cubemap
	(
		const char *filename,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads an HDR image from disk into an OpenGL texture.
	\param filename the name of the file to upload as a texture
	\param fake_HDR_format SOIL_HDR_RGBE, SOIL_HDR_RGBdivA, SOIL_HDR_RGBdivA2
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_HDR_texture
	(
		const char *filename,
		int fake_HDR_format,
		int rescale_to_max,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads an image from RAM into an OpenGL texture.
	\param buffer the image data in RAM just as if it were still in a file
	\param buffer_length the size of the buffer in bytes
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_texture_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 6 images from memory into an OpenGL cubemap texture.
	\param x_pos_buffer the image data in RAM to upload as the +x cube face
	\param x_pos_buffer_length the size of the above buffer
	\param x_neg_buffer the image data in RAM to upload as the +x cube face
	\param x_neg_buffer_length the size of the above buffer
	\param y_pos_buffer the image data in RAM to upload as the +x cube face
	\param y_pos_buffer_length the size of the above buffer
	\param y_neg_buffer the image data in RAM to upload as the +x cube face
	\param y_neg_buffer_length the size of the above buffer
	\param z_pos_buffer the image data in RAM to upload as the +x cube face
	\param z_pos_buffer_length the size of the above buffer
	\param z_neg_buffer the image data in RAM to upload as the +x cube face
	\param z_neg_buffer_length the size of the above buffer
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_cubemap_from_memory
	(
		const unsigned char *const x_pos_buffer,
		int x_pos_buffer_length,
		const unsigned char *const x_neg_buffer,
		int x_neg_buffer_length,
		const unsigned char *const y_pos_buffer,
		int y_pos_buffer_length,
		const unsigned char *const y_neg_buffer,
		int y_neg_buffer_length,
		const unsigned char *const z_pos_buffer,
		int z_pos_buffer_length,
		const unsigned char *const z_neg_buffer,
		int z_neg_buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 1 image from RAM and splits it into an OpenGL cubemap texture.
	\param buffer the image data in RAM just as if it were still in a file
	\param buffer_length the size of the buffer in bytes
	\param face_order the order of the faces in the file, any combination of NSWEUD, for North, South, Up, etc.
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_single_cubemap_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Creates a 2D OpenGL texture from raw image data.  Note that the raw data is
	_NOT_ freed after the upload (so the user can load various versions).
	\param data the raw data to be uploaded as an OpenGL texture
	\param width the pointer of the width of the image in pixels ( if the texture size change, width will be overrided with the new width )
	\param height the pointer of the height of the image in pixels ( if the texture size change, height will be overrided with the new height )
	\param channels the number of channels: 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Creates an OpenGL cubemap texture by splitting up 1 image into 6 parts.
	\param data the raw data to be uploaded as an OpenGL texture
	\param width the width of the image in pixels
	\param height the height of the image in pixels
	\param channels the number of channels: 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param face_order the order of the faces in the file, and combination of NSWEUD, for North, South, Up, etc.
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_create_OGL_single_cubemap
	(
		const unsigned char *const data,
		int width, int height, int channels,
		const char face_order[6],
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Captures the OpenGL window (RGB) and saves it to disk
	\return 0 if it failed, otherwise returns 1
**/
int
	SOIL_save_screenshot
	(
		const char *filename,
		int image_type,
		int x, int y,
		int width, int height
	);

/**
	Loads an image from disk into an array of unsigned chars.
	Note that *channels return the original channel count of the
	image.  If force_channels was other than SOIL_LOAD_AUTO,
	the resulting image has force_channels, but *channels may be
	different (if the original image had a different channel
	count).
	\return 0 if failed, otherwise returns 1
**/
unsigned char*
	SOIL_load_image
	(
		const char *filename,
		int *width, int *height, int *channels,
		int force_channels
	);

/**
	Loads an image from memory into an array of unsigned chars.
	Note that *channels return the original channel count of the
	image.  If force_channels was other than SOIL_LOAD_AUTO,
	the resulting image has force_channels, but *channels may be
	different (if the original image had a different channel
	count).
	\return 0 if failed, otherwise returns 1
**/
unsigned char*
	SOIL_load_image_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int *width, int *height, int *channels,
		int force_channels
	);

/**
	Saves an image from an array of unsigned chars (RGBA) to disk
	\return 0 if failed, otherwise returns 1
**/
int
	SOIL_save_image
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data
	);

/**
	Frees the image data (note, this is just C's "free()"...this function is
	present mostly so C++ programmers don't forget to use "free()" and call
	"delete []" instead [8^)
**/
void
	SOIL_free_image_data
	(
		unsigned char *img_data
	);

/**
	This function resturn a pointer to a string describing the last thing
	that happened inside SOIL.  It can be used to determine why an image
	failed to load.
**/
const char*
	SOIL_last_result
	(
		void
	);

/** @return The address of the GL function proc, or NULL if the function is not found. */
void *
	SOIL_GL_GetProcAddress
	(
		const char *proc
	);

/** @return 1 if an OpenGL extension is supported for the current context, 0 otherwise. */
int
	SOIL_GL_ExtensionSupported
	(
		const char *extension
	);

/** Loads the DDS texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_DDS(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the DDS texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_DDS_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_PVR(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_PVR_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_ETC1(const char *filename,
		unsigned int reuse_texture_ID,
		int flags );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_ETC1_from_memory(const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags );

#ifdef __cplusplus
}
#endif

#endif /* HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY	*/



//#line 1 "SOIL2.c"
#define SOIL_CHECK_FOR_GL_ERRORS 0

#if defined( __APPLE_CC__ ) || defined ( __APPLE__ )
	#include <TargetConditionals.h>

	#if defined( __IPHONE__ ) || ( defined( TARGET_OS_IPHONE ) && TARGET_OS_IPHONE ) || ( defined( TARGET_IPHONE_SIMULATOR ) && TARGET_IPHONE_SIMULATOR )
		#define SOIL_PLATFORM_IOS
		#include <dlfcn.h>
	#else
		#define SOIL_PLATFORM_OSX
	#endif
#elif defined( __ANDROID__ ) || defined( ANDROID )
	#define SOIL_PLATFORM_ANDROID
#elif ( defined ( linux ) || defined( __linux__ ) || defined( __FreeBSD__ ) || defined(__OpenBSD__) || defined( __NetBSD__ ) || defined( __DragonFly__ ) || defined( __SVR4 ) )
	#define SOIL_X11_PLATFORM
#endif

#if ( defined( SOIL_PLATFORM_IOS ) || defined( SOIL_PLATFORM_ANDROID ) ) && ( !defined( SOIL_GLES1 ) && !defined( SOIL_GLES2 ) )
	#define SOIL_GLES2
#endif

#if ( defined( SOIL_GLES2 ) || defined( SOIL_GLES1 ) ) && !defined( SOIL_NO_EGL ) && !defined( SOIL_PLATFORM_IOS )
	#include <EGL/egl.h>
#endif

#if defined( SOIL_GLES2 )
	#ifdef SOIL_PLATFORM_IOS
		#include <OpenGLES/ES2/gl.h>
		#include <OpenGLES/ES2/glext.h>
	#else
		#include <GLES2/gl2.h>
		#include <GLES2/gl2ext.h>
	#endif

	#define APIENTRY GL_APIENTRY
#elif defined( SOIL_GLES1 )
	#ifndef GL_GLEXT_PROTOTYPES
	#define GL_GLEXT_PROTOTYPES
	#endif
	#ifdef SOIL_PLATFORM_IOS
		#include <OpenGLES/ES1/gl.h>
		#include <OpenGLES/ES1/glext.h>
	#else
		#include <GLES/gl.h>
		#include <GLES/glext.h>
	#endif

	#define APIENTRY GL_APIENTRY
#else

#if defined( __WIN32__ ) || defined( _WIN32 ) || defined( WIN32 )
	#define SOIL_PLATFORM_WIN32
	#define WIN32_LEAN_AND_MEAN
	#include <windows.h>
	#include <wingdi.h>
	#include <GL/gl.h>

	#ifndef GL_UNSIGNED_SHORT_4_4_4_4
	#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
	#endif
	#ifndef GL_UNSIGNED_SHORT_5_5_5_1
	#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
	#endif
	#ifndef GL_UNSIGNED_SHORT_5_6_5
	#define GL_UNSIGNED_SHORT_5_6_5 0x8363
	#endif
#elif defined(__APPLE__) || defined(__APPLE_CC__)
	/*	I can't test this Apple stuff!	*/
	#include <OpenGL/gl.h>
	#include <Carbon/Carbon.h>
	#define APIENTRY
#elif defined( SOIL_X11_PLATFORM )
	#include <GL/gl.h>
	#include <GL/glx.h>
#else
	#include <GL/gl.h>
#endif

#endif

#ifndef GL_BGRA
#define GL_BGRA                                             0x80E1
#endif

#ifndef GL_RG
#define GL_RG                             0x8227
#endif

#define STB_IMAGE_WRITE_IMPLEMENTATION

#include <stdlib.h>
#include <string.h>

/*	error reporting	*/
const char *result_string_pointer = "SOIL initialized";

/*	for loading cube maps	*/
enum{
	SOIL_CAPABILITY_UNKNOWN = -1,
	SOIL_CAPABILITY_NONE = 0,
	SOIL_CAPABILITY_PRESENT = 1
};
static int has_cubemap_capability = SOIL_CAPABILITY_UNKNOWN;
int query_cubemap_capability( void );
#define SOIL_TEXTURE_WRAP_R					0x8072
#define SOIL_CLAMP_TO_EDGE					0x812F
#define SOIL_NORMAL_MAP						0x8511
#define SOIL_REFLECTION_MAP					0x8512
#define SOIL_TEXTURE_CUBE_MAP				0x8513
#define SOIL_TEXTURE_BINDING_CUBE_MAP		0x8514
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_X	0x8515
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X	0x8516
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y	0x8517
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y	0x8518
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z	0x8519
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z	0x851A
#define SOIL_PROXY_TEXTURE_CUBE_MAP			0x851B
#define SOIL_MAX_CUBE_MAP_TEXTURE_SIZE		0x851C
/*	for non-power-of-two texture	*/
#define SOIL_IS_POW2( v ) ( ( v & ( v - 1 ) ) == 0 )
static int has_NPOT_capability = SOIL_CAPABILITY_UNKNOWN;
int query_NPOT_capability( void );
/*	for texture rectangles	*/
static int has_tex_rectangle_capability = SOIL_CAPABILITY_UNKNOWN;
int query_tex_rectangle_capability( void );
#define SOIL_TEXTURE_RECTANGLE_ARB				0x84F5
#define SOIL_MAX_RECTANGLE_TEXTURE_SIZE_ARB		0x84F8
/*	for using DXT compression	*/
static int has_DXT_capability = SOIL_CAPABILITY_UNKNOWN;
int query_DXT_capability( void );
#define SOIL_RGB_S3TC_DXT1		0x83F0
#define SOIL_RGBA_S3TC_DXT1		0x83F1
#define SOIL_RGBA_S3TC_DXT3		0x83F2
#define SOIL_RGBA_S3TC_DXT5		0x83F3
typedef void (APIENTRY * P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data);
static P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC soilGlCompressedTexImage2D = NULL;

typedef void (APIENTRY *P_SOIL_GLGENERATEMIPMAPPROC)(GLenum target);
static P_SOIL_GLGENERATEMIPMAPPROC soilGlGenerateMipmap = NULL;

static int has_gen_mipmap_capability = SOIL_CAPABILITY_UNKNOWN;
static int query_gen_mipmap_capability( void );

static int has_PVR_capability = SOIL_CAPABILITY_UNKNOWN;
int query_PVR_capability( void );
static int has_BGRA8888_capability = SOIL_CAPABILITY_UNKNOWN;
int query_BGRA8888_capability( void );
static int has_ETC1_capability = SOIL_CAPABILITY_UNKNOWN;
int query_ETC1_capability( void );

/* GL_IMG_texture_compression_pvrtc */
#define SOIL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG                      0x8C00
#define SOIL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG                      0x8C01
#define SOIL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG                     0x8C02
#define SOIL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG                     0x8C03
#define SOIL_GL_ETC1_RGB8_OES                                     0x8D64

#if defined( SOIL_X11_PLATFORM ) || defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX )
typedef const GLubyte *(APIENTRY * P_SOIL_glGetStringiFunc) (GLenum, GLuint);
static P_SOIL_glGetStringiFunc soilGlGetStringiFunc = NULL;

static int isAtLeastGL3()
{
	static int is_gl3 = SOIL_CAPABILITY_UNKNOWN;

	if ( SOIL_CAPABILITY_UNKNOWN == is_gl3 )
	{
		const char * verstr	= (const char *) glGetString( GL_VERSION );
		is_gl3				= ( verstr && ( atoi(verstr) >= 3 ) );
	}

	return is_gl3;
}
#endif

#ifdef SOIL_PLATFORM_WIN32
static int soilTestWinProcPointer(const PROC pTest)
{
	ptrdiff_t iTest;
	if(!pTest) return 0;
	iTest = (ptrdiff_t)pTest;
	if(iTest == 1 || iTest == 2 || iTest == 3 || iTest == -1) return 0;
	return 1;
}
#endif

void * SOIL_GL_GetProcAddress(const char *proc)
{
	void *func = NULL;

#if defined( SOIL_PLATFORM_IOS )
	func = dlsym( RTLD_DEFAULT, proc );
#elif defined( SOIL_GLES2 ) || defined( SOIL_GLES1 )
	#ifndef SOIL_NO_EGL
		func = eglGetProcAddress( proc );
	#else
		func = NULL;
	#endif
#elif defined( SOIL_PLATFORM_WIN32 )
	func =  wglGetProcAddress( proc );

	if (!soilTestWinProcPointer((const PROC)func))
		func = NULL;
#elif defined( SOIL_PLATFORM_OSX )
	/*	I can't test this Apple stuff!	*/
	CFBundleRef bundle;
	CFURLRef bundleURL =
	CFURLCreateWithFileSystemPath(
								  kCFAllocatorDefault,
								  CFSTR("/System/Library/Frameworks/OpenGL.framework"),
								  kCFURLPOSIXPathStyle,
								  true );
	CFStringRef extensionName =
	CFStringCreateWithCString(
							  kCFAllocatorDefault,
							  proc,
							  kCFStringEncodingASCII );
	bundle = CFBundleCreate( kCFAllocatorDefault, bundleURL );
	assert( bundle != NULL );

	func = CFBundleGetFunctionPointerForName( bundle, extensionName );

	CFRelease( bundleURL );
	CFRelease( extensionName );
	CFRelease( bundle );
#elif defined( SOIL_X11_PLATFORM )
	func =
#if !defined(GLX_VERSION_1_4)
	glXGetProcAddressARB
#else
	glXGetProcAddress
#endif
	( (const GLubyte *)proc );
#endif

	return func;
}

/* Based on the SDL2 implementation */
int SOIL_GL_ExtensionSupported(const char *extension)
{
	const char *extensions;
	const char *start;
	const char *where, *terminator;

	/* Extension names should not have spaces. */
	where = strchr(extension, ' ');

	if (where || *extension == '\0')
	{
		return 0;
	}

	#if defined( SOIL_X11_PLATFORM ) || defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX )
	/* Lookup the available extensions */
	if ( isAtLeastGL3() )
	{
		GLint num_exts = 0;
		GLint i;

		if ( NULL == soilGlGetStringiFunc )
		{
			soilGlGetStringiFunc = (P_SOIL_glGetStringiFunc)SOIL_GL_GetProcAddress("glGetStringi");

			if ( NULL == soilGlGetStringiFunc )
			{
				return 0;
			}
		}

		#ifndef GL_NUM_EXTENSIONS
		#define GL_NUM_EXTENSIONS 0x821D
		#endif
		glGetIntegerv(GL_NUM_EXTENSIONS, &num_exts);
		for (i = 0; i < num_exts; i++)
		{
			const char *thisext = (const char *) soilGlGetStringiFunc(GL_EXTENSIONS, i);

			if (strcmp(thisext, extension) == 0)
			{
				return 1;
			}
		}

		return 0;
	}
	#endif

	/* Try the old way with glGetString(GL_EXTENSIONS) ... */
	extensions = (const char *) glGetString(GL_EXTENSIONS);

	if (!extensions)
	{
		return 0;
	}

	/*
	 * It takes a bit of care to be fool-proof about parsing the OpenGL
	 * extensions string. Don't be fooled by sub-strings, etc.
	 */
	start = extensions;

	for (;;) {
		where = strstr(start, extension);

		if (!where)
			break;

		terminator = where + strlen(extension);

		if (where == start || *(where - 1) == ' ')
			if (*terminator == ' ' || *terminator == '\0')
				return 1;

		start = terminator;
	}

	return 0;
}

/*	other functions	*/
unsigned int
	SOIL_internal_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags,
		unsigned int opengl_texture_type,
		unsigned int opengl_texture_target,
		unsigned int texture_check_size_enum
	);

/*	and the code magic begins here [8^)	*/
unsigned int
	SOIL_load_OGL_texture
	(
		const char *filename,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS( filename, reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR( filename, reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_ETC1( filename, reuse_texture_ID, flags );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	/*	try to load the image	*/
	img = SOIL_load_image( filename, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_HDR_texture
	(
		const char *filename,
		int fake_HDR_format,
		int rescale_to_max,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img = NULL;
	int width, height, channels;
	unsigned int tex_id;
	/*	no direct uploading of the image as a DDS file	*/
	/* error check */
	if( (fake_HDR_format != SOIL_HDR_RGBE) &&
		(fake_HDR_format != SOIL_HDR_RGBdivA) &&
		(fake_HDR_format != SOIL_HDR_RGBdivA2) )
	{
		result_string_pointer = "Invalid fake HDR format specified";
		return 0;
	}

	/* check if the image is HDR */
	if ( stbi_is_hdr( filename ) )
	{
		/*	try to load the image (only the HDR type) */
		img = stbi_load( filename, &width, &height, &channels, 4 );
	}

	/*	channels holds the original number of channels, which may have been forced	*/
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/* the load worked, do I need to convert it? */
	if( fake_HDR_format == SOIL_HDR_RGBdivA )
	{
		RGBE_to_RGBdivA( img, width, height, rescale_to_max );
	} else if( fake_HDR_format == SOIL_HDR_RGBdivA2 )
	{
		RGBE_to_RGBdivA2( img, width, height, rescale_to_max );
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_texture_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_ETC1_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	/*	try to load the image	*/
	img = SOIL_load_image_from_memory(
					buffer, buffer_length,
					&width, &height, &channels,
					force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_cubemap
	(
		const char *x_pos_file,
		const char *x_neg_file,
		const char *y_pos_file,
		const char *y_neg_file,
		const char *z_pos_file,
		const char *z_neg_file,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	error checking	*/
	if( (x_pos_file == NULL) ||
		(x_neg_file == NULL) ||
		(y_pos_file == NULL) ||
		(y_neg_file == NULL) ||
		(z_pos_file == NULL) ||
		(z_neg_file == NULL) )
	{
		result_string_pointer = "Invalid cube map files list";
		return 0;
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st face: try to load the image	*/
	img = SOIL_load_image( x_pos_file, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	upload the texture, and create a texture ID if necessary	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_X,
			SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( x_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( y_pos_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( y_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( z_pos_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( z_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_cubemap_from_memory
	(
		const unsigned char *const x_pos_buffer,
		int x_pos_buffer_length,
		const unsigned char *const x_neg_buffer,
		int x_neg_buffer_length,
		const unsigned char *const y_pos_buffer,
		int y_pos_buffer_length,
		const unsigned char *const y_neg_buffer,
		int y_neg_buffer_length,
		const unsigned char *const z_pos_buffer,
		int z_pos_buffer_length,
		const unsigned char *const z_neg_buffer,
		int z_neg_buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	error checking	*/
	if( (x_pos_buffer == NULL) ||
		(x_neg_buffer == NULL) ||
		(y_pos_buffer == NULL) ||
		(y_neg_buffer == NULL) ||
		(z_pos_buffer == NULL) ||
		(z_neg_buffer == NULL) )
	{
		result_string_pointer = "Invalid cube map buffers list";
		return 0;
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st face: try to load the image	*/
	img = SOIL_load_image_from_memory(
			x_pos_buffer, x_pos_buffer_length,
			&width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	upload the texture, and create a texture ID if necessary	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_X,
			SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				x_neg_buffer, x_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				y_pos_buffer, y_pos_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				y_neg_buffer, y_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				z_pos_buffer, z_pos_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				z_neg_buffer, z_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_single_cubemap
	(
		const char *filename,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels, i;
	unsigned int tex_id = 0;
	/*	error checking	*/
	if( filename == NULL )
	{
		result_string_pointer = "Invalid single cube map file name";
		return 0;
	}
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS( filename, reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR( filename, reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		return 0;
	}

	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st off, try to load the full image	*/
	img = SOIL_load_image( filename, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		SOIL_free_image_data( img );
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	try the image split and create	*/
	tex_id = SOIL_create_OGL_single_cubemap(
			img, width, height, channels,
			face_order, reuse_texture_ID, flags
			);
	/*	nuke the temporary image data and return the texture handle	*/
	SOIL_free_image_data( img );
	return tex_id;
}

unsigned int
	SOIL_load_OGL_single_cubemap_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels, i;
	unsigned int tex_id = 0;
	/*	error checking	*/
	if( buffer == NULL )
	{
		result_string_pointer = "Invalid single cube map buffer";
		return 0;
	}
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 1 );
		if ( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		return 0;
	}

	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st off, try to load the full image	*/
	img = SOIL_load_image_from_memory(
			buffer, buffer_length,
			&width, &height, &channels,
			force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		SOIL_free_image_data( img );
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	try the image split and create	*/
	tex_id = SOIL_create_OGL_single_cubemap(
			img, width, height, channels,
			face_order, reuse_texture_ID, flags
			);
	/*	nuke the temporary image data and return the texture handle	*/
	SOIL_free_image_data( img );
	return tex_id;
}

unsigned int
	SOIL_create_OGL_single_cubemap
	(
		const unsigned char *const data,
		int width, int height, int channels,
		const char face_order[6],
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* sub_img;
	int dw, dh, sz, i;
	unsigned int tex_id;
	/*	error checking	*/
	if( data == NULL )
	{
		result_string_pointer = "Invalid single cube map image data";
		return 0;
	}
	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	which way am I stepping?	*/
	if( width > height )
	{
		dw = height;
		dh = 0;
	} else
	{
		dw = 0;
		dh = width;
	}
	sz = dw+dh;
	sub_img = (unsigned char *)malloc( sz*sz*channels );
	/*	do the splitting and uploading	*/
	tex_id = reuse_texture_ID;
	for( i = 0; i < 6; ++i )
	{
		int x, y, idx = 0;
		unsigned int cubemap_target = 0;
		/*	copy in the sub-image	*/
		for( y = i*dh; y < i*dh+sz; ++y )
		{
			for( x = i*dw*channels; x < (i*dw+sz)*channels; ++x )
			{
				sub_img[idx++] = data[y*width*channels+x];
			}
		}
		/*	what is my texture target?
			remember, this coordinate system is
			LHS if viewed from inside the cube!	*/
		switch( face_order[i] )
		{
		case 'N':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z;
			break;
		case 'S':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
			break;
		case 'W':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X;
			break;
		case 'E':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_X;
			break;
		case 'U':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y;
			break;
		case 'D':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y;
			break;
		}
		/*	upload it as a texture	*/
		tex_id = SOIL_internal_create_OGL_texture(
				sub_img, &sz, &sz, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP,
				cubemap_target,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	}
	/*	and nuke the image and sub-image data	*/
	SOIL_free_image_data( sub_img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	wrapper function for 2D textures	*/
	return SOIL_internal_create_OGL_texture(
				data, width, height, channels,
				reuse_texture_ID, flags,
				GL_TEXTURE_2D, GL_TEXTURE_2D,
				GL_MAX_TEXTURE_SIZE );
}

#if SOIL_CHECK_FOR_GL_ERRORS
void check_for_GL_errors( const char *calling_location )
{
	/*	check for errors	*/
	GLenum err_code = glGetError();
	while( GL_NO_ERROR != err_code )
	{
		printf( "OpenGL Error @ %s: %i", calling_location, err_code );
		err_code = glGetError();
	}
}
#else
void check_for_GL_errors( const char *calling_location )
{
	/*	no check for errors	*/
}
#endif

static void createMipmaps(const unsigned char *const img,
		int width, int height, int channels,
		unsigned int flags,
		unsigned int opengl_texture_target,
		unsigned int internal_texture_format,
		unsigned int original_texture_format,
		int DXT_mode)
{
	if ( ( flags & SOIL_FLAG_GL_MIPMAPS ) && query_gen_mipmap_capability() == SOIL_CAPABILITY_PRESENT )
	{
		soilGlGenerateMipmap(opengl_texture_target);
	}
	else
	{
		int MIPlevel = 1;
		int MIPwidth = (width+1) / 2;
		int MIPheight = (height+1) / 2;
		unsigned char *resampled = (unsigned char*)malloc( channels*MIPwidth*MIPheight );

		while( ((1<<MIPlevel) <= width) || ((1<<MIPlevel) <= height) )
		{
			/*	do this MIPmap level	*/
			mipmap_image(
					img, width, height, channels,
					resampled,
					(1 << MIPlevel), (1 << MIPlevel) );

			/*  upload the MIPmaps	*/
			if( DXT_mode == SOIL_CAPABILITY_PRESENT )
			{
				/*	user wants me to do the DXT conversion!	*/
				int DDS_size;
				unsigned char *DDS_data = NULL;
				if( (channels & 1) == 1 )
				{
					/*	RGB, use DXT1	*/
					DDS_data = convert_image_to_DXT1(
							resampled, MIPwidth, MIPheight, channels, &DDS_size );
				} else
				{
					/*	RGBA, use DXT5	*/
					DDS_data = convert_image_to_DXT5(
							resampled, MIPwidth, MIPheight, channels, &DDS_size );
				}
				if( DDS_data )
				{
					soilGlCompressedTexImage2D(
						opengl_texture_target, MIPlevel,
						internal_texture_format, MIPwidth, MIPheight, 0,
						DDS_size, DDS_data );
					check_for_GL_errors( "glCompressedTexImage2D" );
					SOIL_free_image_data( DDS_data );
				} else
				{
					/*	my compression failed, try the OpenGL driver's version	*/
					glTexImage2D(
						opengl_texture_target, MIPlevel,
						internal_texture_format, MIPwidth, MIPheight, 0,
						original_texture_format, GL_UNSIGNED_BYTE, resampled );
					check_for_GL_errors( "glTexImage2D" );
				}
			} else
			{
				/*	user want OpenGL to do all the work!	*/
				glTexImage2D(
					opengl_texture_target, MIPlevel,
					internal_texture_format, MIPwidth, MIPheight, 0,
					original_texture_format, GL_UNSIGNED_BYTE, resampled );
				check_for_GL_errors( "glTexImage2D" );
			}
			/*	prep for the next level	*/
			++MIPlevel;
			MIPwidth = (MIPwidth + 1) / 2;
			MIPheight = (MIPheight + 1) / 2;
		}

		SOIL_free_image_data( resampled );
	}
}

unsigned int
	SOIL_internal_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags,
		unsigned int opengl_texture_type,
		unsigned int opengl_texture_target,
		unsigned int texture_check_size_enum
	)
{
	/*	variables	*/
	unsigned char* img = NULL;
	unsigned int tex_id;
	unsigned int internal_texture_format = 0, original_texture_format = 0;
	int DXT_mode = SOIL_CAPABILITY_UNKNOWN;
	int max_supported_size;
	int iwidth = *width;
	int iheight = *height;
	int needCopy;
	GLint unpack_aligment;

	/*	how large of a texture can this OpenGL implementation handle?	*/
	/*	texture_check_size_enum will be GL_MAX_TEXTURE_SIZE or SOIL_MAX_CUBE_MAP_TEXTURE_SIZE	*/
	glGetIntegerv( texture_check_size_enum, &max_supported_size );

	/*	If the user wants to use the texture rectangle I kill a few flags	*/
	if( flags & SOIL_FLAG_TEXTURE_RECTANGLE )
	{
		/*	well, the user asked for it, can we do that?	*/
		if( query_tex_rectangle_capability() == SOIL_CAPABILITY_PRESENT )
		{
			/*	only allow this if the user in _NOT_ trying to do a cubemap!	*/
			if( opengl_texture_type == GL_TEXTURE_2D )
			{
				/*	clean out the flags that cannot be used with texture rectangles	*/
				flags &= ~(
						SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS |
						SOIL_FLAG_TEXTURE_REPEATS
					);
				/*	and change my target	*/
				opengl_texture_target = SOIL_TEXTURE_RECTANGLE_ARB;
				opengl_texture_type = SOIL_TEXTURE_RECTANGLE_ARB;
			} else
			{
				/*	not allowed for any other uses (yes, I'm looking at you, cubemaps!)	*/
				flags &= ~SOIL_FLAG_TEXTURE_RECTANGLE;
			}

		} else
		{
			/*	can't do it, and that is a breakable offense (uv coords use pixels instead of [0,1]!)	*/
			result_string_pointer = "Texture Rectangle extension unsupported";
			return 0;
		}
	}

	/*	if the user can't support NPOT textures, make sure we force the POT option	*/
	if( (query_NPOT_capability() == SOIL_CAPABILITY_NONE) &&
		!(flags & SOIL_FLAG_TEXTURE_RECTANGLE) )
	{
		/*	add in the POT flag */
		flags |= SOIL_FLAG_POWER_OF_TWO;
	}

	needCopy = ( ( flags & SOIL_FLAG_INVERT_Y ) ||
				 ( flags & SOIL_FLAG_NTSC_SAFE_RGB ) ||
				 ( flags & SOIL_FLAG_MULTIPLY_ALPHA ) ||
				 ( flags & SOIL_FLAG_CoCg_Y )
				);

	/*	create a copy the image data only if needed */
	if ( needCopy ) {
		img = (unsigned char*)malloc( iwidth*iheight*channels );
		memcpy( img, data, iwidth*iheight*channels );
	}

	/*	does the user want me to invert the image?	*/
	if( flags & SOIL_FLAG_INVERT_Y )
	{
		int i, j;
		for( j = 0; j*2 < iheight; ++j )
		{
			int index1 = j * iwidth * channels;
			int index2 = (iheight - 1 - j) * iwidth * channels;
			for( i = iwidth * channels; i > 0; --i )
			{
				unsigned char temp = img[index1];
				img[index1] = img[index2];
				img[index2] = temp;
				++index1;
				++index2;
			}
		}
	}
	/*	does the user want me to scale the colors into the NTSC safe RGB range?	*/
	if( flags & SOIL_FLAG_NTSC_SAFE_RGB )
	{
		scale_image_RGB_to_NTSC_safe( img, iwidth, iheight, channels );
	}
	/*	does the user want me to convert from straight to pre-multiplied alpha?
		(and do we even _have_ alpha?)	*/
	if( flags & SOIL_FLAG_MULTIPLY_ALPHA )
	{
		int i;
		switch( channels )
		{
		case 2:
			for( i = 0; i < 2*iwidth*iheight; i += 2 )
			{
				img[i] = (img[i] * img[i+1] + 128) >> 8;
			}
			break;
		case 4:
			for( i = 0; i < 4*iwidth*iheight; i += 4 )
			{
				img[i+0] = (img[i+0] * img[i+3] + 128) >> 8;
				img[i+1] = (img[i+1] * img[i+3] + 128) >> 8;
				img[i+2] = (img[i+2] * img[i+3] + 128) >> 8;
			}
			break;
		default:
			/*	no other number of channels contains alpha data	*/
			break;
		}
	}

	/*	do I need to make it a power of 2?	*/
	if(
		( ( flags & SOIL_FLAG_POWER_OF_TWO) && ( !SOIL_IS_POW2(iwidth) || !SOIL_IS_POW2(iheight) ) ) ||	/*	user asked for it and the texture is not power of 2	*/
		( (flags & SOIL_FLAG_MIPMAPS)&& !( ( flags & SOIL_FLAG_GL_MIPMAPS ) &&
										   query_gen_mipmap_capability() == SOIL_CAPABILITY_PRESENT &&
										   query_NPOT_capability() == SOIL_CAPABILITY_PRESENT ) ) ||	/*	need it for the MIP-maps when mipmaps required
																											and not GL mipmaps required and supported	*/
		(iwidth > max_supported_size) ||		/*	it's too big, (make sure it's	*/
		(iheight > max_supported_size) )		/*	2^n for later down-sampling)	*/
	{
		int new_width = 1;
		int new_height = 1;
		while( new_width < iwidth )
		{
			new_width *= 2;
		}
		while( new_height < iheight )
		{
			new_height *= 2;
		}
		/*	still?	*/
		if( (new_width != iwidth) || (new_height != iheight) )
		{
			/*	yep, resize	*/
			unsigned char *resampled = (unsigned char*)malloc( channels*new_width*new_height );
			up_scale_image(
					NULL != img ? img : data, iwidth, iheight, channels,
					resampled, new_width, new_height );

			/*	nuke the old guy ( if a copy exists ), then point it at the new guy	*/
			SOIL_free_image_data( img );
			img = resampled;
			*width = new_width;
			*height = new_height;
			iwidth = new_width;
			iheight = new_height;
		}
	}
	/*	now, if it is too large...	*/
	if( (iwidth > max_supported_size) || (iheight > max_supported_size) )
	{
		/*	I've already made it a power of two, so simply use the MIPmapping
			code to reduce its size to the allowable maximum.	*/
		unsigned char *resampled;
		int reduce_block_x = 1, reduce_block_y = 1;
		int new_width, new_height;
		if( iwidth > max_supported_size )
		{
			reduce_block_x = iwidth / max_supported_size;
		}
		if( iheight > max_supported_size )
		{
			reduce_block_y = iheight / max_supported_size;
		}
		new_width = iwidth / reduce_block_x;
		new_height = iheight / reduce_block_y;
		resampled = (unsigned char*)malloc( channels*new_width*new_height );
		/*	perform the actual reduction	*/
		mipmap_image( NULL != img ? img : data, iwidth, iheight, channels,
						resampled, reduce_block_x, reduce_block_y );
		/*	nuke the old guy, then point it at the new guy	*/
		SOIL_free_image_data( img );
		img = resampled;
		*width = new_width;
		*height = new_height;
		iwidth = new_width;
		iheight = new_height;
	}
	/*	does the user want us to use YCoCg color space?	*/
	if( flags & SOIL_FLAG_CoCg_Y )
	{
		/*	this will only work with RGB and RGBA images */
		convert_RGB_to_YCoCg( img, iwidth, iheight, channels );
	}
	/*	create the OpenGL texture ID handle
		(note: allowing a forced texture ID lets me reload a texture)	*/
	tex_id = reuse_texture_ID;
	if( tex_id == 0 )
	{
		glGenTextures( 1, &tex_id );
	}
	check_for_GL_errors( "glGenTextures" );
	/* Note: sometimes glGenTextures fails (usually no OpenGL context)	*/
	if( tex_id )
	{
		/*	and what type am I using as the internal texture format?	*/
		switch( channels )
		{
		case 1:
			#if defined( SOIL_X11_PLATFORM ) || defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX )
			original_texture_format = isAtLeastGL3() ? GL_RED : GL_LUMINANCE;
			#else
			original_texture_format = GL_LUMINANCE;
			#endif
			break;
		case 2:
			#if defined( SOIL_X11_PLATFORM ) || defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX )
			original_texture_format = isAtLeastGL3() ? GL_RG : GL_LUMINANCE_ALPHA;
			#else
			original_texture_format = GL_LUMINANCE_ALPHA;
			#endif
			break;
		case 3:
			original_texture_format = GL_RGB;
			break;
		case 4:
			original_texture_format = GL_RGBA;
			break;
		}
		internal_texture_format = original_texture_format;
		/*	does the user want me to, and can I, save as DXT?	*/
		if( flags & SOIL_FLAG_COMPRESS_TO_DXT )
		{
			DXT_mode = query_DXT_capability();
			if( DXT_mode == SOIL_CAPABILITY_PRESENT )
			{
				/*	I can use DXT, whether I compress it or OpenGL does	*/
				if( (channels & 1) == 1 )
				{
					/*	1 or 3 channels = DXT1	*/
					internal_texture_format = SOIL_RGB_S3TC_DXT1;
				} else
				{
					/*	2 or 4 channels = DXT5	*/
					internal_texture_format = SOIL_RGBA_S3TC_DXT5;
				}
			}
		}
		/*  bind an OpenGL texture ID	*/
		glBindTexture( opengl_texture_type, tex_id );
		check_for_GL_errors( "glBindTexture" );

		/* set the unpack aligment */
		glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack_aligment);
		if ( 1 != unpack_aligment )
		{
			glPixelStorei(GL_UNPACK_ALIGNMENT,1);
		}

		/*  upload the main image	*/
		if( DXT_mode == SOIL_CAPABILITY_PRESENT )
		{
			/*	user wants me to do the DXT conversion!	*/
			int DDS_size;
			unsigned char *DDS_data = NULL;
			if( (channels & 1) == 1 )
			{
				/*	RGB, use DXT1	*/
				DDS_data = convert_image_to_DXT1( NULL != img ? img : data, iwidth, iheight, channels, &DDS_size );
			} else
			{
				/*	RGBA, use DXT5	*/
				DDS_data = convert_image_to_DXT5( NULL != img ? img : data, iwidth, iheight, channels, &DDS_size );
			}
			if( DDS_data )
			{
				soilGlCompressedTexImage2D(
					opengl_texture_target, 0,
					internal_texture_format, iwidth, iheight, 0,
					DDS_size, DDS_data );
				check_for_GL_errors( "glCompressedTexImage2D" );
				SOIL_free_image_data( DDS_data );
				/*	printf( "Internal DXT compressor\n" );	*/
			} else
			{
				/*	my compression failed, try the OpenGL driver's version	*/
				glTexImage2D(
					opengl_texture_target, 0,
					internal_texture_format, iwidth, iheight, 0,
					original_texture_format, GL_UNSIGNED_BYTE, NULL != img ? img : data );
				check_for_GL_errors( "glTexImage2D" );
				/*	printf( "OpenGL DXT compressor\n" );	*/
			}
		} else
		{
			/*	user want OpenGL to do all the work!	*/
			glTexImage2D(
				opengl_texture_target, 0,
				internal_texture_format, iwidth, iheight, 0,
				original_texture_format, GL_UNSIGNED_BYTE, NULL != img ? img : data );

			check_for_GL_errors( "glTexImage2D" );
			/*printf( "OpenGL DXT compressor\n" );	*/
		}

		/*	are any MIPmaps desired?	*/
		if( flags & SOIL_FLAG_MIPMAPS || flags & SOIL_FLAG_GL_MIPMAPS )
		{
			createMipmaps( NULL != img ? img : data, iwidth, iheight, channels, flags, opengl_texture_target, internal_texture_format, original_texture_format, DXT_mode );

			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
			check_for_GL_errors( "GL_TEXTURE_MIN/MAG_FILTER" );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
			check_for_GL_errors( "GL_TEXTURE_MIN/MAG_FILTER" );
		}

		/* recover the unpack aligment */
		if ( 1 != unpack_aligment )
		{
			glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
		}

		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			if( opengl_texture_type == SOIL_TEXTURE_CUBE_MAP )
			{
				/*	SOIL_TEXTURE_WRAP_R is invalid if cubemaps aren't supported	*/
				glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
			}
			check_for_GL_errors( "GL_TEXTURE_WRAP_*" );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			if( opengl_texture_type == SOIL_TEXTURE_CUBE_MAP )
			{
				/*	SOIL_TEXTURE_WRAP_R is invalid if cubemaps aren't supported	*/
				glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
			}
			check_for_GL_errors( "GL_TEXTURE_WRAP_*" );
		}
		/*	done	*/
		result_string_pointer = "Image loaded as an OpenGL texture";
	} else
	{
		/*	failed	*/
		result_string_pointer = "Failed to generate an OpenGL texture name; missing OpenGL context?";
	}

	SOIL_free_image_data( img );

	return tex_id;
}

int
	SOIL_save_screenshot
	(
		const char *filename,
		int image_type,
		int x, int y,
		int width, int height
	)
{
	unsigned char *pixel_data;
	int i, j;
	int save_result;

	/*	error checks	*/
	if( (width < 1) || (height < 1) )
	{
		result_string_pointer = "Invalid screenshot dimensions";
		return 0;
	}
	if( (x < 0) || (y < 0) )
	{
		result_string_pointer = "Invalid screenshot location";
		return 0;
	}
	if( filename == NULL )
	{
		result_string_pointer = "Invalid screenshot filename";
		return 0;
	}

	/*  Get the data from OpenGL	*/
	pixel_data = (unsigned char*)malloc( 3*width*height );
	glReadPixels (x, y, width, height, GL_RGB, GL_UNSIGNED_BYTE, pixel_data);

	/*	invert the image	*/
	for( j = 0; j*2 < height; ++j )
	{
		int index1 = j * width * 3;
		int index2 = (height - 1 - j) * width * 3;
		for( i = width * 3; i > 0; --i )
		{
			unsigned char temp = pixel_data[index1];
			pixel_data[index1] = pixel_data[index2];
			pixel_data[index2] = temp;
			++index1;
			++index2;
		}
	}

	/*	save the image	*/
	save_result = SOIL_save_image( filename, image_type, width, height, 3, pixel_data);

	/*	And free the memory	*/
	SOIL_free_image_data( pixel_data );
	return save_result;
}

unsigned char*
	SOIL_load_image
	(
		const char *filename,
		int *width, int *height, int *channels,
		int force_channels
	)
{
	unsigned char *result = stbi_load( filename,
			width, height, channels, force_channels );
	if( result == NULL )
	{
		result_string_pointer = stbi_failure_reason();
	} else
	{
		result_string_pointer = "Image loaded";
	}
	return result;
}

unsigned char*
	SOIL_load_image_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int *width, int *height, int *channels,
		int force_channels
	)
{
	unsigned char *result = stbi_load_from_memory(
				buffer, buffer_length,
				width, height, channels,
				force_channels );
	if( result == NULL )
	{
		result_string_pointer = stbi_failure_reason();
	} else
	{
		result_string_pointer = "Image loaded from memory";
	}
	return result;
}

int
	SOIL_save_image
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data
	)
{
	int save_result;

	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (channels > 4) ||
		(data == NULL) ||
		(filename == NULL) )
	{
		return 0;
	}
	if( image_type == SOIL_SAVE_TYPE_BMP )
	{
		save_result = stbi_write_bmp( filename,
				width, height, channels, (void*)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_TGA )
	{
		save_result = stbi_write_tga( filename,
				width, height, channels, (void*)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_DDS )
	{
		save_result = save_image_as_DDS( filename,
				width, height, channels, (const unsigned char *const)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_PNG )
	{
		save_result = stbi_write_png( filename,
				width, height, channels, (const unsigned char *const)data, 0 );
	} else
	{
		save_result = 0;
	}

	if( save_result == 0 )
	{
		result_string_pointer = "Saving the image failed";
	} else
	{
		result_string_pointer = "Image saved";
	}
	return save_result;
}

void
	SOIL_free_image_data
	(
		unsigned char *img_data
	)
{
	if ( img_data )
		free( (void*)img_data );
}

const char*
	SOIL_last_result
	(
		void
	)
{
	return result_string_pointer;
}

unsigned int SOIL_direct_load_DDS_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	/*	variables	*/
	DDS_header header;
	unsigned int buffer_index = 0;
	unsigned int tex_ID = 0;
	/*	file reading variables	*/
	unsigned int S3TC_type = 0;
	unsigned char *DDS_data;
	unsigned int DDS_main_size;
	unsigned int DDS_full_size;
	unsigned int width, height;
	int mipmaps, cubemap, uncompressed, block_size = 16;
	unsigned int flag;
	unsigned int cf_target, ogl_target_start, ogl_target_end;
	unsigned int opengl_texture_type;
	int i;
	/*	1st off, does the filename even exist?	*/
	if( NULL == buffer )
	{
		/*	we can't do it!	*/
		result_string_pointer = "NULL buffer";
		return 0;
	}
	if( buffer_length < sizeof( DDS_header ) )
	{
		/*	we can't do it!	*/
		result_string_pointer = "DDS file was too small to contain the DDS header";
		return 0;
	}
	/*	try reading in the header	*/
	memcpy ( (void*)(&header), (const void *)buffer, sizeof( DDS_header ) );
	buffer_index = sizeof( DDS_header );
	/*	guilty until proven innocent	*/
	result_string_pointer = "Failed to read a known DDS header";
	/*	validate the header (warning, "goto"'s ahead, shield your eyes!!)	*/
	flag = ('D'<<0)|('D'<<8)|('S'<<16)|(' '<<24);
	if( header.dwMagic != flag ) {goto quick_exit;}
	if( header.dwSize != 124 ) {goto quick_exit;}
	/*	I need all of these	*/
	flag = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flag) != flag ) {goto quick_exit;}
	/*	According to the MSDN spec, the dwFlags should contain
		DDSD_LINEARSIZE if it's compressed, or DDSD_PITCH if
		uncompressed.  Some DDS writers do not conform to the
		spec, so I need to make my reader more tolerant	*/
	/*	I need one of these	*/
	flag = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flag) == 0 ) {goto quick_exit;}
	if( header.sPixelFormat.dwSize != 32 ) {goto quick_exit;}
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) {goto quick_exit;}
	/*	make sure it is a type we can upload	*/
	if( (header.sPixelFormat.dwFlags & DDPF_FOURCC) &&
		!(
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('1'<<24))) ||
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('3'<<24))) ||
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('5'<<24)))
		) )
	{
		goto quick_exit;
	}
	/*	OK, validated the header, let's load the image data	*/
	result_string_pointer = "DDS header loaded and validated";
	width = header.dwWidth;
	height = header.dwHeight;
	uncompressed = 1 - (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	cubemap = (header.sCaps.dwCaps2 & DDSCAPS2_CUBEMAP) / DDSCAPS2_CUBEMAP;
	if( uncompressed )
	{
		S3TC_type = GL_RGB;
		block_size = 3;
		if( header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS )
		{
			S3TC_type = GL_RGBA;
			block_size = 4;
		}
		DDS_main_size = width * height * block_size;
	} else
	{
		/*	can we even handle direct uploading to OpenGL DXT compressed images?	*/
		if( query_DXT_capability() != SOIL_CAPABILITY_PRESENT )
		{
			/*	we can't do it!	*/
			result_string_pointer = "Direct upload of S3TC images not supported by the OpenGL driver";
			return 0;
		}
		/*	well, we know it is DXT1/3/5, because we checked above	*/
		switch( (header.sPixelFormat.dwFourCC >> 24) - '0' )
		{
		case 1:
			S3TC_type = SOIL_RGBA_S3TC_DXT1;
			block_size = 8;
			break;
		case 3:
			S3TC_type = SOIL_RGBA_S3TC_DXT3;
			block_size = 16;
			break;
		case 5:
			S3TC_type = SOIL_RGBA_S3TC_DXT5;
			block_size = 16;
			break;
		}
		DDS_main_size = ((width+3)>>2)*((height+3)>>2)*block_size;
	}
	if( cubemap )
	{
		/* does the user want a cubemap?	*/
		if( !loading_as_cubemap )
		{
			/*	we can't do it!	*/
			result_string_pointer = "DDS image was a cubemap";
			return 0;
		}
		/*	can we even handle cubemaps with the OpenGL driver?	*/
		if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
		{
			/*	we can't do it!	*/
			result_string_pointer = "Direct upload of cubemap images not supported by the OpenGL driver";
			return 0;
		}
		ogl_target_start = SOIL_TEXTURE_CUBE_MAP_POSITIVE_X;
		ogl_target_end =   SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
		opengl_texture_type = SOIL_TEXTURE_CUBE_MAP;
	} else
	{
		/* does the user want a non-cubemap?	*/
		if( loading_as_cubemap )
		{
			/*	we can't do it!	*/
			result_string_pointer = "DDS image was not a cubemap";
			return 0;
		}
		ogl_target_start = GL_TEXTURE_2D;
		ogl_target_end =   GL_TEXTURE_2D;
		opengl_texture_type = GL_TEXTURE_2D;
	}
	if( (header.sCaps.dwCaps1 & DDSCAPS_MIPMAP) && (header.dwMipMapCount > 1) )
	{
		int shift_offset;
		mipmaps = header.dwMipMapCount - 1;
		DDS_full_size = DDS_main_size;
		if( uncompressed )
		{
			/*	uncompressed DDS, simple MIPmap size calculation	*/
			shift_offset = 0;
		} else
		{
			/*	compressed DDS, MIPmap size calculation is block based	*/
			shift_offset = 2;
		}
		for( i = 1; i <= mipmaps; ++ i )
		{
			int w, h;
			w = width >> (shift_offset + i);
			h = height >> (shift_offset + i);
			if( w < 1 )
			{
				w = 1;
			}
			if( h < 1 )
			{
				h = 1;
			}
			DDS_full_size += w*h*block_size;
		}
	} else
	{
		mipmaps = 0;
		DDS_full_size = DDS_main_size;
	}
	DDS_data = (unsigned char*)malloc( DDS_full_size );
	/*	got the image data RAM, create or use an existing OpenGL texture handle	*/
	tex_ID = reuse_texture_ID;
	if( tex_ID == 0 )
	{
		glGenTextures( 1, &tex_ID );
	}
	/*  bind an OpenGL texture ID	*/
	glBindTexture( opengl_texture_type, tex_ID );
	/*	do this for each face of the cubemap!	*/
	for( cf_target = ogl_target_start; cf_target <= ogl_target_end; ++cf_target )
	{
		if( buffer_index + DDS_full_size <= (unsigned int)buffer_length )
		{
			unsigned int byte_offset = DDS_main_size;
			memcpy( (void*)DDS_data, (const void*)(&buffer[buffer_index]), DDS_full_size );
			buffer_index += DDS_full_size;
			/*	upload the main chunk	*/
			if( uncompressed )
			{
				/*	and remember, DXT uncompressed uses BGR(A),
					so swap to RGB(A) for ALL MIPmap levels	*/
				for( i = 0; i < (int)DDS_full_size; i += block_size )
				{
					unsigned char temp = DDS_data[i];
					DDS_data[i] = DDS_data[i+2];
					DDS_data[i+2] = temp;
				}
				glTexImage2D(
					cf_target, 0,
					S3TC_type, width, height, 0,
					S3TC_type, GL_UNSIGNED_BYTE, DDS_data );
			} else
			{
				soilGlCompressedTexImage2D(
					cf_target, 0,
					S3TC_type, width, height, 0,
					DDS_main_size, DDS_data );
			}
			/*	upload the mipmaps, if we have them	*/
			for( i = 1; i <= mipmaps; ++i )
			{
				int w, h, mip_size;
				w = width >> i;
				h = height >> i;
				if( w < 1 )
				{
					w = 1;
				}
				if( h < 1 )
				{
					h = 1;
				}
				/*	upload this mipmap	*/
				if( uncompressed )
				{
					mip_size = w*h*block_size;
					glTexImage2D(
						cf_target, i,
						S3TC_type, w, h, 0,
						S3TC_type, GL_UNSIGNED_BYTE, &DDS_data[byte_offset] );
				} else
				{
					mip_size = ((w+3)/4)*((h+3)/4)*block_size;
					soilGlCompressedTexImage2D(
						cf_target, i,
						S3TC_type, w, h, 0,
						mip_size, &DDS_data[byte_offset] );
				}
				/*	and move to the next mipmap	*/
				byte_offset += mip_size;
			}
			/*	it worked!	*/
			result_string_pointer = "DDS file loaded";
		} else
		{
			glDeleteTextures( 1, & tex_ID );
			tex_ID = 0;
			cf_target = ogl_target_end + 1;
			result_string_pointer = "DDS file was too small for expected image data";
		}
	}/* end reading each face */
	SOIL_free_image_data( DDS_data );
	if( tex_ID )
	{
		/*	did I have MIPmaps?	*/
		if( mipmaps > 0 )
		{
			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
		}
		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
		}
	}

quick_exit:
	/*	report success or failure	*/
	return tex_ID;
}

unsigned int SOIL_direct_load_DDS(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	FILE *f;
	unsigned char *buffer;
	size_t buffer_length, bytes_read;
	unsigned int tex_ID = 0;
	/*	error checks	*/
	if( NULL == filename )
	{
		result_string_pointer = "NULL filename";
		return 0;
	}
	f = fopen( filename, "rb" );
	if( NULL == f )
	{
		/*	the file doesn't seem to exist (or be open-able)	*/
		result_string_pointer = "Can not find DDS file";
		return 0;
	}
	fseek( f, 0, SEEK_END );
	buffer_length = ftell( f );
	fseek( f, 0, SEEK_SET );
	buffer = (unsigned char *) malloc( buffer_length );
	if( NULL == buffer )
	{
		result_string_pointer = "malloc failed";
		fclose( f );
		return 0;
	}
	bytes_read = fread( (void*)buffer, 1, buffer_length, f );
	fclose( f );
	if( bytes_read < buffer_length )
	{
		/*	huh?	*/
		buffer_length = bytes_read;
	}
	/*	now try to do the loading	*/
	tex_ID = SOIL_direct_load_DDS_from_memory(
		(const unsigned char *const)buffer, (int)buffer_length,
		reuse_texture_ID, flags, loading_as_cubemap );
	SOIL_free_image_data( buffer );
	return tex_ID;
}

unsigned int SOIL_direct_load_PVR_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	PVR_Texture_Header* header = (PVR_Texture_Header*)buffer;
	int num_surfs = 1;
	GLuint tex_ID = 0;
	GLenum PVR_format = 0;
	GLenum PVR_type = GL_RGB;
	unsigned int opengl_texture_type = loading_as_cubemap ? SOIL_TEXTURE_CUBE_MAP : GL_TEXTURE_2D;
	int is_PVRTC_supported = query_PVR_capability() == SOIL_CAPABILITY_PRESENT;
	int is_BGRA8888_supported  = query_BGRA8888_capability() == SOIL_CAPABILITY_PRESENT;
	int is_compressed_format_supported = 0;
	int is_compressed_format = 0;
	int mipmaps = 0;
	int i;
	GLint unpack_aligment;

	// Check the header size
	if ( header->dwHeaderSize != sizeof(PVR_Texture_Header) ) {
		if ( header->dwHeaderSize == PVRTEX_V1_HEADER_SIZE ) {
			result_string_pointer = "this is an old pvr ( update the PVR file )";

			if ( loading_as_cubemap ) {
				if( header->dwpfFlags & PVRTEX_CUBEMAP ) {
					num_surfs = 6;
				} else {
					result_string_pointer = "tried to load a non-cubemap PVR as cubemap";
					return 0;
				}
			}
		} else {
			result_string_pointer = "invalid PVR header";

			return 0;
		}
	} else {
		if ( loading_as_cubemap ) {
			// Header V2
			if( header->dwNumSurfs < 1 ) {
				if( header->dwpfFlags & PVRTEX_CUBEMAP ) {
					num_surfs = 6;
				} else {
					result_string_pointer = "tried to load a non-cubemap PVR as cubemap";
					return 0;
				}
			} else {
				num_surfs = header->dwNumSurfs;
			}
		}
	}

	// Check the magic identifier
	if ( header->dwPVR != PVRTEX_IDENTIFIER ) {
		result_string_pointer = "invalid PVR header";
		return 0;
	}

	/* Only accept untwiddled data UNLESS texture format is PVRTC */
	if ( ((header->dwpfFlags & PVRTEX_TWIDDLE) == PVRTEX_TWIDDLE)
		&& ((header->dwpfFlags & PVRTEX_PIXELTYPE)!=OGL_PVRTC2)
		&& ((header->dwpfFlags & PVRTEX_PIXELTYPE)!=OGL_PVRTC4) )
	{
		// We need to load untwiddled textures -- hw will twiddle for us.
		result_string_pointer = "pvr is not compressed ( untwiddled texture )";
		return 0;
	}

	switch( header->dwpfFlags & PVRTEX_PIXELTYPE )
	{
		case OGL_RGBA_4444:
			PVR_format = GL_UNSIGNED_SHORT_4_4_4_4;
			PVR_type = GL_RGBA;
			break;
		case OGL_RGBA_5551:
			PVR_format = GL_UNSIGNED_SHORT_5_5_5_1;
			PVR_type = GL_RGBA;
			break;
		case OGL_RGBA_8888:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_RGBA;
			break;
		case OGL_RGB_565:
			PVR_format = GL_UNSIGNED_SHORT_5_6_5;
			PVR_type = GL_RGB;
			break;
		case OGL_RGB_555:
			result_string_pointer = "failed: pixel type OGL_RGB_555 not supported.";
			return 0;
		case OGL_RGB_888:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_RGB;
			break;
		case OGL_I_8:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_LUMINANCE;
			break;
		case OGL_AI_88:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_LUMINANCE_ALPHA;
			break;
		case MGLPT_PVRTC2:
		case OGL_PVRTC2:
			if(is_PVRTC_supported) {
				is_compressed_format_supported = is_compressed_format = 1;
				PVR_format = header->dwAlphaBitMask==0 ? SOIL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG : SOIL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG ;	// PVRTC2
			} else {
				result_string_pointer = "error: PVRTC2 not supported.Decompress the texture first.";
				return 0;
			}
			break;
		case MGLPT_PVRTC4:
		case OGL_PVRTC4:
			if(is_PVRTC_supported) {
				is_compressed_format_supported = is_compressed_format = 1;
				PVR_format = header->dwAlphaBitMask==0 ? SOIL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG : SOIL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG ;	// PVRTC4
			} else {
				result_string_pointer = "error: PVRTC4 not supported. Decompress the texture first.";
				return 0;
			}
			break;
		case OGL_BGRA_8888:
			if(is_BGRA8888_supported) {
				PVR_format = GL_UNSIGNED_BYTE;
				PVR_type   = GL_BGRA;
				break;
			} else {
				result_string_pointer = "Unable to load GL_BGRA texture as extension GL_IMG_texture_format_BGRA8888 is unsupported.";
				return 0;
			}
		default:											// NOT SUPPORTED
			result_string_pointer = "failed: pixel type not supported.";
			return 0;
	}

	#ifdef SOIL_GLES1
	//  check that this data is cube map data or not.
	if( loading_as_cubemap ) {
		result_string_pointer = "cube map textures are not available in GLES1.x.";
		return 0;
	}
	#endif

	// load the texture up
	tex_ID = reuse_texture_ID;
	if( tex_ID == 0 )
	{
		glGenTextures( 1, &tex_ID );
	}

	glBindTexture( opengl_texture_type, tex_ID );

	if( glGetError() ) {
		result_string_pointer = "failed: glBindTexture() failed.";
		return 0;
	}

	glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack_aligment);
	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT,1);				// Never have row-aligned in headers
	}

	#define _MAX( a, b ) (( a <= b )? b : a)
	for(i=0; i<num_surfs; i++) {
		char *texture_ptr = (char*)buffer + header->dwHeaderSize + header->dwTextureDataSize * i;
		char *cur_texture_ptr = 0;
		int	mipmap_level;
		unsigned int width= header->dwWidth, height = header->dwHeight;
		unsigned int compressed_image_size = 0;

		mipmaps = ( ( flags & SOIL_FLAG_MIPMAPS ) && (header->dwpfFlags & PVRTEX_MIPMAP) ) ? header->dwMipMapCount : 0;

		for(mipmap_level = 0; mipmap_level <= mipmaps; width = _MAX(width/2, (unsigned int)1), height = _MAX(height/2, (unsigned int)1), mipmap_level++ ) {
			// Do Alpha-swap if needed
			cur_texture_ptr = texture_ptr;

			// Load the Texture
			/* If the texture is PVRTC then use GLCompressedTexImage2D */
			if( is_compressed_format ) {
				/* Calculate how many bytes this MIP level occupies */
				if ((header->dwpfFlags & PVRTEX_PIXELTYPE)==OGL_PVRTC2) {
					compressed_image_size = ( _MAX(width, PVRTC2_MIN_TEXWIDTH) * _MAX(height, PVRTC2_MIN_TEXHEIGHT) * header->dwBitCount + 7 ) / 8;
				} else {// PVRTC4 case
					compressed_image_size = ( _MAX(width, PVRTC4_MIN_TEXWIDTH) * _MAX(height, PVRTC4_MIN_TEXHEIGHT) * header->dwBitCount + 7 ) / 8;
				}

				if ( is_compressed_format_supported ) {
					/* Load compressed texture data at selected MIP level */
					if ( loading_as_cubemap ) {
						soilGlCompressedTexImage2D( SOIL_TEXTURE_CUBE_MAP_POSITIVE_X + i, mipmap_level, PVR_format, width, height, 0, compressed_image_size, cur_texture_ptr );
					} else {
						soilGlCompressedTexImage2D( opengl_texture_type, mipmap_level, PVR_format, width, height, 0, compressed_image_size, cur_texture_ptr );
					}
				} else {
					result_string_pointer = "failed: GPU doesnt support compressed textures";
				}
			} else {
				/* Load uncompressed texture data at selected MIP level */
				if ( loading_as_cubemap ) {
					glTexImage2D( SOIL_TEXTURE_CUBE_MAP_POSITIVE_X + i, mipmap_level, PVR_type, width, height, 0, PVR_type, PVR_format, cur_texture_ptr );
				} else {
					glTexImage2D( opengl_texture_type, mipmap_level, PVR_type, width, height, 0, PVR_type, PVR_format, cur_texture_ptr );
				}
			}

			if( glGetError() ) {
				result_string_pointer = "failed: glCompressedTexImage2D() failed.";
				if ( 1 != unpack_aligment )
				{
					glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
				}
				return 0;
			}

			// offset the texture pointer by one mip-map level
			/* PVRTC case */
			if ( is_compressed_format ) {
				texture_ptr += compressed_image_size;
			} else {
				/* New formula that takes into account bit counts inferior to 8 (e.g. 1 bpp) */
				texture_ptr += (width * height * header->dwBitCount + 7) / 8;
			}
		}
	}
	#undef _MAX

	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
	}

	if( tex_ID )
	{
		/*	did I have MIPmaps?	*/
		if( mipmaps )
		{
			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
		}

		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
		}
	}

	return tex_ID;
}

unsigned int SOIL_direct_load_PVR(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	FILE *f;
	unsigned char *buffer;
	size_t buffer_length, bytes_read;
	unsigned int tex_ID = 0;
	/*	error checks	*/
	if( NULL == filename )
	{
		result_string_pointer = "NULL filename";
		return 0;
	}
	f = fopen( filename, "rb" );
	if( NULL == f )
	{
		/*	the file doesn't seem to exist (or be open-able)	*/
		result_string_pointer = "Can not find PVR file";
		return 0;
	}
	fseek( f, 0, SEEK_END );
	buffer_length = ftell( f );
	fseek( f, 0, SEEK_SET );
	buffer = (unsigned char *) malloc( buffer_length );
	if( NULL == buffer )
	{
		result_string_pointer = "malloc failed";
		fclose( f );
		return 0;
	}
	bytes_read = fread( (void*)buffer, 1, buffer_length, f );
	fclose( f );
	if( bytes_read < buffer_length )
	{
		/*	huh?	*/
		buffer_length = bytes_read;
	}
	/*	now try to do the loading	*/
	tex_ID = SOIL_direct_load_PVR_from_memory(
		(const unsigned char *const)buffer, (int)buffer_length,
		reuse_texture_ID, flags, loading_as_cubemap );
	SOIL_free_image_data( buffer );
	return tex_ID;
}

unsigned int SOIL_direct_load_ETC1_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags )
{
	GLuint tex_ID = 0;
	PKMHeader* header = (PKMHeader*)buffer;
	unsigned int opengl_texture_type = GL_TEXTURE_2D;
	unsigned int width;
	unsigned int height;
	unsigned long compressed_image_size = buffer_length - PKM_HEADER_SIZE;
	char *texture_ptr = (char*)buffer + PKM_HEADER_SIZE;
	GLint unpack_aligment;

	if ( query_ETC1_capability() != SOIL_CAPABILITY_PRESENT ) {
		result_string_pointer = "error: ETC1 not supported. Decompress the texture first.";
		return 0;
	}

	if ( 0 != strcmp( header->aName, "PKM 10" ) ) {
		result_string_pointer = "error: PKM 10 header not found.";
		return 0;
	}

	width = (header->iWidthMSB << 8) | header->iWidthLSB;
	height = (header->iHeightMSB << 8) | header->iHeightLSB;
	compressed_image_size = (((width + 3) & ~3) * ((height + 3) & ~3)) >> 1;

	// load the texture up
	tex_ID = reuse_texture_ID;
	if( tex_ID == 0 )
	{
		glGenTextures( 1, &tex_ID );
	}

	glBindTexture( opengl_texture_type, tex_ID );

	if( glGetError() ) {
		result_string_pointer = "failed: glBindTexture() failed.";
		return 0;
	}

	glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack_aligment);
	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT,1);				// Never have row-aligned in headers
	}

	soilGlCompressedTexImage2D( opengl_texture_type, 0, SOIL_GL_ETC1_RGB8_OES, width, height, 0, compressed_image_size, texture_ptr );

	if( glGetError() ) {
		result_string_pointer = "failed: glCompressedTexImage2D() failed.";

		if ( 1 != unpack_aligment )
		{
			glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
		}
		return 0;
	}

	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
	}

	if( tex_ID )
	{
		/* No MIPmaps for ETC1 */
		glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
		glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );

		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
		}
	}

	return tex_ID;
}

unsigned int SOIL_direct_load_ETC1(const char *filename,
		unsigned int reuse_texture_ID,
		int flags )
{
	FILE *f;
	unsigned char *buffer;
	size_t buffer_length, bytes_read;
	unsigned int tex_ID = 0;
	/*	error checks	*/
	if( NULL == filename )
	{
		result_string_pointer = "NULL filename";
		return 0;
	}
	f = fopen( filename, "rb" );
	if( NULL == f )
	{
		/*	the file doesn't seem to exist (or be open-able)	*/
		result_string_pointer = "Can not find PVR file";
		return 0;
	}
	fseek( f, 0, SEEK_END );
	buffer_length = ftell( f );
	fseek( f, 0, SEEK_SET );
	buffer = (unsigned char *) malloc( buffer_length );
	if( NULL == buffer )
	{
		result_string_pointer = "malloc failed";
		fclose( f );
		return 0;
	}
	bytes_read = fread( (void*)buffer, 1, buffer_length, f );
	fclose( f );
	if( bytes_read < buffer_length )
	{
		/*	huh?	*/
		buffer_length = bytes_read;
	}
	/*	now try to do the loading	*/
	tex_ID = SOIL_direct_load_ETC1_from_memory(
		(const unsigned char *const)buffer, (int)buffer_length,
		reuse_texture_ID, flags );
	SOIL_free_image_data( buffer );
	return tex_ID;
}

int query_NPOT_capability( void )
{
	/*	check for the capability	*/
	if( has_NPOT_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(0 == SOIL_GL_ExtensionSupported(
				"GL_ARB_texture_non_power_of_two" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_OES_texture_npot" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_NPOT_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_NPOT_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do non-power-of-two textures or not	*/
	return has_NPOT_capability;
}

int query_tex_rectangle_capability( void )
{
	/*	check for the capability	*/
	if( has_tex_rectangle_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(0 == SOIL_GL_ExtensionSupported(
				"GL_ARB_texture_rectangle" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_EXT_texture_rectangle" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_NV_texture_rectangle" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_tex_rectangle_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_tex_rectangle_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do texture rectangles or not	*/
	return has_tex_rectangle_capability;
}

int query_cubemap_capability( void )
{
	/*	check for the capability	*/
	if( has_cubemap_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(0 == SOIL_GL_ExtensionSupported(
				"GL_ARB_texture_cube_map" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_EXT_texture_cube_map" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_cubemap_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_cubemap_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_cubemap_capability;
}

static P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC get_glCompressedTexImage2D_addr()
{
	/*	and find the address of the extension function	*/
	P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC ext_addr = NULL;

#if defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX ) || defined( SOIL_X11_PLATFORM )
	ext_addr = (P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC)SOIL_GL_GetProcAddress( "glCompressedTexImage2D" );
#else
	ext_addr = (P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC)&glCompressedTexImage2D;
#endif

	return ext_addr;
}

int query_DXT_capability( void )
{
	/*	check for the capability	*/
	if( has_DXT_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (	0 == SOIL_GL_ExtensionSupported(
					"GL_EXT_texture_compression_s3tc" )  &&
				0 == SOIL_GL_ExtensionSupported(
					"WEBGL_compressed_texture_s3tc ") &&
				0 == SOIL_GL_ExtensionSupported(
					"WEBKIT_WEBGL_compressed_texture_s3tc") &&
				0 == SOIL_GL_ExtensionSupported(
					"MOZ_WEBGL_compressed_texture_s3tc"
				)
			)
		{
			/*	not there, flag the failure	*/
			has_DXT_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC ext_addr = get_glCompressedTexImage2D_addr();

			/*	Flag it so no checks needed later	*/
			if( NULL == ext_addr )
			{
				/*	hmm, not good!!  This should not happen, but does on my
					laptop's VIA chipset.  The GL_EXT_texture_compression_s3tc
					spec requires that ARB_texture_compression be present too.
					this means I can upload and have the OpenGL drive do the
					conversion, but I can't use my own routines or load DDS files
					from disk and upload them directly [8^(	*/
				has_DXT_capability = SOIL_CAPABILITY_NONE;
			} else
			{
				/*	all's well!	*/
				soilGlCompressedTexImage2D = ext_addr;
				has_DXT_capability = SOIL_CAPABILITY_PRESENT;
			}
		}
	}
	/*	let the user know if we can do DXT or not	*/
	return has_DXT_capability;
}

int query_PVR_capability( void )
{
	/*	check for the capability	*/
	if( has_PVR_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (0 == SOIL_GL_ExtensionSupported(
				"GL_IMG_texture_compression_pvrtc" ) )
		{
			/*	not there, flag the failure	*/
			has_PVR_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			if ( NULL == soilGlCompressedTexImage2D ) {
				soilGlCompressedTexImage2D = get_glCompressedTexImage2D_addr();
			}

			/*	it's there!	*/
			has_PVR_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_PVR_capability;
}

int query_BGRA8888_capability( void )
{
	/*	check for the capability	*/
	if( has_BGRA8888_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (0 == SOIL_GL_ExtensionSupported(
				"GL_IMG_texture_format_BGRA8888" ) )
		{
			/*	not there, flag the failure	*/
			has_BGRA8888_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_BGRA8888_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_BGRA8888_capability;
}

int query_ETC1_capability( void )
{
	/*	check for the capability	*/
	if( has_ETC1_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (0 == SOIL_GL_ExtensionSupported(
				"GL_OES_compressed_ETC1_RGB8_texture" ) )
		{
			/*	not there, flag the failure	*/
			has_ETC1_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			if ( NULL == soilGlCompressedTexImage2D ) {
				soilGlCompressedTexImage2D = get_glCompressedTexImage2D_addr();
			}

			/*	it's there!	*/
			has_ETC1_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_ETC1_capability;
}

int query_gen_mipmap_capability( void )
{
	/* check for the capability   */
	P_SOIL_GLGENERATEMIPMAPPROC ext_addr = NULL;

	if( has_gen_mipmap_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		if (	0 == SOIL_GL_ExtensionSupported(
					"GL_ARB_framebuffer_object" )
			&&
				0 == SOIL_GL_ExtensionSupported(
					"GL_EXT_framebuffer_object" )
			&&  0 == SOIL_GL_ExtensionSupported(
					"GL_OES_framebuffer_object" )
			)
		{
			/* not there, flag the failure */
			has_gen_mipmap_capability = SOIL_CAPABILITY_NONE;
		}
		else
		{
			#if !defined( SOIL_GLES1 ) && !defined( SOIL_GLES2 )

			ext_addr = (P_SOIL_GLGENERATEMIPMAPPROC)SOIL_GL_GetProcAddress("glGenerateMipmap");

			if(ext_addr == NULL)
			{
				ext_addr = (P_SOIL_GLGENERATEMIPMAPPROC)SOIL_GL_GetProcAddress("glGenerateMipmapEXT");
			}

			#elif defined( SOIL_GLES2 )
				ext_addr = 	&glGenerateMipmap;
			#else /** SOIL_GLES1 */
				ext_addr = &glGenerateMipmapOES;
			#endif
		}

		if(ext_addr == NULL)
		{
			/* this should never happen */
			has_gen_mipmap_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/* it's there! */
			has_gen_mipmap_capability = SOIL_CAPABILITY_PRESENT;
			soilGlGenerateMipmap = ext_addr;
		}
	}

	return has_gen_mipmap_capability;
}

#endif


//#line 1 "BitScale.cpp"

//#line 1 "BitScale.h"
#ifndef JTHLIM_BITSCALE_H
#define JTHLIM_BITSCALE_H

#include <cstdint>

namespace Javelin
{
  namespace Data
  {

	extern const uint8_t BITSCALE_5_TO_8[32];
	extern const uint8_t BITSCALE_4_TO_8[16];
	extern const uint8_t BITSCALE_3_TO_8[8];
	extern const uint8_t BITSCALE_8_TO_5_FLOOR[256];
	extern const uint8_t BITSCALE_8_TO_4_FLOOR[256];
	extern const uint8_t BITSCALE_8_TO_3_FLOOR[256];
	extern const uint8_t BITSCALE_8_TO_5_CEIL[256];
	extern const uint8_t BITSCALE_8_TO_4_CEIL[256];
	extern const uint8_t BITSCALE_8_TO_3_CEIL[256];

  } // namespace Data
} // namespace Javelin

#endif

const uint8_t Javelin::Data::BITSCALE_5_TO_8[32] = {
 0, 8, 16, 24, 32, 41, 49, 57, 65, 74,
 82, 90, 98, 106, 115, 123, 131, 139, 148, 156,
 164, 172, 180, 189, 197, 205, 213, 222, 230, 238,
 246, 255};

const uint8_t Javelin::Data::BITSCALE_4_TO_8[16] = {
 0, 17, 34, 51, 68, 85, 102, 119, 136, 153,
 170, 187, 204, 221, 238, 255};

const uint8_t Javelin::Data::BITSCALE_3_TO_8[8] = {
 0, 36, 72, 109, 145, 182, 218, 255};

const uint8_t Javelin::Data::BITSCALE_8_TO_5_FLOOR[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,
 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
 9, 9, 9, 10, 10, 10, 10, 10, 10, 10,
 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
 12, 12, 12, 12, 12, 12, 12, 13, 13, 13,
 13, 13, 13, 13, 13, 13, 14, 14, 14, 14,
 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,
 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 18,
 18, 18, 18, 18, 18, 18, 18, 19, 19, 19,
 19, 19, 19, 19, 19, 20, 20, 20, 20, 20,
 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
 21, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 23, 23, 23, 23, 23, 23, 23, 23, 24, 24,
 24, 24, 24, 24, 24, 24, 25, 25, 25, 25,
 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 27, 27, 27, 27, 27, 27, 27,
 27, 28, 28, 28, 28, 28, 28, 28, 28, 29,
 29, 29, 29, 29, 29, 29, 29, 30, 30, 30,
 30, 30, 30, 30, 30, 31};

const uint8_t Javelin::Data::BITSCALE_8_TO_4_FLOOR[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
 13, 13, 13, 13, 13, 13, 13, 13, 14, 14,
 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
 14, 14, 14, 14, 14, 15};

const uint8_t Javelin::Data::BITSCALE_8_TO_3_FLOOR[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 7};

const uint8_t Javelin::Data::BITSCALE_8_TO_5_CEIL[256] = {
 0, 1, 1, 1, 1, 1, 1, 1, 1, 2,
 2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
 7, 7, 7, 7, 7, 7, 7, 7, 8, 8,
 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
 9, 9, 9, 9, 9, 10, 10, 10, 10, 10,
 10, 10, 10, 11, 11, 11, 11, 11, 11, 11,
 11, 12, 12, 12, 12, 12, 12, 12, 12, 13,
 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,
 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
 15, 15, 15, 15, 16, 16, 16, 16, 16, 16,
 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
 20, 20, 20, 20, 20, 21, 21, 21, 21, 21,
 21, 21, 21, 22, 22, 22, 22, 22, 22, 22,
 22, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,
 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,
 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
 27, 27, 27, 28, 28, 28, 28, 28, 28, 28,
 28, 29, 29, 29, 29, 29, 29, 29, 29, 30,
 30, 30, 30, 30, 30, 30, 30, 31, 31, 31,
 31, 31, 31, 31, 31, 31};

const uint8_t Javelin::Data::BITSCALE_8_TO_4_CEIL[256] = {
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
 8, 8, 8, 8, 8, 8, 8, 9, 9, 9,
 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
 9, 9, 9, 9, 10, 10, 10, 10, 10, 10,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 13, 13, 13, 13, 13,
 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
 14, 14, 14, 14, 14, 14, 14, 14, 14, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15};

const uint8_t Javelin::Data::BITSCALE_8_TO_3_CEIL[256] = {
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7};


//#line 1 "MortonTable.cpp"

//#line 1 "MortonTable.h"
#ifndef JTHLIM_MORTONTABLE_H
#define JTHLIM_MORTONTABLE_H

namespace Javelin
{
	namespace Data
	{

		extern const unsigned short MORTON_TABLE[256];

	} // namespace Data
} // namespace Javelin

#endif

const unsigned short Javelin::Data::MORTON_TABLE[256] =
{
	0x0000, 0x0001, 0x0004, 0x0005, 0x0010, 0x0011, 0x0014, 0x0015,
	0x0040, 0x0041, 0x0044, 0x0045, 0x0050, 0x0051, 0x0054, 0x0055,
	0x0100, 0x0101, 0x0104, 0x0105, 0x0110, 0x0111, 0x0114, 0x0115,
	0x0140, 0x0141, 0x0144, 0x0145, 0x0150, 0x0151, 0x0154, 0x0155,
	0x0400, 0x0401, 0x0404, 0x0405, 0x0410, 0x0411, 0x0414, 0x0415,
	0x0440, 0x0441, 0x0444, 0x0445, 0x0450, 0x0451, 0x0454, 0x0455,
	0x0500, 0x0501, 0x0504, 0x0505, 0x0510, 0x0511, 0x0514, 0x0515,
	0x0540, 0x0541, 0x0544, 0x0545, 0x0550, 0x0551, 0x0554, 0x0555,
	0x1000, 0x1001, 0x1004, 0x1005, 0x1010, 0x1011, 0x1014, 0x1015,
	0x1040, 0x1041, 0x1044, 0x1045, 0x1050, 0x1051, 0x1054, 0x1055,
	0x1100, 0x1101, 0x1104, 0x1105, 0x1110, 0x1111, 0x1114, 0x1115,
	0x1140, 0x1141, 0x1144, 0x1145, 0x1150, 0x1151, 0x1154, 0x1155,
	0x1400, 0x1401, 0x1404, 0x1405, 0x1410, 0x1411, 0x1414, 0x1415,
	0x1440, 0x1441, 0x1444, 0x1445, 0x1450, 0x1451, 0x1454, 0x1455,
	0x1500, 0x1501, 0x1504, 0x1505, 0x1510, 0x1511, 0x1514, 0x1515,
	0x1540, 0x1541, 0x1544, 0x1545, 0x1550, 0x1551, 0x1554, 0x1555,
	0x4000, 0x4001, 0x4004, 0x4005, 0x4010, 0x4011, 0x4014, 0x4015,
	0x4040, 0x4041, 0x4044, 0x4045, 0x4050, 0x4051, 0x4054, 0x4055,
	0x4100, 0x4101, 0x4104, 0x4105, 0x4110, 0x4111, 0x4114, 0x4115,
	0x4140, 0x4141, 0x4144, 0x4145, 0x4150, 0x4151, 0x4154, 0x4155,
	0x4400, 0x4401, 0x4404, 0x4405, 0x4410, 0x4411, 0x4414, 0x4415,
	0x4440, 0x4441, 0x4444, 0x4445, 0x4450, 0x4451, 0x4454, 0x4455,
	0x4500, 0x4501, 0x4504, 0x4505, 0x4510, 0x4511, 0x4514, 0x4515,
	0x4540, 0x4541, 0x4544, 0x4545, 0x4550, 0x4551, 0x4554, 0x4555,
	0x5000, 0x5001, 0x5004, 0x5005, 0x5010, 0x5011, 0x5014, 0x5015,
	0x5040, 0x5041, 0x5044, 0x5045, 0x5050, 0x5051, 0x5054, 0x5055,
	0x5100, 0x5101, 0x5104, 0x5105, 0x5110, 0x5111, 0x5114, 0x5115,
	0x5140, 0x5141, 0x5144, 0x5145, 0x5150, 0x5151, 0x5154, 0x5155,
	0x5400, 0x5401, 0x5404, 0x5405, 0x5410, 0x5411, 0x5414, 0x5415,
	0x5440, 0x5441, 0x5444, 0x5445, 0x5450, 0x5451, 0x5454, 0x5455,
	0x5500, 0x5501, 0x5504, 0x5505, 0x5510, 0x5511, 0x5514, 0x5515,
	0x5540, 0x5541, 0x5544, 0x5545, 0x5550, 0x5551, 0x5554, 0x5555
};


//#line 1 "PvrTcDecoder.cpp"

//#line 1 "PvrTcDecoder.h"
#ifndef JTHLIM_PVRTCDECODER_H
#define JTHLIM_PVRTCDECODER_H


//#line 1 "Point2.h"
#ifndef JTHLIM_POINT2_H
#define JTHLIM_POINT2_H

namespace Javelin {

template<typename T>
class Point2 {
public:
	T x;
	T y;

	Point2(int a, int b)
		: x(a)
		, y(b) {
	}
};

}

#endif


//#line 1 "ColorRgba.h"
#ifndef JTHLIM_COLORRGBA_H
#define JTHLIM_COLORRGBA_H

namespace Javelin {

template<typename T>
class ColorRgb {
public:
	T b;
	T g;
	T r;

	ColorRgb()
		: r(0)
		, g(0)
		, b(0) {
	}

	ColorRgb(T red, T green, T blue)
		: r(red)
		, g(green)
		, b(blue) {
	}

	ColorRgb(const ColorRgb<T> &x)
		: r(x.r)
		, g(x.g)
		, b(x.b) {
	}

	ColorRgb<int> operator *(int x) {
		return ColorRgb<int>(r * x, g * x, b * x);
	}

	ColorRgb<int> operator +(const ColorRgb<T> &x) const {
		return ColorRgb<int>(r + (int)x.r, g + (int)x.g, b + (int)x.b);
	}

	ColorRgb<int> operator -(const ColorRgb<T> &x) const {
		return ColorRgb<int>(r - (int)x.r, g - (int)x.g, b - (int)x.b);
	}

	int operator %(const ColorRgb<T> &x) const {
		return r * (int)x.r + g * (int)x.g + b * (int)x.b;
	}

	bool operator ==(const ColorRgb<T> &x) const {
		return r == x.r && g == x.g && b == x.b;
	}

	bool operator !=(const ColorRgb<T> &x) const {
		return r != x.r || g != x.g || b != x.b;
	}

	void SetMin(const ColorRgb<T> &x) {
		if (x.r < r) {
			r = x.r;
		}
		if (x.g < g) {
			g = x.g;
		}
		if (x.b < b) {
			b = x.b;
		}
	}

	void SetMax(const ColorRgb<T> &x) {
		if (x.r > r) {
			r = x.r;
		}
		if (x.g > g) {
			g = x.g;
		}
		if (x.b > b) {
			b = x.b;
		}
	}
};

template<typename T>
class ColorRgba : public ColorRgb<T> {
public:
	T a;

	ColorRgba() :
		a(0) {
	}

	ColorRgba(T red, T green, T blue, T alpha)
		: ColorRgb<T>(red, green, blue)
		, a(alpha) {
	}

	ColorRgba(const ColorRgba<T> &x)
		: ColorRgb<T>(x.r, x.g, x.b)
		, a(x.a) {
	}

	ColorRgba<int> operator *(int x) {
		return ColorRgba<T>(ColorRgb<T>::r * x,
							ColorRgb<T>::g * x,
							ColorRgb<T>::b * x,
							a * x);
	}

	ColorRgba<int> operator +(const ColorRgba<T> &x) {
		return ColorRgba<T>(ColorRgb<T>::r + (int)x.r,
							ColorRgb<T>::g + (int)x.g,
							ColorRgb<T>::b + (int)x.b,
							a + (int)x.a);
	}

	ColorRgba<int> operator -(const ColorRgba<T> &x) {
		return ColorRgba<T>(ColorRgb<T>::r - (int)x.r,
							ColorRgb<T>::g - (int)x.g,
							ColorRgb<T>::b - (int)x.b,
							a - (int)x.a);
	}

	int operator %(const ColorRgba<T> &x) {
		return ColorRgb<T>::r * (int)x.r +
			   ColorRgb<T>::g * (int)x.g +
			   ColorRgb<T>::b * (int)x.b +
			   a * (int)x.a;
	}

	bool operator ==(const ColorRgba<T> &x) {
		return ColorRgb<T>::r == x.r && ColorRgb<T>::g == x.g &&
			   ColorRgb<T>::b == x.b && a == x.a;
	}

	bool operator !=(const ColorRgba<T> &x) {
		return ColorRgb<T>::r != x.r || ColorRgb<T>::g != x.g ||
			   ColorRgb<T>::b != x.b || a != x.a;
	}

	void SetMin(const ColorRgba<T> &x) {
		ColorRgb<T>::SetMin(x);
		if (x.a < a) {
			a = x.a;
		}
	}

	void SetMax(const ColorRgba<T> &x) {
		ColorRgb<T>::SetMax(x);
		if (x.a > a) {
			a = x.a;
		}
	}
};

}

#endif

namespace Javelin
{

	class PvrTcDecoder
	{
	public:
		static void DecodeRgb4Bpp(ColorRgb<unsigned char>* result, const Point2<int>& size, const void* data);
		static void DecodeRgba4Bpp(ColorRgba<unsigned char>* result, const Point2<int>& size, const void* data);

	private:
		static unsigned GetMortonNumber(int x, int y);
	};

}

#endif


//#line 1 "PvrTcPacket.h"
//
// Modulation data specifies weightings of colorA to colorB for each pixel
//
// For mode = 0
//	00: 0/8
//  01: 3/8
//  10: 5/8
//  11: 8/8
//
// For mode = 1
//  00: 0/8
//  01: 4/8
//  10: 4/8 with alpha punchthrough
//  11: 8/8
//
// For colorIsOpaque=0
//  3 bits A
//  4 bits R
//  4 bits G
//  3/4 bits B
//
// For colorIsOpaque=1
//  5 bits R
//  5 bits G
//  4/5 bits B
//

#ifndef JTHLIM_PVRTCPACKET_H
#define JTHLIM_PVRTCPACKET_H

namespace Javelin
{

	struct PvrTcPacket
	{
		unsigned int    modulationData;
		unsigned        usePunchthroughAlpha : 1;
		unsigned        colorA          	 : 14;
		unsigned        colorAIsOpaque  	 : 1;
		unsigned        colorB        		 : 15;
		unsigned        colorBIsOpaque  	 : 1;

		ColorRgb<int> GetColorRgbA() const;
		ColorRgb<int> GetColorRgbB() const;
		ColorRgba<int> GetColorRgbaA() const;
		ColorRgba<int> GetColorRgbaB() const;

		void SetColorA(const ColorRgb<unsigned char>& c);
		void SetColorB(const ColorRgb<unsigned char>& c);

		void SetColorA(const ColorRgba<unsigned char>& c);
		void SetColorB(const ColorRgba<unsigned char>& c);

		static const unsigned char BILINEAR_FACTORS[16][4];
		static const unsigned char WEIGHTS[8][4];
	};

} // namespace Javelin

#endif

#include <assert.h>

using namespace Javelin;
using Data::MORTON_TABLE;

inline unsigned PvrTcDecoder::GetMortonNumber(int x, int y)
{
	return MORTON_TABLE[x >> 8] << 17 | MORTON_TABLE[y >> 8] << 16 | MORTON_TABLE[x & 0xFF] << 1 | MORTON_TABLE[y & 0xFF];
}

void PvrTcDecoder::DecodeRgb4Bpp(ColorRgb<unsigned char>* result, const Point2<int>& size, const void* data)
{
	assert(size.x == size.y);

	const int blocks = size.x / 4;
	const int blockMask = blocks-1;
	const PvrTcPacket* packets = static_cast<const PvrTcPacket*>(data);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const PvrTcPacket* packet = packets + GetMortonNumber(x, y);

			unsigned mod = packet->modulationData;
			const unsigned char (*weights)[4] = PvrTcPacket::WEIGHTS + 4*packet->usePunchthroughAlpha;
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgb<int> ca = p0->GetColorRgbA() * (*factor)[0] +
									   p1->GetColorRgbA() * (*factor)[1] +
									   p2->GetColorRgbA() * (*factor)[2] +
									   p3->GetColorRgbA() * (*factor)[3];

					ColorRgb<int> cb = p0->GetColorRgbB() * (*factor)[0] +
									   p1->GetColorRgbB() * (*factor)[1] +
									   p2->GetColorRgbB() * (*factor)[2] +
									   p3->GetColorRgbB() * (*factor)[3];

					const unsigned char* w = weights[mod&3];
					ColorRgb<unsigned char> c;
					c.r = (ca.r * w[0] + cb.r * w[1]) >> 7;
					c.g = (ca.g * w[0] + cb.g * w[1]) >> 7;
					c.b = (ca.b * w[0] + cb.b * w[1]) >> 7;

					result[(py+y*4)*size.x + (px+x*4)] = c;
					mod >>= 2;
					factor++;
				}
			}
		}
	}
}

void PvrTcDecoder::DecodeRgba4Bpp(ColorRgba<unsigned char>* result, const Point2<int>& size, const void* data)
{
	assert(size.x == size.y);

	const int blocks = size.x / 4;
	const int blockMask = blocks-1;
	const PvrTcPacket* packets = static_cast<const PvrTcPacket*>(data);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const PvrTcPacket* packet = packets + GetMortonNumber(x, y);

			unsigned mod = packet->modulationData;
			const unsigned char (*weights)[4] = PvrTcPacket::WEIGHTS + 4*packet->usePunchthroughAlpha;
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgba<int> ca = p0->GetColorRgbaA() * (*factor)[0] +
									   	p1->GetColorRgbaA() * (*factor)[1] +
									   	p2->GetColorRgbaA() * (*factor)[2] +
										p3->GetColorRgbaA() * (*factor)[3];

					ColorRgba<int> cb = p0->GetColorRgbaB() * (*factor)[0] +
										p1->GetColorRgbaB() * (*factor)[1] +
										p2->GetColorRgbaB() * (*factor)[2] +
										p3->GetColorRgbaB() * (*factor)[3];

					const unsigned char* w = weights[mod&3];
					ColorRgba<unsigned char> c;
					c.r = (ca.r * w[0] + cb.r * w[1]) >> 7;
					c.g = (ca.g * w[0] + cb.g * w[1]) >> 7;
					c.b = (ca.b * w[0] + cb.b * w[1]) >> 7;
					c.a = (ca.a * w[2] + cb.a * w[3]) >> 7;

					result[(py+y*4)*size.x + (px+x*4)] = c;
					mod >>= 2;
					factor++;
				}
			}
		}
	}
}


//#line 1 "PvrTcEncoder.cpp"

//#line 1 "PvrTcEncoder.h"
#ifndef JTHLIM_PVRTCENCODER_H
#define JTHLIM_PVRTCENCODER_H

namespace Javelin
{

	class AlphaBitmap;
	class RgbBitmap;
	class RgbaBitmap;

	class PvrTcEncoder
	{
	public:
		// Result must be large enough for bitmap.GetArea()/4 bytes
		static void EncodeAlpha2Bpp(void* result, const AlphaBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeAlpha4Bpp(void* result, const AlphaBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeRgb4Bpp(void* result, const RgbBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeRgb4Bpp(void* result, const RgbaBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeRgba4Bpp(void* result, const RgbaBitmap& bitmap);

	private:
		static unsigned GetMortonNumber(int x, int y);
	};

}

#endif


//#line 1 "AlphaBitmap.h"
#ifndef JTHLIM_ALPHABITMAP_H
#define JTHLIM_ALPHABITMAP_H


//#line 1 "Bitmap.h"
#ifndef JTHLIM_BITMAP_H
#define JTHLIM_BITMAP_H

namespace Javelin {

class Bitmap {
public:
	int width;
	int height;
	unsigned char *data;

	Bitmap(int w, int h, int bytesPerPixel)
		: width(w)
		, height(h)
		, data(new unsigned char[width * height * bytesPerPixel]) {
	}

	virtual ~Bitmap() {
		delete [] data;
	}

	Point2<int> GetSize() const { return Point2<int>(width, height); }

	int GetArea() const { return width * height; }

	int GetBitmapWidth() const { return width; }

	int GetBitmapHeight() const { return height; }

	const unsigned char *GetRawData() const { return data; }
};

}

#endif

namespace Javelin {

class AlphaBitmap : public Bitmap {
public:
	AlphaBitmap(int w, int h)
		: Bitmap(w, h, 1) {
	}

	const unsigned char *GetData() const { return data; }

	unsigned char *GetData() { return data; }
};

}

#endif


//#line 1 "RgbBitmap.h"
#ifndef JTHLIM_RGBBITMAP_H
#define JTHLIM_RGBBITMAP_H

namespace Javelin {

class RgbBitmap : public Bitmap {
public:
	RgbBitmap(int w, int h)
		: Bitmap(w, h, 3) {
	}

	const ColorRgb<unsigned char> *GetData() const {
		return reinterpret_cast<ColorRgb<unsigned char> *>(data);
	}

	ColorRgb<unsigned char> *GetData() {
		return reinterpret_cast<ColorRgb<unsigned char> *>(data);
	}
};

}

#endif


//#line 1 "RgbaBitmap.h"
#ifndef JTHLIM_RGBABITMAP_H
#define JTHLIM_RGBABITMAP_H

namespace Javelin {

class RgbaBitmap : public Bitmap {
public:
	RgbaBitmap(int w, int h)
		: Bitmap(w, h, 4) {
	}

	const ColorRgba<unsigned char> *GetData() const {
		return reinterpret_cast<ColorRgba<unsigned char> *>(data);
	}

	ColorRgba<unsigned char> *GetData() {
		return reinterpret_cast<ColorRgba<unsigned char> *>(data);
	}
};

}

#endif


//#line 1 "BitUtility.h"
#ifndef JTHLIM_BITUTILITY_H
#define JTHLIM_BITUTILITY_H

namespace Javelin {

class BitUtility {
public:
	static bool IsPowerOf2(unsigned int x) {
		return (x & (x - 1)) == 0;
	}

	static unsigned int RotateRight(unsigned int value, unsigned int shift) {
		if ((shift &= sizeof(value) * 8 - 1) == 0) {
			return value;
		}
		return (value >> shift) | (value << (sizeof(value) * 8 - shift));
	}
};

}

#endif


//#line 1 "Interval.h"
#ifndef JTHLIM_INTERVAL_H
#define JTHLIM_INTERVAL_H

namespace Javelin {

template<typename T>
class Interval {
public:
	T min;
	T max;

	Interval() {
	}

	Interval<T> &operator|=(const T &x) {
		min.SetMin(x);
		max.SetMax(x);
		return *this;
	}
};

}

#endif

#include <assert.h>
#include <math.h>
#include <stdint.h>

using namespace Javelin;
using Data::MORTON_TABLE;

static const unsigned char MODULATION_LUT[16] =
{
	0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3
};

inline unsigned PvrTcEncoder::GetMortonNumber(int x, int y)
{
	return MORTON_TABLE[x >> 8] << 17 | MORTON_TABLE[y >> 8] << 16 | MORTON_TABLE[x & 0xFF] << 1 | MORTON_TABLE[y & 0xFF];
}

void PvrTcEncoder::EncodeAlpha2Bpp(void* result, const AlphaBitmap& bitmap)
{
	int size = bitmap.GetBitmapWidth();
	assert(size == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(size));

	// Blocks in each dimension.
	int xBlocks = size/8;
	int yBlocks = size/4;

	const unsigned char* bitmapData = bitmap.GetRawData();

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);
	for(int y = 0; y < yBlocks; ++y)
	{
		for(int x = 0; x < xBlocks; ++x)
		{
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->colorAIsOpaque = 0;
			packet->colorA = 0x7ff;		// White, with 0 alpha
			packet->colorBIsOpaque = 1;
			packet->colorB = 0x7fff;	// White with full alpha

			const unsigned char* blockBitmapData = &bitmapData[y*4*size + x*8];

			uint32_t modulationData = 0;
			for(int py = 0; py < 4; ++py)
			{
				const unsigned char* rowBitmapData = blockBitmapData;
				for(int px = 0; px < 8; ++px)
				{
					unsigned char pixel = *rowBitmapData++;
					modulationData = BitUtility::RotateRight(modulationData | (pixel >> 7), 1);
				}
				blockBitmapData += size;
			}
			packet->modulationData = modulationData;
		}
	}
}

void PvrTcEncoder::EncodeAlpha4Bpp(void* result, const AlphaBitmap& bitmap)
{
	int size = bitmap.GetBitmapWidth();
	assert(size == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(size));

	// Blocks in each dimension.
	int blocks = size/4;

	const unsigned char* bitmapData = bitmap.GetRawData();

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);
	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->colorAIsOpaque = 0;
			packet->colorA = 0x7ff;		// White, with 0 alpha
			packet->colorBIsOpaque = 1;
			packet->colorB = 0x7fff;	// White with full alpha

			const unsigned char* blockBitmapData = &bitmapData[(y*size + x)*4];

			uint32_t modulationData = 0;
			for(int py = 0; py < 4; ++py)
			{
				const unsigned char* rowBitmapData = blockBitmapData;
				for(int px = 0; px < 4; ++px)
				{
					unsigned char pixel = *rowBitmapData++;
					modulationData = BitUtility::RotateRight(modulationData | MODULATION_LUT[pixel>>4], 2);
				}
				blockBitmapData += size;
			}
			packet->modulationData = modulationData;
		}
	}
}

typedef Interval<ColorRgb<unsigned char>> ColorRgbBoundingBox;

static void CalculateBoundingBox(ColorRgbBoundingBox& cbb, const RgbBitmap& bitmap, int blockX, int blockY)
{
	int size = bitmap.GetBitmapWidth();
	const ColorRgb<unsigned char>* data = bitmap.GetData() + blockY * 4 * size + blockX * 4;

	cbb.min = data[0];
	cbb.max = data[0];
	cbb |= data[1];
	cbb |= data[2];
	cbb |= data[3];

	cbb |= data[size];
	cbb |= data[size+1];
	cbb |= data[size+2];
	cbb |= data[size+3];

	cbb |= data[2*size];
	cbb |= data[2*size+1];
	cbb |= data[2*size+2];
	cbb |= data[2*size+3];

	cbb |= data[3*size];
	cbb |= data[3*size+1];
	cbb |= data[3*size+2];
	cbb |= data[3*size+3];
}

void PvrTcEncoder::EncodeRgb4Bpp(void* result, const RgbBitmap& bitmap)
{
	assert(bitmap.GetBitmapWidth() == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(bitmap.GetBitmapWidth()));
	const int size = bitmap.GetBitmapWidth();
	const int blocks = size / 4;
	const int blockMask = blocks-1;

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			ColorRgbBoundingBox cbb;
			CalculateBoundingBox(cbb, bitmap, x, y);
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->SetColorA(cbb.min);
			packet->SetColorB(cbb.max);
		}
	}

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;
			const ColorRgb<unsigned char>* data = bitmap.GetData() + y * 4 * size + x * 4;

			uint32_t modulationData = 0;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgb<int> ca = p0->GetColorRgbA() * (*factor)[0] +
									   p1->GetColorRgbA() * (*factor)[1] +
									   p2->GetColorRgbA() * (*factor)[2] +
									   p3->GetColorRgbA() * (*factor)[3];

					ColorRgb<int> cb = p0->GetColorRgbB() * (*factor)[0] +
									   p1->GetColorRgbB() * (*factor)[1] +
									   p2->GetColorRgbB() * (*factor)[2] +
									   p3->GetColorRgbB() * (*factor)[3];

					const ColorRgb<unsigned char>& pixel = data[py*size + px];
					ColorRgb<int> d = cb - ca;
					ColorRgb<int> p( pixel.r*16, pixel.g*16, pixel.b*16 );
					ColorRgb<int> v = p - ca;

					// PVRTC uses weightings of 0, 3/8, 5/8 and 1
					// The boundaries for these are 3/16, 1/2 (=8/16), 13/16
					int projection = (v % d) * 16;
					int lengthSquared = d % d;
					if(projection > 3*lengthSquared) modulationData++;
					if(projection > 8*lengthSquared) modulationData++;
					if(projection > 13*lengthSquared) modulationData++;

					modulationData = BitUtility::RotateRight(modulationData, 2);

					factor++;
				}
			}

			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->modulationData = modulationData;
		}
	}
}

static void CalculateBoundingBox(ColorRgbBoundingBox& cbb, const RgbaBitmap& bitmap, int blockX, int blockY)
{
	int size = bitmap.GetBitmapWidth();
	const ColorRgba<unsigned char>* data = bitmap.GetData() + blockY * 4 * size + blockX * 4;

	cbb.min = data[0];
	cbb.max = data[0];

	cbb |= data[1];
	cbb |= data[2];
	cbb |= data[3];

	cbb |= data[size];
	cbb |= data[size+1];
	cbb |= data[size+2];
	cbb |= data[size+3];

	cbb |= data[2*size];
	cbb |= data[2*size+1];
	cbb |= data[2*size+2];
	cbb |= data[2*size+3];

	cbb |= data[3*size];
	cbb |= data[3*size+1];
	cbb |= data[3*size+2];
	cbb |= data[3*size+3];
}

void PvrTcEncoder::EncodeRgb4Bpp(void* result, const RgbaBitmap& bitmap)
{
	assert(bitmap.GetBitmapWidth() == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(bitmap.GetBitmapWidth()));
	const int size = bitmap.GetBitmapWidth();
	const int blocks = size / 4;
	const int blockMask = blocks-1;

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			ColorRgbBoundingBox cbb;
			CalculateBoundingBox(cbb, bitmap, x, y);
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->SetColorA(cbb.min);
			packet->SetColorB(cbb.max);
		}
	}

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;
			const ColorRgba<unsigned char>* data = bitmap.GetData() + y * 4 * size + x * 4;

			uint32_t modulationData = 0;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgb<int> ca = p0->GetColorRgbA() * (*factor)[0] +
									   p1->GetColorRgbA() * (*factor)[1] +
									   p2->GetColorRgbA() * (*factor)[2] +
									   p3->GetColorRgbA() * (*factor)[3];

					ColorRgb<int> cb = p0->GetColorRgbB() * (*factor)[0] +
									   p1->GetColorRgbB() * (*factor)[1] +
									   p2->GetColorRgbB() * (*factor)[2] +
									   p3->GetColorRgbB() * (*factor)[3];

					const ColorRgb<unsigned char>& pixel = data[py*size + px];
					ColorRgb<int> d = cb - ca;
					ColorRgb<int> p( pixel.r*16, pixel.g*16, pixel.b*16 );
					ColorRgb<int> v = p - ca;

					// PVRTC uses weightings of 0, 3/8, 5/8 and 1
					// The boundaries for these are 3/16, 1/2 (=8/16), 13/16
					int projection = (v % d) * 16;
					int lengthSquared = d % d;
					if(projection > 3*lengthSquared) modulationData++;
					if(projection > 8*lengthSquared) modulationData++;
					if(projection > 13*lengthSquared) modulationData++;

					modulationData = BitUtility::RotateRight(modulationData, 2);

					factor++;
				}
			}

			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->modulationData = modulationData;
		}
	}
}

typedef Interval<ColorRgba<unsigned char>> ColorRgbaBoundingBox;

static void CalculateBoundingBox(ColorRgbaBoundingBox& cbb, const RgbaBitmap& bitmap, int blockX, int blockY)
{
	int size = bitmap.GetBitmapWidth();
	const ColorRgba<unsigned char>* data = bitmap.GetData() + blockY * 4 * size + blockX * 4;

	cbb.min = data[0];
	cbb.max = data[0];

	cbb |= data[1];
	cbb |= data[2];
	cbb |= data[3];

	cbb |= data[size];
	cbb |= data[size+1];
	cbb |= data[size+2];
	cbb |= data[size+3];

	cbb |= data[2*size];
	cbb |= data[2*size+1];
	cbb |= data[2*size+2];
	cbb |= data[2*size+3];

	cbb |= data[3*size];
	cbb |= data[3*size+1];
	cbb |= data[3*size+2];
	cbb |= data[3*size+3];
}

void PvrTcEncoder::EncodeRgba4Bpp(void* result, const RgbaBitmap& bitmap)
{
	assert(bitmap.GetBitmapWidth() == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(bitmap.GetBitmapWidth()));
	const int size = bitmap.GetBitmapWidth();
	const int blocks = size / 4;
	const int blockMask = blocks-1;

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			ColorRgbaBoundingBox cbb;
			CalculateBoundingBox(cbb, bitmap, x, y);
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->SetColorA(cbb.min);
			packet->SetColorB(cbb.max);
		}
	}

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;
			const ColorRgba<unsigned char>* data = bitmap.GetData() + y * 4 * size + x * 4;

			uint32_t modulationData = 0;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgba<int> ca = p0->GetColorRgbaA() * (*factor)[0] +
										p1->GetColorRgbaA() * (*factor)[1] +
										p2->GetColorRgbaA() * (*factor)[2] +
										p3->GetColorRgbaA() * (*factor)[3];

					ColorRgba<int> cb = p0->GetColorRgbaB() * (*factor)[0] +
										p1->GetColorRgbaB() * (*factor)[1] +
										p2->GetColorRgbaB() * (*factor)[2] +
										p3->GetColorRgbaB() * (*factor)[3];

					const ColorRgba<unsigned char>& pixel = data[py*size + px];
					ColorRgba<int> d = cb - ca;
					ColorRgba<int> p( pixel.r*16, pixel.g*16, pixel.b*16, pixel.a*16 );
					ColorRgba<int> v = p - ca;

					// PVRTC uses weightings of 0, 3/8, 5/8 and 1
					// The boundaries for these are 3/16, 1/2 (=8/16), 13/16
					int projection = (v % d) * 16;
					int lengthSquared = d % d;
					if(projection > 3*lengthSquared) modulationData++;
					if(projection > 8*lengthSquared) modulationData++;
					if(projection > 13*lengthSquared) modulationData++;

					modulationData = BitUtility::RotateRight(modulationData, 2);

					factor++;
				}
			}

			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->modulationData = modulationData;
		}
	}
}


//#line 1 "PvrTcPacket.cpp"
using namespace Javelin;

const unsigned char PvrTcPacket::BILINEAR_FACTORS[16][4] =
{
	{ 4, 4, 4, 4 },
	{ 2, 6, 2, 6 },
	{ 8, 0, 8, 0 },
	{ 6, 2, 6, 2 },

	{ 2, 2, 6, 6 },
	{ 1, 3, 3, 9 },
	{ 4, 0, 12, 0 },
	{ 3, 1, 9, 3 },

	{ 8, 8, 0, 0 },
	{ 4, 12, 0, 0 },
	{ 16, 0, 0, 0 },
	{ 12, 4, 0, 0 },

	{ 6, 6, 2, 2 },
	{ 3, 9, 1, 3 },
	{ 12, 0, 4, 0 },
	{ 9, 3, 3, 1 },
};

// Weights are { colorA, colorB, alphaA, alphaB }
const unsigned char PvrTcPacket::WEIGHTS[8][4] =
{
	// Weights for Mode=0
	{ 8, 0, 8, 0 },
	{ 5, 3, 5, 3 },
	{ 3, 5, 3, 5 },
	{ 0, 8, 0, 8 },

	// Weights for Mode=1
	{ 8, 0, 8, 0 },
	{ 4, 4, 4, 4 },
	{ 4, 4, 0, 0 },
	{ 0, 8, 0, 8 },
};

ColorRgb<int> PvrTcPacket::GetColorRgbA() const
{
	if(colorAIsOpaque)
	{
		unsigned char r = colorA >> 9;
		unsigned char g = colorA >> 4 & 0x1f;
		unsigned char b = colorA & 0xf;
		return ColorRgb<int>(Data::BITSCALE_5_TO_8[r],
							 Data::BITSCALE_5_TO_8[g],
							 Data::BITSCALE_4_TO_8[b]);
	}
	else
	{
		unsigned char r = (colorA >> 7) & 0xf;
		unsigned char g = (colorA >> 3) & 0xf;
		unsigned char b = colorA & 7;
		return ColorRgb<int>(Data::BITSCALE_4_TO_8[r],
							 Data::BITSCALE_4_TO_8[g],
							 Data::BITSCALE_3_TO_8[b]);
	}
}

ColorRgb<int> PvrTcPacket::GetColorRgbB() const
{
	if(colorBIsOpaque)
	{
		unsigned char r = colorB >> 10;
		unsigned char g = colorB >> 5 & 0x1f;
		unsigned char b = colorB & 0x1f;
		return ColorRgb<int>(Data::BITSCALE_5_TO_8[r],
							 Data::BITSCALE_5_TO_8[g],
							 Data::BITSCALE_5_TO_8[b]);
	}
	else
	{
		unsigned char r = colorB >> 8 & 0xf;
		unsigned char g = colorB >> 4 & 0xf;
		unsigned char b = colorB & 0xf;
		return ColorRgb<int>(Data::BITSCALE_4_TO_8[r],
							 Data::BITSCALE_4_TO_8[g],
							 Data::BITSCALE_4_TO_8[b]);
	}
}

ColorRgba<int> PvrTcPacket::GetColorRgbaA() const
{
	if(colorAIsOpaque)
	{
		unsigned char r = colorA >> 9;
		unsigned char g = colorA >> 4 & 0x1f;
		unsigned char b = colorA & 0xf;
		return ColorRgba<int>(Data::BITSCALE_5_TO_8[r],
							  Data::BITSCALE_5_TO_8[g],
							  Data::BITSCALE_4_TO_8[b],
							  255);
	}
	else
	{
		unsigned char a = colorA >> 11 & 7;
		unsigned char r = colorA >> 7 & 0xf;
		unsigned char g = colorA >> 3 & 0xf;
		unsigned char b = colorA & 7;
		return ColorRgba<int>(Data::BITSCALE_4_TO_8[r],
							  Data::BITSCALE_4_TO_8[g],
							  Data::BITSCALE_3_TO_8[b],
							  Data::BITSCALE_3_TO_8[a]);
	}
}

ColorRgba<int> PvrTcPacket::GetColorRgbaB() const
{
	if(colorBIsOpaque)
	{
		unsigned char r = colorB >> 10;
		unsigned char g = colorB >> 5 & 0x1f;
		unsigned char b = colorB & 0x1f;
		return ColorRgba<int>(Data::BITSCALE_5_TO_8[r],
							  Data::BITSCALE_5_TO_8[g],
							  Data::BITSCALE_5_TO_8[b],
							  255);
	}
	else
	{
		unsigned char a = colorB >> 12 & 7;
		unsigned char r = colorB >> 8 & 0xf;
		unsigned char g = colorB >> 4 & 0xf;
		unsigned char b = colorB & 0xf;
		return ColorRgba<int>(Data::BITSCALE_4_TO_8[r],
							  Data::BITSCALE_4_TO_8[g],
							  Data::BITSCALE_4_TO_8[b],
							  Data::BITSCALE_3_TO_8[a]);
	}
}

void PvrTcPacket::SetColorA(const ColorRgb<unsigned char>& c)
{
	int r = Data::BITSCALE_8_TO_5_FLOOR[c.r];
	int g = Data::BITSCALE_8_TO_5_FLOOR[c.g];
	int b = Data::BITSCALE_8_TO_4_FLOOR[c.b];
	colorA = r<<9 | g<<4 | b;
	colorAIsOpaque = true;
}

void PvrTcPacket::SetColorB(const ColorRgb<unsigned char>& c)
{
	int r = Data::BITSCALE_8_TO_5_CEIL[c.r];
	int g = Data::BITSCALE_8_TO_5_CEIL[c.g];
	int b = Data::BITSCALE_8_TO_5_CEIL[c.b];
	colorB = r<<10 | g<<5 | b;
	colorBIsOpaque = true;
}

void PvrTcPacket::SetColorA(const ColorRgba<unsigned char>& c)
{
	int a = Data::BITSCALE_8_TO_3_FLOOR[c.a];
	if(a == 7)
	{
		int r = Data::BITSCALE_8_TO_5_FLOOR[c.r];
		int g = Data::BITSCALE_8_TO_5_FLOOR[c.g];
		int b = Data::BITSCALE_8_TO_4_FLOOR[c.b];
		colorA = r<<9 | g<<4 | b;
		colorAIsOpaque = true;
	}
	else
	{
		int r = Data::BITSCALE_8_TO_4_FLOOR[c.r];
		int g = Data::BITSCALE_8_TO_4_FLOOR[c.g];
		int b = Data::BITSCALE_8_TO_3_FLOOR[c.b];
		colorA = a<<11 | r<<7 | g<<3 | b;
		colorAIsOpaque = false;
	}
}

void PvrTcPacket::SetColorB(const ColorRgba<unsigned char>& c)
{
	int a = Data::BITSCALE_8_TO_3_CEIL[c.a];
	if(a == 7)
	{
		int r = Data::BITSCALE_8_TO_5_CEIL[c.r];
		int g = Data::BITSCALE_8_TO_5_CEIL[c.g];
		int b = Data::BITSCALE_8_TO_5_CEIL[c.b];
		colorB = r<<10 | g<<5 | b;
		colorBIsOpaque = true;
	}
	else
	{
		int r = Data::BITSCALE_8_TO_4_CEIL[c.r];
		int g = Data::BITSCALE_8_TO_4_CEIL[c.g];
		int b = Data::BITSCALE_8_TO_4_CEIL[c.b];
		colorB = a<<12 | r<<8 | g<<4 | b;
		colorBIsOpaque = false;
	}
}

namespace spot {

//#line 1 "pvr3.hpp"
// - rlyeh, public domain

struct pvr3 {
	enum table1 {
		PVRTC_2BPP_RGB = 0,
		PVRTC_2BPP_RGBA = 1,
		PVRTC_4BPP_RGB = 2,
		PVRTC_4BPP_RGBA = 3,
		PVRTC_II_2BPP = 4,
		PVRTC_II_4BPP = 5,
		ETC1 = 6,
		DXT1 = 7,
		DXT2 = 8,
		DXT3 = 9,
		DXT4 = 10,
		DXT5 = 11,
		BC1 = 7,
		BC2 = 9,
		BC3 = 11,
		BC4 = 12,
		BC5 = 13,
		BC6 = 14,
		BC7 = 15,
		UYVY = 16,
		YUY2 = 17,
		BW1BPP = 18,
		R9G9B9E5_SHARED_EXPONENT = 19,
		RGBG8888 = 20,
		GRGB8888 = 21,
		ETC2_RGB = 22,
		ETC2_RGBA = 23,
		ETC2_RGB_A1 = 24,
		EAC_R11_UNSIGNED = 25,
		EAC_R11_SIGNED = 26,
		EAC_RG11_UNSIGNED = 27,
		EAC_RG11_SIGNED = 28,
	};
	enum table2 {
		UNSIGNED_BYTE_NORMALIZED = 0,
		SIGNED_BYTE_NORMALIZED = 1,
		UNSIGNED_BYTE = 2,
		SIGNED_BYTE = 3,
		UNSIGNED_SHORT_NORMALIZED = 4,
		SIGNED_SHORT_NORMALIZED = 5,
		UNSIGNED_SHORT = 6,
		SIGNED_SHORT = 7,
		UNSIGNED_INTEGER_NORMALIZED = 8,
		SIGNED_INTEGER_NORMALIZED = 9,
		UNSIGNED_INTEGER = 10,
		SIGNED_INTEGER = 11,
		FLOAT = 12,
	};

	struct header {
		uint32_t version;           // 0x03525650, if endianess does not match ; 0x50565203, if endianess does match
		uint32_t flags;             // 0x02, colour values within the texture have been pre-multiplied by the alpha values
		uint32_t pixel_format_1;    // see table1 above
		uint32_t pixel_format_2;    // 0

		uint32_t color_space;       // 0 linear rgb, 1 standard rgb
		uint32_t channel_type;      // see table2 above
		uint32_t height;            // 1d texture
		uint32_t width;             // 2d texture; >= 1

		uint32_t depth;             // 3d texture; >= 1
		uint32_t num_surfaces;      // num surfaces in texture array; >= 1
		uint32_t num_faces;         // num faces in cubemap; >= 1
		uint32_t num_mipmaps;       // num levels of mipmaps; >= 1

		uint32_t metadata_size;     // length of following header
	} hd;
	struct metadata {
		uint32_t fourcc;            // any 'PVRx' where x[0..255] are reserved
		uint32_t key;               // opcode
		uint32_t datasize;          // length of following field
		uint32_t data;              // dummy field [raw binary data here]
	} mt;
	struct texturedata {
		uint32_t data;              // dummy field [raw binary data here]
	} tx;

	bool is_pvr() const {
		const char id[] = { 'P', 'V', 'R', '\x3' };
		return 0 == memcmp( id, &hd, sizeof(id) );
	}

	bool is_currently_supported() const {
		bool ok = true;
		ok &= is_pvr();
		ok &= hd.flags != 0x2;           // 0x02, colour values within the texture have been pre-multiplied by the alpha values
		ok &= hd.color_space == 0;       // 0 linear rgb, 1 standard rgb
		ok &= hd.channel_type == 0;      // see table2 above
		ok &= hd.height >= 1;            // 1d texture
		ok &= hd.width >= 1;             // 2d texture; >= 1
		ok &= hd.depth <= 1;             // 3d texture; >= 1
		ok &= hd.num_surfaces <= 1;      // num surfaces in texture array; >= 1
		ok &= hd.num_faces <= 1;         // num faces in cubemap; >= 1
	 // ok &= hd.num_mipmaps <= 1;       // num levels of mipmaps; >= 1
	 // ok &= hd.metadata_size == 0;     // length of following header
		ok &= hd.pixel_format_2 == 0;    // 0
		ok &= (                          // see table1 above
			   hd.pixel_format_1 == table1::ETC1
			|| hd.pixel_format_1 <= table1::PVRTC_4BPP_RGBA
		);
		return ok;
	}

	int get_spot_fmt() const {
		return hd.pixel_format_1;
	}

	std::ostream &debug( std::ostream &ss ) const {
		if( !is_pvr() ) {
			ss << "not a .pvr3 header" << std::endl;
		} else {
			ss << "supported .pvr3 file: " << is_currently_supported() << std::endl;
			ss << std::hex;
			ss << "pvr.version: 0x" << hd.version << std::endl;
			ss << "pvr.flags: 0x" << hd.flags << std::endl;
			ss << "pvr.pixel_format_1: 0x" << hd.pixel_format_1 << std::endl;
			ss << "pvr.pixel_format_2: 0x" << hd.pixel_format_2 << std::endl;
			ss << "pvr.color_space: 0x" << hd.color_space << std::endl;
			ss << "pvr.channel_type: 0x" << hd.channel_type << std::endl;
			ss << std::dec;
			ss << "pvr.height: " << hd.height << std::endl;
			ss << "pvr.width: " << hd.width << std::endl;
			ss << "pvr.depth: " << hd.depth << std::endl;
			ss << "pvr.num_surfaces: " << hd.num_surfaces << std::endl;
			ss << "pvr.num_faces: " << hd.num_faces << std::endl;
			ss << "pvr.num_mipmaps: " << hd.num_mipmaps << std::endl;
			ss << "pvr.metadata_size: " << hd.metadata_size << std::endl;
			ss << std::endl;
		}
		return ss;
	}

};



//#line 1 "pkm.hpp"
// - rlyeh, public domain

struct pkm {
	struct header {
		uint32_t id;                // "PKM "
		uint16_t version;           // "10"
		uint16_t type;              // 0: ETC1_RGB_NO_MIPMAPS
		uint16_t width;             // after %4; big endian
		uint16_t height;            // after %4; big endian
		uint16_t width_src;         // original width; big endian
		uint16_t height_src;        // original height; big endian
	} hd;
	struct texturedata {
		uint32_t data;              // dummy field [raw binary data here]
	} tx;

	bool is_pkm() const {
		const char xx[] = {'P','K','M',' ','1','0'};
		return 0 == memcmp(this, xx, sizeof(xx));
	}

	bool is_currently_supported() const {
		return is_pkm() && get_spot_fmt() != -1;
	}

	int get_spot_fmt() const {
		return hd.type == 0 ? pvr3::table1::ETC1 : -1;
	}

	std::ostream &debug( std::ostream &ss ) const {
		if( !is_pkm() ) {
			ss << "not a .pkm header" << std::endl;
		} else {
			ss << "supported .pkm file: " << is_currently_supported() << std::endl;
			ss << "pkm.id: "; ss.write( (const char *)&hd.id, sizeof(hd.id) ); ss << std::endl;
			ss << "pkm.version: "; ss.write( (const char *)&hd.version, sizeof(hd.version) ); ss << std::endl;
			ss << std::hex;
			ss << "pkm.type: 0x" << hd.type << std::endl;
			ss << std::dec;
			ss << "pkm.width: " << hd.width << std::endl;
			ss << "pkm.height: " << hd.height << std::endl;
			ss << "pkm.width_src: " << hd.width_src << std::endl;
			ss << "pkm.height_src: " << hd.height_src << std::endl;
			ss << std::endl;
		}
		return ss;
	}
};


//#line 1 "ktx.hpp"
// - rlyeh, public domain

struct ktx {
	struct header {
		uint32_t identifier0;           // '+', 'K', 'T', 'X', ' ', '1', '1', ';', '\r', '\n', '\x1A', '\n'
		uint32_t identifier1;
		uint32_t identifier2;
		uint32_t endianness;            // 0x04030201 a little endian program must convert from big endian, and a big endian program must convert to little endian

		uint32_t glType;                // compressed == 0
		uint32_t glTypeSize;            // compressed == 1
		uint32_t glFormat;              // STENCIL_INDEX, DEPTH_COMPONENT, DEPTH_STENCIL, RED, GREEN, BLUE, RG, RGB, RGBA, BGR, BGRA, RED_INTEGER, GREEN_INTEGER, BLUE_INTEGER, RG_INTEGER, RGB_INTEGER, RGBA_INTEGER, BGR_INTEGER, BGRA_INTEGER,
		uint32_t glInternalFormat;      // COMPRESSED_RED, COMPRESSED_RG, COMPRESSED_RGB, COMPRESSED_RGBA, COMPRESSED_SRGB, COMPRESSED_SRGB_ALPHA, COMPRESSED_RED_RGTC1, COMPRESSED_SIGNED_RED_RGTC1, COMPRESSED_RG_RGTC2, COMPRESSED_SIGNED_RG_RGTC2, COMPRESSED_RGBA_BPTC_UNORM, COMPRESSED_SRGB_ALPHA_BPTC_UNORM, COMPRESSED_RGB_BPTC_SIGNED_FLOAT, COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC,

		uint32_t glBaseInternalFormat;  // DEPTH_COMPONENT, DEPTH_STENCIL, RED, RG, RGB, RGBA, STENCIL_INDEX,
		uint32_t pixelWidth;
		uint32_t pixelHeight;
		uint32_t pixelDepth;

		uint32_t numberOfArrayElements;
		uint32_t numberOfFaces;
		uint32_t numberOfMipmapLevels;
		uint32_t bytesOfKeyValueData;
	} hd;

	struct metadata {
		uint32_t keyAndValueByteSize;
		uint8_t  keyAndValue;
		uint8_t  valuePadding;
	} mt;

	struct texturedata {
		uint32_t size;
		uint32_t data;
	} tx;

	bool is_ktx() const {
		const char id[] = { char(0xAB), 'K', 'T', 'X', ' ', '1', '1', char(0xBB), '\r', '\n', '\x1A', '\n' };
		return 0 == memcmp( id, &hd, sizeof(id) );
	}

	bool is_currently_supported() const {
		bool ok = true;
		ok &= is_ktx();
		ok &= hd.pixelDepth <= 1;
//        ok &= hd.bytesOfKeyValueData == 0;
//        ok &= hd.numberOfMipmapLevels <= 1;
		ok &= hd.numberOfArrayElements <= 1;
		ok &= hd.numberOfFaces <= 1;
		ok &= get_spot_fmt() != -1;
		return ok;
	}

	int get_spot_fmt() const {
		if( hd.glInternalFormat == 0x8d64 && hd.glBaseInternalFormat == 0x1907 ) return pvr3::table1::ETC1;            // etc1
		if( hd.glInternalFormat == 0x8c01 && hd.glBaseInternalFormat == 0x1907 ) return pvr3::table1::PVRTC_2BPP_RGB;  // pvrtc-2bpp-rgb
		if( hd.glInternalFormat == 0x8c03 && hd.glBaseInternalFormat == 0x1908 ) return pvr3::table1::PVRTC_2BPP_RGBA; // pvrtc-2bpp-rgba
		if( hd.glInternalFormat == 0x8c00 && hd.glBaseInternalFormat == 0x1907 ) return pvr3::table1::PVRTC_4BPP_RGB;  // pvrtc-4bpp-rgb
		if( hd.glInternalFormat == 0x8c02 && hd.glBaseInternalFormat == 0x1908 ) return pvr3::table1::PVRTC_4BPP_RGBA; // pvrtc-4bpp-rgba
		return -1;
	}

	std::ostream &debug( std::ostream &ss ) const {
		if( !is_ktx() ) {
			ss << "not a .ktx header" << std::endl;
		} else {
			ss << "supported .ktx file: " << is_currently_supported() << std::endl;
			ss << std::hex;
			ss << "ktx.identifier0: 0x" << hd.identifier0 << std::endl;
			ss << "ktx.identifier1: 0x" << hd.identifier1 << std::endl;
			ss << "ktx.identifier2: 0x" << hd.identifier2 << std::endl;
			ss << "ktx.endianness: 0x" << std::hex << hd.endianness << std::endl;
			ss << "ktx.glType: 0x" << hd.glType << std::endl;
			ss << "ktx.glTypeSize: 0x" << hd.glTypeSize << std::endl;
			ss << "ktx.glFormat: 0x" << std::hex << hd.glFormat << std::endl;
			ss << "ktx.glInternalFormat: 0x" << std::hex << hd.glInternalFormat << std::endl;
			ss << "ktx.glBaseInternalFormat: 0x" << std::hex << hd.glBaseInternalFormat << std::endl;
			ss << std::dec;
			ss << "ktx.pixelWidth: " << hd.pixelWidth << std::endl;
			ss << "ktx.pixelHeight: " << hd.pixelHeight << std::endl;
			ss << "ktx.pixelDepth: " << hd.pixelDepth << std::endl;
			ss << "ktx.numberOfArrayElements: " << hd.numberOfArrayElements << std::endl;
			ss << "ktx.numberOfFaces: " << hd.numberOfFaces << std::endl;
			ss << "ktx.numberOfMipmapLevels: " << hd.numberOfMipmapLevels << std::endl;
			ss << "ktx.bytesOfKeyValueData: " << hd.bytesOfKeyValueData << std::endl;
			ss << std::endl;
		}
		return ss;
	}
};


//#line 1 "PVRTDecompress.cpp"
typedef unsigned char      PVRTuint8;
typedef unsigned short     PVRTuint16;
typedef unsigned int       PVRTuint32;

/*****************************************************************************
 * defines and consts
 *****************************************************************************/
#define PT_INDEX (2)	// The Punch-through index

#define BLK_Y_SIZE 	(4) // always 4 for all 2D block types

#define BLK_X_MAX	(8)	// Max X dimension for blocks

#define BLK_X_2BPP	(8) // dimensions for the two formats
#define BLK_X_4BPP	(4)

#define WRAP_COORD(Val, Size) ((Val) & ((Size)-1))

#define POWER_OF_2(X)   util_number_is_power_2(X)

/*
	Define an expression to either wrap or clamp large or small vals to the
	legal coordinate range
*/
#define PVRT_MIN(a,b)            (((a) < (b)) ? (a) : (b))
#define PVRT_MAX(a,b)            (((a) > (b)) ? (a) : (b))
#define PVRT_CLAMP(x, l, h)      (PVRT_MIN((h), PVRT_MAX((x), (l))))

#define LIMIT_COORD(Val, Size, AssumeImageTiles) \
	  ((AssumeImageTiles)? WRAP_COORD((Val), (Size)): PVRT_CLAMP((Val), 0, (Size)-1))

/*****************************************************************************
 * Useful typedefs
 *****************************************************************************/
typedef PVRTuint32 U32;
typedef PVRTuint8 U8;

/***********************************************************
				DECOMPRESSION ROUTINES
************************************************************/

/*!***********************************************************************
 @Struct	AMTC_BLOCK_STRUCT
 @Brief
*************************************************************************/
typedef struct
{
	// Uses 64 bits pre block
	U32 PackedData[2];
}AMTC_BLOCK_STRUCT;

 /*!***********************************************************************
  @Function		util_number_is_power_2
  @Input		input A number
  @Returns		TRUE if the number is an integer power of two, else FALSE.
  @Description	Check that a number is an integer power of two, i.e.
				1, 2, 4, 8, ... etc.
				Returns FALSE for zero.
*************************************************************************/
int util_number_is_power_2( unsigned  input )
{
  unsigned minus1;

  if( !input ) return 0;

  minus1 = input - 1;
  return ( (input | minus1) == (input ^ minus1) ) ? 1 : 0;
}

/*!***********************************************************************
 @Function		Unpack5554Colour
 @Input			pBlock
 @Input			ABColours
 @Description	Given a block, extract the colour information and convert
				to 5554 formats
*************************************************************************/
static void Unpack5554Colour(const AMTC_BLOCK_STRUCT *pBlock,
							 int   ABColours[2][4])
{
	U32 RawBits[2];

	int i;

	// Extract A and B
	RawBits[0] = pBlock->PackedData[1] & (0xFFFE); // 15 bits (shifted up by one)
	RawBits[1] = pBlock->PackedData[1] >> 16;	   // 16 bits

	// step through both colours
	for(i = 0; i < 2; i++)
	{
		// If completely opaque
		if(RawBits[i] & (1<<15))
		{
			// Extract R and G (both 5 bit)
			ABColours[i][0] = (RawBits[i] >> 10) & 0x1F;
			ABColours[i][1] = (RawBits[i] >>  5) & 0x1F;

			/*
				The precision of Blue depends on  A or B. If A then we need to
				replicate the top bit to get 5 bits in total
			*/
			ABColours[i][2] = RawBits[i] & 0x1F;
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// set 4bit alpha fully on...
			ABColours[i][3] = 0xF;
		}
		else // Else if colour has variable translucency
		{
			/*
				Extract R and G (both 4 bit).
				(Leave a space on the end for the replication of bits
			*/
			ABColours[i][0] = (RawBits[i] >>  (8-1)) & 0x1E;
			ABColours[i][1] = (RawBits[i] >>  (4-1)) & 0x1E;

			// replicate bits to truly expand to 5 bits
			ABColours[i][0] |= ABColours[i][0] >> 4;
			ABColours[i][1] |= ABColours[i][1] >> 4;

			// grab the 3(+padding) or 4 bits of blue and add an extra padding bit
			ABColours[i][2] = (RawBits[i] & 0xF) << 1;

			/*
				expand from 3 to 5 bits if this is from colour A, or 4 to 5 bits if from
				colour B
			*/
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 3;
			}
			else
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// Set the alpha bits to be 3 + a zero on the end
			ABColours[i][3] = (RawBits[i] >> 11) & 0xE;
		}
	}
}

/*!***********************************************************************
 @Function		UnpackModulations
 @Input			pBlock
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			StartX
 @Input			StartY
 @Description	Given the block and the texture type and it's relative
				position in the 2x2 group of blocks, extract the bit
				patterns for the fully defined pixels.
*************************************************************************/
static void	UnpackModulations(const AMTC_BLOCK_STRUCT *pBlock,
							  const int Do2bitMode,
							  int ModulationVals[8][16],
							  int ModulationModes[8][16],
							  int StartX,
							  int StartY)
{
	int BlockModMode;
	U32 ModulationBits;

	int x, y;

	BlockModMode= pBlock->PackedData[1] & 1;
	ModulationBits	= pBlock->PackedData[0];

	// if it's in an interpolated mode
	if(Do2bitMode && BlockModMode)
	{
		/*
			run through all the pixels in the block. Note we can now treat all the
			"stored" values as if they have 2bits (even when they didn't!)
		*/
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// if this is a stored value...
				if(((x^y)&1) == 0)
				{
					ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
					ModulationBits >>= 2;
				}
			}
		}
	}
	else if(Do2bitMode) // else if direct encoded 2bit mode - i.e. 1 mode bit per pixel
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// double the bits so 0=> 00, and 1=>11
				if(ModulationBits & 1)
				{
					ModulationVals[y+StartY][x+StartX] = 0x3;
				}
				else
				{
					ModulationVals[y+StartY][x+StartX] = 0x0;
				}
				ModulationBits >>= 1;
			}
		}
	}
	else // else its the 4bpp mode so each value has 2 bits
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_4BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
				ModulationBits >>= 2;
			}
		}
	}

	// make sure nothing is left over
	assert(ModulationBits==0);
}

/*!***********************************************************************
 @Function		InterpolateColours
 @Input			ColourP
 @Input			ColourQ
 @Input			ColourR
 @Input			ColourS
 @Input			Do2bitMode
 @Input			x
 @Input			y
 @Modified		Result
 @Description	This performs a HW bit accurate interpolation of either the
				A or B colours for a particular pixel.

				NOTE: It is assumed that the source colours are in ARGB 5554
				format - This means that some "preparation" of the values will
				be necessary.
*************************************************************************/
static void InterpolateColours(const int ColourP[4],
						  const int ColourQ[4],
						  const int ColourR[4],
						  const int ColourS[4],
						  const int Do2bitMode,
						  const int x,
						  const int y,
						  int Result[4])
{
	int u, v, uscale;
	int k;

	int tmp1, tmp2;

	int P[4], Q[4], R[4], S[4];

	// Copy the colours
	for(k = 0; k < 4; k++)
	{
		P[k] = ColourP[k];
		Q[k] = ColourQ[k];
		R[k] = ColourR[k];
		S[k] = ColourS[k];
	}

	// put the x and y values into the right range
	v = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		u = (x & 0x7) | ((~x & 0x4) << 1);
	else
		u = (x & 0x3) | ((~x & 0x2) << 1);

	// get the u and v scale amounts
	v  = v - BLK_Y_SIZE/2;

	if(Do2bitMode)
	{
		u = u - BLK_X_2BPP/2;
		uscale = 8;
	}
	else
	{
		u = u - BLK_X_4BPP/2;
		uscale = 4;
	}

	for(k = 0; k < 4; k++)
	{
		tmp1 = P[k] * uscale + u * (Q[k] - P[k]);
		tmp2 = R[k] * uscale + u * (S[k] - R[k]);

		tmp1 = tmp1 * 4 + v * (tmp2 - tmp1);

		Result[k] = tmp1;
	}

	// Lop off the appropriate number of bits to get us to 8 bit precision
	if(Do2bitMode)
	{
		// do RGB
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 2;
		}

		Result[3] >>= 1;
	}
	else
	{
		// do RGB  (A is ok)
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 1;
		}
	}

	// sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

	/*
		Convert from 5554 to 8888

		do RGB 5.3 => 8
	*/
	for(k = 0; k < 3; k++)
	{
		Result[k] += Result[k] >> 5;
	}

	Result[3] += Result[3] >> 4;

	// 2nd sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

}

/*!***********************************************************************
 @Function		GetModulationValue
 @Input			x
 @Input			y
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			Mod
 @Input			DoPT
 @Description	Get the modulation value as a numerator of a fraction of 8ths
*************************************************************************/
static void GetModulationValue(int x,
							   int y,
							   const int Do2bitMode,
							   const int ModulationVals[8][16],
							   const int ModulationModes[8][16],
							   int *Mod,
							   int *DoPT)
{
	static const int RepVals0[4] = {0, 3, 5, 8};
	static const int RepVals1[4] = {0, 4, 4, 8};

	int ModVal;

	// Map X and Y into the local 2x2 block
	y = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		x = (x & 0x7) | ((~x & 0x4) << 1);
	else
		x = (x & 0x3) | ((~x & 0x2) << 1);

	// assume no PT for now
	*DoPT = 0;

	// extract the modulation value. If a simple encoding
	if(ModulationModes[y][x]==0)
	{
		ModVal = RepVals0[ModulationVals[y][x]];
	}
	else if(Do2bitMode)
	{
		// if this is a stored value
		if(((x^y)&1)==0)
			ModVal = RepVals0[ModulationVals[y][x]];
		else if(ModulationModes[y][x] == 1) // else average from the neighbours if H&V interpolation..
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] +
					  RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 2) / 4;
		}
		else if(ModulationModes[y][x] == 2) // else if H-Only
		{
			ModVal = (RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 1) / 2;
		}
		else // else it's V-Only
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] + 1) / 2;
		}
	}
	else // else it's 4BPP and PT encoding
	{
		ModVal = RepVals1[ModulationVals[y][x]];

		*DoPT = ModulationVals[y][x] == PT_INDEX;
	}

	*Mod =ModVal;
}

/*!***********************************************************************
 @Function		TwiddleUV
 @Input			YSize	Y dimension of the texture in pixels
 @Input			XSize	X dimension of the texture in pixels
 @Input			YPos	Pixel Y position
 @Input			XPos	Pixel X position
 @Returns		The twiddled offset of the pixel
 @Description	Given the Block (or pixel) coordinates and the dimension of
				the texture in blocks (or pixels) this returns the twiddled
				offset of the block (or pixel) from the start of the map.

				NOTE the dimensions of the texture must be a power of 2
*************************************************************************/
static int DisableTwiddlingRoutine = 0;

static U32 TwiddleUV(U32 YSize, U32 XSize, U32 YPos, U32 XPos)
{
	U32 Twiddled;

	U32 MinDimension;
	U32 MaxValue;

	U32 SrcBitPos;
	U32 DstBitPos;

	int ShiftCount;

	assert(YPos < YSize);
	assert(XPos < XSize);

	assert(POWER_OF_2(YSize));
	assert(POWER_OF_2(XSize));

	if(YSize < XSize)
	{
		MinDimension = YSize;
		MaxValue	 = XPos;
	}
	else
	{
		MinDimension = XSize;
		MaxValue	 = YPos;
	}

	// Nasty hack to disable twiddling
	if(DisableTwiddlingRoutine)
		return (YPos* XSize + XPos);

	// Step through all the bits in the "minimum" dimension
	SrcBitPos = 1;
	DstBitPos = 1;
	Twiddled  = 0;
	ShiftCount = 0;

	while(SrcBitPos < MinDimension)
	{
		if(YPos & SrcBitPos)
		{
			Twiddled |= DstBitPos;
		}

		if(XPos & SrcBitPos)
		{
			Twiddled |= (DstBitPos << 1);
		}

		SrcBitPos <<= 1;
		DstBitPos <<= 2;
		ShiftCount += 1;

	}

	// prepend any unused bits
	MaxValue >>= ShiftCount;

	Twiddled |=  (MaxValue << (2*ShiftCount));

	return Twiddled;
}

/***********************************************************/
/*
// Decompress
//
// Takes the compressed input data and outputs the equivalent decompressed
// image.
*/
/***********************************************************/

static void Decompress(AMTC_BLOCK_STRUCT *pCompressedData,
					   const int Do2bitMode,
					   const int XDim,
					   const int YDim,
					   const int AssumeImageTiles,
					   unsigned char* pResultImage)
{
	int x, y;
	int i, j;

	int BlkX, BlkY;
	int BlkXp1, BlkYp1;
	int XBlockSize;
	int BlkXDim, BlkYDim;

	int StartX, StartY;

	int ModulationVals[8][16];
	int ModulationModes[8][16];

	int Mod, DoPT;

	unsigned int uPosition;

	/*
	// local neighbourhood of blocks
	*/
	AMTC_BLOCK_STRUCT *pBlocks[2][2];

	AMTC_BLOCK_STRUCT *pPrevious[2][2] = {{NULL, NULL}, {NULL, NULL}};

	/*
	// Low precision colours extracted from the blocks
	*/
	struct
	{
		int Reps[2][4];
	}Colours5554[2][2];

	/*
	// Interpolated A and B colours for the pixel
	*/
	int ASig[4], BSig[4];

	int Result[4];

	if(Do2bitMode)
	{
		XBlockSize = BLK_X_2BPP;
	}
	else
	{
		XBlockSize = BLK_X_4BPP;
	}

	/*
	// For MBX don't allow the sizes to get too small
	*/
	BlkXDim = PVRT_MAX(2, XDim / XBlockSize);
	BlkYDim = PVRT_MAX(2, YDim / BLK_Y_SIZE);

	/*
	// Step through the pixels of the image decompressing each one in turn
	//
	// Note that this is a hideously inefficient way to do this!
	*/
	for(y = 0; y < YDim; y++)
	{
		for(x = 0; x < XDim; x++)
		{
			/*
			// map this pixel to the top left neighbourhood of blocks
			*/
			BlkX = (x - XBlockSize/2);
			BlkY = (y - BLK_Y_SIZE/2);

			BlkX = LIMIT_COORD(BlkX, XDim, AssumeImageTiles);
			BlkY = LIMIT_COORD(BlkY, YDim, AssumeImageTiles);

			BlkX /= XBlockSize;
			BlkY /= BLK_Y_SIZE;

			//BlkX = LIMIT_COORD(BlkX, BlkXDim, AssumeImageTiles);
			//BlkY = LIMIT_COORD(BlkY, BlkYDim, AssumeImageTiles);

			/*
			// compute the positions of the other 3 blocks
			*/
			BlkXp1 = LIMIT_COORD(BlkX+1, BlkXDim, AssumeImageTiles);
			BlkYp1 = LIMIT_COORD(BlkY+1, BlkYDim, AssumeImageTiles);

			/*
			// Map to block memory locations
			*/
			pBlocks[0][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkX);
			pBlocks[0][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkXp1);
			pBlocks[1][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkX);
			pBlocks[1][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkXp1);

			/*
			// extract the colours and the modulation information IF the previous values
			// have changed.
			*/
			if(memcmp(pPrevious, pBlocks, 4*sizeof(void*)) != 0)
			{
				StartY = 0;
				for(i = 0; i < 2; i++)
				{
					StartX = 0;
					for(j = 0; j < 2; j++)
					{
						Unpack5554Colour(pBlocks[i][j], Colours5554[i][j].Reps);

						UnpackModulations(pBlocks[i][j],
							Do2bitMode,
							ModulationVals,
							ModulationModes,
							StartX, StartY);

						StartX += XBlockSize;
					}/*end for j*/

					StartY += BLK_Y_SIZE;
				}/*end for i*/

				/*
				// make a copy of the new pointers
				*/
				memcpy(pPrevious, pBlocks, 4*sizeof(void*));
			}/*end if the blocks have changed*/

			/*
			// decompress the pixel.  First compute the interpolated A and B signals
			*/
			InterpolateColours(Colours5554[0][0].Reps[0],
				Colours5554[0][1].Reps[0],
				Colours5554[1][0].Reps[0],
				Colours5554[1][1].Reps[0],
				Do2bitMode, x, y,
				ASig);

			InterpolateColours(Colours5554[0][0].Reps[1],
				Colours5554[0][1].Reps[1],
				Colours5554[1][0].Reps[1],
				Colours5554[1][1].Reps[1],
				Do2bitMode, x, y,
				BSig);

			GetModulationValue(x,y, Do2bitMode, (const int (*)[16])ModulationVals, (const int (*)[16])ModulationModes,
				&Mod, &DoPT);

			/*
			// compute the modulated colour
			*/
			for(i = 0; i < 4; i++)
			{
				Result[i] = ASig[i] * 8 + Mod * (BSig[i] - ASig[i]);
				Result[i] >>= 3;
			}
			if(DoPT)
			{
				Result[3] = 0;
			}

			/*
			// Store the result in the output image
			*/
			uPosition = (x+y*XDim)<<2;
			pResultImage[uPosition+0] = (unsigned char)Result[0];
			pResultImage[uPosition+1] = (unsigned char)Result[1];
			pResultImage[uPosition+2] = (unsigned char)Result[2];
			pResultImage[uPosition+3] = (unsigned char)Result[3];

		}/*end for x*/
	}/*end for y*/

}

}

#define Bitmap Bitmap2

//#line 1 "Bitmap.cpp"
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <string>


//#line 1 "Bitmap.hpp"
#ifndef __DARKRL__BITMAP_HPP__
#define __DARKRL__BITMAP_HPP__

#include <memory>


//#line 1 "Types.hpp"
#ifndef __DARKRL__TYPES_HPP__
#define __DARKRL__TYPES_HPP__

#include <stdint.h>

typedef unsigned int uint;

#endif


//#line 1 "Vector.hpp"
#ifndef __DARKRL__VECTOR_HPP__
#define __DARKRL__VECTOR_HPP__

#include <assert.h>
#include <algorithm>
#include <math.h>


//#line 1 "Math.hpp"
#ifndef __DARKRL__MATH_HPP__
#define __DARKRL__MATH_HPP__

#include <algorithm>

template<typename T>
inline T AlignPOT( T val )
{
	if( val == 0 ) return 1;
	val--;
	for( unsigned int i=1; i<sizeof( T ) * 8; i <<= 1 )
	{
		val |= val >> i;
	}
	return val + 1;
}

inline int CountSetBits( uint32_t val )
{
	val -= ( val >> 1 ) & 0x55555555;
	val = ( ( val >> 2 ) & 0x33333333 ) + ( val & 0x33333333 );
	val = ( ( val >> 4 ) + val ) & 0x0f0f0f0f;
	val += val >> 8;
	val += val >> 16;
	return val & 0x0000003f;
}

inline int CountLeadingZeros( uint32_t val )
{
	val |= val >> 1;
	val |= val >> 2;
	val |= val >> 4;
	val |= val >> 8;
	val |= val >> 16;
	return 32 - CountSetBits( val );
}

inline float sRGB2linear( float v )
{
	const float a = 0.055f;
	if( v <= 0.04045f )
	{
		return v / 12.92f;
	}
	else
	{
		return pow( ( v + a ) / ( 1 + a ), 2.4f );
	}
}

inline float linear2sRGB( float v )
{
	const float a = 0.055f;
	if( v <= 0.0031308f )
	{
		return 12.92f * v;
	}
	else
	{
		return ( 1 + a ) * pow( v, 1/2.4f ) - a;
	}
}

template<class T>
inline T SmoothStep( T x )
{
	return x*x*(3-2*x);
}

inline uint8_t clampu8( int32_t val )
{
	return std::min( std::max( 0, val ), 255 );
}

template<class T>
inline T sq( T val )
{
	return val * val;
}

static inline int mul8bit( int a, int b )
{
	int t = a*b + 128;
	return ( t + ( t >> 8 ) ) >> 8;
}

#endif

template<class T>
struct Vector2
{
	Vector2() : x( 0 ), y( 0 ) {}
	Vector2( T v ) : x( v ), y( v ) {}
	Vector2( T _x, T _y ) : x( _x ), y( _y ) {}

	bool operator==( const Vector2<T>& rhs ) const { return x == rhs.x && y == rhs.y; }
	bool operator!=( const Vector2<T>& rhs ) const { return !( *this == rhs ); }

	Vector2<T>& operator+=( const Vector2<T>& rhs )
	{
		x += rhs.x;
		y += rhs.y;
		return *this;
	}
	Vector2<T>& operator-=( const Vector2<T>& rhs )
	{
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}
	Vector2<T>& operator*=( const Vector2<T>& rhs )
	{
		x *= rhs.x;
		y *= rhs.y;
		return *this;
	}

	T x, y;
};

template<class T>
Vector2<T> operator+( const Vector2<T>& lhs, const Vector2<T>& rhs )
{
	return Vector2<T>( lhs.x + rhs.x, lhs.y + rhs.y );
}

template<class T>
Vector2<T> operator-( const Vector2<T>& lhs, const Vector2<T>& rhs )
{
	return Vector2<T>( lhs.x - rhs.x, lhs.y - rhs.y );
}

template<class T>
Vector2<T> operator*( const Vector2<T>& lhs, const float& rhs )
{
	return Vector2<T>( lhs.x * rhs, lhs.y * rhs );
}

template<class T>
Vector2<T> operator/( const Vector2<T>& lhs, const T& rhs )
{
	return Vector2<T>( lhs.x / rhs, lhs.y / rhs );
}

typedef Vector2<int32_t> v2i;
typedef Vector2<float> v2f;

template<class T>
struct Vector3
{
	Vector3() : x( 0 ), y( 0 ), z( 0 ) {}
	Vector3( T v ) : x( v ), y( v ), z( v ) {}
	Vector3( T _x, T _y, T _z ) : x( _x ), y( _y ), z( _z ) {}
	template<class Y>
	Vector3( const Vector3<Y>& v ) : x( T( v.x ) ), y( T( v.y ) ), z( T( v.z ) ) {}

	T Luminance() const { return T( x * 0.3f + y * 0.59f + z * 0.11f ); }
	void Clamp()
	{
		x = std::min( T(1), std::max( T(0), x ) );
		y = std::min( T(1), std::max( T(0), y ) );
		z = std::min( T(1), std::max( T(0), z ) );
	}

	bool operator==( const Vector3<T>& rhs ) const { return x == rhs.x && y == rhs.y && z == rhs.z; }
	bool operator!=( const Vector2<T>& rhs ) const { return !( *this == rhs ); }

	T& operator[]( uint idx ) { assert( idx < 3 ); return ((T*)this)[idx]; }
	const T& operator[]( uint idx ) const { assert( idx < 3 ); return ((T*)this)[idx]; }

	Vector3<T> operator+=( const Vector3<T>& rhs )
	{
		x += rhs.x;
		y += rhs.y;
		z += rhs.z;
		return *this;
	}

	Vector3<T> operator*=( const Vector3<T>& rhs )
	{
		x *= rhs.x;
		y *= rhs.y;
		z *= rhs.z;
		return *this;
	}

	Vector3<T> operator*=( const float& rhs )
	{
		x *= rhs;
		y *= rhs;
		z *= rhs;
		return *this;
	}

	T x, y, z;
	T padding;
};

template<class T>
Vector3<T> operator+( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return Vector3<T>( lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z );
}

template<class T>
Vector3<T> operator-( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return Vector3<T>( lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z );
}

template<class T>
Vector3<T> operator*( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return Vector3<T>( lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z );
}

template<class T>
Vector3<T> operator*( const Vector3<T>& lhs, const float& rhs )
{
	return Vector3<T>( T( lhs.x * rhs ), T( lhs.y * rhs ), T( lhs.z * rhs ) );
}

template<class T>
Vector3<T> operator/( const Vector3<T>& lhs, const T& rhs )
{
	return Vector3<T>( lhs.x / rhs, lhs.y / rhs, lhs.z / rhs );
}

template<class T>
bool operator<( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return lhs.Luminance() < rhs.Luminance();
}

typedef Vector3<int32_t> v3i;
typedef Vector3<float> v3f;
typedef Vector3<uint8_t> v3b;

static inline v3b v3f_to_v3b( const v3f& v )
{
	return v3b( uint8_t( std::min( 1.f, v.x ) * 255 ), uint8_t( std::min( 1.f, v.y ) * 255 ), uint8_t( std::min( 1.f, v.z ) * 255 ) );
}

template<class T>
Vector3<T> Mix( const Vector3<T>& v1, const Vector3<T>& v2, float amount )
{
	return v1 + ( v2 - v1 ) * amount;
}

template<>
inline v3b Mix( const v3b& v1, const v3b& v2, float amount )
{
	return v3b( v3f( v1 ) + ( v3f( v2 ) - v3f( v1 ) ) * amount );
}

template<class T>
Vector3<T> Desaturate( const Vector3<T>& v )
{
	T l = v.Luminance();
	return Vector3<T>( l, l, l );
}

template<class T>
Vector3<T> Desaturate( const Vector3<T>& v, float mul )
{
	T l = T( v.Luminance() * mul );
	return Vector3<T>( l, l, l );
}

template<class T>
Vector3<T> pow( const Vector3<T>& base, float exponent )
{
	return Vector3<T>(
		pow( base.x, exponent ),
		pow( base.y, exponent ),
		pow( base.z, exponent ) );
}

template<class T>
Vector3<T> sRGB2linear( const Vector3<T>& v )
{
	return Vector3<T>(
		sRGB2linear( v.x ),
		sRGB2linear( v.y ),
		sRGB2linear( v.z ) );
}

template<class T>
Vector3<T> linear2sRGB( const Vector3<T>& v )
{
	return Vector3<T>(
		linear2sRGB( v.x ),
		linear2sRGB( v.y ),
		linear2sRGB( v.z ) );
}

#endif

class Bitmap
{
public:
	Bitmap( const uint32_t* data, uint len, uint width, uint height, uint lines );
	Bitmap( const v2i& size );
	virtual ~Bitmap();

	const uint32_t* Data() const { return m_data; }
	const v2i& Size() const { return m_size; }
	bool Alpha() const { return m_alpha; }

	const uint32_t* NextBlock( uint& lines, bool& done );

protected:
	Bitmap( const Bitmap& src, uint lines );

	const uint32_t* m_data;
	const uint32_t* m_block;
	uint m_lines;
	uint m_linesLeft;
	uint32_t *m_padding;
	v2i m_size;
	bool m_alpha;
};

typedef std::shared_ptr<Bitmap> BitmapPtr;

#endif


//#line 1 "Common.hpp"
#ifndef __DARKRL__UTILS_HPP__
#define __DARKRL__UTILS_HPP__

#include <assert.h>
#include <stddef.h>

#ifdef DEBUG
#  include <sstream>
#  include <stdlib.h>
#  define DBGPRINT(msg) do { std::stringstream __buf; __buf << msg; printf( "%s", __buf.str().c_str() ); } while(0)
#else
#  define DBGPRINT(msg) do { ((void)0); } while(0)
#endif

float CalcMSE3( const Bitmap& bmp, const Bitmap& out );
float CalcMSE1( const Bitmap& bmp, const Bitmap& out );
void Dither( uint8_t* data );

inline int NumberOfMipLevels( const v2i& size )
{
	//return (int)floor( log2( std::max( size.x, size.y ) ) ) + 1;
	double log2n = log( std::max( size.x, size.y ) ) / log( 2. );
	return (int)floor( log2n ) + 1;
}

extern const int32_t g_table[8][4];
extern const int64_t g_table256[8][4];

extern const uint32_t g_id[4][16];

extern const uint32_t g_avg2[16];

// process {
uint64_t ProcessAlpha( const uint8_t* src );
uint64_t ProcessRGB( const uint8_t* src );

template<class T>
static size_t GetLeastError( const T* err, size_t num )
{
	size_t idx = 0;
	for( size_t i=1; i<num; i++ )
	{
		if( err[i] < err[idx] )
		{
			idx = i;
		}
	}
	return idx;
}

static uint64_t FixByteOrder( uint64_t d )
{
	return ( ( d & 0x00000000FFFFFFFF ) ) |
		   ( ( d & 0xFF00000000000000 ) >> 24 ) |
		   ( ( d & 0x000000FF00000000 ) << 24 ) |
		   ( ( d & 0x00FF000000000000 ) >> 8 ) |
		   ( ( d & 0x0000FF0000000000 ) << 8 );
}

template<class T>
static uint64_t EncodeSelectors( uint64_t d, const T terr[2][8], const uint tsel[16][8], const uint32_t* id )
{
	size_t tidx[2];
	tidx[0] = GetLeastError( terr[0], 8 );
	tidx[1] = GetLeastError( terr[1], 8 );

	d |= tidx[0] << 26;
	d |= tidx[1] << 29;
	for( int i=0; i<16; i++ )
	{
		uint64_t t = tsel[i][tidx[id[i]%2]];
		d |= ( t & 0x1 ) << ( i + 32 );
		d |= ( t & 0x2 ) << ( i + 47 );
	}

	return d;
}
// }

#endif

Bitmap::Bitmap( const uint32_t* data, uint len, uint width, uint height, uint lines )
	: m_block( nullptr )
	, m_lines( lines )
	, m_padding( 0 )
	, m_alpha( false ) //len > width * height * 3 )
{
	m_size.x = ( width / 4 ) * 4;
	m_size.y = ( height / 4 ) * 4;

	// crop right border if not multiple of 4
	if( width > m_size.x ) {
		m_padding = new uint32_t [m_size.x * m_size.y];
		for( unsigned y = 0; y < m_size.y; ++y ) {
			memcpy( &m_padding[ y * m_size.x ], &data[ y * width ], m_size.x * 4 );
		}
		data = m_padding;
	}

	m_block = m_data = (const uint32_t *)data;
	m_linesLeft = m_size.y / 4;
}

Bitmap::Bitmap( const Bitmap& src, uint lines )
	: m_lines( lines )
	, m_linesLeft( 0)
	, m_padding( 0 )
	, m_alpha( src.Alpha() )
{
}

Bitmap::~Bitmap() {
	if( m_padding ) {
		delete [] m_padding;
	}
}

const uint32_t* Bitmap::NextBlock( uint& lines, bool& done )
{
	lines = std::min( m_lines, m_linesLeft );
	auto ret = m_block;
	m_block += m_size.x * 4 * lines;
	m_linesLeft -= lines;
	done = m_linesLeft == 0;
	return ret;
}



//#line 1 "BlockBitmap.cpp"
#include <assert.h>
#include <utility>


//#line 1 "BlockBitmap.hpp"
#ifndef __BLOCKBITMAP_HPP__
#define __BLOCKBITMAP_HPP__

#include <memory>

enum class Channels
{
	RGB,
	Alpha
};

class BlockBitmap
{
public:
	BlockBitmap( const uint32_t* data, const v2i& size, Channels type );
	BlockBitmap( const BitmapPtr& bmp, Channels type );
	~BlockBitmap();

	void Dither();

	const uint8_t* Data() const { return m_data; }
	const v2i& Size() const { return m_size; }
	const Channels Type() const { return m_type; }

private:
	void Process( const uint32_t* src );

	uint8_t* m_data;
	v2i m_size;
	Channels m_type;
};

typedef std::shared_ptr<BlockBitmap> BlockBitmapPtr;

#endif

BlockBitmap::BlockBitmap( const uint32_t* data, const v2i& size, Channels type )
	: m_data( new uint8_t[std::max( 4, size.x ) * std::max( 4, size.y ) * ( type == Channels::RGB ? 4 : 4 )] )
	, m_size( size )
	, m_type( type )
{
	Process( data );
}

BlockBitmap::BlockBitmap( const BitmapPtr& bmp, Channels type )
	: m_data( new uint8_t[std::max( 4, bmp->Size().x ) * std::max( 4, bmp->Size().y ) * ( type == Channels::RGB ? 4 : 4 )] )
	, m_size( bmp->Size() )
	, m_type( type )
{
	Process( bmp->Data() );
}

void BlockBitmap::Process( const uint32_t* __restrict src )
{
	uint8_t* __restrict dst = m_data;

	int w = std::max( 4, m_size.x );
	int h = std::max( 4, m_size.y );

	assert( w % 4 == 0 && h % 4 == 0 );

	if( m_type == Channels::RGB )
	{
		for( int by=0; by<h/4; by++ )
		{
			for( int bx=0; bx<w/4; bx++ )
			{
				for( int x=0; x<4; x++ )
				{
					for( int y=0; y<4; y++ )
					{
						const uint32_t c = *src;
						src += m_size.x;
						*dst++ = ( c & 0x00FF0000 ) >> 16;
						*dst++ = ( c & 0x0000FF00 ) >> 8;
						*dst++ =   c & 0x000000FF;
						*dst++ = 0;
					}
					src -= m_size.x * 4 - 1;
				}
			}
			src += m_size.x * 3;
		}
	}
	else
	{
		for( int by=0; by<h/4; by++ )
		{
			for( int bx=0; bx<w/4; bx++ )
			{
				for( int x=0; x<4; x++ )
				{
					for( int y=0; y<4; y++ )
					{
						*dst++ = *src >> 24;
						*dst++ = *src >> 24;
						*dst++ = *src >> 24;
						*dst++ = 0;
						src += m_size.x;
					}
					src -= m_size.x * 4 - 1;
				}
			}
			src += m_size.x * 3;
		}
	}
}

BlockBitmap::~BlockBitmap()
{
	delete[] m_data;
}

void BlockBitmap::Dither()
{
	assert( m_type == Channels::RGB );

	int w = std::max( 4, m_size.x );
	int h = std::max( 4, m_size.y );

	uint8_t* ptr = m_data;

	for( int by=0; by<h/4; by++ )
	{
		for( int bx=0; bx<w/4; bx++ )
		{
			::Dither( ptr );
			ptr += 64;
		}
	}
}


//#line 1 "BlockData.cpp"
#include <assert.h>
#include <string.h>


//#line 1 "BlockData.hpp"
#ifndef __BLOCKDATA_HPP__
#define __BLOCKDATA_HPP__

#include <future>
#include <memory>
#include <mutex>
#include <vector>

class BlockData
{
public:
	BlockData( const v2i& size, bool mipmap );
	~BlockData();

	void Process( const uint8_t* src, uint32_t blocks, size_t offset, uint quality, Channels type );
	void Finish();

	uint8_t* m_data;
	v2i m_size;
	size_t m_dataOffset;
private:

	BlockBitmapPtr m_bmp;
	bool m_done;
	std::vector<std::future<void>> m_work;
	std::mutex m_lock;
	size_t m_maplen;
};

typedef std::shared_ptr<BlockData> BlockDataPtr;

#endif

//#include "ColorSpace.hpp"


//#line 1 "ProcessCommon.hpp"
#ifndef __PROCESSCOMMON_HPP__
#define __PROCESSCOMMON_HPP__

#endif

static int AdjustSizeForMipmaps( const v2i& size, int levels )
{
	int len = 0;
	v2i current = size;
	for( int i=1; i<levels; i++ )
	{
		assert( current.x != 1 || current.y != 1 );
		current.x = std::max( 1, current.x / 2 );
		current.y = std::max( 1, current.y / 2 );
		len += std::max( 4, current.x ) * std::max( 4, current.y ) / 2;
	}
	assert( current.x == 1 && current.y == 1 );
	return len;
}

BlockData::BlockData( const v2i& size, bool mipmap )
	: m_size( size )
	, m_done( false )
	, m_dataOffset( 52 )
	, m_maplen( 52 + m_size.x*m_size.y/2 )
{
	assert( m_size.x%4 == 0 && m_size.y%4 == 0 );
	if( mipmap )
	{
		const int levels = NumberOfMipLevels( size );
		m_maplen += AdjustSizeForMipmaps( size, levels );
	}
	m_data = new uint8_t[m_maplen];
}

BlockData::~BlockData()
{
	if( !m_done ) Finish();
	delete[] m_data;
}

void BlockData::Process( const uint8_t* src, uint32_t blocks, size_t offset, uint quality, Channels type )
{
	auto dst = ((uint64_t*)( m_data + m_dataOffset )) + offset;

	std::lock_guard<std::mutex> lock( m_lock );

	if( type == Channels::Alpha )
	{
		m_work.push_back( std::async( [src, dst, blocks, this]() mutable { do { *dst++ = ProcessAlpha( src ); src += 4*4; } while( --blocks ); } ) );
	}
	else
	{
		switch( quality )
		{
		case 0:
			m_work.push_back( std::async( [src, dst, blocks, this]() mutable { do { *dst++ = ProcessRGB( src ); src += 4*4*4; } while( --blocks ); } ) );
			break;
		case 1:
			//m_work.push_back( std::async( [src, dst, blocks, this]{ ProcessBlocksLab( src, dst, blocks ); } ) );
			break;
		default:
			assert( false );
			break;
		}
	}
}

void BlockData::Finish()
{
	assert( !m_done );
	assert( !m_work.empty() );
	for( auto& f : m_work )
	{
		f.wait();
	}
	m_done = true;
	m_work.clear();
	m_bmp.reset();
}


//#line 1 "Dither.cpp"
#include <algorithm>
#include <string.h>

#if 1
static const uint8_t e5[32] = {
	 0,     8,    16,    24,    33,    41,    49,    57,    66,    74,    82,    90,    99,   107,   115,   123,
   132,   140,   148,   156,   165,   173,   181,   189,   198,   206,   214,   222,   231,   239,   247,   255};
static const uint8_t e6[64] = {
	 0,     4,     8,    12,    16,    20,    24,    28,    32,    36,    40,    44,    48,    52,    56,    60,
	65,    69,    73,    77,    81,    85,    89,    93,    97,   101,   105,   109,   113,   117,   121,   125,
   130,   134,   138,   142,   146,   150,   154,   158,   162,   166,   170,   174,   178,   182,   186,   190,
   195,   199,   203,   207,   211,   215,   219,   223,   227,   231,   235,   239,   243,   247,   251,   255};
static const uint8_t qrb[256+16] = {
	 0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     8,     8,     8,
	 8,     8,     8,     8,     8,    16,    16,    16,    16,    16,    16,    16,    16,    24,    24,    24,
	24,    24,    24,    24,    24,    33,    33,    33,    33,    33,    33,    33,    33,    33,    41,    41,
	41,    41,    41,    41,    41,    41,    49,    49,    49,    49,    49,    49,    49,    49,    57,    57,
	57,    57,    57,    57,    57,    57,    66,    66,    66,    66,    66,    66,    66,    66,    74,    74,
	74,    74,    74,    74,    74,    74,    74,    82,    82,    82,    82,    82,    82,    82,    82,    90,
	90,    90,    90,    90,    90,    90,    90,    99,    99,    99,    99,    99,    99,    99,    99,   107,
   107,   107,   107,   107,   107,   107,   107,   107,   115,   115,   115,   115,   115,   115,   115,   115,
   123,   123,   123,   123,   123,   123,   123,   123,   132,   132,   132,   132,   132,   132,   132,   132,
   140,   140,   140,   140,   140,   140,   140,   140,   148,   148,   148,   148,   148,   148,   148,   148,
   148,   156,   156,   156,   156,   156,   156,   156,   156,   165,   165,   165,   165,   165,   165,   165,
   165,   173,   173,   173,   173,   173,   173,   173,   173,   181,   181,   181,   181,   181,   181,   181,
   181,   181,   189,   189,   189,   189,   189,   189,   189,   189,   198,   198,   198,   198,   198,   198,
   198,   198,   206,   206,   206,   206,   206,   206,   206,   206,   214,   214,   214,   214,   214,   214,
   214,   214,   222,   222,   222,   222,   222,   222,   222,   222,   222,   231,   231,   231,   231,   231,
   231,   231,   231,   239,   239,   239,   239,   239,   239,   239,   239,   247,   247,   247,   247,   247,
   247,   247,   247,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255};
static const uint8_t qg[256+16] = {
	 0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     4,     4,     4,     4,     8,
	 8,     8,     8,    12,    12,    12,    12,    16,    16,    16,    16,    20,    20,    20,    20,    24,
	24,    24,    24,    28,    28,    28,    28,    32,    32,    32,    32,    36,    36,    36,    36,    40,
	40,    40,    40,    44,    44,    44,    44,    48,    48,    48,    48,    52,    52,    52,    52,    56,
	56,    56,    56,    60,    60,    60,    60,    65,    65,    65,    65,    69,    69,    69,    69,    73,
	73,    73,    73,    77,    77,    77,    77,    81,    81,    81,    81,    85,    85,    85,    85,    85,
	89,    89,    89,    89,    93,    93,    93,    93,    97,    97,    97,    97,   101,   101,   101,   101,
   105,   105,   105,   105,   109,   109,   109,   109,   113,   113,   113,   113,   117,   117,   117,   117,
   121,   121,   121,   121,   125,   125,   125,   125,   130,   130,   130,   130,   134,   134,   134,   134,
   138,   138,   138,   138,   142,   142,   142,   142,   146,   146,   146,   146,   150,   150,   150,   150,
   154,   154,   154,   154,   158,   158,   158,   158,   162,   162,   162,   162,   166,   166,   166,   166,
   170,   170,   170,   170,   170,   174,   174,   174,   174,   178,   178,   178,   178,   182,   182,   182,
   182,   186,   186,   186,   186,   190,   190,   190,   190,   195,   195,   195,   195,   199,   199,   199,
   199,   203,   203,   203,   203,   207,   207,   207,   207,   211,   211,   211,   211,   215,   215,   215,
   215,   219,   219,   219,   219,   223,   223,   223,   223,   227,   227,   227,   227,   231,   231,   231,
   231,   235,   235,   235,   235,   239,   239,   239,   239,   243,   243,   243,   243,   247,   247,   247,
   247,   251,   251,   251,   251,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255};
#else
static uint8_t e5[32];
static uint8_t e6[64];
static uint8_t qrb[256+16];
static uint8_t qg[256+16];

void InitDither()
{
	for( int i=0; i<32; i++ )
	{
		e5[i] = (i<<3) | (i>>2);
	}
	for( int i=0; i<64; i++ )
	{
		e6[i] = (i<<2) | (i>>4);
	}
	for( int i=0; i<256+16; i++ )
	{
		int v = std::min( std::max( 0, i-8 ), 255 );
		qrb[i] = e5[mul8bit( v, 31 )];
		qg[i] = e6[mul8bit( v, 63 )];
	}
}
#endif

void Dither( uint8_t* data )
{
	int err[8];
	int* ep1 = err;
	int* ep2 = err+4;

	for( int ch=0; ch<3; ch++ )
	{
		uint8_t* ptr = data + ch;
		const uint8_t* quant = (ch == 1) ? qg + 8 : qrb + 8;
		memset( err, 0, sizeof( err ) );

		for( int y=0; y<4; y++ )
		{
			uint8_t tmp;
			tmp = quant[ptr[0] + ( ( 3 * ep2[1] + 5 * ep2[0] ) >> 4 )];
			ep1[0] = ptr[0] - tmp;
			ptr[0] = tmp;
			tmp = quant[ptr[4] + ( ( 7 * ep1[0] + 3 * ep2[2] + 5 * ep2[1] + ep2[0] ) >> 4 )];
			ep1[1] = ptr[4] - tmp;
			ptr[4] = tmp;
			tmp = quant[ptr[8] + ( ( 7 * ep1[1] + 3 * ep2[3] + 5 * ep2[2] + ep2[1] ) >> 4 )];
			ep1[2] = ptr[8] - tmp;
			ptr[8] = tmp;
			tmp = quant[ptr[12] + ( ( 7 * ep1[2] + 5 * ep2[3] + ep2[2] ) >> 4 )];
			ep1[3] = ptr[12] - tmp;
			ptr[12] = tmp;
			ptr += 16;
			std::swap( ep1, ep2 );
		}
	}
}


//#line 1 "MSE.cpp"
float CalcMSE3( const Bitmap& bmp, const Bitmap& out )
{
	float err = 0;

	const uint32_t* p1 = bmp.Data();
	const uint32_t* p2 = out.Data();
	size_t cnt = bmp.Size().x * bmp.Size().y;

	for( size_t i=0; i<cnt; i++ )
	{
		uint32_t c1 = *p1++;
		uint32_t c2 = *p2++;

		err += sq( ( c1 & 0x000000FF ) - ( c2 & 0x000000FF ) );
		err += sq( ( ( c1 & 0x0000FF00 ) >> 8 ) - ( ( c2 & 0x0000FF00 ) >> 8 ) );
		err += sq( ( ( c1 & 0x00FF0000 ) >> 16 ) - ( ( c2 & 0x00FF0000 ) >> 16 ) );
	}

	err /= cnt * 3;

	return err;
}

float CalcMSE1( const Bitmap& bmp, const Bitmap& out )
{
	float err = 0;

	const uint32_t* p1 = bmp.Data();
	const uint32_t* p2 = out.Data();
	size_t cnt = bmp.Size().x * bmp.Size().y;

	for( size_t i=0; i<cnt; i++ )
	{
		uint32_t c1 = *p1++;
		uint32_t c2 = *p2++;

		err += sq( ( c1 >> 24 ) - ( c2 & 0xFF ) );
	}

	err /= cnt;

	return err;
}


//#line 1 "ProcessAlpha.cpp"
static uint Average1( const uint8_t* data )
{
	uint32_t a = 0;
	for( int i=0; i<8; i++ )
	{
		a += *data++;
	}
	return a / 8;
}

static void CalcErrorBlock( const uint8_t* data, uint err[2] )
{
	for( int i=0; i<8; i++ )
	{
		uint v = *data++;
		err[0] += v;
		err[1] += v*v;
	}
}

static uint CalcError( const uint block[2], uint average )
{
	uint err = block[1];
	err -= block[0] * 2 * average;
	err += 8 * sq( average );
	return err;
}

static void ProcessAverages( uint* a )
{
	for( int i=0; i<2; i++ )
	{
		int c1 = mul8bit( a[i*2+1], 31 );
		int c2 = mul8bit( a[i*2], 31 );

		int diff = c2 - c1;
		if( diff > 3 ) diff = 3;
		else if( diff < -4 ) diff = -4;

		int co = c1 + diff;

		a[5+i*2] = ( c1 << 3 ) | ( c1 >> 2 );
		a[4+i*2] = ( co << 3 ) | ( co >> 2 );
	}
	for( int i=0; i<4; i++ )
	{
		a[i] = g_avg2[mul8bit( a[i], 15 )];
	}
}

static void EncodeAverages( uint64_t& _d, const uint* a, size_t idx )
{
	auto d = _d;
	d |= ( idx << 24 );
	size_t base = idx << 1;

	uint v;
	if( ( idx & 0x2 ) == 0 )
	{
		v = ( a[base+0] >> 4 ) | ( a[base+1] & 0xF0 );
	}
	else
	{
		v = a[base+1] & 0xF8;
		int32_t c = ( ( a[base+0] & 0xF8 ) - ( a[base+1] & 0xF8 ) ) >> 3;
		v |= c & ~0xFFFFFFF8;
	}
	d |= v | ( v << 8 ) | ( v << 16 );
	_d = d;
}

uint64_t ProcessAlpha( const uint8_t* src )
{
	uint64_t d = 0;

	{
		bool solid = true;
		const uint8_t* ptr = src + 1;
		for( int i=1; i<16; i++ )
		{
			if( *src != *ptr++ )
			{
				solid = false;
				break;
			}
		}
		if( solid )
		{
			uint c = *src & 0xF8;
			d |= 0x02000000 | ( c << 16 ) | ( c << 8 ) | c;
			return d;
		}
	}

	uint8_t b23[2][8];
	const uint8_t* b[4] = { src+8, src, b23[0], b23[1] };

	for( int i=0; i<4; i++ )
	{
		*(b23[1]+i*2) = *(src+i*4);
		*(b23[0]+i*2) = *(src+i*4+3);
	}

	uint a[8];
	for( int i=0; i<4; i++ )
	{
		a[i] = Average1( b[i] );
	}
	ProcessAverages( a );

	uint err[4] = {};
	for( int i=0; i<4; i++ )
	{
		uint errblock[2] = {};
		CalcErrorBlock( b[i], errblock );
		err[i/2] += CalcError( errblock, a[i] );
		err[2+i/2] += CalcError( errblock, a[i+4] );
	}
	size_t idx = GetLeastError( err, 4 );

	EncodeAverages( d, a, idx );

	uint terr[2][8] = {};
	uint tsel[16][8];
	auto id = g_id[idx];
	const uint8_t* data = src;
	for( size_t i=0; i<16; i++ )
	{
		uint* sel = tsel[i];
		uint bid = id[i];
		uint* ter = terr[bid%2];

		uint8_t c = *data++;
		int32_t pix = a[bid] - c;

		for( int t=0; t<8; t++ )
		{
			const int32_t* tab = g_table[t];
			uint idx = 0;
			uint err = sq( tab[0] + pix );
			for( int j=1; j<4; j++ )
			{
				uint local = sq( tab[j] + pix );
				if( local < err )
				{
					err = local;
					idx = j;
				}
			}
			*sel++ = idx;
			*ter++ += err;
		}
	}

	return FixByteOrder( EncodeSelectors( d, terr, tsel, id ) );
}

#define CalcErrorBlock CalcErrorBlock2

//#line 1 "ProcessRGB.cpp"
#include <string.h>

static v3i Average( const uint8_t* data )
{
	uint32_t r = 0, g = 0, b = 0;
	for( int i=0; i<8; i++ )
	{
		b += *data++;
		g += *data++;
		r += *data++;
		data++;
	}
	return v3i( r / 8, g / 8, b / 8 );
}

static void CalcErrorBlock( const uint8_t* data, uint err[4] )
{
	for( int i=0; i<8; i++ )
	{
		uint d = *data++;
		err[0] += d;
		err[3] += d*d;
		d = *data++;
		err[1] += d;
		err[3] += d*d;
		d = *data++;
		err[2] += d;
		err[3] += d*d;
		data++;
	}
}

static uint CalcError( const uint block[4], const v3i& average )
{
	uint err = block[3];
	err -= block[0] * 2 * average.z;
	err -= block[1] * 2 * average.y;
	err -= block[2] * 2 * average.x;
	err += 8 * ( sq( average.x ) + sq( average.y ) + sq( average.z ) );
	return err;
}

static void ProcessAverages( v3i* a )
{
	for( int i=0; i<2; i++ )
	{
		for( int j=0; j<3; j++ )
		{
			int32_t c1 = mul8bit( a[i*2+1][j], 31 );
			int32_t c2 = mul8bit( a[i*2][j], 31 );

			int32_t diff = c2 - c1;
			if( diff > 3 ) diff = 3;
			else if( diff < -4 ) diff = -4;

			int32_t co = c1 + diff;

			a[5+i*2][j] = ( c1 << 3 ) | ( c1 >> 2 );
			a[4+i*2][j] = ( co << 3 ) | ( co >> 2 );
		}
	}
	for( int i=0; i<4; i++ )
	{
		a[i].x = g_avg2[mul8bit( a[i].x, 15 )];
		a[i].y = g_avg2[mul8bit( a[i].y, 15 )];
		a[i].z = g_avg2[mul8bit( a[i].z, 15 )];
	}
}

static void EncodeAverages( uint64_t& _d, const v3i* a, size_t idx )
{
	auto d = _d;
	d |= ( idx << 24 );
	size_t base = idx << 1;

	if( ( idx & 0x2 ) == 0 )
	{
		for( int i=0; i<3; i++ )
		{
			d |= uint64_t( a[base+0][i] >> 4 ) << ( i*8 );
			d |= uint64_t( a[base+1][i] >> 4 ) << ( i*8 + 4 );
		}
	}
	else
	{
		for( int i=0; i<3; i++ )
		{
			d |= uint64_t( a[base+1][i] & 0xF8 ) << ( i*8 );
			int32_t c = ( ( a[base+0][i] & 0xF8 ) - ( a[base+1][i] & 0xF8 ) ) >> 3;
			c &= ~0xFFFFFFF8;
			d |= ((uint64_t)c) << ( i*8 );
		}
	}
	_d = d;
}

static uint64_t CheckSolid( const uint8_t* src )
{
	const uint8_t* ptr = src + 4;
	for( int i=1; i<16; i++ )
	{
		if( memcmp( src, ptr, 4 ) != 0 )
		{
			return 0;
		}
		ptr += 4;
	}
	return 0x02000000 |
		( uint( src[0] & 0xF8 ) << 16 ) |
		( uint( src[1] & 0xF8 ) << 8 ) |
		( uint( src[2] & 0xF8 ) );
}

static void PrepareBuffers( uint8_t b23[2][32], const uint8_t* src )
{
	for( int i=0; i<4; i++ )
	{
		memcpy( b23[1]+i*8, src+i*16, 8 );
		memcpy( b23[0]+i*8, src+i*16+8, 8 );
	}
}

static void PrepareAverages( v3i a[8], const uint8_t* b[4], uint err[4] )
{
	for( int i=0; i<4; i++ )
	{
		a[i] = Average( b[i] );
	}
	ProcessAverages( a );

	for( int i=0; i<4; i++ )
	{
		uint errblock[4] = {};
		CalcErrorBlock( b[i], errblock );
		err[i/2] += CalcError( errblock, a[i] );
		err[2+i/2] += CalcError( errblock, a[i+4] );
	}
}

static void FindBestFit( uint64_t terr[2][8], uint tsel[16][8], v3i a[8], const uint32_t* id, const uint8_t* data )
{
	for( size_t i=0; i<16; i++ )
	{
		uint* sel = tsel[i];
		uint bid = id[i];
		uint64_t* ter = terr[bid%2];

		uint8_t b = *data++;
		uint8_t g = *data++;
		uint8_t r = *data++;
		data++;

		int dr = a[bid].x - r;
		int dg = a[bid].y - g;
		int db = a[bid].z - b;

		int pix = dr * 77 + dg * 151 + db * 28;

		for( int t=0; t<8; t++ )
		{
			const int64_t* tab = g_table256[t];
			uint idx = 0;
			uint64_t err = sq( tab[0] + pix );
			for( int j=1; j<4; j++ )
			{
				uint64_t local = sq( tab[j] + pix );
				if( local < err )
				{
					err = local;
					idx = j;
				}
			}
			*sel++ = idx;
			*ter++ += err;
		}
	}
}

uint64_t ProcessRGB( const uint8_t* src )
{
	uint64_t d = CheckSolid( src );
	if( d != 0 ) return d;

	uint8_t b23[2][32];
	const uint8_t* b[4] = { src+32, src, b23[0], b23[1] };
	PrepareBuffers( b23, src );

	v3i a[8];
	uint err[4] = {};
	PrepareAverages( a, b, err );
	size_t idx = GetLeastError( err, 4 );
	EncodeAverages( d, a, idx );

	uint64_t terr[2][8] = {};
	uint tsel[16][8];
	auto id = g_id[idx];
	FindBestFit( terr, tsel, a, id, src );

	return FixByteOrder( EncodeSelectors( d, terr, tsel, id ) );
}



//#line 1 "Tables.cpp"
const int32_t g_table[8][4] = {
	{  2,  8,   -2,   -8 },
	{  5, 17,   -5,  -17 },
	{  9, 29,   -9,  -29 },
	{ 13, 42,  -13,  -42 },
	{ 18, 60,  -18,  -60 },
	{ 24, 80,  -24,  -80 },
	{ 33, 106, -33, -106 },
	{ 47, 183, -47, -183 }
};

const int64_t g_table256[8][4] = {
	{  2*256,  8*256,   -2*256,   -8*256 },
	{  5*256, 17*256,   -5*256,  -17*256 },
	{  9*256, 29*256,   -9*256,  -29*256 },
	{ 13*256, 42*256,  -13*256,  -42*256 },
	{ 18*256, 60*256,  -18*256,  -60*256 },
	{ 24*256, 80*256,  -24*256,  -80*256 },
	{ 33*256, 106*256, -33*256, -106*256 },
	{ 47*256, 183*256, -47*256, -183*256 }
};

const uint32_t g_id[4][16] = {
	{ 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2 },
	{ 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4 },
	{ 7, 7, 6, 6, 7, 7, 6, 6, 7, 7, 6, 6, 7, 7, 6, 6 }
};

extern const uint32_t g_avg2[16] = {
	0x00,
	0x11,
	0x22,
	0x33,
	0x44,
	0x55,
	0x66,
	0x77,
	0x88,
	0x99,
	0xAA,
	0xBB,
	0xCC,
	0xDD,
	0xEE,
	0xFF
};


//#line 1 "unifont.hpp"
// an embeddable/compact console font that supports most european/greek/cyrillic unicode codepoints. aimed to gamedev.
// - rlyeh, zlib/libpng licensed.

// using:
// - [PressStart2P.ttf v2.14](http://www.zone38.net/font/) by Cody "CodeMan38" Boisclair (SIL Open Font License).
// - [UTF-8 dfa decoder](http://bjoern.hoehrmann.de/utf-8/decoder/dfa/) by Bjoern Hoehrmann (MIT license).
// - Gradient retro style mask taken from [DoDonPachi arcade](http://en.wikipedia.org/wiki/DoDonPachi).

////#pragma once
#include <stdint.h>
#include <vector>
#include <map>

#define UNIFONT_VERSION "v1.0.0 (C++0x version)"

template<typename color>
struct unifont {

	struct dim {
		uint32_t w, h;
	};

	enum {
		NORMAL = 0,
		INVERT = 1,
		SHADOW = 2,
		RETRO  = 4,
	};

	struct framebuffer {
		color *pixel;
		uint32_t width;
		color (*make_rgba)( uint8_t r, uint8_t g, uint8_t b, uint8_t a );
	} fb;

	std::vector<color> gradient;   // precomputed gradient colors [8][8]
	std::vector<color> flat;       // precomputed flat colors [8][8]
	color Z, W, P;                 // precomputed base colors

	unifont( color *pixel, uint32_t width, color (*make_rgba)( uint8_t r, uint8_t g, uint8_t b, uint8_t a )  )
		: PressStart2P_ttf(get_font())
	{
		fb.pixel = pixel;
		fb.width = width;
		fb.make_rgba = make_rgba;

		Z = (*fb.make_rgba)(   0,   0,   0, 255 );
		W = (*fb.make_rgba)( 255, 255, 255, 255 );
		P = (*fb.make_rgba)( 255,   0, 255, 255 );

		color A = (*fb.make_rgba)( 255, 165,  82, 255 );
		color B = (*fb.make_rgba)( 255, 115,  33, 255 );
		color C = (*fb.make_rgba)( 247,  66,  16, 255 );
		color D = (*fb.make_rgba)( 206,  24,   8, 255 );
		color E = (*fb.make_rgba)( 156,   0,   0, 255 );
		color F = (*fb.make_rgba)( 115,   0,   0, 255 );

		flat = std::vector<color>( 64, W ); // default white (flat) gradient
		// do don pachi gradient style
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C);
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C);
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D);
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D);
		gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E);
		gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E),gradient.push_back(E);
		gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E),gradient.push_back(E),gradient.push_back(F);
		gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E),gradient.push_back(E),gradient.push_back(F),gradient.push_back(F);
	}

	dim render_line( int x0, int y0, int x1, int y1, const color &c ) const {
		if( x1 == x0 ) {
			for( ; y0 < y1 ; ++y0 ) {
				fb.pixel[ x0 + y0 * fb.width ] = c;
			}
		} else {
			float deltax = x1 - x0;
			float deltay = y1 - y0;
			float error = 0.0f;
			float deltaerr = abs(deltay / deltax);
			float y = y0;
			for( float x = x0; x < x1; ++x) {
				fb.pixel[ (uint32_t)(x + y * fb.width) ] = c;
				error += deltaerr;
				while( error >= 0.5f ) {
					fb.pixel[ (uint32_t)(x + y * fb.width) ] = c;
					y += y1 - y0 > 0 ? 1 : -1;
					error -= 1.0f;
				}
			}
		}
		return dim { unsigned(x1 - x0), unsigned(y1 - y0) };
	}

	dim render_string( int ox, int oy, int mode, const std::vector<uint64_t> &glyphs, const color *mask8x8 = 0 ) const {
		if( !mask8x8 ) mask8x8 = (mode & 4 ? &gradient[0] : &flat[0]);

		auto *ptr = &fb.pixel[ ox + oy * fb.width ];
		for( const auto &rune : glyphs ) {
			for( unsigned y = 0; y < 8; ++y ) {
				const unsigned y64 = ( 7 - y ) * 8;
				if( mode & SHADOW ) {
				ptr += fb.width + 1;
				ptr[0] = rune & (0x80ULL << y64) ? Z : ptr[0];
				ptr[1] = rune & (0x40ULL << y64) ? Z : ptr[1];
				ptr[2] = rune & (0x20ULL << y64) ? Z : ptr[2];
				ptr[3] = rune & (0x10ULL << y64) ? Z : ptr[3];
				ptr[4] = rune & (0x08ULL << y64) ? Z : ptr[4];
				ptr[5] = rune & (0x04ULL << y64) ? Z : ptr[5];
				ptr[6] = rune & (0x02ULL << y64) ? Z : ptr[6];
				ptr[7] = rune & (0x01ULL << y64) ? Z : ptr[7];
				ptr -= fb.width + 1;
				}
				if( mode & INVERT ) {
				ptr[0] = rune & (0x80ULL << y64) ? ptr[0] : mask8x8[0+y*8];
				ptr[1] = rune & (0x40ULL << y64) ? ptr[1] : mask8x8[1+y*8];
				ptr[2] = rune & (0x20ULL << y64) ? ptr[2] : mask8x8[2+y*8];
				ptr[3] = rune & (0x10ULL << y64) ? ptr[3] : mask8x8[3+y*8];
				ptr[4] = rune & (0x08ULL << y64) ? ptr[4] : mask8x8[4+y*8];
				ptr[5] = rune & (0x04ULL << y64) ? ptr[5] : mask8x8[5+y*8];
				ptr[6] = rune & (0x02ULL << y64) ? ptr[6] : mask8x8[6+y*8];
				ptr[7] = rune & (0x01ULL << y64) ? ptr[7] : mask8x8[7+y*8];
				} else { // NORMAL
				ptr[0] = rune & (0x80ULL << y64) ? mask8x8[0+y*8] : ptr[0];
				ptr[1] = rune & (0x40ULL << y64) ? mask8x8[1+y*8] : ptr[1];
				ptr[2] = rune & (0x20ULL << y64) ? mask8x8[2+y*8] : ptr[2];
				ptr[3] = rune & (0x10ULL << y64) ? mask8x8[3+y*8] : ptr[3];
				ptr[4] = rune & (0x08ULL << y64) ? mask8x8[4+y*8] : ptr[4];
				ptr[5] = rune & (0x04ULL << y64) ? mask8x8[5+y*8] : ptr[5];
				ptr[6] = rune & (0x02ULL << y64) ? mask8x8[6+y*8] : ptr[6];
				ptr[7] = rune & (0x01ULL << y64) ? mask8x8[7+y*8] : ptr[7];
				}
				ptr += fb.width;
			}
			ptr -= fb.width * 8;
			ptr += 8;
		}

		dim d; d.w = unsigned(glyphs.size() * 8), d.h = unsigned((!glyphs.empty()) * 8);
		return d;
	}

	dim render_string( int ox, int oy, int mode, const std::vector<int32_t> &codepoints, const color *mask8x8 = 0 ) const {
		std::vector<uint64_t> glyphs;
		for( auto &cp : codepoints ) {
			auto found = PressStart2P_ttf.find(cp);
			if( found != PressStart2P_ttf.end() ) {
				glyphs.push_back( found->second );
			} else {
				glyphs.push_back( 0 );
			}
		}
		return render_string( ox, oy, mode, glyphs, mask8x8 );
	}

	dim render_string( int ox, int oy, int mode, const char *utf8, const color *mask8x8 = 0 ) const {
		auto decode = []( std::vector<int32_t> &codepoints, const char *utf8 ) -> const char * {
			uint32_t result, state = 0;
			while( *utf8 ) {
				// Decode utf8 codepoint a byte at a time. Uses explictly user provided state variable,
				// that should be initialized to zero before first use. Places the result to codep.
				// Returns UTF8_ACCEPT when a full codepoint achieved
				enum { UTF8_ACCEPT = 0, UTF8_REJECT = 1 };
				auto decode_state = []( uint32_t *state, uint32_t *codep, uint32_t byte ) -> uint32_t {
					static const uint8_t utf8d[] = {
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f
					  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f
					  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf
					  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df
					  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef
					  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff
					  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0
					  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2
					  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4
					  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6
					  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8
					};
					uint32_t type = utf8d[byte];
					*codep = (*state != UTF8_ACCEPT) ? (byte & 0x3fu) | (*codep << 6) : (0xff >> type) & (byte);
					*state = utf8d[256 + *state*16 + type];
					return *state;
				};
				uint32_t res = decode_state( &state, &result, (unsigned char)(*utf8++) );
				/**/ if(res == UTF8_ACCEPT) return codepoints.push_back( result ), utf8;
				else if(res == UTF8_REJECT) break;
			}
			return codepoints.push_back( 0xfffd ), utf8;
		};
		std::vector<int32_t> codepoints;
		while( *utf8 ) {
			utf8 = decode( codepoints, utf8 );
		}
		return render_string( ox, oy, mode, codepoints, mask8x8 );
	}

	dim render_glyphs( int ox, int oy, int mode, const color *mask8x8 = 0 ) const {
		uint32_t h = (PressStart2P_ttf.size() / 16) + 1;
		for( uint32_t y = 0; y < h; y++ ) {
			render_line( ox, oy + y*9, ox + 16*9, oy + y*9, P );
			for( uint32_t x = 0; x < 16; x++ ) {
				render_line( ox + x*9, oy, ox + x*9, oy + h*9, P );
				auto it = PressStart2P_ttf.cbegin();
				std::advance( it, x + y * 16 );
				render_string( 1 + ox + x*9, 1 + oy + y*9, mode, std::vector<int32_t> { it->first }, mask8x8 );
			}
		}
		dim d; d. w =16*9, d.h = h*9; return d;
	}

	dim render_string( int ox, int oy, int mode, const std::vector<uint64_t> &glyphs, const color &c ) {
		return render_string( ox, oy, mode, glyphs, &std::vector<color>( 64, c )[0] );
	}
	dim render_string( int ox, int oy, int mode, const std::vector<int32_t> &codepoints, const color &c ){
		return render_string( ox, oy, mode, codepoints, &std::vector<color>( 64, c )[0] );
	}
	dim render_string( int ox, int oy, int mode, const char *utf8, const color &c ) {
		return render_string( ox, oy, mode, utf8, &std::vector<color>( 64, c )[0] );
	}
	dim render_glyphs( int ox, int oy, int mode, const color &c ) {
		return render_glyphs( ox, oy, mode, &std::vector<color>( 64, c )[0] );
	}

	/* generated by ttf2mono.cc - https://github.com/r-lyeh */
	const std::map<int,uint64_t> &PressStart2P_ttf;
	static const std::map<int,uint64_t> &get_font() {
	static std::map<int,uint64_t> map;
	if( !map.empty() ) return map; else return
	map[0x0020]=0x0000000000000000,map[0x0021]=0x3838383030003000,map[0x0022]=0x6c6c6c0000000000,
	map[0x0023]=0x6cfe6c6c6cfe6c00,map[0x0024]=0x107cd07c16fc1000,map[0x0025]=0x62a4c810264a8c00,
	map[0x0026]=0x70d8d870dacc7e00,map[0x0027]=0x3030300000000000,map[0x0028]=0x0c18303030180c00,
	map[0x0029]=0x6030181818306000,map[0x002a]=0x006c38fe386c0000,map[0x002b]=0x0018187e18180000,
	map[0x002c]=0x0000000000303060,map[0x002d]=0x0000007e00000000,map[0x002e]=0x0000000000303000,
	map[0x002f]=0x0204081020408000,map[0x0030]=0x384cc6c6c6643800,map[0x0031]=0x1838181818187e00,
	map[0x0032]=0x7cc60e3c78e0fe00,map[0x0033]=0x7e0c183c06c67c00,map[0x0034]=0x1c3c6cccfe0c0c00,
	map[0x0035]=0xfcc0fc0606c67c00,map[0x0036]=0x3c60c0fcc6c67c00,map[0x0037]=0xfec60c1830303000,
	map[0x0038]=0x78c4e4789e867c00,map[0x0039]=0x7cc6c67e060c7800,map[0x003a]=0x0030300030300000,
	map[0x003b]=0x0030300030306000,map[0x003c]=0x0c18306030180c00,map[0x003d]=0x0000fe00fe000000,
	map[0x003e]=0x6030180c18306000,map[0x003f]=0x7cfec60c38003800,map[0x0040]=0x7c82baaabe807c00,
	map[0x0041]=0x386cc6c6fec6c600,map[0x0042]=0xfcc6c6fcc6c6fc00,map[0x0043]=0x3c66c0c0c0663c00,
	map[0x0044]=0xf8ccc6c6c6ccf800,map[0x0045]=0xfec0c0fcc0c0fe00,map[0x0046]=0xfec0c0fcc0c0c000,
	map[0x0047]=0x3e60c0cec6663e00,map[0x0048]=0xc6c6c6fec6c6c600,map[0x0049]=0x7e18181818187e00,
	map[0x004a]=0x0606060606c67c00,map[0x004b]=0xc6ccd8f0f8dcce00,map[0x004c]=0x6060606060607e00,
	map[0x004d]=0xc6eefefed6c6c600,map[0x004e]=0xc6e6f6fedecec600,map[0x004f]=0x7cc6c6c6c6c67c00,
	map[0x0050]=0xfcc6c6c6fcc0c000,map[0x0051]=0x7cc6c6c6decc7a00,map[0x0052]=0xfcc6c6cef8dcce00,
	map[0x0053]=0x78ccc07c06c67c00,map[0x0054]=0x7e18181818181800,map[0x0055]=0xc6c6c6c6c6c67c00,
	map[0x0056]=0xc6c6c6ee7c381000,map[0x0057]=0xc6c6d6fefeeec600,map[0x0058]=0xc6ee7c387ceec600,
	map[0x0059]=0x6666663c18181800,map[0x005a]=0xfe0e1c3870e0fe00,map[0x005b]=0x3c30303030303c00,
	map[0x005c]=0x8040201008040200,map[0x005d]=0x7818181818187800,map[0x005e]=0x386c000000000000,
	map[0x005f]=0x00000000000000fe,map[0x0060]=0x1008000000000000,map[0x0061]=0x00007c067ec67e00,
	map[0x0062]=0xc0c0fcc6c6c67c00,map[0x0063]=0x00007ec0c0c07e00,map[0x0064]=0x06067ec6c6c67e00,
	map[0x0065]=0x00007cc6fec07c00,map[0x0066]=0x0e187e1818181800,map[0x0067]=0x00007ec6c67e067c,
	map[0x0068]=0xc0c0fcc6c6c6c600,map[0x0069]=0x1800381818187e00,map[0x006a]=0x0c001c0c0c0c0c78,
	map[0x006b]=0xc0c0cefcf8dcce00,map[0x006c]=0x3818181818187e00,map[0x006d]=0x0000fcb6b6b6b600,
	map[0x006e]=0x0000fcc6c6c6c600,map[0x006f]=0x00007cc6c6c67c00,map[0x0070]=0x0000fcc6c6fcc0c0,
	map[0x0071]=0x00007ec6c67e0606,map[0x0072]=0x00006e7060606000,map[0x0073]=0x00007cc07c06fc00,
	map[0x0074]=0x18187e1818181800,map[0x0075]=0x0000c6c6c6c67e00,map[0x0076]=0x00006666663c1800,
	map[0x0077]=0x0000b6b6b6b67e00,map[0x0078]=0x0000c6fe38fec600,map[0x0079]=0x0000c6c6c67e067c,
	map[0x007a]=0x0000fe1c3870fe00,map[0x007b]=0x0c18183018180c00,map[0x007c]=0x1818181818181800,
	map[0x007d]=0x6030301830306000,map[0x007e]=0x000070ba1c000000,map[0x007f]=0x00000000006c6c00,
	map[0x00a0]=0x0000000000000000,map[0x00a1]=0x1800181838383800,map[0x00a2]=0x107cd6d0d67c1000,
	map[0x00a3]=0x3c6660fc6060fe00,map[0x00a4]=0x005a2424245a0000,map[0x00a5]=0x66663c7e187e1800,
	map[0x00a6]=0x1818180018181800,map[0x00a7]=0x3c6678241e663c00,map[0x00a8]=0x6c00000000000000,
	map[0x00a9]=0x3c4299a1a199423c,map[0x00aa]=0x783c6c3c00000000,map[0x00ab]=0x00366cd86c360000,
	map[0x00ac]=0x00007e0606000000,map[0x00ad]=0x0000007e00000000,map[0x00ae]=0x3c42b9a5b9a5423c,
	map[0x00af]=0x7c00000000000000,map[0x00b0]=0x1028100000000000,map[0x00b1]=0x18187e1818007e00,
	map[0x00b2]=0x380c183c00000000,map[0x00b3]=0x3c180c3800000000,map[0x00b4]=0x0810000000000000,
	map[0x00b5]=0x0000ccccccccf6c0,map[0x00b6]=0x3e6a4a6a3e0a0a00,map[0x00b7]=0x0000003030000000,
	map[0x00b8]=0x0000000000000830,map[0x00b9]=0x1838183c00000000,map[0x00ba]=0x386c6c3800000000,
	map[0x00bb]=0x00d86c366cd80000,map[0x00bc]=0x42c44852264e8200,map[0x00bd]=0x42c4485622448e00,
	map[0x00be]=0xe24428d2264e8200,map[0x00bf]=0x38003860c6fe7c00,map[0x00c0]=0x2010386cc6fec600,
	map[0x00c1]=0x0810386cc6fec600,map[0x00c2]=0x386c386cc6fec600,map[0x00c3]=0x3458386cc6fec600,
	map[0x00c4]=0x6c00386cc6fec600,map[0x00c5]=0x1028386cc6fec600,map[0x00c6]=0x3e78d8def8d8de00,
	map[0x00c7]=0x3c66c0c0663c0830,map[0x00c8]=0x2010fec0fcc0fe00,map[0x00c9]=0x0810fec0fcc0fe00,
	map[0x00ca]=0x386cfec0fcc0fe00,map[0x00cb]=0x6c00fec0fcc0fe00,map[0x00cc]=0x10087e1818187e00,
	map[0x00cd]=0x08107e1818187e00,map[0x00ce]=0x183c7e1818187e00,map[0x00cf]=0x66007e1818187e00,
	map[0x00d0]=0x786c66f6666c7800,map[0x00d1]=0x3458e6f6fedece00,map[0x00d2]=0x20107cc6c6c67c00,
	map[0x00d3]=0x08107cc6c6c67c00,map[0x00d4]=0x386c7cc6c6c67c00,map[0x00d5]=0x34587cc6c6c67c00,
	map[0x00d6]=0x6c007cc6c6c67c00,map[0x00d7]=0x0044281028440000,map[0x00d8]=0x7cc6ced6e6c67c00,
	map[0x00d9]=0x2010c6c6c6c67c00,map[0x00da]=0x0810c6c6c6c67c00,map[0x00db]=0x386c00c6c6c67c00,
	map[0x00dc]=0x6c00c6c6c6c67c00,map[0x00dd]=0x081066663c181800,map[0x00de]=0xc0fcc6c6c6fcc000,
	map[0x00df]=0x3c66666c66766c00,map[0x00e0]=0x20107c067ec67e00,map[0x00e1]=0x08107c067ec67e00,
	map[0x00e2]=0x386c7c067ec67e00,map[0x00e3]=0x34587c067ec67e00,map[0x00e4]=0x6c007c067ec67e00,
	map[0x00e5]=0x10287c067ec67e00,map[0x00e6]=0x00007c167ed07c00,map[0x00e7]=0x00007ec0c07e0830,
	map[0x00e8]=0x20107cc6fec07c00,map[0x00e9]=0x08107cc6fec07c00,map[0x00ea]=0x386c7cc6fec07c00,
	map[0x00eb]=0x6c007cc6fec07c00,map[0x00ec]=0x2010003818187e00,map[0x00ed]=0x0810003818187e00,
	map[0x00ee]=0x386c003818187e00,map[0x00ef]=0x6c00381818187e00,map[0x00f0]=0x6478987cc6c67c00,
	map[0x00f1]=0x3458fcc6c6c6c600,map[0x00f2]=0x20107cc6c6c67c00,map[0x00f3]=0x08107cc6c6c67c00,
	map[0x00f4]=0x386c7cc6c6c67c00,map[0x00f5]=0x34587cc6c6c67c00,map[0x00f6]=0x6c007cc6c6c67c00,
	map[0x00f7]=0x0018007e00180000,map[0x00f8]=0x00007cced6e67c00,map[0x00f9]=0x2010c6c6c6c67e00,
	map[0x00fa]=0x0810c6c6c6c67e00,map[0x00fb]=0x386c00c6c6c67e00,map[0x00fc]=0x6c00c6c6c6c67e00,
	map[0x00fd]=0x0810c6c6c67e067c,map[0x00fe]=0xc0c0fcc6c6fcc0c0,map[0x00ff]=0x6c00c6c6c67e067c,
	map[0x0100]=0x7c00386cc6fec600,map[0x0101]=0x7c007c067ec67e00,map[0x0102]=0x4438386cc6fec600,
	map[0x0103]=0x44387c067ec67e00,map[0x0104]=0x386cc6fec6040806,map[0x0105]=0x7c067ec67e102018,
	map[0x0106]=0x08103c66c0663c00,map[0x0107]=0x08107ec0c0c07e00,map[0x0108]=0x386c3c66c0663c00,
	map[0x0109]=0x386c7ec0c0c07e00,map[0x010a]=0x18003c66c0663c00,map[0x010b]=0x18007ec0c0c07e00,
	map[0x010c]=0x663c3c66c0663c00,map[0x010d]=0x6c387ec0c0c07e00,map[0x010e]=0x6c38f8ccc6ccf800,
	map[0x010f]=0x1b1b7ad8d8d87800,map[0x0110]=0x786c66f6666c7800,map[0x0111]=0x0c1e7ccccccc7c00,
	map[0x0112]=0x7c00fec0fcc0fe00,map[0x0113]=0x7c007cc6fec07c00,map[0x0114]=0x4438fec0fcc0fe00,
	map[0x0115]=0x44387cc6fec07c00,map[0x0116]=0x1800fec0fcc0fe00,map[0x0117]=0x18007cc6fec07c00,
	map[0x0118]=0xfec0fcc0fe102018,map[0x0119]=0x7cc6fec07c102018,map[0x011a]=0x6c38fec0fcc0fe00,
	map[0x011b]=0x6c387cc6fec07c00,map[0x011c]=0x386c7ec0cec67e00,map[0x011d]=0x386c7ec6c67e067c,
	map[0x011e]=0x44387ec0cec67e00,map[0x011f]=0x44387ec6c67e067c,map[0x0120]=0x18007ec0cec67e00,
	map[0x0121]=0x18007ec6c67e067c,map[0x0122]=0x3e60c0ce663e1830,map[0x0123]=0x18307ec6c67e067c,
	map[0x0124]=0x38eec6c6fec6c600,map[0x0125]=0x38ecc0fcc6c6c600,map[0x0126]=0xc6fec6fec6c6c600,
	map[0x0127]=0x60f07c6666666600,map[0x0128]=0x324c7e1818187e00,map[0x0129]=0x324c003818187e00,
	map[0x012a]=0x7e007e1818187e00,map[0x012b]=0x7c00381818187e00,map[0x012c]=0x24187e1818187e00,
	map[0x012d]=0x4438381818187e00,map[0x012e]=0x7e1818187e102018,map[0x012f]=0x180038187e102018,
	map[0x0130]=0x18007e1818187e00,map[0x0131]=0x0000381818187e00,map[0x0132]=0xf6666666f6067c00,
	map[0x0133]=0x6600ee666666063c,map[0x0134]=0x1c36060606c67c00,map[0x0135]=0x1c36001c0c0c0c78,
	map[0x0136]=0xccd8f0f8dcce3060,map[0x0137]=0xc0cefcf8dcce3060,map[0x0138]=0x0000c6ccf8ccc600,
	map[0x0139]=0x0870606060607e00,map[0x013a]=0x102070303030fc00,map[0x013b]=0x60606060607e1830,
	map[0x013c]=0x38181818187e1830,map[0x013d]=0x6666646060607e00,map[0x013e]=0x763634303030fc00,
	map[0x013f]=0x60606c6c60607e00,map[0x0140]=0x703036363030fc00,map[0x0141]=0x606070e060607e00,
	map[0x0142]=0x38181c3818187e00,map[0x0143]=0x0810e6f6fedece00,map[0x0144]=0x0810fcc6c6c6c600,
	map[0x0145]=0xe6f6fedecec61830,map[0x0146]=0x00fcc6c6c6c61830,map[0x0147]=0x6c38e6f6fedece00,
	map[0x0148]=0x6c38fcc6c6c6c600,map[0x0149]=0xc0c0bc3636363600,map[0x014a]=0xe6f6fedecec6063c,
	map[0x014b]=0x00fcc6c6c6c6063c,map[0x014c]=0x7c007cc6c6c67c00,map[0x014d]=0x7c007cc6c6c67c00,
	map[0x014e]=0x44387cc6c6c67c00,map[0x014f]=0x44387cc6c6c67c00,map[0x0150]=0x24487cc6c6c67c00,
	map[0x0151]=0x24487cc6c6c67c00,map[0x0152]=0x7ed8d8ded8d87e00,map[0x0153]=0x00007cd6ded07c00,
	map[0x0154]=0x0810fccef8dcce00,map[0x0155]=0x08106e7060606000,map[0x0156]=0xfcc6cef8dcce1830,
	map[0x0157]=0x006e706060603060,map[0x0158]=0x2810fccef8dcce00,map[0x0159]=0x361c6e7060606000,
	map[0x015a]=0x08107cc07c06fc00,map[0x015b]=0x08107cc07c06fc00,map[0x015c]=0x386c7cc07c06fc00,
	map[0x015d]=0x386c7cc07c06fc00,map[0x015e]=0x7cc07c06c67c0830,map[0x015f]=0x007cc07c06fc0830,
	map[0x0160]=0x6c387cc07c06fc00,map[0x0161]=0x6c387cc07c06fc00,map[0x0162]=0x7e18181818180830,
	map[0x0163]=0x18187e1818180830,map[0x0164]=0x24187e1818181800,map[0x0165]=0x2418187e18181800,
	map[0x0166]=0x7e18181c38181800,map[0x0167]=0x18187e181c381800,map[0x0168]=0x3458c6c6c6c67c00,
	map[0x0169]=0x3458c6c6c6c67e00,map[0x016a]=0x7c00c6c6c6c67c00,map[0x016b]=0x7c00c6c6c6c67e00,
	map[0x016c]=0x4438c6c6c6c67c00,map[0x016d]=0x4438c6c6c6c67e00,map[0x016e]=0x386cbac6c6c67c00,
	map[0x016f]=0x386cbac6c6c67e00,map[0x0170]=0x2448c6c6c6c67c00,map[0x0171]=0x2448c6c6c6c67e00,
	map[0x0172]=0xc6c6c6c67c102018,map[0x0173]=0xc6c6c6c67e102018,map[0x0174]=0x386cc6d6fefeee00,
	map[0x0175]=0x386cb6b6b6b67e00,map[0x0176]=0x182466663c181800,map[0x0177]=0x386cc6c6c67e067c,
	map[0x0178]=0x660066663c181800,map[0x0179]=0x0810fe1c3870fe00,map[0x017a]=0x0810fe1c3870fe00,
	map[0x017b]=0x1800fe1c3870fe00,map[0x017c]=0x1800fe1c3870fe00,map[0x017d]=0x6c38fe1c3870fe00,
	map[0x017e]=0x6c38fe1c3870fe00,map[0x017f]=0x0e18181818181800,map[0x0192]=0x0e187e1818187000,
	map[0x02c6]=0x386c000000000000,map[0x02c7]=0x6c38000000000000,map[0x02c9]=0x7c00000000000000,
	map[0x02ca]=0x0810000000000000,map[0x02cb]=0x1008000000000000,map[0x02d7]=0x0000007c00000000,
	map[0x02d8]=0x4438000000000000,map[0x02d9]=0x1800000000000000,map[0x02da]=0x386c380000000000,
	map[0x02db]=0x0000000000102018,map[0x02dc]=0x3458000000000000,map[0x02dd]=0x2448000000000000,
	map[0x037a]=0x000000000000100c,map[0x037e]=0x0030300030306000,map[0x0384]=0x0810000000000000,
	map[0x0385]=0x4a10000000000000,map[0x0386]=0x58bc66667e666600,map[0x0387]=0x0000003030000000,
	map[0x0388]=0x7fb0303c30303f00,map[0x0389]=0x73b3333f33333300,map[0x038a]=0x5e8c0c0c0c0c1e00,
	map[0x038c]=0x5eb3333333331e00,map[0x038e]=0x73b3331e0c0c0c00,map[0x038f]=0x5cb6636363367700,
	map[0x0390]=0x9420703030301c00,map[0x0391]=0x386cc6c6fec6c600,map[0x0392]=0xfcc6c6fcc6c6fc00,
	map[0x0393]=0x7e60606060606000,map[0x0394]=0x386cc6c6c6c6fe00,map[0x0395]=0xfec0c0fcc0c0fe00,
	map[0x0396]=0xfe0e1c3870e0fe00,map[0x0397]=0xc6c6c6fec6c6c600,map[0x0398]=0x7cc6c6fec6c67c00,
	map[0x0399]=0x7e18181818187e00,map[0x039a]=0xc6ccd8f0f8dcce00,map[0x039b]=0x386cc6c6c6c6c600,
	map[0x039c]=0xc6eefefed6c6c600,map[0x039d]=0xc6e6f6fedecec600,map[0x039e]=0xfe00007c0000fe00,
	map[0x039f]=0x7cc6c6c6c6c67c00,map[0x03a0]=0xfec6c6c6c6c6c600,map[0x03a1]=0xfcc6c6c6fcc0c000,
	map[0x03a3]=0xfe66301c3066fe00,map[0x03a4]=0x7e18181818181800,map[0x03a5]=0x6666663c18181800,
	map[0x03a6]=0x107cd6d6d67c1000,map[0x03a7]=0xc6ee7c387ceec600,map[0x03a8]=0xdbdbdb7e18183c00,
	map[0x03a9]=0x386cc6c6c66cee00,map[0x03aa]=0x66007e1818187e00,map[0x03ab]=0x660066663c181800,
	map[0x03ac]=0x08107ec6c6c67e00,map[0x03ad]=0x08107ec07cc07e00,map[0x03ae]=0x0810dc6666666606,
	map[0x03af]=0x1020703030301c00,map[0x03b0]=0x9420cc6666663c00,map[0x03b1]=0x00007ec6c6c67e00,
	map[0x03b2]=0x7cc6c6fcc6c6fcc0,map[0x03b3]=0x0000c666663c1818,map[0x03b4]=0x0e180c7ec6c67c00,
	map[0x03b5]=0x00007ec07cc07e00,map[0x03b6]=0x7c3060c0c07c060c,map[0x03b7]=0x0000dc6666666606,
	map[0x03b8]=0x386cc6fec66c3800,map[0x03b9]=0x0000703030301c00,map[0x03ba]=0x0000c6ccf8ccc600,
	map[0x03bb]=0xc06030386cc6c600,map[0x03bc]=0x0000ccccccccf6c0,map[0x03bd]=0x0000c666663c1800,
	map[0x03be]=0xfc603860c0780c18,map[0x03bf]=0x00007cc6c6c67c00,map[0x03c0]=0x0000fe6c6c6ce600,
	map[0x03c1]=0x00007cc6c6fcc0c0,map[0x03c2]=0x00007cc0c07c067c,map[0x03c3]=0x00007ed8cccc7800,
	map[0x03c4]=0x00007e1818180e00,map[0x03c5]=0x0000cc6666663c00,map[0x03c6]=0x00004cd6d6d67c10,
	map[0x03c7]=0x0000c66c386cc6c6,map[0x03c8]=0x0018dbdbdbdb7e18,map[0x03c9]=0x000044d6d6d66c00,
	map[0x03ca]=0xd800703030301c00,map[0x03cb]=0x6c00cc6666663c00,map[0x03cc]=0x08107cc6c6c67c00,
	map[0x03cd]=0x0810cc6666663c00,map[0x03ce]=0x081044d6d6d66c00,map[0x0400]=0x2010fec0fcc0fe00,
	map[0x0401]=0x6c00fec0fcc0fe00,map[0x0402]=0xf8607c666666660c,map[0x0403]=0x08107e6060606000,
	map[0x0404]=0x3c66c0fcc0663c00,map[0x0405]=0x78ccc07c06c67c00,map[0x0406]=0x7e18181818187e00,
	map[0x0407]=0x66007e1818187e00,map[0x0408]=0x0606060606c67c00,map[0x0409]=0x3070dcd6d6d6dc00,
	map[0x040a]=0xd0d0dcf6d6d6dc00,map[0x040b]=0xf8607c6666666600,map[0x040c]=0x0810c6ccf8ccc600,
	map[0x040d]=0x2010cedefef6e600,map[0x040e]=0x4438c6c67e06fc00,map[0x040f]=0xc6c6c6c6c6c6fe10,
	map[0x0410]=0x386cc6c6fec6c600,map[0x0411]=0xfcc0c0fcc6c6fc00,map[0x0412]=0xfcc6c6fcc6c6fc00,
	map[0x0413]=0x7e60606060606000,map[0x0414]=0x1e3636666666fec3,map[0x0415]=0xfec0c0fcc0c0fe00,
	map[0x0416]=0xd6d67c387cd6d600,map[0x0417]=0x7cc6063c06c67c00,map[0x0418]=0xc6cedefef6e6c600,
	map[0x0419]=0x4438cedefef6e600,map[0x041a]=0xc6ccd8f0f8dcce00,map[0x041b]=0x1e366666c6c6c600,
	map[0x041c]=0xc6eefefed6c6c600,map[0x041d]=0xc6c6c6fec6c6c600,map[0x041e]=0x7cc6c6c6c6c67c00,
	map[0x041f]=0xfec6c6c6c6c6c600,map[0x0420]=0xfcc6c6c6fcc0c000,map[0x0421]=0x3c66c0c0c0663c00,
	map[0x0422]=0x7e18181818181800,map[0x0423]=0xc6c6c67e06c67c00,map[0x0424]=0x107cd6d6d67c1000,
	map[0x0425]=0xc6ee7c387ceec600,map[0x0426]=0xccccccccccccfe06,map[0x0427]=0xc6c6c67e06060600,
	map[0x0428]=0xd6d6d6d6d6d6fe00,map[0x0429]=0xd6d6d6d6d6d6ff03,map[0x042a]=0xe0607c6666667c00,
	map[0x042b]=0xc6c6f6dededef600,map[0x042c]=0xc0c0fcc6c6c6fc00,map[0x042d]=0x78cc067e06cc7800,
	map[0x042e]=0xcedbdbfbdbdbce00,map[0x042f]=0x7ec6c6e63e76e600,map[0x0430]=0x00007c067ec67e00,
	map[0x0431]=0x7ec0dce6c6c67c00,map[0x0432]=0x0000fcc6fcc6fc00,map[0x0433]=0x00007e6060606000,
	map[0x0434]=0x00007ec6c67e067c,map[0x0435]=0x00007cc6fec07c00,map[0x0436]=0x0000d6d67cd6d600,
	map[0x0437]=0x0000fc067c06fc00,map[0x0438]=0x0000c6ced6e6c600,map[0x0439]=0x4438c6ced6e6c600,
	map[0x043a]=0x0000c6ccf8ccc600,map[0x043b]=0x00003e6666c6c600,map[0x043c]=0x0000c6eed6d6c600,
	map[0x043d]=0x0000c6c6fec6c600,map[0x043e]=0x00007cc6c6c67c00,map[0x043f]=0x0000fec6c6c6c600,
	map[0x0440]=0x0000fcc6c6fcc0c0,map[0x0441]=0x00007ec0c0c07e00,map[0x0442]=0x00007e1818181800,
	map[0x0443]=0x0000c6c6c67e067c,map[0x0444]=0x00107cd6d6d67c10,map[0x0445]=0x0000c6fe38fec600,
	map[0x0446]=0x0000ccccccccfe06,map[0x0447]=0x0000c6c67e060600,map[0x0448]=0x0000d6d6d6d6fe00,
	map[0x0449]=0x0000d6d6d6d6ff03,map[0x044a]=0x0000e0607c667c00,map[0x044b]=0x0000c6c6f6def600,
	map[0x044c]=0x0000c0c0fcc6fc00,map[0x044d]=0x00007cc61ec67c00,map[0x044e]=0x0000cedbfbdbce00,
	map[0x044f]=0x00007ec67ec6c600,map[0x0450]=0x20107cc6fec07c00,map[0x0451]=0x6c007cc6fec07c00,
	map[0x0452]=0x60f8607c6666660c,map[0x0453]=0x08107e6060606000,map[0x0454]=0x00007cc6f0c67c00,
	map[0x0455]=0x00007cc07c06fc00,map[0x0456]=0x1800381818187e00,map[0x0457]=0x6c00381818187e00,
	map[0x0458]=0x0c001c0c0c0c0c78,map[0x0459]=0x0000307cd6d6dc00,map[0x045a]=0x0000d0dcf6d6dc00,
	map[0x045b]=0x60f8607c66666600,map[0x045c]=0x0810c6ccf8ccc600,map[0x045d]=0x2010c6ced6e6c600,
	map[0x045e]=0x4438c6c6c67e067c,map[0x045f]=0x0000c6c6c6c6fe10,map[0x2013]=0x000000fe00000000,
	map[0x2014]=0x000000ff00000000,map[0x2015]=0x000000fe00000000,map[0x2018]=0x1830300000000000,
	map[0x2019]=0x1818300000000000,map[0x201a]=0x0000000018183000,map[0x201c]=0x366c6c0000000000,
	map[0x201d]=0x36366c0000000000,map[0x201e]=0x000000006c6cd800,map[0x2020]=0x18187e1818181800,
	map[0x2021]=0x18187e187e181800,map[0x2022]=0x0000183c3c180000,map[0x2026]=0x0000000000929200,
	map[0x2030]=0x62a4c8102f559e00,map[0x2039]=0x000c1830180c0000,map[0x203a]=0x0060301830600000,
	map[0x2044]=0x0204081020408000,map[0x20ac]=0x1c36f860f8361c00,map[0x20af]=0x6090949a9a9aec08,
	map[0x2116]=0xc4aaaaaaa4a0ae00,map[0x2122]=0x7e2e2a2a00000000,map[0x2190]=0x10307fff7f301000,
	map[0x2191]=0x10387cfe38383838,map[0x2192]=0x080cfefffe0c0800,map[0x2193]=0x38383838fe7c3810,
	map[0x2202]=0x78cc067ec6c67c00,map[0x2206]=0x386cc6c6c6c6fe00,map[0x220f]=0xfec6c6c6c6c6c600,
	map[0x2211]=0xfe66301c3066fe00,map[0x221a]=0x1e181818d8783800,map[0x221e]=0x00006c92926c0000,
	map[0x222b]=0x0c1a181818185830,map[0x2248]=0x0064980064980000,map[0x2260]=0x0204fe10fe408000,
	map[0x2264]=0x0c1830180c003c00,map[0x2265]=0x30180c1830003c00,map[0x25b2]=0x101038387c7cfe00,
	map[0x25b6]=0x80e0f8fef8e08000,map[0x25bc]=0xfe7c7c3838101000,map[0x25c0]=0x020e3efe3e0e0200,
	map[0x25ca]=0x1028448244281000,map[0x2605]=0x1010fe7c386c4400,map[0x2606]=0x1010ee44287c4400,
	map[0x2660]=0x10387cfefe387c00,map[0x2663]=0x1818666618183c00,map[0x2665]=0x6cfefefe7c381000,
	map[0x2666]=0x10387cfe7c381000,map[0x266a]=0x1018141274f06000,map[0xf101]=0x00000000001c7c00,
	map[0xf8ff]=0x0876fdfdfb7e2c00,map[0xfb01]=0x3860fe6666666600,map[0xfb02]=0x3e66fe6666666600, map; }
};

// portable endianness stuff. rlyeh, public domain {
#include <stdint.h>
#if __STDC_VERSION__ >= 199901L
#define IS_BIG_ENDIAN (!*(unsigned char *)&(uint16_t){1})
#else
#define IS_BIG_ENDIAN (*(uint16_t *)"\0\xff" < 0x100)
#endif
uint16_t swap16( uint16_t x ) {
	return ( x << 8 ) | ( x >> 8 );
}
uint32_t swap32( uint32_t x ) {
	return ( x << 24 ) | (( x << 8 ) & 0xff0000) | (( x >> 8 ) & 0xff00) | ( x >> 24 );
}
uint16_t tobe16( uint16_t x ) {
	return IS_BIG_ENDIAN ? x : swap16(x);
}
uint32_t tobe32( uint32_t x ) {
	return IS_BIG_ENDIAN ? x : swap32(x);
}
uint16_t tole16( uint16_t x ) {
	return IS_BIG_ENDIAN ? swap16(x) : x;
}
uint32_t tole32( uint32_t x ) {
	return IS_BIG_ENDIAN ? swap32(x) : x;
}
#define  hton16(x) ( IS_BIG_ENDIAN ? (x) : swap16(x) )
#define  hton32(x) ( IS_BIG_ENDIAN ? (x) : swap32(x) )
#define  ntoh16(x) ( IS_BIG_ENDIAN ? (x) : swap16(x) )
#define  ntoh32(x) ( IS_BIG_ENDIAN ? (x) : swap32(x) )
// }

extern "C"
int stbi_write_dds( char const *filename, int w, int h, int comp, const void *data ) {
   return save_image_as_DDS( filename, w, h, comp, (const unsigned char *const) data );
}

extern "C"
int WebPGetInfo(const uint8_t* data, size_t data_size, int* width, int* height);

extern "C"
uint8_t* WebPDecodeRGBA(const uint8_t* data, size_t data_size, int* width, int* height);

extern "C"
size_t WebPEncodeRGBA(const unsigned char* rgba, int width, int height, int stride, float quality_factor, unsigned char** output);

#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

// we're ready at this point...

namespace spot {

bool devel = false;

/*
#define STBI_ASSERT assert
#define stbi__errpuc(...) 0
#define stbi__malloc malloc
#define STBI_FREE free
#define stbi_uc unsigned char */
static stbi_uc stbi__compute_y(int r, int g, int b) {
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
static stbi_uc *stbi__convert_format(unsigned char *data, int bpp_src, int bpp_dst, unsigned int x, unsigned int y) {
   int i,j;
   stbi_uc *good;

   if (bpp_dst == bpp_src) return data;
   STBI_ASSERT(bpp_dst >= 1 && bpp_dst <= 4);

   good = (stbi_uc *) stbi__malloc(bpp_dst * x * y);
   if (good == NULL) {
	  STBI_FREE(data);
	  return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
	  stbi_uc *src  = data + j * x * bpp_src   ;
	  stbi_uc *dest = good + j * x * bpp_dst;

	  #define COMBO(a,b)  ((a)*8+(b))
	  #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
	  // convert source image with bpp_src components to one with bpp_dst components;
	  // avoid switch per pixel, so use switch per scanline and massive macros
	  switch (COMBO(bpp_src, bpp_dst)) {
		 CASE(1,2) dest[0]=src[0], dest[1]=255; break;
		 CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;
		 CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;
		 CASE(2,1) dest[0]=src[0]; break;
		 CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;
		 CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;
		 CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;
		 CASE(3,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
		 CASE(3,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255; break;
		 CASE(4,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
		 CASE(4,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;
		 CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;
		 default: STBI_ASSERT(0);
	  }
	  #undef CASE
   }

   STBI_FREE(data);
   return good;
}
/*
	if( (req_comp <= 4) && (req_comp >= 1) ) {
		//  user has some requirements, meet them
		if( req_comp != img_n ) {
			pkm_res_data = stbi__convert_format( pkm_res_data, img_n, req_comp, img_x, img_y );
		}
	}
*/

static stbi_uc *decode_etc1_stream(const void *stream, int len, int width, int height, unsigned int *zlen)
{
	int img_x = width, img_y = height, img_n = 3;

	unsigned int align = 0;
	unsigned int stride = ((width * 3) + align) & ~align;
	unsigned int size = stride * height;

	stbi_uc *unpacked = (stbi_uc *)malloc(size);
	if( unpacked ) {
		// pixelSize 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
		if( 0 == etc1_decode_image((const etc1_byte*)stream, (etc1_byte*)unpacked, width, height, 3, stride) ) {
			if( zlen ) *zlen = size;
			return (stbi_uc *)unpacked;
		}
		free( unpacked );
	}

	return NULL;
}

static stbi_uc *decode_pvrtc_stream(const void *stream, int len, int width, int height, int px_type, unsigned int *zlen)
{
	int img_x = width, img_y = height, img_n = 3;
	int bitmode = 0;

	switch( px_type ) {
		default: return 0;
		case pvr3::table1::PVRTC_2BPP_RGB:
		case pvr3::table1::PVRTC_2BPP_RGBA: bitmode = 1; img_n = 4; break;
		case pvr3::table1::PVRTC_4BPP_RGB:
		case pvr3::table1::PVRTC_4BPP_RGBA: img_n = 4; break;
	}

	// Load only the first mip map level
	unsigned int bytes = img_x * img_y * 4;
	stbi_uc *unpacked = (stbi_uc *)malloc( bytes );
	if( unpacked ) {
		Decompress( (AMTC_BLOCK_STRUCT*)stream, bitmode, img_x, img_y, 1, (unsigned char*)unpacked );
		if( zlen ) *zlen = bytes;
		return unpacked;
	}

	return 0;
}

bool stream::is_valid() const {
	return w && h && error.empty(); // && data && len
}

bool stream::is_etc1() const {
	return is_valid() && 0 == w % 4 && 0 == h % 4 && fmt == pvr3::table1::ETC1;
}

bool stream::is_compressed() const {
	return is_valid() && w * h * ( d >= 1 ? d : 1 ) * comp / 4 < len;
}

template<typename T>
void endianness( T &self ) {
}
template<>
void endianness( pkm::header &hd ) {
	hd.width = ntoh16(hd.width);
	hd.height = ntoh16(hd.height);
	hd.width_src = ntoh16(hd.width_src);
	hd.height_src = ntoh16(hd.height_src);
 }

template<typename T>
bool preload( T &self, const void *ptr, size_t len ) {
	if( sizeof( typename T::header ) < len ) {
		memcpy( &self.hd, ptr, sizeof( typename T::header ) );
		endianness( self.hd );
		return self.is_currently_supported();
	}
	memset( &self, 0, sizeof( typename T::header ) );
	return false;
}

/*
bool load( std::string &data, const std::string &name, uint32_t reserved = 0 ) {
	std::stringstream ss;
	std::ifstream ifs( name.c_str(), std::ios::binary );
	if( ifs.good() && ss << ifs.rdbuf() ) {
		return data = std::string( reserved, 0 ) + ss.str(), true;
	}
	return data = std::string( reserved, 0 ), false;
}
*/

stream encode_as_pvrtc( const void *bgra, int w, int h, int bpp = 32, int quality = 0, unsigned reserved = 0 ) {
	stream out = {};

	/*
	auto is_power_of_two = []( unsigned x ) {
		return ((x & (x - 1)) == 0);
	};
	if( !is_power_of_two(w) ) return out;
	if( !is_power_of_two(h) ) return out;
	*/
	bool is_4bpp = true; //quality >= 50;
	if( w % 4 ) return out;
	if( h % 4 ) return out;

	// @todo check is %4
	// Alloc mem
	int len = ( is_4bpp ? w * h / 2 : w * h / 4 ) + 4;
	uint8_t *dst = new uint8_t [ reserved + len ];
	if( !dst ) return out;
	uint8_t *pvrtc = &dst[ reserved ];

	// init
	out.w = w;
	out.h = h;
	out.d = 1;
	out.out = dst;
	out.len = len;

	/****/ if( bpp == 24 ) {
		Javelin::RgbBitmap bitmap( w, h );
		memcpy( bitmap.GetData(), bgra, w * h * 3 );
		//if( is_4bpp ) {
			out.fmt = pvr3::table1::PVRTC_4BPP_RGB;
			PvrTcEncoder::EncodeRgb4Bpp(pvrtc, bitmap);
		/*} else {
			out.fmt = pvr3::table1::PVRTC_2BPP_RGB;
			PvrTcEncoder::EncodeRgb2Bpp(pvrtc, bitmap);
		}*/
	} else if( bpp == 32 ) {
		Javelin::RgbaBitmap bitmap( w, h );
		memcpy( bitmap.GetData(), bgra, w * h * 4 );
		//if( is_4bpp ) {
			out.fmt = pvr3::table1::PVRTC_4BPP_RGBA;
			PvrTcEncoder::EncodeRgba4Bpp(pvrtc, bitmap);
		/*} else {
			out.fmt = pvr3::table1::PVRTC_2BPP_RGBA;
			PvrTcEncoder::EncodeRgba2Bpp(pvrtc, bitmap);
		}*/
	}

	return out;
}

stream encode_as_etc1_etcpak( const void *rgba, int w, int h, int bpp = 32, int quality = 0, unsigned reserved = 0 ) {
	stream out = {};

	bool alpha = false;
	bool mipmap = false;
	bool dither = quality >= 50;
	/*int*/ quality = 0;

	{
		auto bmp = std::make_shared<Bitmap>( (const uint32_t *)rgba, w * h * (bpp/8), w, h, std::numeric_limits<uint>::max() );

		auto bd = std::make_shared<BlockData>( bmp->Size(), false );
		auto block = std::make_shared<BlockBitmap>( bmp, Channels::RGB );
		if( dither ) block->Dither();
		bd->Process( block->Data(), bmp->Size().x * bmp->Size().y / 16, 0, quality, Channels::RGB );
		bd->Finish();

		BlockDataPtr bda;
		if( alpha && bpp == 32 ) {
			bda = std::make_shared<BlockData>( bmp->Size(), false );
			auto blocka = std::make_shared<BlockBitmap>( bmp, Channels::Alpha );
			// do not dither alpha
			bda->Process( blocka->Data(), bmp->Size().x * bmp->Size().y / 16, 0, quality, Channels::RGB );
			bda->Finish();
		}

		if( bd ) {
			out.w = bd->m_size.x;
			out.h = bd->m_size.y;
			out.d = 1;
			out.fmt = pvr3::table1::ETC1;
			out.len = out.w * out.h / 2;
			out.out = new unsigned char [ out.len ];
			memcpy( out.out, (const char *)&bd->m_data[ bd->m_dataOffset ], out.len );
		}
		if( bda ) {
			// to be done
		}

		bd.reset();
		bda.reset();
	}

	return out;
}
stream encode_as_etc1( const void *rgba, int w, int h, int bpp = 32, int quality = 0, unsigned reserved = 0 ) {

	if( quality < 50 ) return encode_as_etc1_etcpak( rgba, w, h, bpp, quality * 2, reserved );
	else quality = (quality - 50) * 2;

	stream out = {};

	/* Check for power of 2 {
	auto is_power_of_two = []( unsigned x ) {
		return ((x & (x - 1)) == 0);
	};
	if( !is_power_of_two(w) ) return out;
	if( !is_power_of_two(h) ) return out;
	// } */

	// Alloc mem
	unsigned pitch = w * (bpp / 8);
	unsigned blockw = w/4;
	unsigned blockh = h/4;
	size_t len = blockw * blockh * 8;
	uint8_t *dst = new uint8_t [ reserved + len ];
	if( !dst ) return out;
	uint8_t *data = &dst[ reserved ];

	// init
	rg_etc1::pack_etc1_block_init();
	rg_etc1::etc1_pack_params params;

	int step = 100/6;
	/**/ if( quality >= 100 - step * 1 ) params.m_quality = rg_etc1::cHighQuality,   params.m_dithering = true;
	else if( quality >= 100 - step * 2 ) params.m_quality = rg_etc1::cHighQuality,   params.m_dithering = false;
	else if( quality >= 100 - step * 3 ) params.m_quality = rg_etc1::cMediumQuality, params.m_dithering = true;
	else if( quality >= 100 - step * 4 ) params.m_quality = rg_etc1::cMediumQuality, params.m_dithering = false;
	else if( quality >= 100 - step * 5 ) params.m_quality = rg_etc1::cLowQuality,    params.m_dithering = true;
	else                                 params.m_quality = rg_etc1::cLowQuality,    params.m_dithering = false;

	// RGBA to ETC1
#pragma omp parallel for
	for( unsigned y = 0; y < blockh; y++ ) {
		for( unsigned x = 0; x < blockw; x++ ) {
			uint32_t block[16];
			for( unsigned iy = 0; iy < 4; iy++ ) {
				memcpy(block + 4 * iy, (uint8_t*)rgba + ((y * 4 + iy) * (pitch/4) + x * 4) * 4, 16);
			}
			rg_etc1::pack_etc1_block((data) + (blockw * y + x) * 8, block, params);
		}
	}

	out.w = blockw*4;
	out.h = blockh*4;
	out.d = 1;
	out.fmt = pvr3::table1::ETC1;
	out.out = dst;
	out.len = len;
	return out;
}

bool save_pkm_etc1( std::string &out, const stream &sm, unsigned reserved ) {
	if( sm.is_valid() && sm.is_etc1() ) {
		pkm p;
		p.hd.id = hton32('PKM ');
		p.hd.version = hton16('10');
		p.hd.type = hton16(0);
		p.hd.width = hton16(sm.w - sm.w % 4);
		p.hd.height = hton16(sm.h - sm.h % 4);
		p.hd.width_src = hton16(sm.w);
		p.hd.height_src = hton16(sm.h);
		if( devel ) p.debug(std::cout);

		out.resize( sizeof(p.hd) + reserved );
		memcpy( &out[0], &p.hd, sizeof(p.hd) );
		return true;
	}
	return out.clear(), false;
}

bool save_pvr( std::string &out, const stream &sm, unsigned reserved = 0 ) {
	if( sm.is_valid() /* && sm.is_etc1() */ ) {
		pvr3 pvr;
		pvr.hd.version = tole32(0x03525650);     // 0x03525650, if endianess does not match ; 0x50565203, if endianess does match
		pvr.hd.flags = tole32(0);                // 0x02, colour values within the texture have been pre-multiplied by the alpha values
		pvr.hd.pixel_format_1 = tole32(sm.fmt);  // see table1 above
		pvr.hd.pixel_format_2 = tole32(0);       // 0
		pvr.hd.color_space = tole32(0);          // 0 linear rgb, 1 standard rgb
		pvr.hd.channel_type = tole32(0);         // see table2 above
		pvr.hd.height = tole32(sm.h);            // 1d texture
		pvr.hd.width = tole32(sm.w);             // 2d texture; >= 1
		pvr.hd.depth = tole32(1);                // 3d texture; >= 1
		pvr.hd.num_surfaces = tole32(1);         // num surfaces in texture array; >= 1
		pvr.hd.num_faces = tole32(1);            // num faces in cubemap; >= 1
		pvr.hd.num_mipmaps = tole32(1);          // num levels of mipmaps; >= 1
		pvr.hd.metadata_size = tole32(0);        // length of following header
		if( devel ) pvr.debug(std::cout);

		out.resize( sizeof(pvr3::header) + reserved );
		memcpy( &out[0], &pvr.hd, sizeof(pvr.hd) );
		return true;
	}
	return out.clear(), false;
}

bool save_ktx( std::string &out, const stream &sm, unsigned reserved = 0 ) {
	if( sm.is_valid() ) {
		ktx k;
		auto &hd = k.hd;
		hd.identifier0 = tole32(0x58544bab);
		hd.identifier1 = tole32(0xbb313120);
		hd.identifier2 = tole32(0xa1a0a0d);
		hd.endianness = tole32(0x4030201);
		hd.glType = tole32(0x0); // table 8.2 of opengl 4.4 spec; UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5, etc.)
		hd.glTypeSize = tole32(0x1); // 1 for compressed data
		hd.glFormat = tole32(0x0); // table 8.3 of opengl 4.4 spec; RGB, RGBA, BGRA...
		// glInternalFormat:     table 8.14 of opengl 4.4 spec; ETC1_RGB8_OES (0x8D64)
		// glBaseInternalFormat: table 8.11 of opengl 4.4 spec; GL_RGB (0x1907), RGBA, ALPHA...
		/**/ if( sm.fmt == pvr3::table1::ETC1 )            { hd.glInternalFormat = tole32(0x8d64), hd.glBaseInternalFormat = tole32(0x1907); }
		else if( sm.fmt == pvr3::table1::PVRTC_2BPP_RGB )  { hd.glInternalFormat = tole32(0x8c01), hd.glBaseInternalFormat = tole32(0x1907); }
		else if( sm.fmt == pvr3::table1::PVRTC_2BPP_RGBA ) { hd.glInternalFormat = tole32(0x8c03), hd.glBaseInternalFormat = tole32(0x1908); }
		else if( sm.fmt == pvr3::table1::PVRTC_4BPP_RGB )  { hd.glInternalFormat = tole32(0x8c00), hd.glBaseInternalFormat = tole32(0x1907); }
		else if( sm.fmt == pvr3::table1::PVRTC_4BPP_RGBA ) { hd.glInternalFormat = tole32(0x8c02), hd.glBaseInternalFormat = tole32(0x1908); }
		else return false;
		hd.pixelWidth = tole32(sm.w);
		hd.pixelHeight = tole32(sm.h);
		hd.pixelDepth = tole32(0);
		hd.numberOfArrayElements = tole32(0);
		hd.numberOfFaces = tole32(1);
		hd.numberOfMipmapLevels = tole32(1);
		hd.bytesOfKeyValueData = tole32(0);
		if( devel ) k.debug(std::cout);

		out.resize( sizeof(ktx::header) + reserved );
		memcpy( &out[0], &k.hd, sizeof(ktx::header) );
		return true;
	}
	return out.clear(), false;
}

std::string save_pvr( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_pvr( out, sm, reserved ) ? out : std::string();
}
std::string save_ktx( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_ktx( out, sm, reserved ) ? out : std::string();
}
std::string save_pkm_etc1( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_pkm_etc1( out, sm, reserved ) ? out : std::string();
}

}

/*
@todo:
.pvr3
	for each MIP-Map Level in MIP-Map Count {
		for each Surface in Num. Surfaces {
			for each Face in Num. Faces {
				for each Slice in Depth {
					for each Row in Height {
						for each Pixel in Width {
							Byte data[Size_Based_On_PixelFormat]
	}}}}}

.ktx
	[header]

	for each keyValuePair that fits in bytesOfKeyValueData
		uint32_t   keyAndValueByteSize
		uint8_t    keyAndValue[keyAndValueByteSize]
		uint8_t    valuePadding[3 - ((keyAndValueByteSize + 3) % 4)]
	end

	for each mipmap_level in numberOfMipmapLevels* {
		uint32_t imageSize;
		for each array_element in numberOfArrayElements* {
		   for each face in numberOfFaces {
			   for each z_slice in pixelDepth* {
				   for each row or row_of_blocks in pixelHeight* {
					   for each pixel or block_of_pixels in pixelWidth {
						   uint8_t data[format-specific-number-of-bytes]**
					   }
				   }
			   }
			   uint8_t cubePadding[0-3]
		   }
		}
		uint8_t mipPadding[3 - ((imageSize + 3) % 4)]
	}

	* Replace with 1 if this field is 0.
	** Uncompressed texture data matches a GL_UNPACK_ALIGNMENT of 4.
*/

namespace spot
{
	namespace internals {

		int32_t swapbe( int32_t v ) {
			// swap bytes on big endian only; little remains unchanged
			union autodetect {
				int word;
				char byte[ sizeof(int) ];
				autodetect() : word(1)
				{}
			} _;
			bool is_big = _.byte[0] == 0;
			if( is_big ) {
				unsigned char *p = (unsigned char *)&v;
				std::swap( p[0], p[3] );
				std::swap( p[1], p[2] );
			}
			return v;
		}

		std::string encode_png( unsigned w, unsigned h, const void *data, unsigned stride ) {
			if( w && h && data && stride ) {
				auto mode = LCT_RGBA;
				/**/ if( stride == 3 ) mode = LCT_RGB;
				else if( stride == 2 ) mode = LCT_GREY_ALPHA;
				else if( stride == 1 ) mode = LCT_GREY;
				unsigned char* png;
				size_t pngsize;
				unsigned bpp = 8;
				unsigned error = lodepng_encode_memory_std( &png, &pngsize, (const unsigned char *)data, w, h, mode, bpp );
				if( !error && pngsize ) {
					std::string buf;
					buf.resize(pngsize);
					memcpy(&buf[0],png,pngsize);
					free(png);
					return buf;
				}
			}
			return std::string();
		}

		std::string encode_jpg( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				std::string buf( 1024 + w * h * 3, '\0' );
				jpge::params p;
				p.m_quality = (int)quality;
				p.m_two_pass_flag = true; // slower but slighty smaller
				int buf_size = (int)buf.size();
				if( jpge::compress_image_to_jpeg_file_in_memory(&buf[0], buf_size, w, h, 4, (const jpge::uint8 *)data, p) ) {
					if( buf_size > 0 ) {
						buf.resize((unsigned)(buf_size));
						return buf;
					}
				}
			}
			return std::string();
		}

		std::string encode_wbp( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				unsigned char *buf = 0;
				size_t buflen = WebPEncodeRGBA( (const unsigned char *)data, w, h, w * 4, quality, &buf );
				if( buflen && buf ) {
					std::string s;
					s.resize(buflen);
					memcpy(&s[0],buf,buflen);
					free(buf);
					return s;
				}
			}
			return std::string();
		}

		std::string encode_pug( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				// encode color as jpg
				std::string jpg = encode_jpg( w, h, data, quality );
				// encode alpha as png (gray, lum8)
				std::vector<unsigned char> alpha( w * h );
				unsigned char *ptr = ((unsigned char *)data) + 3;
				for( unsigned x = 0; x < w * h; ++x, ptr += 4 ) alpha[ x ] = *ptr;
				std::string png = encode_png( w, h, alpha.data(), 1 );
				// glue and footer
				int32_t size24 = internals::swapbe( int32_t(jpg.size()) );
				int32_t size08 = internals::swapbe( int32_t(png.size()) );
				if( size24 && size08 ) {
					std::stringstream ss;
					ss.write( &jpg[0], size24 );
					ss.write( &png[0], size08 );
					ss.write( (const char *)&size24, 4 );
					ss.write( (const char *)&size08, 4 );
					ss.write( "pug1", 4 );
					if( ss.good() ) {
						return ss.str();
					}
				}
			}
			return std::string();
		}

		std::string encode_ktx( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				stream sm = encode_as_etc1( data, w, h, 32, quality );
				std::stringstream ss;
				ss << save_ktx(sm);
				uint32_t len32( sm.len );
				ss.write( (const char *)&len32, 4 );
				ss.write( (const char *)sm.in, sm.len );
				delete [] ((uint8_t *)sm.out);
				return ss.str();
			}
			return std::string();
		}

		std::string encode_pvr( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				//stream sm = encode_as_etc1( data, w, h, 32, quality );
				stream sm = encode_as_pvrtc( data, w, h, 32, quality );
				std::stringstream ss;
				ss << save_pvr(sm);
				ss.write( (const char *)sm.in, sm.len );
				delete [] ((uint8_t *)sm.out);
				return ss.str();
			}
			return std::string();
		}

		std::string encode_pkm( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				stream sm = encode_as_etc1( data, w, h, 32, quality );
				std::stringstream ss;
				ss << save_pkm_etc1(sm);
				ss.write( (const char *)sm.in, sm.len );
				delete [] ((uint8_t *)sm.out);
				return ss.str();
			}
			return std::string();
		}

		/*
			transcoding
			===========

			std::cout << "fast: " << bench([&]{ encode_as_etc1( img.rgba32().data(), img.w, img.h, 32, SPOT_ETC1_LOW );} ) << std::endl;
			std::cout << "medium: " << bench([&]{ encode_as_etc1( img.rgba32().data(), img.w, img.h, 32, SPOT_ETC1_MEDIUM );} ) << std::endl;
			//std::cout << "high: " << bench([&]{ encode_as_etc1( img.rgba32().data(), img.w, img.h, 32, SPOT_ETC1_HIGH );} ) << std::endl;

			if( k.is_currently_supported() ) {
				auto header = save_pkm_etc1( stream { k.hd.pixelWidth, k.hd.pixelHeight, pvr3::table1::ETC1 } );
				buffer = buffer + sizeof(k.hd) + 4 - header.size();
				uint32_t len = tole32( uint32_t( header.size() ) );
				memcpy( &data[buffer - 4], &len, 4 );
				memcpy( &data[buffer], &header[0], header.size() );

				preload(pk, &data[buffer], data.size() - buffer );
				pk.debug( std::cout );
			}
			if( p.is_currently_supported() ) {
				auto header = save_pkm_etc1( stream { p.hd.width, p.hd.height, pvr3::table1::ETC1 } );
				buffer = buffer + sizeof(p.hd) - header.size();
				memcpy( &data[buffer], &header[0], header.size() );

				preload(pk, &data[buffer], data.size() - buffer );
				pk.debug( std::cout );
			}
			if( pk.is_currently_supported() ) {
				const stbi_uc *rgba = decode_etc1_stream( &data[buffer+sizeof(pkm::header)], data.size(), pk.hd.width, pk.hd.height, 3, &zlen);
				spot::texture tx( rgba, zlen, pk.hd.width, pk.hd.height );
				spot::image img = tx;
				display( img );
			}
		}
		*/

		bool writefile( const std::string &filename, const std::string &data ) {
			if( !data.empty() ) {
				std::ofstream ofs( filename.c_str(), std::ios::binary );
				ofs.write( &data[0], data.size() );
				return ofs.good();
			}
			return false;
		}
	}

	std::vector<std::string> list_supported_inputs() {
		const char *str[] = { "bmp", "dds", "gif", "hdr", "jpg", "pic", "pkm", "png", "psd", "pvr", "svg", "tga", "webp", "pnm", "pug", "crn", 0 };
		std::vector<std::string> list;
		for( int i = 0; str[i]; ++i ) {
			list.push_back( str[i] );
		}
		return list;
	}
	std::vector<std::string> list_supported_outputs() {
		const char *str[] = { "bmp", "dds", "jpg", "png", "tga", "webp", "pug", "ktx", "pvr", "pkm", 0 };
		std::vector<std::string> list;
		for( int i = 0; str[i]; ++i ) {
			list.push_back( str[i] );
		}
		return list;
	}

	enum { NO_DELETER, STBI_DELETER, FREE_DELETER, NEW_DELETER, NEW_ARRAY_DELETER };
	enum { UNK, IS_STBI, IS_CRN, IS_WEBP, IS_SVG, IS_KTX, IS_PVR3, IS_PKM };

	bool info( stream &sm, const void *src, size_t len ) {
		stream blank = {};
		sm = blank;
		sm.in = src;
		sm.len = len;

		if( !src ) return false;
		if( !len ) return false;

		const char *src8 = (const char *)src;

		// crn?
		bool is_crn = len > 2 && (src8[0] == 'H' && src8[1] == 'x');
		if( is_crn ) {
			sm.w = (( src8[0xC] << 8) | src8[0xD] );
			sm.h = (( src8[0xE] << 8) | src8[0xF] );
			sm.comp = 4;
			sm.hint = IS_CRN;
			sm.deleter = STBI_DELETER;
			return true;
		}

		// pkm? (etc1)
		{
			pkm f;
			preload( f, src, len );
			if( devel ) f.debug( std::cout );
			if( f.is_currently_supported() ) {
				sm.w = int(f.hd.width);
				sm.h = int(f.hd.height);
				sm.fmt = f.get_spot_fmt();
				sm.comp = 3;
				sm.hint = IS_PKM;
				return true;
			}
		}

		// ktx? (etc1)
		{
			ktx f;
			preload( f, src, len );
			if( devel ) f.debug( std::cout );
			if( f.is_currently_supported() ) {
				sm.w = int(f.hd.pixelWidth);
				sm.h = int(f.hd.pixelHeight);
				sm.fmt = f.get_spot_fmt();
				sm.comp = 3;
				sm.hint = IS_KTX;
				return true;
			}
		}

		// pvr3? (etc1)
		{
			pvr3 f;
			preload( f, src, len );
			if( devel ) f.debug( std::cout );
			if( f.is_currently_supported() ) {
				sm.w = int(f.hd.width);
				sm.h = int(f.hd.height);
				sm.fmt = f.get_spot_fmt();
				sm.comp = 3;
				sm.hint = IS_PVR3;
				return true;
			}
		}

		// pvr2 ?
		int iscompressed = false;
		int ok = stbi__pvr_info_from_memory( (stbi_uc const *)src, int(len), &sm.w, &sm.h, &sm.comp, &iscompressed );
		if( ok ) {
			return sm.hint = IS_STBI, sm.deleter = STBI_DELETER, true;
		}

		// dds ?
		ok = stbi__dds_info_from_memory( (stbi_uc const *)src, int(len), &sm.w, &sm.h, &sm.comp, &iscompressed );
		if( ok ) {
			return sm.hint = IS_STBI, sm.deleter = STBI_DELETER, true;
		}

		// try most
		ok = stbi_info_from_memory( (stbi_uc const *)src, int(len), &sm.w, &sm.h, &sm.comp );
		if( ok ) {
			// pug?
			const char *magic = (const char *)src + len - 4;
			if( magic[0] == 'p' && magic[1] == 'u' && magic[2] == 'g' && magic[3] == '1' ) sm.comp = 4;

			return sm.hint = IS_STBI, sm.deleter = STBI_DELETER, true;
		}

		// webp ?
		ok = 0 != WebPGetInfo( (const uint8_t *)src, len, &sm.w, &sm.h );
		if( ok ) return sm.hint = IS_WEBP, sm.deleter = FREE_DELETER, sm.comp = 4, true;

		// svg ?
		if( src8[0] == '<' || src8[0] == ' ' || src8[0] == '\t' ) {
			// Load SVG, parse and rasterize
			char *str = new char[ len + 1 ];
			memcpy( str, src, len );
			str[ len ] = '\0';

			NSVGimage *image = nsvgParse( str, "px" /*units*/, 96.f /* dpi */ );
			if( image ) {
				double scale = 1.0;
				sm.hint = IS_SVG;
				sm.w = int(image->width * scale);
				sm.h = int(image->height * scale);
				sm.comp = 4;

				nsvgDelete(image);
				delete [] str;
				return sm.deleter = FREE_DELETER, true;
			} else {
				delete [] str;
			}
		}

		return false;
	}

	bool decode( stream &dst, const stream &src )
	{
		if( !src.in || !dst.out ) {
			dst.error = "Error: invalid pointer provided";
			return false;
		}

		if( !src.len || !dst.len ) {
			dst.error = "Error: invalid size provided";
			return false;
		}

		// decode
		int imageWidth = 0, imageHeight = 0, imageComp = 0, imageHint = 0;
		int deleter = NO_DELETER;

		if( !src.hint ) {
			if( !info( dst, src.in, src.len ) ) {
				return false;
			}
		}

		imageWidth = src.w;
		imageHeight = src.h;
		imageComp = src.comp;
		imageHint = src.hint;

		stbi_uc *imageuc = 0;

		switch( imageHint ) {
		default:
		break;
		case IS_CRN :{
			std::string dds;
			if( crn2dds( dds, src.in, src.len ) ) {
				imageuc = stbi_load_from_memory( (const unsigned char *)&dds[0], dds.size(), &imageWidth, &imageHeight, &imageComp, 4 );
				deleter = STBI_DELETER;
				imageComp = 4;
			}
		}
		break;
		case IS_PKM :{
			unsigned int zlen;
			const stbi_uc *data = (const stbi_uc *)src.in;
			size_t offset = sizeof(pkm::header);
			imageuc = decode_etc1_stream( &data[offset], src.len - offset, imageWidth, imageHeight, &zlen);
			deleter = FREE_DELETER;
			imageComp = 3;
		}
		break;
		case IS_KTX :{
			unsigned int zlen;
			const stbi_uc *data = (const stbi_uc *)src.in;
			size_t offset = sizeof(ktx::header) + ((ktx::header *)src.in)->bytesOfKeyValueData + 4;
			/****/ if( src.fmt == pvr3::table1::ETC1 ) {
				imageuc = decode_etc1_stream( &data[offset], src.len - offset, imageWidth, imageHeight, &zlen);
				imageComp = 3;
			} else if( src.fmt <= pvr3::table1::PVRTC_4BPP_RGBA ) {
				imageuc = decode_pvrtc_stream( &data[offset], src.len - offset, imageWidth, imageHeight, src.fmt, &zlen);
				imageComp = (src.fmt == pvr3::table1::PVRTC_2BPP_RGBA || pvr3::table1::PVRTC_4BPP_RGBA) ? 4 : 3;
			}
			deleter = FREE_DELETER;
		}
		break;
		case IS_PVR3: {
			unsigned int zlen;
			const stbi_uc *data = (const stbi_uc *)src.in;
			size_t offset = sizeof(pvr3::header) + ((pvr3::header *)src.in)->metadata_size;
			/****/ if( src.fmt == pvr3::table1::ETC1 ) {
				imageuc = decode_etc1_stream( &data[offset], src.len - offset, imageWidth, imageHeight, &zlen);
				imageComp = 3;
			} else if( src.fmt <= pvr3::table1::PVRTC_4BPP_RGBA ) {
				imageuc = decode_pvrtc_stream( &data[offset], src.len - offset, imageWidth, imageHeight, src.fmt, &zlen);
				imageComp = (src.fmt == pvr3::table1::PVRTC_2BPP_RGBA || pvr3::table1::PVRTC_4BPP_RGBA) ? 4 : 3;
			}
			deleter = FREE_DELETER;
		}
		break;
		case IS_STBI: {
			imageuc = stbi_load_from_memory( (const stbi_uc *)src.in, src.len, &imageWidth, &imageHeight, &imageComp, src.comp < 3 ? 3 : src.comp );
			imageComp = src.comp < 3 ? 3 : src.comp;
			deleter = STBI_DELETER;
			// if it is a .pug file, then decode alpha
			const char *magic = (const char *)src.in + src.len - 4;
			if( magic[0] == 'p' && magic[1] == 'u' && magic[2] == 'g' && magic[3] == '1' ) {
				imageComp = 4;
				const int32_t color_size = internals::swapbe( *(const int32_t *)((const char *)src.in + src.len - 12) );
				const int32_t alpha_size = internals::swapbe( *(const int32_t *)((const char *)src.in + src.len - 8) );
				int w2 = 0, h2 = 0, bpp2 = 0;
				stbi_uc *alpha = stbi_load_from_memory( (const unsigned char *)src.in + color_size, alpha_size, &w2, &h2, &bpp2, 1 );
				if( alpha ) {
					stbi_uc *data8 = &alpha[ 0 ], *end8 = &alpha[ w2*h2 ], *dst8 = &imageuc[ 3 ];
					while( data8 < end8 ) {
						*dst8 = *data8++;
						dst8 += 4;
					}
					stbi_image_free( alpha );
				}
			}
		}
		break;
		case IS_WEBP: {
			imageuc = (stbi_uc *) WebPDecodeRGBA( (const uint8_t *)src.in, src.len, &imageWidth, &imageHeight );
			deleter = FREE_DELETER;
			imageComp = 4;
		}
		break;
		case IS_SVG :{
			// Load SVG, parse and rasterize
			char *str = new char[ src.len + 1 ];
			memcpy( str, src.in, src.len );
			str[ src.len ] = '\0';

			NSVGimage *image = nsvgParse( str, "px" /*units*/, 96.f /* dpi */ );
			if( image ) {
				// Create rasterizer (can be used to render multiple images).
				static struct install {
					NSVGrasterizer *rasterizer;
					 install() { rasterizer = nsvgCreateRasterizer(); }
					~install() { if( rasterizer ) nsvgDeleteRasterizer( rasterizer ); rasterizer = 0; }
				} local;
				// Allocate memory for image
				int w = image->width;
				int h = image->height;

				imageuc = (stbi_uc *)malloc(w*h*4); //imageWidth*imageHeight*4
				deleter = FREE_DELETER;
				if( imageuc ) {
					// Rasterizes SVG image, returns RGBA image (non-premultiplied alpha)
					//   r - pointer to rasterizer context
					//   image - pointer to image to rasterize
					//   tx,ty - image offset (applied after scaling)
					//   scale - image scale
					//   dst - pointer to destination image data, 4 bytes per pixel (RGBA)
					//   w - width of the image to render
					//   h - height of the image to render
					//   stride - number of bytes per scaleline in the destination buffer
					double scale = 1.0;
					nsvgRasterize( local.rasterizer, image, 0,0,scale, imageuc, w, h, w*scale*4 );
				}
				nsvgDelete(image);
			}

			delete [] str;
		}
		};

		if( !imageuc )
		{
			// assert( false );
			// return yellow/black texture instead?
			dst.error = "Error! unable to decode image";
			return false;
		}

		memcpy( dst.out, imageuc, imageWidth * imageHeight * imageComp ); //dst.len );

		/****/ if( deleter == STBI_DELETER ) {
			stbi_image_free( imageuc );
		} else if( deleter == FREE_DELETER ) {
			free(imageuc);
		} else if( deleter == NEW_DELETER ) {
			delete imageuc;
		} else if( deleter == NEW_ARRAY_DELETER ) {
			delete [] (imageuc);
		}
		imageuc = 0;

		dst.w = imageWidth;
		dst.h = imageHeight;
		dst.d = 1;
		dst.comp = imageComp;
		dst.fmt = RGBA_8888;

		return true;
	}

	std::vector<unsigned char> decode8( const void *src, size_t size, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		stream in = {};
		stream out = {};
		if( info( in, src, size ) ) {
			if( in.is_valid() ) {
				std::vector<unsigned char> dst( in.w * in.h * 4 /*srccomp*/ );
				out.out = &dst[0];
				out.len = int(dst.size());
				out.fmt = RGBA_8888;
				if( decode( out, in ) ) {
					if( w     ) *w = size_t(out.w);
					if( h     ) *h = size_t(out.h);
					if( comp  ) *comp = size_t(out.comp);
					if( error ) *error = out.error;
					return dst;
				}
			}
		}
		return std::vector<unsigned char>();
	}

	std::vector<unsigned char> decode8( const std::string &filename, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		std::ifstream ifs( filename.c_str(), std::ios::binary );
		std::vector<char> buffer( (std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
		return decode8( (const unsigned char *)buffer.data(), buffer.size(), w, h, comp, error );
	}

	std::vector<unsigned int> decode32( const void *ptr, size_t size, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		std::vector<unsigned char> decoded = decode8( ptr, size, w, h, comp, error );
		std::vector<unsigned int> out;
		if( !decoded.empty() ) {
			out.reserve( decoded.size() / 4 );
			if( comp && *comp == 3 )
			for( unsigned char *data8 = &decoded[0], *end8 = data8 + decoded.size(); data8 != end8; ) {
				pixel p;
				p.r = *data8++;
				p.g = *data8++;
				p.b = *data8++;
				p.a = 255;
				out.push_back( p.rgba );
			}
			if( comp && *comp == 4 )
			for( unsigned char *data8 = &decoded[0], *end8 = data8 + decoded.size(); data8 != end8; ) {
				pixel p;
				p.r = *data8++;
				p.g = *data8++;
				p.b = *data8++;
				p.a = *data8++;
				out.push_back( p.rgba );
			}
			return out;
		}
		return out;
	}

	std::vector<unsigned int> decode32( const std::string &filename, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		std::ifstream ifs( filename.c_str(), std::ios::binary );
		std::vector<char> buffer( (std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
		return decode32( (const unsigned char *)buffer.data(), buffer.size(), w, h, comp, error );
	}

	void hsl2rgb( const float *hsl, float *rgb )
	{
		// Given H,S,L in range of 0-1
		// Returns a Color (RGB struct) in range of 0-1

		const float &h = hsl[0];
		const float &s = hsl[1];
		const float &l = hsl[2];

		float &r = rgb[0];
		float &g = rgb[1];
		float &b = rgb[2];

		float v;

		r = l;   // default to gray
		g = l;
		b = l;
		v = (l <= 0.5f) ? (l * (1.f + s)) : (l + s - l * s);

		if (v > 0)
		{
			  float m = l + l - v;
			  float sv = (v - m ) / v;
			  float h6 = h * 6.f;
			  int sextant = (int)h6;
			  float fract = h6 - sextant;
			  float vsf = v * sv * fract;
			  float mid1 = m + vsf;
			  float mid2 = v - vsf;

			  switch (sextant)
			  {
					default:
					case 0:
						  r = v;
						  g = mid1;
						  b = m;
						  break;
					case 1:
						  r = mid2;
						  g = v;
						  b = m;
						  break;
					case 2:
						  r = m;
						  g = v;
						  b = mid1;
						  break;
					case 3:
						  r = m;
						  g = mid2;
						  b = v;
						  break;
					case 4:
						  r = mid1;
						  g = m;
						  b = v;
						  break;
					case 5:
						  r = v;
						  g = m;
						  b = mid2;
						  break;
			  }
		}
	}

	void rgb2hsl( const float *rgb, float *hsl )
	{
		// Given a Color (RGB Struct) in range of 0-1
		// Return H,S,L in range of 0-1

		const float &r = rgb[0];
		const float &g = rgb[1];
		const float &b = rgb[2];
		float v;
		float m;
		float vm;
		float r2, g2, b2;

		float &h = hsl[0];
		float &s = hsl[1];
		float &l = hsl[2];

		h = 0; // default to black
		s = 0;
		l = 0;
		v = ( r > g ? r : g );
		v = ( v > b ? v : b );
		m = ( r < g ? r : g );
		m = ( m < b ? m : b );
		l = (m + v) / 2.f;
		if (l <= 0.f)
		{
			  return;
		}
		vm = v - m;
		s = vm;
		if (s > 0.f)
		{
			  s /= (l <= 0.5f) ? (v + m ) : (2.f - v - m) ;
		}
		else
		{
			  return;
		}
		r2 = (v - r) / vm;
		g2 = (v - g) / vm;
		b2 = (v - b) / vm;
		if (r == v)
		{
			  h = (g == m ? 5.f + b2 : 1.f - g2);
		}
		else if (g == v)
		{
			  h = (b == m ? 1.f + r2 : 3.f - b2);
		}
		else
		{
			  h = (r == m ? 3.f + g2 : 5.f - r2);
		}
		h /= 6.f;
	}

	pixel::operator color() const {
		pixel c = this->clamp().to_hsla();
		return spot::color(c.r / 255.f, c.g / 255.f, c.b / 255.f, c.a / 255.f);
	}

	static pixel rgba8888( unsigned char r, unsigned char g, unsigned char b, unsigned char a ) {
		return pixel(r,g,b,a);
	}
	static color rgba8888_alt( unsigned char r, unsigned char g, unsigned char b, unsigned char a ) {
		return pixel(r,g,b,a);
	}

	void texture::print( int x, int y, const char *utf8 ) {
		unifont<pixel> f( &(this->operator[](0)), this->w, &rgba8888 );
		f.render_string( x, y, 0|2, utf8 );
	}
	void image::print( int x, int y, const char *utf8 ) {
		unifont<color> f( &(this->operator[](0)), this->w, &rgba8888_alt );
		f.render_string( x, y, 0|2, utf8 );
	}
}

