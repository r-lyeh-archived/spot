/** this is an amalgamated file. do not edit.
 */

/* Handy pixel/color and texture/image classes. zlib/libpng licensed.
 * - rlyeh ~~ listening to Twilightning - Painting the blue eyes

 *   Hue - Think of a color wheel. Around 0 and 255 are reds 85 are greens, 170 are blues. Use anything in between 0-255. Values above and below will be modulus 255.
 *   Saturation - 0 is completely denatured (grayscale). 255 is fully saturated (full color).
 *   Lightness - 0 is completely dark (black). 255 is completely light (white). 127 is average lightness.
 *   alpha - Opacity/Transparency value. 0 is fully transparent. 255 is fully opaque. 127 is 50% transparent.

 *   enum hue
 *   {
 *       hred1 = 0,
 *       hgreen = 85,
 *       hblue = 170,
 *       hred2 = 255,

 *       hpurple =  ( ( hblue + hred2 ) / 2 ) % 255,
 *       hcyan =  ( ( hgreen + hblue ) / 2 ) % 255,
 *       hyellow = ( ( hred1 + hgreen ) / 2 ) % 255
 *   };

 *   unsigned char make_hue( float reds, float greens, float blues )
 *   {
 *       return (unsigned char)( int( reds * 255 + greens * 85 + blues * 170 ) % 255 );
 *   }

 * valid color components in range [0..1]
 * components can handle higher values (useful for color algebra), but their values will be clamped when displayed

 * image = array of pixels[] in RGBA or HSLA format
 * texture = strict subset of an image { squared, rgba only }
 * so, image > texture

 * image @todo
 * vg {
 * image.glow( 1px, pixel::black )
 * image.glow( 2px, pixel::red )
 * image.mask(white);
 * image.mask(white).glow( 2x, pixel::blue ).replace(white,transp) --> L4D2 style
 * image.aabb(); -> return aabb for this frame
 * }
 * composition {
 * image.append( img[], align09 = 6 )
 * image.crop( columns/rows to remove, align09 = 2, method = fast/carving )
 * image.shrink( w, h )
 * }
 * image.noisex()
 * image.perlin()
 * image.mipmap()
 * image.upload()/unload()
 * image.download()/capture()
 * image.rotate(deg, bgcolor/transparent?)
 * image.premultiply()/unpremultiply()
 * image.gamma(1.22)
 * image.atlas( image[] )/combine(other)
 * image.blur()/sharpen()
 * image.scale(marquee_scale,content_scale,scale_method)
 * @todo: also image1 * / *= / + / += image2

 * pixel @Todo:
 *  replace float with float8 (microfloat 0.4.4 ; good idea?)
 *  to_rg() // computer vision: r = r/r+g+b, g = g/r+g+b
 *  munsell 5 hues: red, yellow, green, blue, purple
 *  hsl 6 hues: red, yellow, green, cyan, blue, purple
 *  rgy
 *  http://en.wikipedia.org/wiki/HSL_color_space#Disadvantages
 *  http://cgit.haiku-os.org/haiku/plain/src/add-ons/translators/exr/openexr/half/half.h
 *  ftp://www.fox-toolkit.org/pub/fasthalffloatconversion.pdf
 *  std::string str() const { return std::string(); } //#ffffffff

*/

#include <assert.h>
#include <math.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <algorithm>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <vector>

#include "spot.hpp"

#define NANOSVG_ALL_COLOR_KEYWORDS  // Include full list of color keywords.
#define NANOSVG_IMPLEMENTATION      // Expands implementation
#define NANOSVGRAST_IMPLEMENTATION  // Expands implementation


//#line 1 "nanosvg.h"
#ifndef NANOSVG_H
#define NANOSVG_H

#ifdef __cplusplus
extern "C" {
#endif

// NanoSVG is a simple stupid single-header-file SVG parse. The output of the parser is a list of cubic bezier shapes.
//
// The library suits well for anything from rendering scalable icons in your editor application to prototyping a game.
//
// NanoSVG supports a wide range of SVG features, but something may be missing, feel free to create a pull request!
//
// The shapes in the SVG images are transformed by the viewBox and converted to specified units.
// That is, you should get the same looking data as your designed in your favorite app.
//
// NanoSVG can return the paths in few different units. For example if you want to render an image, you may choose
// to get the paths in pixels, or if you are feeding the data into a CNC-cutter, you may want to use millimeters.
//
// The units passed to NanoVG should be one of: 'px', 'pt', 'pc' 'mm', 'cm', or 'in'.
// DPI (dots-per-inch) controls how the unit conversion is done.
//
// If you don't know or care about the units stuff, "px" and 96 should get you going.

/* Example Usage:
	// Load
	SNVGImage* image;
	image = nsvgParseFromFile("test.svg", "px", 96);
	printf("size: %f x %f\n", image->width, image->height);
	// Use...
	for (shape = image->shapes; shape != NULL; shape = shape->next) {
		for (path = shape->paths; path != NULL; path = path->next) {
			for (i = 0; i < path->npts-1; i += 3) {
				float* p = &path->pts[i*2];
				drawCubicBez(p[0],p[1], p[2],p[3], p[4],p[5], p[6],p[7]);
			}
		}
	}
	// Delete
	nsvgDelete(image);
*/

enum NSVGpaintType {
	NSVG_PAINT_NONE = 0,
	NSVG_PAINT_COLOR = 1,
	NSVG_PAINT_LINEAR_GRADIENT = 2,
	NSVG_PAINT_RADIAL_GRADIENT = 3,
};

enum NSVGspreadType {
	NSVG_SPREAD_PAD = 0,
	NSVG_SPREAD_REFLECT = 1,
	NSVG_SPREAD_REPEAT = 2,
};

enum NSVGlineJoin {
	NSVG_JOIN_MITER = 0,
	NSVG_JOIN_ROUND = 1,
	NSVG_JOIN_BEVEL = 2,
};

enum NSVGlineCap {
	NSVG_CAP_BUTT = 0,
	NSVG_CAP_ROUND = 1,
	NSVG_CAP_SQUARE = 2,
};

enum NSVGfillRule {
	NSVG_FILLRULE_NONZERO = 0,
	NSVG_FILLRULE_EVENODD = 1,
};

enum NSVGflags {
	NSVG_FLAGS_VISIBLE = 0x01
};

typedef struct NSVGgradientStop {
	unsigned int color;
	float offset;
} NSVGgradientStop;

typedef struct NSVGgradient {
	float xform[6];
	char spread;
	float fx, fy;
	int nstops;
	NSVGgradientStop stops[1];
} NSVGgradient;

typedef struct NSVGpaint {
	char type;
	union {
		unsigned int color;
		NSVGgradient* gradient;
	};
} NSVGpaint;

typedef struct NSVGpath
{
	float* pts;					// Cubic bezier points: x0,y0, [cpx1,cpx1,cpx2,cpy2,x1,y1], ...
	int npts;					// Total number of bezier points.
	char closed;				// Flag indicating if shapes should be treated as closed.
	float bounds[4];			// Tight bounding box of the shape [minx,miny,maxx,maxy].
	struct NSVGpath* next;		// Pointer to next path, or NULL if last element.
} NSVGpath;

typedef struct NSVGshape
{
	char id[64];				// Optional 'id' attr of the shape or its group
	NSVGpaint fill;				// Fill paint
	NSVGpaint stroke;			// Stroke paint
	float opacity;				// Opacity of the shape.
	float strokeWidth;			// Stroke width (scaled).
	float strokeDashOffset;		// Stroke dash offset (scaled).
	float strokeDashArray[8];			// Stroke dash array (scaled).
	char strokeDashCount;				// Number of dash values in dash array.
	char strokeLineJoin;		// Stroke join type.
	char strokeLineCap;			// Stroke cap type.
	char fillRule;				// Fill rule, see NSVGfillRule.
	unsigned char flags;		// Logical or of NSVG_FLAGS_* flags
	float bounds[4];			// Tight bounding box of the shape [minx,miny,maxx,maxy].
	NSVGpath* paths;			// Linked list of paths in the image.
	struct NSVGshape* next;		// Pointer to next shape, or NULL if last element.
} NSVGshape;

typedef struct NSVGimage
{
	float width;				// Width of the image.
	float height;				// Height of the image.
	NSVGshape* shapes;			// Linked list of shapes in the image.
} NSVGimage;

// Parses SVG file from a file, returns SVG image as paths.
NSVGimage* nsvgParseFromFile(const char* filename, const char* units, float dpi);

// Parses SVG file from a null terminated string, returns SVG image as paths.
// Important note: changes the string.
NSVGimage* nsvgParse(char* input, const char* units, float dpi);

// Deletes list of paths.
void nsvgDelete(NSVGimage* image);

#ifdef __cplusplus
};
#endif

#endif // NANOSVG_H

#ifdef NANOSVG_IMPLEMENTATION

#include <string.h>
#include <stdlib.h>
#include <math.h>

#define NSVG_PI (3.14159265358979323846264338327f)
#define NSVG_KAPPA90 (0.5522847493f)	// Lenght proportional to radius of a cubic bezier handle for 90deg arcs.

#define NSVG_ALIGN_MIN 0
#define NSVG_ALIGN_MID 1
#define NSVG_ALIGN_MAX 2
#define NSVG_ALIGN_NONE 0
#define NSVG_ALIGN_MEET 1
#define NSVG_ALIGN_SLICE 2

#define NSVG_NOTUSED(v) do { (void)(1 ? (void)0 : ( (void)(v) ) ); } while(0)
#define NSVG_RGB(r, g, b) (((unsigned int)r) | ((unsigned int)g << 8) | ((unsigned int)b << 16))

#ifdef _MSC_VER
	#pragma warning (disable: 4996) // Switch off security warnings
	#pragma warning (disable: 4100) // Switch off unreferenced formal parameter warnings
	#ifdef __cplusplus
	#define NSVG_INLINE inline
	#else
	#define NSVG_INLINE
	#endif
#else
	#define NSVG_INLINE inline
#endif

static int nsvg__isspace(char c)
{
	return strchr(" \t\n\v\f\r", c) != 0;
}

static int nsvg__isdigit(char c)
{
	return strchr("0123456789", c) != 0;
}

static int nsvg__isnum(char c)
{
	return strchr("0123456789+-.eE", c) != 0;
}

static NSVG_INLINE float nsvg__minf(float a, float b) { return a < b ? a : b; }
static NSVG_INLINE float nsvg__maxf(float a, float b) { return a > b ? a : b; }

// Simple XML parser

#define NSVG_XML_TAG 1
#define NSVG_XML_CONTENT 2
#define NSVG_XML_MAX_ATTRIBS 256

static void nsvg__parseContent(char* s,
							   void (*contentCb)(void* ud, const char* s),
							   void* ud)
{
	// Trim start white spaces
	while (*s && nsvg__isspace(*s)) s++;
	if (!*s) return;

	if (contentCb)
		(*contentCb)(ud, s);
}

static void nsvg__parseElement(char* s,
							   void (*startelCb)(void* ud, const char* el, const char** attr),
							   void (*endelCb)(void* ud, const char* el),
							   void* ud)
{
	const char* attr[NSVG_XML_MAX_ATTRIBS];
	int nattr = 0;
	char* name;
	int start = 0;
	int end = 0;
	char quote;

	// Skip white space after the '<'
	while (*s && nsvg__isspace(*s)) s++;

	// Check if the tag is end tag
	if (*s == '/') {
		s++;
		end = 1;
	} else {
		start = 1;
	}

	// Skip comments, data and preprocessor stuff.
	if (!*s || *s == '?' || *s == '!')
		return;

	// Get tag name
	name = s;
	while (*s && !nsvg__isspace(*s)) s++;
	if (*s) { *s++ = '\0'; }

	// Get attribs
	while (!end && *s && nattr < NSVG_XML_MAX_ATTRIBS-3) {
		// Skip white space before the attrib name
		while (*s && nsvg__isspace(*s)) s++;
		if (!*s) break;
		if (*s == '/') {
			end = 1;
			break;
		}
		attr[nattr++] = s;
		// Find end of the attrib name.
		while (*s && !nsvg__isspace(*s) && *s != '=') s++;
		if (*s) { *s++ = '\0'; }
		// Skip until the beginning of the value.
		while (*s && *s != '\"' && *s != '\'') s++;
		if (!*s) break;
		quote = *s;
		s++;
		// Store value and find the end of it.
		attr[nattr++] = s;
		while (*s && *s != quote) s++;
		if (*s) { *s++ = '\0'; }
	}

	// List terminator
	attr[nattr++] = 0;
	attr[nattr++] = 0;

	// Call callbacks.
	if (start && startelCb)
		(*startelCb)(ud, name, attr);
	if (end && endelCb)
		(*endelCb)(ud, name);
}

int nsvg__parseXML(char* input,
				   void (*startelCb)(void* ud, const char* el, const char** attr),
				   void (*endelCb)(void* ud, const char* el),
				   void (*contentCb)(void* ud, const char* s),
				   void* ud)
{
	char* s = input;
	char* mark = s;
	int state = NSVG_XML_CONTENT;
	while (*s) {
		if (*s == '<' && state == NSVG_XML_CONTENT) {
			// Start of a tag
			*s++ = '\0';
			nsvg__parseContent(mark, contentCb, ud);
			mark = s;
			state = NSVG_XML_TAG;
		} else if (*s == '>' && state == NSVG_XML_TAG) {
			// Start of a content or new tag.
			*s++ = '\0';
			nsvg__parseElement(mark, startelCb, endelCb, ud);
			mark = s;
			state = NSVG_XML_CONTENT;
		} else {
			s++;
		}
	}

	return 1;
}

/* Simple SVG parser. */

#define NSVG_MAX_ATTR 128

enum NSVGgradientUnits {
	NSVG_USER_SPACE = 0,
	NSVG_OBJECT_SPACE = 1,
};

#define NSVG_MAX_DASHES 8

enum NSVGunits {
	NSVG_UNITS_USER,
	NSVG_UNITS_PX,
	NSVG_UNITS_PT,
	NSVG_UNITS_PC,
	NSVG_UNITS_MM,
	NSVG_UNITS_CM,
	NSVG_UNITS_IN,
	NSVG_UNITS_PERCENT,
	NSVG_UNITS_EM,
	NSVG_UNITS_EX,
};

typedef struct NSVGcoordinate {
	float value;
	int units;
} NSVGcoordinate;

typedef struct NSVGlinearData {
	NSVGcoordinate x1, y1, x2, y2;
} NSVGlinearData;

typedef struct NSVGradialData {
	NSVGcoordinate cx, cy, r, fx, fy;
} NSVGradialData;

typedef struct NSVGgradientData
{
	char id[64];
	char ref[64];
	char type;
	union {
		NSVGlinearData linear;
		NSVGradialData radial;
	};
	char spread;
	char units;
	float xform[6];
	int nstops;
	NSVGgradientStop* stops;
	struct NSVGgradientData* next;
} NSVGgradientData;

typedef struct NSVGattrib
{
	char id[64];
	float xform[6];
	unsigned int fillColor;
	unsigned int strokeColor;
	float opacity;
	float fillOpacity;
	float strokeOpacity;
	char fillGradient[64];
	char strokeGradient[64];
	float strokeWidth;
	float strokeDashOffset;
	float strokeDashArray[NSVG_MAX_DASHES];
	int strokeDashCount;
	char strokeLineJoin;
	char strokeLineCap;
	char fillRule;
	float fontSize;
	unsigned int stopColor;
	float stopOpacity;
	float stopOffset;
	char hasFill;
	char hasStroke;
	char visible;
} NSVGattrib;

typedef struct NSVGparser
{
	NSVGattrib attr[NSVG_MAX_ATTR];
	int attrHead;
	float* pts;
	int npts;
	int cpts;
	NSVGpath* plist;
	NSVGimage* image;
	NSVGgradientData* gradients;
	float viewMinx, viewMiny, viewWidth, viewHeight;
	int alignX, alignY, alignType;
	float dpi;
	char pathFlag;
	char defsFlag;
} NSVGparser;

static void nsvg__xformIdentity(float* t)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetTranslation(float* t, float tx, float ty)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = tx; t[5] = ty;
}

static void nsvg__xformSetScale(float* t, float sx, float sy)
{
	t[0] = sx; t[1] = 0.0f;
	t[2] = 0.0f; t[3] = sy;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetSkewX(float* t, float a)
{
	t[0] = 1.0f; t[1] = 0.0f;
	t[2] = tanf(a); t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetSkewY(float* t, float a)
{
	t[0] = 1.0f; t[1] = tanf(a);
	t[2] = 0.0f; t[3] = 1.0f;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformSetRotation(float* t, float a)
{
	float cs = cosf(a), sn = sinf(a);
	t[0] = cs; t[1] = sn;
	t[2] = -sn; t[3] = cs;
	t[4] = 0.0f; t[5] = 0.0f;
}

static void nsvg__xformMultiply(float* t, float* s)
{
	float t0 = t[0] * s[0] + t[1] * s[2];
	float t2 = t[2] * s[0] + t[3] * s[2];
	float t4 = t[4] * s[0] + t[5] * s[2] + s[4];
	t[1] = t[0] * s[1] + t[1] * s[3];
	t[3] = t[2] * s[1] + t[3] * s[3];
	t[5] = t[4] * s[1] + t[5] * s[3] + s[5];
	t[0] = t0;
	t[2] = t2;
	t[4] = t4;
}

static void nsvg__xformInverse(float* inv, float* t)
{
	double invdet, det = (double)t[0] * t[3] - (double)t[2] * t[1];
	if (det > -1e-6 && det < 1e-6) {
		nsvg__xformIdentity(t);
		return;
	}
	invdet = 1.0 / det;
	inv[0] = (float)(t[3] * invdet);
	inv[2] = (float)(-t[2] * invdet);
	inv[4] = (float)(((double)t[2] * t[5] - (double)t[3] * t[4]) * invdet);
	inv[1] = (float)(-t[1] * invdet);
	inv[3] = (float)(t[0] * invdet);
	inv[5] = (float)(((double)t[1] * t[4] - (double)t[0] * t[5]) * invdet);
}

static void nsvg__xformPremultiply(float* t, float* s)
{
	float s2[6];
	memcpy(s2, s, sizeof(float)*6);
	nsvg__xformMultiply(s2, t);
	memcpy(t, s2, sizeof(float)*6);
}

static void nsvg__xformPoint(float* dx, float* dy, float x, float y, float* t)
{
	*dx = x*t[0] + y*t[2] + t[4];
	*dy = x*t[1] + y*t[3] + t[5];
}

static void nsvg__xformVec(float* dx, float* dy, float x, float y, float* t)
{
	*dx = x*t[0] + y*t[2];
	*dy = x*t[1] + y*t[3];
}

#define NSVG_EPSILON (1e-12)

static int nsvg__ptInBounds(float* pt, float* bounds)
{
	return pt[0] >= bounds[0] && pt[0] <= bounds[2] && pt[1] >= bounds[1] && pt[1] <= bounds[3];
}

static double nsvg__evalBezier(double t, double p0, double p1, double p2, double p3)
{
	double it = 1.0-t;
	return it*it*it*p0 + 3.0*it*it*t*p1 + 3.0*it*t*t*p2 + t*t*t*p3;
}

static void nsvg__curveBounds(float* bounds, float* curve)
{
	int i, j, count;
	double roots[2], a, b, c, b2ac, t, v;
	float* v0 = &curve[0];
	float* v1 = &curve[2];
	float* v2 = &curve[4];
	float* v3 = &curve[6];

	// Start the bounding box by end points
	bounds[0] = nsvg__minf(v0[0], v3[0]);
	bounds[1] = nsvg__minf(v0[1], v3[1]);
	bounds[2] = nsvg__maxf(v0[0], v3[0]);
	bounds[3] = nsvg__maxf(v0[1], v3[1]);

	// Bezier curve fits inside the convex hull of it's control points.
	// If control points are inside the bounds, we're done.
	if (nsvg__ptInBounds(v1, bounds) && nsvg__ptInBounds(v2, bounds))
		return;

	// Add bezier curve inflection points in X and Y.
	for (i = 0; i < 2; i++) {
		a = -3.0 * v0[i] + 9.0 * v1[i] - 9.0 * v2[i] + 3.0 * v3[i];
		b = 6.0 * v0[i] - 12.0 * v1[i] + 6.0 * v2[i];
		c = 3.0 * v1[i] - 3.0 * v0[i];
		count = 0;
		if (fabs(a) < NSVG_EPSILON) {
			if (fabs(b) > NSVG_EPSILON) {
				t = -c / b;
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
			}
		} else {
			b2ac = b*b - 4.0*c*a;
			if (b2ac > NSVG_EPSILON) {
				t = (-b + sqrt(b2ac)) / (2.0 * a);
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
				t = (-b - sqrt(b2ac)) / (2.0 * a);
				if (t > NSVG_EPSILON && t < 1.0-NSVG_EPSILON)
					roots[count++] = t;
			}
		}
		for (j = 0; j < count; j++) {
			v = nsvg__evalBezier(roots[j], v0[i], v1[i], v2[i], v3[i]);
			bounds[0+i] = nsvg__minf(bounds[0+i], (float)v);
			bounds[2+i] = nsvg__maxf(bounds[2+i], (float)v);
		}
	}
}

static NSVGparser* nsvg__createParser()
{
	NSVGparser* p;
	p = (NSVGparser*)malloc(sizeof(NSVGparser));
	if (p == NULL) goto error;
	memset(p, 0, sizeof(NSVGparser));

	p->image = (NSVGimage*)malloc(sizeof(NSVGimage));
	if (p->image == NULL) goto error;
	memset(p->image, 0, sizeof(NSVGimage));

	// Init style
	nsvg__xformIdentity(p->attr[0].xform);
	memset(p->attr[0].id, 0, sizeof p->attr[0].id);
	p->attr[0].fillColor = NSVG_RGB(0,0,0);
	p->attr[0].strokeColor = NSVG_RGB(0,0,0);
	p->attr[0].opacity = 1;
	p->attr[0].fillOpacity = 1;
	p->attr[0].strokeOpacity = 1;
	p->attr[0].stopOpacity = 1;
	p->attr[0].strokeWidth = 1;
	p->attr[0].strokeLineJoin = NSVG_JOIN_MITER;
	p->attr[0].strokeLineCap = NSVG_CAP_BUTT;
	p->attr[0].fillRule = NSVG_FILLRULE_NONZERO;
	p->attr[0].hasFill = 1;
	p->attr[0].visible = 1;

	return p;

error:
	if (p) {
		if (p->image) free(p->image);
		free(p);
	}
	return NULL;
}

static void nsvg__deletePaths(NSVGpath* path)
{
	while (path) {
		NSVGpath *next = path->next;
		if (path->pts != NULL)
			free(path->pts);
		free(path);
		path = next;
	}
}

static void nsvg__deletePaint(NSVGpaint* paint)
{
	if (paint->type == NSVG_PAINT_LINEAR_GRADIENT || paint->type == NSVG_PAINT_RADIAL_GRADIENT)
		free(paint->gradient);
}

static void nsvg__deleteGradientData(NSVGgradientData* grad)
{
	NSVGgradientData* next;
	while (grad != NULL) {
		next = grad->next;
		free(grad->stops);
		free(grad);
		grad = next;
	}
}

static void nsvg__deleteParser(NSVGparser* p)
{
	if (p != NULL) {
		nsvg__deletePaths(p->plist);
		nsvg__deleteGradientData(p->gradients);
		nsvgDelete(p->image);
		free(p->pts);
		free(p);
	}
}

static void nsvg__resetPath(NSVGparser* p)
{
	p->npts = 0;
}

static void nsvg__addPoint(NSVGparser* p, float x, float y)
{
	if (p->npts+1 > p->cpts) {
		p->cpts = p->cpts ? p->cpts*2 : 8;
		p->pts = (float*)realloc(p->pts, p->cpts*2*sizeof(float));
		if (!p->pts) return;
	}
	p->pts[p->npts*2+0] = x;
	p->pts[p->npts*2+1] = y;
	p->npts++;
}

static void nsvg__moveTo(NSVGparser* p, float x, float y)
{
	if (p->npts > 0) {
		p->pts[(p->npts-1)*2+0] = x;
		p->pts[(p->npts-1)*2+1] = y;
	} else {
		nsvg__addPoint(p, x, y);
	}
}

static void nsvg__lineTo(NSVGparser* p, float x, float y)
{
	float px,py, dx,dy;
	if (p->npts > 0) {
		px = p->pts[(p->npts-1)*2+0];
		py = p->pts[(p->npts-1)*2+1];
		dx = x - px;
		dy = y - py;
		nsvg__addPoint(p, px + dx/3.0f, py + dy/3.0f);
		nsvg__addPoint(p, x - dx/3.0f, y - dy/3.0f);
		nsvg__addPoint(p, x, y);
	}
}

static void nsvg__cubicBezTo(NSVGparser* p, float cpx1, float cpy1, float cpx2, float cpy2, float x, float y)
{
	nsvg__addPoint(p, cpx1, cpy1);
	nsvg__addPoint(p, cpx2, cpy2);
	nsvg__addPoint(p, x, y);
}

static NSVGattrib* nsvg__getAttr(NSVGparser* p)
{
	return &p->attr[p->attrHead];
}

static void nsvg__pushAttr(NSVGparser* p)
{
	if (p->attrHead < NSVG_MAX_ATTR-1) {
		p->attrHead++;
		memcpy(&p->attr[p->attrHead], &p->attr[p->attrHead-1], sizeof(NSVGattrib));
	}
}

static void nsvg__popAttr(NSVGparser* p)
{
	if (p->attrHead > 0)
		p->attrHead--;
}

static float nsvg__actualOrigX(NSVGparser* p)
{
	return p->viewMinx;
}

static float nsvg__actualOrigY(NSVGparser* p)
{
	return p->viewMiny;
}

static float nsvg__actualWidth(NSVGparser* p)
{
	return p->viewWidth;
}

static float nsvg__actualHeight(NSVGparser* p)
{
	return p->viewHeight;
}

static float nsvg__actualLength(NSVGparser* p)
{
	float w = nsvg__actualWidth(p), h = nsvg__actualHeight(p);
	return sqrtf(w*w + h*h) / sqrtf(2.0f);
}

static float nsvg__convertToPixels(NSVGparser* p, NSVGcoordinate c, float orig, float length)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	switch (c.units) {
		case NSVG_UNITS_USER:		return c.value;
		case NSVG_UNITS_PX:			return c.value;
		case NSVG_UNITS_PT:			return c.value / 72.0f * p->dpi;
		case NSVG_UNITS_PC:			return c.value / 6.0f * p->dpi;
		case NSVG_UNITS_MM:			return c.value / 25.4f * p->dpi;
		case NSVG_UNITS_CM:			return c.value / 2.54f * p->dpi;
		case NSVG_UNITS_IN:			return c.value * p->dpi;
		case NSVG_UNITS_EM:			return c.value * attr->fontSize;
		case NSVG_UNITS_EX:			return c.value * attr->fontSize * 0.52f; // x-height of Helvetica.
		case NSVG_UNITS_PERCENT:	return orig + c.value / 100.0f * length;
		default:					return c.value;
	}
	return c.value;
}

static NSVGgradientData* nsvg__findGradientData(NSVGparser* p, const char* id)
{
	NSVGgradientData* grad = p->gradients;
	while (grad) {
		if (strcmp(grad->id, id) == 0)
			return grad;
		grad = grad->next;
	}
	return NULL;
}

static NSVGgradient* nsvg__createGradient(NSVGparser* p, const char* id, const float* localBounds, char* paintType)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	NSVGgradientData* data = NULL;
	NSVGgradientData* ref = NULL;
	NSVGgradientStop* stops = NULL;
	NSVGgradient* grad;
	float ox, oy, sw, sh, sl;
	int nstops = 0;

	data = nsvg__findGradientData(p, id);
	if (data == NULL) return NULL;

	// TODO: use ref to fill in all unset values too.
	ref = data;
	while (ref != NULL) {
		if (stops == NULL && ref->stops != NULL) {
			stops = ref->stops;
			nstops = ref->nstops;
			break;
		}
		ref = nsvg__findGradientData(p, ref->ref);
	}
	if (stops == NULL) return NULL;

	grad = (NSVGgradient*)malloc(sizeof(NSVGgradient) + sizeof(NSVGgradientStop)*(nstops-1));
	if (grad == NULL) return NULL;

	// The shape width and height.
	if (data->units == NSVG_OBJECT_SPACE) {
		ox = localBounds[0];
		oy = localBounds[1];
		sw = localBounds[2] - localBounds[0];
		sh = localBounds[3] - localBounds[1];
	} else {
		ox = nsvg__actualOrigX(p);
		oy = nsvg__actualOrigY(p);
		sw = nsvg__actualWidth(p);
		sh = nsvg__actualHeight(p);
	}
	sl = sqrtf(sw*sw + sh*sh) / sqrtf(2.0f);

	if (data->type == NSVG_PAINT_LINEAR_GRADIENT) {
		float x1, y1, x2, y2, dx, dy;
		x1 = nsvg__convertToPixels(p, data->linear.x1, ox, sw);
		y1 = nsvg__convertToPixels(p, data->linear.y1, oy, sh);
		x2 = nsvg__convertToPixels(p, data->linear.x2, ox, sw);
		y2 = nsvg__convertToPixels(p, data->linear.y2, oy, sh);
		// Calculate transform aligned to the line
		dx = x2 - x1;
		dy = y2 - y1;
		grad->xform[0] = dy; grad->xform[1] = -dx;
		grad->xform[2] = dx; grad->xform[3] = dy;
		grad->xform[4] = x1; grad->xform[5] = y1;
	} else {
		float cx, cy, fx, fy, r;
		cx = nsvg__convertToPixels(p, data->radial.cx, ox, sw);
		cy = nsvg__convertToPixels(p, data->radial.cy, oy, sh);
		fx = nsvg__convertToPixels(p, data->radial.fx, ox, sw);
		fy = nsvg__convertToPixels(p, data->radial.fy, oy, sh);
		r = nsvg__convertToPixels(p, data->radial.r, 0, sl);
		// Calculate transform aligned to the circle
		grad->xform[0] = r; grad->xform[1] = 0;
		grad->xform[2] = 0; grad->xform[3] = r;
		grad->xform[4] = cx; grad->xform[5] = cy;
		grad->fx = fx / r;
		grad->fy = fy / r;
	}

	nsvg__xformMultiply(grad->xform, data->xform);
	nsvg__xformMultiply(grad->xform, attr->xform);

	grad->spread = data->spread;
	memcpy(grad->stops, stops, nstops*sizeof(NSVGgradientStop));
	grad->nstops = nstops;

	*paintType = data->type;

	return grad;
}

static float nsvg__getAverageScale(float* t)
{
	float sx = sqrtf(t[0]*t[0] + t[2]*t[2]);
	float sy = sqrtf(t[1]*t[1] + t[3]*t[3]);
	return (sx + sy) * 0.5f;
}

static void nsvg__getLocalBounds(float* bounds, NSVGshape *shape, float* xform)
{
	NSVGpath* path;
	float curve[4*2], curveBounds[4];
	int i, first = 1;
	for (path = shape->paths; path != NULL; path = path->next) {
		nsvg__xformPoint(&curve[0], &curve[1], path->pts[0], path->pts[1], xform);
		for (i = 0; i < path->npts-1; i += 3) {
			nsvg__xformPoint(&curve[2], &curve[3], path->pts[(i+1)*2], path->pts[(i+1)*2+1], xform);
			nsvg__xformPoint(&curve[4], &curve[5], path->pts[(i+2)*2], path->pts[(i+2)*2+1], xform);
			nsvg__xformPoint(&curve[6], &curve[7], path->pts[(i+3)*2], path->pts[(i+3)*2+1], xform);
			nsvg__curveBounds(curveBounds, curve);
			if (first) {
				bounds[0] = curveBounds[0];
				bounds[1] = curveBounds[1];
				bounds[2] = curveBounds[2];
				bounds[3] = curveBounds[3];
				first = 0;
			} else {
				bounds[0] = nsvg__minf(bounds[0], curveBounds[0]);
				bounds[1] = nsvg__minf(bounds[1], curveBounds[1]);
				bounds[2] = nsvg__maxf(bounds[2], curveBounds[2]);
				bounds[3] = nsvg__maxf(bounds[3], curveBounds[3]);
			}
			curve[0] = curve[6];
			curve[1] = curve[7];
		}
	}
}

static void nsvg__addShape(NSVGparser* p)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	float scale = 1.0f;
	NSVGshape *shape, *cur, *prev;
	NSVGpath* path;
	int i;

	if (p->plist == NULL)
		return;

	shape = (NSVGshape*)malloc(sizeof(NSVGshape));
	if (shape == NULL) goto error;
	memset(shape, 0, sizeof(NSVGshape));

	memcpy(shape->id, attr->id, sizeof shape->id);
	scale = nsvg__getAverageScale(attr->xform);
	shape->strokeWidth = attr->strokeWidth * scale;
	shape->strokeDashOffset = attr->strokeDashOffset * scale;
	shape->strokeDashCount = attr->strokeDashCount;
	for (i = 0; i < attr->strokeDashCount; i++)
		shape->strokeDashArray[i] = attr->strokeDashArray[i] * scale;
	shape->strokeLineJoin = attr->strokeLineJoin;
	shape->strokeLineCap = attr->strokeLineCap;
	shape->fillRule = attr->fillRule;
	shape->opacity = attr->opacity;

	shape->paths = p->plist;
	p->plist = NULL;

	// Calculate shape bounds
	shape->bounds[0] = shape->paths->bounds[0];
	shape->bounds[1] = shape->paths->bounds[1];
	shape->bounds[2] = shape->paths->bounds[2];
	shape->bounds[3] = shape->paths->bounds[3];
	for (path = shape->paths->next; path != NULL; path = path->next) {
		shape->bounds[0] = nsvg__minf(shape->bounds[0], path->bounds[0]);
		shape->bounds[1] = nsvg__minf(shape->bounds[1], path->bounds[1]);
		shape->bounds[2] = nsvg__maxf(shape->bounds[2], path->bounds[2]);
		shape->bounds[3] = nsvg__maxf(shape->bounds[3], path->bounds[3]);
	}

	// Set fill
	if (attr->hasFill == 0) {
		shape->fill.type = NSVG_PAINT_NONE;
	} else if (attr->hasFill == 1) {
		shape->fill.type = NSVG_PAINT_COLOR;
		shape->fill.color = attr->fillColor;
		shape->fill.color |= (unsigned int)(attr->fillOpacity*255) << 24;
	} else if (attr->hasFill == 2) {
		float inv[6], localBounds[4];
		nsvg__xformInverse(inv, attr->xform);
		nsvg__getLocalBounds(localBounds, shape, inv);
		shape->fill.gradient = nsvg__createGradient(p, attr->fillGradient, localBounds, &shape->fill.type);
		if (shape->fill.gradient == NULL) {
			shape->fill.type = NSVG_PAINT_NONE;
		}
	}

	// Set stroke
	if (attr->hasStroke == 0) {
		shape->stroke.type = NSVG_PAINT_NONE;
	} else if (attr->hasStroke == 1) {
		shape->stroke.type = NSVG_PAINT_COLOR;
		shape->stroke.color = attr->strokeColor;
		shape->stroke.color |= (unsigned int)(attr->strokeOpacity*255) << 24;
	} else if (attr->hasStroke == 2) {
		float inv[6], localBounds[4];
		nsvg__xformInverse(inv, attr->xform);
		nsvg__getLocalBounds(localBounds, shape, inv);
		shape->stroke.gradient = nsvg__createGradient(p, attr->strokeGradient, localBounds, &shape->stroke.type);
		if (shape->stroke.gradient == NULL)
			shape->stroke.type = NSVG_PAINT_NONE;
	}

	// Set flags
	shape->flags = (attr->visible ? NSVG_FLAGS_VISIBLE : 0x00);

	// Add to tail
	prev = NULL;
	cur = p->image->shapes;
	while (cur != NULL) {
		prev = cur;
		cur = cur->next;
	}
	if (prev == NULL)
		p->image->shapes = shape;
	else
		prev->next = shape;

	return;

error:
	if (shape) free(shape);
}

static void nsvg__addPath(NSVGparser* p, char closed)
{
	NSVGattrib* attr = nsvg__getAttr(p);
	NSVGpath* path = NULL;
	float bounds[4];
	float* curve;
	int i;

	if (p->npts < 4)
		return;

	if (closed)
		nsvg__lineTo(p, p->pts[0], p->pts[1]);

	path = (NSVGpath*)malloc(sizeof(NSVGpath));
	if (path == NULL) goto error;
	memset(path, 0, sizeof(NSVGpath));

	path->pts = (float*)malloc(p->npts*2*sizeof(float));
	if (path->pts == NULL) goto error;
	path->closed = closed;
	path->npts = p->npts;

	// Transform path.
	for (i = 0; i < p->npts; ++i)
		nsvg__xformPoint(&path->pts[i*2], &path->pts[i*2+1], p->pts[i*2], p->pts[i*2+1], attr->xform);

	// Find bounds
	for (i = 0; i < path->npts-1; i += 3) {
		curve = &path->pts[i*2];
		nsvg__curveBounds(bounds, curve);
		if (i == 0) {
			path->bounds[0] = bounds[0];
			path->bounds[1] = bounds[1];
			path->bounds[2] = bounds[2];
			path->bounds[3] = bounds[3];
		} else {
			path->bounds[0] = nsvg__minf(path->bounds[0], bounds[0]);
			path->bounds[1] = nsvg__minf(path->bounds[1], bounds[1]);
			path->bounds[2] = nsvg__maxf(path->bounds[2], bounds[2]);
			path->bounds[3] = nsvg__maxf(path->bounds[3], bounds[3]);
		}
	}

	path->next = p->plist;
	p->plist = path;

	return;

error:
	if (path != NULL) {
		if (path->pts != NULL) free(path->pts);
		free(path);
	}
}

static const char* nsvg__parseNumber(const char* s, char* it, const int size)
{
	const int last = size-1;
	int i = 0;

	// sign
	if (*s == '-' || *s == '+') {
		if (i < last) it[i++] = *s;
		s++;
	}
	// integer part
	while (*s && nsvg__isdigit(*s)) {
		if (i < last) it[i++] = *s;
		s++;
	}
	if (*s == '.') {
		// decimal point
		if (i < last) it[i++] = *s;
		s++;
		// fraction part
		while (*s && nsvg__isdigit(*s)) {
			if (i < last) it[i++] = *s;
			s++;
		}
	}
	// exponent
	if (*s == 'e' || *s == 'E') {
		if (i < last) it[i++] = *s;
		s++;
		if (*s == '-' || *s == '+') {
			if (i < last) it[i++] = *s;
			s++;
		}
		while (*s && nsvg__isdigit(*s)) {
			if (i < last) it[i++] = *s;
			s++;
		}
	}
	it[i] = '\0';

	return s;
}

static const char* nsvg__getNextPathItem(const char* s, char* it)
{
	it[0] = '\0';
	// Skip white spaces and commas
	while (*s && (nsvg__isspace(*s) || *s == ',')) s++;
	if (!*s) return s;
	if (*s == '-' || *s == '+' || *s == '.' || nsvg__isdigit(*s)) {
		s = nsvg__parseNumber(s, it, 64);
	} else {
		// Parse command
		it[0] = *s++;
		it[1] = '\0';
		return s;
	}

	return s;
}

static unsigned int nsvg__parseColorHex(const char* str)
{
	unsigned int c = 0, r = 0, g = 0, b = 0;
	int n = 0;
	str++; // skip #
	// Calculate number of characters.
	while(str[n] && !nsvg__isspace(str[n]))
		n++;
	if (n == 6) {
		sscanf(str, "%x", &c);
	} else if (n == 3) {
		sscanf(str, "%x", &c);
		c = (c&0xf) | ((c&0xf0) << 4) | ((c&0xf00) << 8);
		c |= c<<4;
	}
	r = (c >> 16) & 0xff;
	g = (c >> 8) & 0xff;
	b = c & 0xff;
	return NSVG_RGB(r,g,b);
}

static unsigned int nsvg__parseColorRGB(const char* str)
{
	int r = -1, g = -1, b = -1;
	char s1[32]="", s2[32]="";
	sscanf(str + 4, "%d%[%%, \t]%d%[%%, \t]%d", &r, s1, &g, s2, &b);
	if (strchr(s1, '%')) {
		return NSVG_RGB((r*255)/100,(g*255)/100,(b*255)/100);
	} else {
		return NSVG_RGB(r,g,b);
	}
}

typedef struct NSVGNamedColor {
	const char* name;
	unsigned int color;
} NSVGNamedColor;

NSVGNamedColor nsvg__colors[] = {

	{ "red", NSVG_RGB(255, 0, 0) },
	{ "green", NSVG_RGB( 0, 128, 0) },
	{ "blue", NSVG_RGB( 0, 0, 255) },
	{ "yellow", NSVG_RGB(255, 255, 0) },
	{ "cyan", NSVG_RGB( 0, 255, 255) },
	{ "magenta", NSVG_RGB(255, 0, 255) },
	{ "black", NSVG_RGB( 0, 0, 0) },
	{ "grey", NSVG_RGB(128, 128, 128) },
	{ "gray", NSVG_RGB(128, 128, 128) },
	{ "white", NSVG_RGB(255, 255, 255) },

#ifdef NANOSVG_ALL_COLOR_KEYWORDS
	{ "aliceblue", NSVG_RGB(240, 248, 255) },
	{ "antiquewhite", NSVG_RGB(250, 235, 215) },
	{ "aqua", NSVG_RGB( 0, 255, 255) },
	{ "aquamarine", NSVG_RGB(127, 255, 212) },
	{ "azure", NSVG_RGB(240, 255, 255) },
	{ "beige", NSVG_RGB(245, 245, 220) },
	{ "bisque", NSVG_RGB(255, 228, 196) },
	{ "blanchedalmond", NSVG_RGB(255, 235, 205) },
	{ "blueviolet", NSVG_RGB(138, 43, 226) },
	{ "brown", NSVG_RGB(165, 42, 42) },
	{ "burlywood", NSVG_RGB(222, 184, 135) },
	{ "cadetblue", NSVG_RGB( 95, 158, 160) },
	{ "chartreuse", NSVG_RGB(127, 255, 0) },
	{ "chocolate", NSVG_RGB(210, 105, 30) },
	{ "coral", NSVG_RGB(255, 127, 80) },
	{ "cornflowerblue", NSVG_RGB(100, 149, 237) },
	{ "cornsilk", NSVG_RGB(255, 248, 220) },
	{ "crimson", NSVG_RGB(220, 20, 60) },
	{ "darkblue", NSVG_RGB( 0, 0, 139) },
	{ "darkcyan", NSVG_RGB( 0, 139, 139) },
	{ "darkgoldenrod", NSVG_RGB(184, 134, 11) },
	{ "darkgray", NSVG_RGB(169, 169, 169) },
	{ "darkgreen", NSVG_RGB( 0, 100, 0) },
	{ "darkgrey", NSVG_RGB(169, 169, 169) },
	{ "darkkhaki", NSVG_RGB(189, 183, 107) },
	{ "darkmagenta", NSVG_RGB(139, 0, 139) },
	{ "darkolivegreen", NSVG_RGB( 85, 107, 47) },
	{ "darkorange", NSVG_RGB(255, 140, 0) },
	{ "darkorchid", NSVG_RGB(153, 50, 204) },
	{ "darkred", NSVG_RGB(139, 0, 0) },
	{ "darksalmon", NSVG_RGB(233, 150, 122) },
	{ "darkseagreen", NSVG_RGB(143, 188, 143) },
	{ "darkslateblue", NSVG_RGB( 72, 61, 139) },
	{ "darkslategray", NSVG_RGB( 47, 79, 79) },
	{ "darkslategrey", NSVG_RGB( 47, 79, 79) },
	{ "darkturquoise", NSVG_RGB( 0, 206, 209) },
	{ "darkviolet", NSVG_RGB(148, 0, 211) },
	{ "deeppink", NSVG_RGB(255, 20, 147) },
	{ "deepskyblue", NSVG_RGB( 0, 191, 255) },
	{ "dimgray", NSVG_RGB(105, 105, 105) },
	{ "dimgrey", NSVG_RGB(105, 105, 105) },
	{ "dodgerblue", NSVG_RGB( 30, 144, 255) },
	{ "firebrick", NSVG_RGB(178, 34, 34) },
	{ "floralwhite", NSVG_RGB(255, 250, 240) },
	{ "forestgreen", NSVG_RGB( 34, 139, 34) },
	{ "fuchsia", NSVG_RGB(255, 0, 255) },
	{ "gainsboro", NSVG_RGB(220, 220, 220) },
	{ "ghostwhite", NSVG_RGB(248, 248, 255) },
	{ "gold", NSVG_RGB(255, 215, 0) },
	{ "goldenrod", NSVG_RGB(218, 165, 32) },
	{ "greenyellow", NSVG_RGB(173, 255, 47) },
	{ "honeydew", NSVG_RGB(240, 255, 240) },
	{ "hotpink", NSVG_RGB(255, 105, 180) },
	{ "indianred", NSVG_RGB(205, 92, 92) },
	{ "indigo", NSVG_RGB( 75, 0, 130) },
	{ "ivory", NSVG_RGB(255, 255, 240) },
	{ "khaki", NSVG_RGB(240, 230, 140) },
	{ "lavender", NSVG_RGB(230, 230, 250) },
	{ "lavenderblush", NSVG_RGB(255, 240, 245) },
	{ "lawngreen", NSVG_RGB(124, 252, 0) },
	{ "lemonchiffon", NSVG_RGB(255, 250, 205) },
	{ "lightblue", NSVG_RGB(173, 216, 230) },
	{ "lightcoral", NSVG_RGB(240, 128, 128) },
	{ "lightcyan", NSVG_RGB(224, 255, 255) },
	{ "lightgoldenrodyellow", NSVG_RGB(250, 250, 210) },
	{ "lightgray", NSVG_RGB(211, 211, 211) },
	{ "lightgreen", NSVG_RGB(144, 238, 144) },
	{ "lightgrey", NSVG_RGB(211, 211, 211) },
	{ "lightpink", NSVG_RGB(255, 182, 193) },
	{ "lightsalmon", NSVG_RGB(255, 160, 122) },
	{ "lightseagreen", NSVG_RGB( 32, 178, 170) },
	{ "lightskyblue", NSVG_RGB(135, 206, 250) },
	{ "lightslategray", NSVG_RGB(119, 136, 153) },
	{ "lightslategrey", NSVG_RGB(119, 136, 153) },
	{ "lightsteelblue", NSVG_RGB(176, 196, 222) },
	{ "lightyellow", NSVG_RGB(255, 255, 224) },
	{ "lime", NSVG_RGB( 0, 255, 0) },
	{ "limegreen", NSVG_RGB( 50, 205, 50) },
	{ "linen", NSVG_RGB(250, 240, 230) },
	{ "maroon", NSVG_RGB(128, 0, 0) },
	{ "mediumaquamarine", NSVG_RGB(102, 205, 170) },
	{ "mediumblue", NSVG_RGB( 0, 0, 205) },
	{ "mediumorchid", NSVG_RGB(186, 85, 211) },
	{ "mediumpurple", NSVG_RGB(147, 112, 219) },
	{ "mediumseagreen", NSVG_RGB( 60, 179, 113) },
	{ "mediumslateblue", NSVG_RGB(123, 104, 238) },
	{ "mediumspringgreen", NSVG_RGB( 0, 250, 154) },
	{ "mediumturquoise", NSVG_RGB( 72, 209, 204) },
	{ "mediumvioletred", NSVG_RGB(199, 21, 133) },
	{ "midnightblue", NSVG_RGB( 25, 25, 112) },
	{ "mintcream", NSVG_RGB(245, 255, 250) },
	{ "mistyrose", NSVG_RGB(255, 228, 225) },
	{ "moccasin", NSVG_RGB(255, 228, 181) },
	{ "navajowhite", NSVG_RGB(255, 222, 173) },
	{ "navy", NSVG_RGB( 0, 0, 128) },
	{ "oldlace", NSVG_RGB(253, 245, 230) },
	{ "olive", NSVG_RGB(128, 128, 0) },
	{ "olivedrab", NSVG_RGB(107, 142, 35) },
	{ "orange", NSVG_RGB(255, 165, 0) },
	{ "orangered", NSVG_RGB(255, 69, 0) },
	{ "orchid", NSVG_RGB(218, 112, 214) },
	{ "palegoldenrod", NSVG_RGB(238, 232, 170) },
	{ "palegreen", NSVG_RGB(152, 251, 152) },
	{ "paleturquoise", NSVG_RGB(175, 238, 238) },
	{ "palevioletred", NSVG_RGB(219, 112, 147) },
	{ "papayawhip", NSVG_RGB(255, 239, 213) },
	{ "peachpuff", NSVG_RGB(255, 218, 185) },
	{ "peru", NSVG_RGB(205, 133, 63) },
	{ "pink", NSVG_RGB(255, 192, 203) },
	{ "plum", NSVG_RGB(221, 160, 221) },
	{ "powderblue", NSVG_RGB(176, 224, 230) },
	{ "purple", NSVG_RGB(128, 0, 128) },
	{ "rosybrown", NSVG_RGB(188, 143, 143) },
	{ "royalblue", NSVG_RGB( 65, 105, 225) },
	{ "saddlebrown", NSVG_RGB(139, 69, 19) },
	{ "salmon", NSVG_RGB(250, 128, 114) },
	{ "sandybrown", NSVG_RGB(244, 164, 96) },
	{ "seagreen", NSVG_RGB( 46, 139, 87) },
	{ "seashell", NSVG_RGB(255, 245, 238) },
	{ "sienna", NSVG_RGB(160, 82, 45) },
	{ "silver", NSVG_RGB(192, 192, 192) },
	{ "skyblue", NSVG_RGB(135, 206, 235) },
	{ "slateblue", NSVG_RGB(106, 90, 205) },
	{ "slategray", NSVG_RGB(112, 128, 144) },
	{ "slategrey", NSVG_RGB(112, 128, 144) },
	{ "snow", NSVG_RGB(255, 250, 250) },
	{ "springgreen", NSVG_RGB( 0, 255, 127) },
	{ "steelblue", NSVG_RGB( 70, 130, 180) },
	{ "tan", NSVG_RGB(210, 180, 140) },
	{ "teal", NSVG_RGB( 0, 128, 128) },
	{ "thistle", NSVG_RGB(216, 191, 216) },
	{ "tomato", NSVG_RGB(255, 99, 71) },
	{ "turquoise", NSVG_RGB( 64, 224, 208) },
	{ "violet", NSVG_RGB(238, 130, 238) },
	{ "wheat", NSVG_RGB(245, 222, 179) },
	{ "whitesmoke", NSVG_RGB(245, 245, 245) },
	{ "yellowgreen", NSVG_RGB(154, 205, 50) },
#endif
};

static unsigned int nsvg__parseColorName(const char* str)
{
	int i, ncolors = sizeof(nsvg__colors) / sizeof(NSVGNamedColor);

	for (i = 0; i < ncolors; i++) {
		if (strcmp(nsvg__colors[i].name, str) == 0) {
			return nsvg__colors[i].color;
		}
	}

	return NSVG_RGB(128, 128, 128);
}

static unsigned int nsvg__parseColor(const char* str)
{
	size_t len = 0;
	while(*str == ' ') ++str;
	len = strlen(str);
	if (len >= 1 && *str == '#')
		return nsvg__parseColorHex(str);
	else if (len >= 4 && str[0] == 'r' && str[1] == 'g' && str[2] == 'b' && str[3] == '(')
		return nsvg__parseColorRGB(str);
	return nsvg__parseColorName(str);
}

static float nsvg__parseOpacity(const char* str)
{
	float val = 0;
	sscanf(str, "%f", &val);
	if (val < 0.0f) val = 0.0f;
	if (val > 1.0f) val = 1.0f;
	return val;
}

static int nsvg__parseUnits(const char* units)
{
	if (units[0] == 'p' && units[1] == 'x')
		return NSVG_UNITS_PX;
	else if (units[0] == 'p' && units[1] == 't')
		return NSVG_UNITS_PT;
	else if (units[0] == 'p' && units[1] == 'c')
		return NSVG_UNITS_PC;
	else if (units[0] == 'm' && units[1] == 'm')
		return NSVG_UNITS_MM;
	else if (units[0] == 'c' && units[1] == 'm')
		return NSVG_UNITS_CM;
	else if (units[0] == 'i' && units[1] == 'n')
		return NSVG_UNITS_IN;
	else if (units[0] == '%')
		return NSVG_UNITS_PERCENT;
	else if (units[0] == 'e' && units[1] == 'm')
		return NSVG_UNITS_EM;
	else if (units[0] == 'e' && units[1] == 'x')
		return NSVG_UNITS_EX;
	return NSVG_UNITS_USER;
}

static NSVGcoordinate nsvg__parseCoordinateRaw(const char* str)
{
	NSVGcoordinate coord = {0, NSVG_UNITS_USER};
	char units[32]="";
	sscanf(str, "%f%s", &coord.value, units);
	coord.units = nsvg__parseUnits(units);
	return coord;
}

static NSVGcoordinate nsvg__coord(float v, int units)
{
	NSVGcoordinate coord = {v, units};
	return coord;
}

static float nsvg__parseCoordinate(NSVGparser* p, const char* str, float orig, float length)
{
	NSVGcoordinate coord = nsvg__parseCoordinateRaw(str);
	return nsvg__convertToPixels(p, coord, orig, length);
}

static int nsvg__parseTransformArgs(const char* str, float* args, int maxNa, int* na)
{
	const char* end;
	const char* ptr;
	char it[64];

	*na = 0;
	ptr = str;
	while (*ptr && *ptr != '(') ++ptr;
	if (*ptr == 0)
		return 1;
	end = ptr;
	while (*end && *end != ')') ++end;
	if (*end == 0)
		return 1;

	while (ptr < end) {
		if (*ptr == '-' || *ptr == '+' || *ptr == '.' || nsvg__isdigit(*ptr)) {
			if (*na >= maxNa) return 0;
			ptr = nsvg__parseNumber(ptr, it, 64);
			args[(*na)++] = (float)atof(it);
		} else {
			++ptr;
		}
	}
	return (int)(end - str);
}

static int nsvg__parseMatrix(float* xform, const char* str)
{
	float t[6];
	int na = 0;
	int len = nsvg__parseTransformArgs(str, t, 6, &na);
	if (na != 6) return len;
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseTranslate(float* xform, const char* str)
{
	float args[2];
	float t[6];
	int na = 0;
	int len = nsvg__parseTransformArgs(str, args, 2, &na);
	if (na == 1) args[1] = 0.0;

	nsvg__xformSetTranslation(t, args[0], args[1]);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseScale(float* xform, const char* str)
{
	float args[2];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 2, &na);
	if (na == 1) args[1] = args[0];
	nsvg__xformSetScale(t, args[0], args[1]);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseSkewX(float* xform, const char* str)
{
	float args[1];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 1, &na);
	nsvg__xformSetSkewX(t, args[0]/180.0f*NSVG_PI);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseSkewY(float* xform, const char* str)
{
	float args[1];
	int na = 0;
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 1, &na);
	nsvg__xformSetSkewY(t, args[0]/180.0f*NSVG_PI);
	memcpy(xform, t, sizeof(float)*6);
	return len;
}

static int nsvg__parseRotate(float* xform, const char* str)
{
	float args[3];
	int na = 0;
	float m[6];
	float t[6];
	int len = nsvg__parseTransformArgs(str, args, 3, &na);
	if (na == 1)
		args[1] = args[2] = 0.0f;
	nsvg__xformIdentity(m);

	if (na > 1) {
		nsvg__xformSetTranslation(t, -args[1], -args[2]);
		nsvg__xformMultiply(m, t);
	}

	nsvg__xformSetRotation(t, args[0]/180.0f*NSVG_PI);
	nsvg__xformMultiply(m, t);

	if (na > 1) {
		nsvg__xformSetTranslation(t, args[1], args[2]);
		nsvg__xformMultiply(m, t);
	}

	memcpy(xform, m, sizeof(float)*6);

	return len;
}

static void nsvg__parseTransform(float* xform, const char* str)
{
	float t[6];
	nsvg__xformIdentity(xform);
	while (*str)
	{
		if (strncmp(str, "matrix", 6) == 0)
			str += nsvg__parseMatrix(t, str);
		else if (strncmp(str, "translate", 9) == 0)
			str += nsvg__parseTranslate(t, str);
		else if (strncmp(str, "scale", 5) == 0)
			str += nsvg__parseScale(t, str);
		else if (strncmp(str, "rotate", 6) == 0)
			str += nsvg__parseRotate(t, str);
		else if (strncmp(str, "skewX", 5) == 0)
			str += nsvg__parseSkewX(t, str);
		else if (strncmp(str, "skewY", 5) == 0)
			str += nsvg__parseSkewY(t, str);
		else{
			++str;
			continue;
		}

		nsvg__xformPremultiply(xform, t);
	}
}

static void nsvg__parseUrl(char* id, const char* str)
{
	int i = 0;
	str += 4; // "url(";
	if (*str == '#')
		str++;
	while (i < 63 && *str != ')') {
		id[i] = *str++;
		i++;
	}
	id[i] = '\0';
}

static char nsvg__parseLineCap(const char* str)
{
	if (strcmp(str, "butt") == 0)
		return NSVG_CAP_BUTT;
	else if (strcmp(str, "round") == 0)
		return NSVG_CAP_ROUND;
	else if (strcmp(str, "square") == 0)
		return NSVG_CAP_SQUARE;
	// TODO: handle inherit.
	return NSVG_CAP_BUTT;
}

static char nsvg__parseLineJoin(const char* str)
{
	if (strcmp(str, "miter") == 0)
		return NSVG_JOIN_MITER;
	else if (strcmp(str, "round") == 0)
		return NSVG_JOIN_ROUND;
	else if (strcmp(str, "bevel") == 0)
		return NSVG_JOIN_BEVEL;
	// TODO: handle inherit.
	return NSVG_CAP_BUTT;
}

static char nsvg__parseFillRule(const char* str)
{
	if (strcmp(str, "nonzero") == 0)
		return NSVG_FILLRULE_NONZERO;
	else if (strcmp(str, "evenodd") == 0)
		return NSVG_FILLRULE_EVENODD;
	// TODO: handle inherit.
	return NSVG_FILLRULE_NONZERO;
}

static const char* nsvg__getNextDashItem(const char* s, char* it)
{
	int n = 0;
	it[0] = '\0';
	// Skip white spaces and commas
	while (*s && (nsvg__isspace(*s) || *s == ',')) s++;
	// Advance until whitespace, comma or end.
	while (*s && (!nsvg__isspace(*s) && *s != ',')) {
		if (n < 63)
			it[n++] = *s;
		s++;
	}
	it[n++] = '\0';
	return s;
}

static int nsvg__parseStrokeDashArray(NSVGparser* p, const char* str, float* strokeDashArray)
{
	char item[64];
	int count = 0, i;
	float sum = 0.0f;

	// Handle "none"
	if (str[0] == 'n')
		return 0;

	// Parse dashes
	while (*str) {
		str = nsvg__getNextDashItem(str, item);
		if (!*item) break;
		if (count < NSVG_MAX_DASHES)
			strokeDashArray[count++] = fabsf(nsvg__parseCoordinate(p, item, 0.0f, nsvg__actualLength(p)));
	}

	for (i = 0; i < count; i++)
		sum += strokeDashArray[i];
	if (sum <= 1e-6f)
		count = 0;

	return count;
}

static void nsvg__parseStyle(NSVGparser* p, const char* str);

static int nsvg__parseAttr(NSVGparser* p, const char* name, const char* value)
{
	float xform[6];
	NSVGattrib* attr = nsvg__getAttr(p);
	if (!attr) return 0;

	if (strcmp(name, "style") == 0) {
		nsvg__parseStyle(p, value);
	} else if (strcmp(name, "display") == 0) {
		if (strcmp(value, "none") == 0)
			attr->visible = 0;
		// Don't reset ->visible on display:inline, one display:none hides the whole subtree

	} else if (strcmp(name, "fill") == 0) {
		if (strcmp(value, "none") == 0) {
			attr->hasFill = 0;
		} else if (strncmp(value, "url(", 4) == 0) {
			attr->hasFill = 2;
			nsvg__parseUrl(attr->fillGradient, value);
		} else {
			attr->hasFill = 1;
			attr->fillColor = nsvg__parseColor(value);
		}
	} else if (strcmp(name, "opacity") == 0) {
		attr->opacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "fill-opacity") == 0) {
		attr->fillOpacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "stroke") == 0) {
		if (strcmp(value, "none") == 0) {
			attr->hasStroke = 0;
		} else if (strncmp(value, "url(", 4) == 0) {
			attr->hasStroke = 2;
			nsvg__parseUrl(attr->strokeGradient, value);
		} else {
			attr->hasStroke = 1;
			attr->strokeColor = nsvg__parseColor(value);
		}
	} else if (strcmp(name, "stroke-width") == 0) {
		attr->strokeWidth = nsvg__parseCoordinate(p, value, 0.0f, nsvg__actualLength(p));
	} else if (strcmp(name, "stroke-dasharray") == 0) {
		attr->strokeDashCount = nsvg__parseStrokeDashArray(p, value, attr->strokeDashArray);
	} else if (strcmp(name, "stroke-dashoffset") == 0) {
		attr->strokeDashOffset = nsvg__parseCoordinate(p, value, 0.0f, nsvg__actualLength(p));
	} else if (strcmp(name, "stroke-opacity") == 0) {
		attr->strokeOpacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "stroke-linecap") == 0) {
		attr->strokeLineCap = nsvg__parseLineCap(value);
	} else if (strcmp(name, "stroke-linejoin") == 0) {
		attr->strokeLineJoin = nsvg__parseLineJoin(value);
	} else if (strcmp(name, "fill-rule") == 0) {
		attr->fillRule = nsvg__parseFillRule(value);
	} else if (strcmp(name, "font-size") == 0) {
		attr->fontSize = nsvg__parseCoordinate(p, value, 0.0f, nsvg__actualLength(p));
	} else if (strcmp(name, "transform") == 0) {
		nsvg__parseTransform(xform, value);
		nsvg__xformPremultiply(attr->xform, xform);
	} else if (strcmp(name, "stop-color") == 0) {
		attr->stopColor = nsvg__parseColor(value);
	} else if (strcmp(name, "stop-opacity") == 0) {
		attr->stopOpacity = nsvg__parseOpacity(value);
	} else if (strcmp(name, "offset") == 0) {
		attr->stopOffset = nsvg__parseCoordinate(p, value, 0.0f, 1.0f);
	} else if (strcmp(name, "id") == 0) {
		strncpy(attr->id, value, 63);
		attr->id[63] = '\0';
	} else {
		return 0;
	}
	return 1;
}

static int nsvg__parseNameValue(NSVGparser* p, const char* start, const char* end)
{
	const char* str;
	const char* val;
	char name[512];
	char value[512];
	int n;

	str = start;
	while (str < end && *str != ':') ++str;

	val = str;

	// Right Trim
	while (str > start &&  (*str == ':' || nsvg__isspace(*str))) --str;
	++str;

	n = (int)(str - start);
	if (n > 511) n = 511;
	if (n) memcpy(name, start, n);
	name[n] = 0;

	while (val < end && (*val == ':' || nsvg__isspace(*val))) ++val;

	n = (int)(end - val);
	if (n > 511) n = 511;
	if (n) memcpy(value, val, n);
	value[n] = 0;

	return nsvg__parseAttr(p, name, value);
}

static void nsvg__parseStyle(NSVGparser* p, const char* str)
{
	const char* start;
	const char* end;

	while (*str) {
		// Left Trim
		while(*str && nsvg__isspace(*str)) ++str;
		start = str;
		while(*str && *str != ';') ++str;
		end = str;

		// Right Trim
		while (end > start &&  (*end == ';' || nsvg__isspace(*end))) --end;
		++end;

		nsvg__parseNameValue(p, start, end);
		if (*str) ++str;
	}
}

static void nsvg__parseAttribs(NSVGparser* p, const char** attr)
{
	int i;
	for (i = 0; attr[i]; i += 2)
	{
		if (strcmp(attr[i], "style") == 0)
			nsvg__parseStyle(p, attr[i + 1]);
		else
			nsvg__parseAttr(p, attr[i], attr[i + 1]);
	}
}

static int nsvg__getArgsPerElement(char cmd)
{
	switch (cmd) {
		case 'v':
		case 'V':
		case 'h':
		case 'H':
			return 1;
		case 'm':
		case 'M':
		case 'l':
		case 'L':
		case 't':
		case 'T':
			return 2;
		case 'q':
		case 'Q':
		case 's':
		case 'S':
			return 4;
		case 'c':
		case 'C':
			return 6;
		case 'a':
		case 'A':
			return 7;
	}
	return 0;
}

static void nsvg__pathMoveTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel) {
		*cpx += args[0];
		*cpy += args[1];
	} else {
		*cpx = args[0];
		*cpy = args[1];
	}
	nsvg__moveTo(p, *cpx, *cpy);
}

static void nsvg__pathLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel) {
		*cpx += args[0];
		*cpy += args[1];
	} else {
		*cpx = args[0];
		*cpy = args[1];
	}
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathHLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel)
		*cpx += args[0];
	else
		*cpx = args[0];
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathVLineTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	if (rel)
		*cpy += args[0];
	else
		*cpy = args[0];
	nsvg__lineTo(p, *cpx, *cpy);
}

static void nsvg__pathCubicBezTo(NSVGparser* p, float* cpx, float* cpy,
								 float* cpx2, float* cpy2, float* args, int rel)
{
	float x2, y2, cx1, cy1, cx2, cy2;

	if (rel) {
		cx1 = *cpx + args[0];
		cy1 = *cpy + args[1];
		cx2 = *cpx + args[2];
		cy2 = *cpy + args[3];
		x2 = *cpx + args[4];
		y2 = *cpy + args[5];
	} else {
		cx1 = args[0];
		cy1 = args[1];
		cx2 = args[2];
		cy2 = args[3];
		x2 = args[4];
		y2 = args[5];
	}

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx2;
	*cpy2 = cy2;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathCubicBezShortTo(NSVGparser* p, float* cpx, float* cpy,
									  float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		cx2 = *cpx + args[0];
		cy2 = *cpy + args[1];
		x2 = *cpx + args[2];
		y2 = *cpy + args[3];
	} else {
		cx2 = args[0];
		cy2 = args[1];
		x2 = args[2];
		y2 = args[3];
	}

	cx1 = 2*x1 - *cpx2;
	cy1 = 2*y1 - *cpy2;

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx2;
	*cpy2 = cy2;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathQuadBezTo(NSVGparser* p, float* cpx, float* cpy,
								float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx, cy;
	float cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		cx = *cpx + args[0];
		cy = *cpy + args[1];
		x2 = *cpx + args[2];
		y2 = *cpy + args[3];
	} else {
		cx = args[0];
		cy = args[1];
		x2 = args[2];
		y2 = args[3];
	}

	// Convert to cubic bezier
	cx1 = x1 + 2.0f/3.0f*(cx - x1);
	cy1 = y1 + 2.0f/3.0f*(cy - y1);
	cx2 = x2 + 2.0f/3.0f*(cx - x2);
	cy2 = y2 + 2.0f/3.0f*(cy - y2);

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx;
	*cpy2 = cy;
	*cpx = x2;
	*cpy = y2;
}

static void nsvg__pathQuadBezShortTo(NSVGparser* p, float* cpx, float* cpy,
									 float* cpx2, float* cpy2, float* args, int rel)
{
	float x1, y1, x2, y2, cx, cy;
	float cx1, cy1, cx2, cy2;

	x1 = *cpx;
	y1 = *cpy;
	if (rel) {
		x2 = *cpx + args[0];
		y2 = *cpy + args[1];
	} else {
		x2 = args[0];
		y2 = args[1];
	}

	cx = 2*x1 - *cpx2;
	cy = 2*y1 - *cpy2;

	// Convert to cubix bezier
	cx1 = x1 + 2.0f/3.0f*(cx - x1);
	cy1 = y1 + 2.0f/3.0f*(cy - y1);
	cx2 = x2 + 2.0f/3.0f*(cx - x2);
	cy2 = y2 + 2.0f/3.0f*(cy - y2);

	nsvg__cubicBezTo(p, cx1,cy1, cx2,cy2, x2,y2);

	*cpx2 = cx;
	*cpy2 = cy;
	*cpx = x2;
	*cpy = y2;
}

static float nsvg__sqr(float x) { return x*x; }
static float nsvg__vmag(float x, float y) { return sqrtf(x*x + y*y); }

static float nsvg__vecrat(float ux, float uy, float vx, float vy)
{
	return (ux*vx + uy*vy) / (nsvg__vmag(ux,uy) * nsvg__vmag(vx,vy));
}

static float nsvg__vecang(float ux, float uy, float vx, float vy)
{
	float r = nsvg__vecrat(ux,uy, vx,vy);
	if (r < -1.0f) r = -1.0f;
	if (r > 1.0f) r = 1.0f;
	return ((ux*vy < uy*vx) ? -1.0f : 1.0f) * acosf(r);
}

static void nsvg__pathArcTo(NSVGparser* p, float* cpx, float* cpy, float* args, int rel)
{
	// Ported from canvg (https://code.google.com/p/canvg/)
	float rx, ry, rotx;
	float x1, y1, x2, y2, cx, cy, dx, dy, d;
	float x1p, y1p, cxp, cyp, s, sa, sb;
	float ux, uy, vx, vy, a1, da;
	float x, y, tanx, tany, a, px = 0, py = 0, ptanx = 0, ptany = 0, t[6];
	float sinrx, cosrx;
	int fa, fs;
	int i, ndivs;
	float hda, kappa;

	rx = fabsf(args[0]);				// y radius
	ry = fabsf(args[1]);				// x radius
	rotx = args[2] / 180.0f * NSVG_PI;		// x rotation engle
	fa = fabsf(args[3]) > 1e-6 ? 1 : 0;	// Large arc
	fs = fabsf(args[4]) > 1e-6 ? 1 : 0;	// Sweep direction
	x1 = *cpx;							// start point
	y1 = *cpy;
	if (rel) {							// end point
		x2 = *cpx + args[5];
		y2 = *cpy + args[6];
	} else {
		x2 = args[5];
		y2 = args[6];
	}

	dx = x1 - x2;
	dy = y1 - y2;
	d = sqrtf(dx*dx + dy*dy);
	if (d < 1e-6f || rx < 1e-6f || ry < 1e-6f) {
		// The arc degenerates to a line
		nsvg__lineTo(p, x2, y2);
		*cpx = x2;
		*cpy = y2;
		return;
	}

	sinrx = sinf(rotx);
	cosrx = cosf(rotx);

	// Convert to center point parameterization.
	// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	// 1) Compute x1', y1'
	x1p = cosrx * dx / 2.0f + sinrx * dy / 2.0f;
	y1p = -sinrx * dx / 2.0f + cosrx * dy / 2.0f;
	d = nsvg__sqr(x1p)/nsvg__sqr(rx) + nsvg__sqr(y1p)/nsvg__sqr(ry);
	if (d > 1) {
		d = sqrtf(d);
		rx *= d;
		ry *= d;
	}
	// 2) Compute cx', cy'
	s = 0.0f;
	sa = nsvg__sqr(rx)*nsvg__sqr(ry) - nsvg__sqr(rx)*nsvg__sqr(y1p) - nsvg__sqr(ry)*nsvg__sqr(x1p);
	sb = nsvg__sqr(rx)*nsvg__sqr(y1p) + nsvg__sqr(ry)*nsvg__sqr(x1p);
	if (sa < 0.0f) sa = 0.0f;
	if (sb > 0.0f)
		s = sqrtf(sa / sb);
	if (fa == fs)
		s = -s;
	cxp = s * rx * y1p / ry;
	cyp = s * -ry * x1p / rx;

	// 3) Compute cx,cy from cx',cy'
	cx = (x1 + x2)/2.0f + cosrx*cxp - sinrx*cyp;
	cy = (y1 + y2)/2.0f + sinrx*cxp + cosrx*cyp;

	// 4) Calculate theta1, and delta theta.
	ux = (x1p - cxp) / rx;
	uy = (y1p - cyp) / ry;
	vx = (-x1p - cxp) / rx;
	vy = (-y1p - cyp) / ry;
	a1 = nsvg__vecang(1.0f,0.0f, ux,uy);	// Initial angle
	da = nsvg__vecang(ux,uy, vx,vy);		// Delta angle

//	if (vecrat(ux,uy,vx,vy) <= -1.0f) da = NSVG_PI;
//	if (vecrat(ux,uy,vx,vy) >= 1.0f) da = 0;

	if (fa) {
		// Choose large arc
		if (da > 0.0f)
			da = da - 2*NSVG_PI;
		else
			da = 2*NSVG_PI + da;
	}

	// Approximate the arc using cubic spline segments.
	t[0] = cosrx; t[1] = sinrx;
	t[2] = -sinrx; t[3] = cosrx;
	t[4] = cx; t[5] = cy;

	// Split arc into max 90 degree segments.
	// The loop assumes an iteration per end point (including start and end), this +1.
	ndivs = (int)(fabsf(da) / (NSVG_PI*0.5f) + 1.0f);
	hda = (da / (float)ndivs) / 2.0f;
	kappa = fabsf(4.0f / 3.0f * (1.0f - cosf(hda)) / sinf(hda));
	if (da < 0.0f)
		kappa = -kappa;

	for (i = 0; i <= ndivs; i++) {
		a = a1 + da * (i/(float)ndivs);
		dx = cosf(a);
		dy = sinf(a);
		nsvg__xformPoint(&x, &y, dx*rx, dy*ry, t); // position
		nsvg__xformVec(&tanx, &tany, -dy*rx * kappa, dx*ry * kappa, t); // tangent
		if (i > 0)
			nsvg__cubicBezTo(p, px+ptanx,py+ptany, x-tanx, y-tany, x, y);
		px = x;
		py = y;
		ptanx = tanx;
		ptany = tany;
	}

	*cpx = x2;
	*cpy = y2;
}

static void nsvg__parsePath(NSVGparser* p, const char** attr)
{
	const char* s = NULL;
	char cmd = '\0';
	float args[10];
	int nargs;
	int rargs = 0;
	float cpx, cpy, cpx2, cpy2;
	const char* tmp[4];
	char closedFlag;
	int i;
	char item[64];

	for (i = 0; attr[i]; i += 2) {
		if (strcmp(attr[i], "d") == 0) {
			s = attr[i + 1];
		} else {
			tmp[0] = attr[i];
			tmp[1] = attr[i + 1];
			tmp[2] = 0;
			tmp[3] = 0;
			nsvg__parseAttribs(p, tmp);
		}
	}

	if (s) {
		nsvg__resetPath(p);
		cpx = 0; cpy = 0;
		cpx2 = 0; cpy2 = 0;
		closedFlag = 0;
		nargs = 0;

		while (*s) {
			s = nsvg__getNextPathItem(s, item);
			if (!*item) break;
			if (nsvg__isnum(item[0])) {
				if (nargs < 10)
					args[nargs++] = (float)atof(item);
				if (nargs >= rargs) {
					switch (cmd) {
						case 'm':
						case 'M':
							nsvg__pathMoveTo(p, &cpx, &cpy, args, cmd == 'm' ? 1 : 0);
							// Moveto can be followed by multiple coordinate pairs,
							// which should be treated as linetos.
							cmd = (cmd == 'm') ? 'l' : 'L';
							rargs = nsvg__getArgsPerElement(cmd);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'l':
						case 'L':
							nsvg__pathLineTo(p, &cpx, &cpy, args, cmd == 'l' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'H':
						case 'h':
							nsvg__pathHLineTo(p, &cpx, &cpy, args, cmd == 'h' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'V':
						case 'v':
							nsvg__pathVLineTo(p, &cpx, &cpy, args, cmd == 'v' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						case 'C':
						case 'c':
							nsvg__pathCubicBezTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 'c' ? 1 : 0);
							break;
						case 'S':
						case 's':
							nsvg__pathCubicBezShortTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 's' ? 1 : 0);
							break;
						case 'Q':
						case 'q':
							nsvg__pathQuadBezTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 'q' ? 1 : 0);
							break;
						case 'T':
						case 't':
							nsvg__pathQuadBezShortTo(p, &cpx, &cpy, &cpx2, &cpy2, args, cmd == 't' ? 1 : 0);
							break;
						case 'A':
						case 'a':
							nsvg__pathArcTo(p, &cpx, &cpy, args, cmd == 'a' ? 1 : 0);
							cpx2 = cpx; cpy2 = cpy;
							break;
						default:
							if (nargs >= 2) {
								cpx = args[nargs-2];
								cpy = args[nargs-1];
	                            cpx2 = cpx; cpy2 = cpy;
							}
							break;
					}
					nargs = 0;
				}
			} else {
				cmd = item[0];
				rargs = nsvg__getArgsPerElement(cmd);
				if (cmd == 'M' || cmd == 'm') {
					// Commit path.
					if (p->npts > 0)
						nsvg__addPath(p, closedFlag);
					// Start new subpath.
					nsvg__resetPath(p);
					closedFlag = 0;
					nargs = 0;
				} else if (cmd == 'Z' || cmd == 'z') {
					closedFlag = 1;
					// Commit path.
					if (p->npts > 0) {
						// Move current point to first point
						cpx = p->pts[0];
						cpy = p->pts[1];
						cpx2 = cpx; cpy2 = cpy;
						nsvg__addPath(p, closedFlag);
					}
					// Start new subpath.
					nsvg__resetPath(p);
					nsvg__moveTo(p, cpx, cpy);
					closedFlag = 0;
					nargs = 0;
				}
			}
		}
		// Commit path.
		if (p->npts)
			nsvg__addPath(p, closedFlag);
	}

	nsvg__addShape(p);
}

static void nsvg__parseRect(NSVGparser* p, const char** attr)
{
	float x = 0.0f;
	float y = 0.0f;
	float w = 0.0f;
	float h = 0.0f;
	float rx = -1.0f; // marks not set
	float ry = -1.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "x") == 0) x = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "y") == 0) y = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "width") == 0) w = nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualWidth(p));
			if (strcmp(attr[i], "height") == 0) h = nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualHeight(p));
			if (strcmp(attr[i], "rx") == 0) rx = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualWidth(p)));
			if (strcmp(attr[i], "ry") == 0) ry = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualHeight(p)));
		}
	}

	if (rx < 0.0f && ry > 0.0f) rx = ry;
	if (ry < 0.0f && rx > 0.0f) ry = rx;
	if (rx < 0.0f) rx = 0.0f;
	if (ry < 0.0f) ry = 0.0f;
	if (rx > w/2.0f) rx = w/2.0f;
	if (ry > h/2.0f) ry = h/2.0f;

	if (w != 0.0f && h != 0.0f) {
		nsvg__resetPath(p);

		if (rx < 0.00001f || ry < 0.0001f) {
			nsvg__moveTo(p, x, y);
			nsvg__lineTo(p, x+w, y);
			nsvg__lineTo(p, x+w, y+h);
			nsvg__lineTo(p, x, y+h);
		} else {
			// Rounded rectangle
			nsvg__moveTo(p, x+rx, y);
			nsvg__lineTo(p, x+w-rx, y);
			nsvg__cubicBezTo(p, x+w-rx*(1-NSVG_KAPPA90), y, x+w, y+ry*(1-NSVG_KAPPA90), x+w, y+ry);
			nsvg__lineTo(p, x+w, y+h-ry);
			nsvg__cubicBezTo(p, x+w, y+h-ry*(1-NSVG_KAPPA90), x+w-rx*(1-NSVG_KAPPA90), y+h, x+w-rx, y+h);
			nsvg__lineTo(p, x+rx, y+h);
			nsvg__cubicBezTo(p, x+rx*(1-NSVG_KAPPA90), y+h, x, y+h-ry*(1-NSVG_KAPPA90), x, y+h-ry);
			nsvg__lineTo(p, x, y+ry);
			nsvg__cubicBezTo(p, x, y+ry*(1-NSVG_KAPPA90), x+rx*(1-NSVG_KAPPA90), y, x+rx, y);
		}

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseCircle(NSVGparser* p, const char** attr)
{
	float cx = 0.0f;
	float cy = 0.0f;
	float r = 0.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "cx") == 0) cx = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "cy") == 0) cy = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "r") == 0) r = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualLength(p)));
		}
	}

	if (r > 0.0f) {
		nsvg__resetPath(p);

		nsvg__moveTo(p, cx+r, cy);
		nsvg__cubicBezTo(p, cx+r, cy+r*NSVG_KAPPA90, cx+r*NSVG_KAPPA90, cy+r, cx, cy+r);
		nsvg__cubicBezTo(p, cx-r*NSVG_KAPPA90, cy+r, cx-r, cy+r*NSVG_KAPPA90, cx-r, cy);
		nsvg__cubicBezTo(p, cx-r, cy-r*NSVG_KAPPA90, cx-r*NSVG_KAPPA90, cy-r, cx, cy-r);
		nsvg__cubicBezTo(p, cx+r*NSVG_KAPPA90, cy-r, cx+r, cy-r*NSVG_KAPPA90, cx+r, cy);

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseEllipse(NSVGparser* p, const char** attr)
{
	float cx = 0.0f;
	float cy = 0.0f;
	float rx = 0.0f;
	float ry = 0.0f;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "cx") == 0) cx = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "cy") == 0) cy = nsvg__parseCoordinate(p, attr[i+1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "rx") == 0) rx = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualWidth(p)));
			if (strcmp(attr[i], "ry") == 0) ry = fabsf(nsvg__parseCoordinate(p, attr[i+1], 0.0f, nsvg__actualHeight(p)));
		}
	}

	if (rx > 0.0f && ry > 0.0f) {

		nsvg__resetPath(p);

		nsvg__moveTo(p, cx+rx, cy);
		nsvg__cubicBezTo(p, cx+rx, cy+ry*NSVG_KAPPA90, cx+rx*NSVG_KAPPA90, cy+ry, cx, cy+ry);
		nsvg__cubicBezTo(p, cx-rx*NSVG_KAPPA90, cy+ry, cx-rx, cy+ry*NSVG_KAPPA90, cx-rx, cy);
		nsvg__cubicBezTo(p, cx-rx, cy-ry*NSVG_KAPPA90, cx-rx*NSVG_KAPPA90, cy-ry, cx, cy-ry);
		nsvg__cubicBezTo(p, cx+rx*NSVG_KAPPA90, cy-ry, cx+rx, cy-ry*NSVG_KAPPA90, cx+rx, cy);

		nsvg__addPath(p, 1);

		nsvg__addShape(p);
	}
}

static void nsvg__parseLine(NSVGparser* p, const char** attr)
{
	float x1 = 0.0;
	float y1 = 0.0;
	float x2 = 0.0;
	float y2 = 0.0;
	int i;

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "x1") == 0) x1 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "y1") == 0) y1 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
			if (strcmp(attr[i], "x2") == 0) x2 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigX(p), nsvg__actualWidth(p));
			if (strcmp(attr[i], "y2") == 0) y2 = nsvg__parseCoordinate(p, attr[i + 1], nsvg__actualOrigY(p), nsvg__actualHeight(p));
		}
	}

	nsvg__resetPath(p);

	nsvg__moveTo(p, x1, y1);
	nsvg__lineTo(p, x2, y2);

	nsvg__addPath(p, 0);

	nsvg__addShape(p);
}

static void nsvg__parsePoly(NSVGparser* p, const char** attr, int closeFlag)
{
	int i;
	const char* s;
	float args[2];
	int nargs, npts = 0;
	char item[64];

	nsvg__resetPath(p);

	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "points") == 0) {
				s = attr[i + 1];
				nargs = 0;
				while (*s) {
					s = nsvg__getNextPathItem(s, item);
					args[nargs++] = (float)atof(item);
					if (nargs >= 2) {
						if (npts == 0)
							nsvg__moveTo(p, args[0], args[1]);
						else
							nsvg__lineTo(p, args[0], args[1]);
						nargs = 0;
						npts++;
					}
				}
			}
		}
	}

	nsvg__addPath(p, (char)closeFlag);

	nsvg__addShape(p);
}

static void nsvg__parseSVG(NSVGparser* p, const char** attr)
{
	int i;
	for (i = 0; attr[i]; i += 2) {
		if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "width") == 0) {
				p->image->width = nsvg__parseCoordinate(p, attr[i + 1], 0.0f, 1.0f);
			} else if (strcmp(attr[i], "height") == 0) {
				p->image->height = nsvg__parseCoordinate(p, attr[i + 1], 0.0f, 1.0f);
			} else if (strcmp(attr[i], "viewBox") == 0) {
				sscanf(attr[i + 1], "%f%*[%%, \t]%f%*[%%, \t]%f%*[%%, \t]%f", &p->viewMinx, &p->viewMiny, &p->viewWidth, &p->viewHeight);
			} else if (strcmp(attr[i], "preserveAspectRatio") == 0) {
				if (strstr(attr[i + 1], "none") != 0) {
					// No uniform scaling
					p->alignType = NSVG_ALIGN_NONE;
				} else {
					// Parse X align
					if (strstr(attr[i + 1], "xMin") != 0)
						p->alignX = NSVG_ALIGN_MIN;
					else if (strstr(attr[i + 1], "xMid") != 0)
						p->alignX = NSVG_ALIGN_MID;
					else if (strstr(attr[i + 1], "xMax") != 0)
						p->alignX = NSVG_ALIGN_MAX;
					// Parse X align
					if (strstr(attr[i + 1], "yMin") != 0)
						p->alignY = NSVG_ALIGN_MIN;
					else if (strstr(attr[i + 1], "yMid") != 0)
						p->alignY = NSVG_ALIGN_MID;
					else if (strstr(attr[i + 1], "yMax") != 0)
						p->alignY = NSVG_ALIGN_MAX;
					// Parse meet/slice
					p->alignType = NSVG_ALIGN_MEET;
					if (strstr(attr[i + 1], "slice") != 0)
						p->alignType = NSVG_ALIGN_SLICE;
				}
			}
		}
	}
}

static void nsvg__parseGradient(NSVGparser* p, const char** attr, char type)
{
	int i;
	NSVGgradientData* grad = (NSVGgradientData*)malloc(sizeof(NSVGgradientData));
	if (grad == NULL) return;
	memset(grad, 0, sizeof(NSVGgradientData));
	grad->units = NSVG_OBJECT_SPACE;
	grad->type = type;
	if (grad->type == NSVG_PAINT_LINEAR_GRADIENT) {
		grad->linear.x1 = nsvg__coord(0.0f, NSVG_UNITS_PERCENT);
		grad->linear.y1 = nsvg__coord(0.0f, NSVG_UNITS_PERCENT);
		grad->linear.x2 = nsvg__coord(100.0f, NSVG_UNITS_PERCENT);
		grad->linear.y2 = nsvg__coord(0.0f, NSVG_UNITS_PERCENT);
	} else if (grad->type == NSVG_PAINT_RADIAL_GRADIENT) {
		grad->radial.cx = nsvg__coord(50.0f, NSVG_UNITS_PERCENT);
		grad->radial.cy = nsvg__coord(50.0f, NSVG_UNITS_PERCENT);
		grad->radial.r = nsvg__coord(50.0f, NSVG_UNITS_PERCENT);
	}

	nsvg__xformIdentity(grad->xform);

	for (i = 0; attr[i]; i += 2) {
		if (strcmp(attr[i], "id") == 0) {
			strncpy(grad->id, attr[i+1], 63);
			grad->id[63] = '\0';
		} else if (!nsvg__parseAttr(p, attr[i], attr[i + 1])) {
			if (strcmp(attr[i], "gradientUnits") == 0) {
				if (strcmp(attr[i+1], "objectBoundingBox") == 0)
					grad->units = NSVG_OBJECT_SPACE;
				else
					grad->units = NSVG_USER_SPACE;
			} else if (strcmp(attr[i], "gradientTransform") == 0) {
				nsvg__parseTransform(grad->xform, attr[i + 1]);
			} else if (strcmp(attr[i], "cx") == 0) {
				grad->radial.cx = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "cy") == 0) {
				grad->radial.cy = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "r") == 0) {
				grad->radial.r = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "fx") == 0) {
				grad->radial.fx = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "fy") == 0) {
				grad->radial.fy = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "x1") == 0) {
				grad->linear.x1 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "y1") == 0) {
				grad->linear.y1 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "x2") == 0) {
				grad->linear.x2 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "y2") == 0) {
				grad->linear.y2 = nsvg__parseCoordinateRaw(attr[i + 1]);
			} else if (strcmp(attr[i], "spreadMethod") == 0) {
				if (strcmp(attr[i+1], "pad") == 0)
					grad->spread = NSVG_SPREAD_PAD;
				else if (strcmp(attr[i+1], "reflect") == 0)
					grad->spread = NSVG_SPREAD_REFLECT;
				else if (strcmp(attr[i+1], "repeat") == 0)
					grad->spread = NSVG_SPREAD_REPEAT;
			} else if (strcmp(attr[i], "xlink:href") == 0) {
				const char *href = attr[i+1];
				strncpy(grad->ref, href+1, 62);
				grad->ref[62] = '\0';
			}
		}
	}

	grad->next = p->gradients;
	p->gradients = grad;
}

static void nsvg__parseGradientStop(NSVGparser* p, const char** attr)
{
	NSVGattrib* curAttr = nsvg__getAttr(p);
	NSVGgradientData* grad;
	NSVGgradientStop* stop;
	int i, idx;

	curAttr->stopOffset = 0;
	curAttr->stopColor = 0;
	curAttr->stopOpacity = 1.0f;

	for (i = 0; attr[i]; i += 2) {
		nsvg__parseAttr(p, attr[i], attr[i + 1]);
	}

	// Add stop to the last gradient.
	grad = p->gradients;
	if (grad == NULL) return;

	grad->nstops++;
	grad->stops = (NSVGgradientStop*)realloc(grad->stops, sizeof(NSVGgradientStop)*grad->nstops);
	if (grad->stops == NULL) return;

	// Insert
	idx = grad->nstops-1;
	for (i = 0; i < grad->nstops-1; i++) {
		if (curAttr->stopOffset < grad->stops[i].offset) {
			idx = i;
			break;
		}
	}
	if (idx != grad->nstops-1) {
		for (i = grad->nstops-1; i > idx; i--)
			grad->stops[i] = grad->stops[i-1];
	}

	stop = &grad->stops[idx];
	stop->color = curAttr->stopColor;
	stop->color |= (unsigned int)(curAttr->stopOpacity*255) << 24;
	stop->offset = curAttr->stopOffset;
}

static void nsvg__startElement(void* ud, const char* el, const char** attr)
{
	NSVGparser* p = (NSVGparser*)ud;

	if (p->defsFlag) {
		// Skip everything but gradients in defs
		if (strcmp(el, "linearGradient") == 0) {
			nsvg__parseGradient(p, attr, NSVG_PAINT_LINEAR_GRADIENT);
		} else if (strcmp(el, "radialGradient") == 0) {
			nsvg__parseGradient(p, attr, NSVG_PAINT_RADIAL_GRADIENT);
		} else if (strcmp(el, "stop") == 0) {
			nsvg__parseGradientStop(p, attr);
		}
		return;
	}

	if (strcmp(el, "g") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseAttribs(p, attr);
	} else if (strcmp(el, "path") == 0) {
		if (p->pathFlag)	// Do not allow nested paths.
			return;
		nsvg__pushAttr(p);
		nsvg__parsePath(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "rect") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseRect(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "circle") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseCircle(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "ellipse") == 0) {
		nsvg__pushAttr(p);
		nsvg__parseEllipse(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "line") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parseLine(p, attr);
		nsvg__popAttr(p);
	} else if (strcmp(el, "polyline") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parsePoly(p, attr, 0);
		nsvg__popAttr(p);
	} else if (strcmp(el, "polygon") == 0)  {
		nsvg__pushAttr(p);
		nsvg__parsePoly(p, attr, 1);
		nsvg__popAttr(p);
	} else  if (strcmp(el, "linearGradient") == 0) {
		nsvg__parseGradient(p, attr, NSVG_PAINT_LINEAR_GRADIENT);
	} else if (strcmp(el, "radialGradient") == 0) {
		nsvg__parseGradient(p, attr, NSVG_PAINT_RADIAL_GRADIENT);
	} else if (strcmp(el, "stop") == 0) {
		nsvg__parseGradientStop(p, attr);
	} else if (strcmp(el, "defs") == 0) {
		p->defsFlag = 1;
	} else if (strcmp(el, "svg") == 0) {
		nsvg__parseSVG(p, attr);
	}
}

static void nsvg__endElement(void* ud, const char* el)
{
	NSVGparser* p = (NSVGparser*)ud;

	if (strcmp(el, "g") == 0) {
		nsvg__popAttr(p);
	} else if (strcmp(el, "path") == 0) {
		p->pathFlag = 0;
	} else if (strcmp(el, "defs") == 0) {
		p->defsFlag = 0;
	}
}

static void nsvg__content(void* ud, const char* s)
{
	NSVG_NOTUSED(ud);
	NSVG_NOTUSED(s);
	// empty
}

static void nsvg__imageBounds(NSVGparser* p, float* bounds)
{
	NSVGshape* shape;
	shape = p->image->shapes;
	if (shape == NULL) {
		bounds[0] = bounds[1] = bounds[2] = bounds[3] = 0.0;
		return;
	}
	bounds[0] = shape->bounds[0];
	bounds[1] = shape->bounds[1];
	bounds[2] = shape->bounds[2];
	bounds[3] = shape->bounds[3];
	for (shape = shape->next; shape != NULL; shape = shape->next) {
		bounds[0] = nsvg__minf(bounds[0], shape->bounds[0]);
		bounds[1] = nsvg__minf(bounds[1], shape->bounds[1]);
		bounds[2] = nsvg__maxf(bounds[2], shape->bounds[2]);
		bounds[3] = nsvg__maxf(bounds[3], shape->bounds[3]);
	}
}

static float nsvg__viewAlign(float content, float container, int type)
{
	if (type == NSVG_ALIGN_MIN)
		return 0;
	else if (type == NSVG_ALIGN_MAX)
		return container - content;
	// mid
	return (container - content) * 0.5f;
}

static void nsvg__scaleGradient(NSVGgradient* grad, float tx, float ty, float sx, float sy)
{
	grad->xform[0] *= sx;
	grad->xform[1] *= sx;
	grad->xform[2] *= sy;
	grad->xform[3] *= sy;
	grad->xform[4] += tx*sx;
	grad->xform[5] += ty*sx;
}

static void nsvg__scaleToViewbox(NSVGparser* p, const char* units)
{
	NSVGshape* shape;
	NSVGpath* path;
	float tx, ty, sx, sy, us, bounds[4], t[6], avgs;
	int i;
	float* pt;

	// Guess image size if not set completely.
	nsvg__imageBounds(p, bounds);

	if (p->viewWidth == 0) {
		if (p->image->width > 0) {
			p->viewWidth = p->image->width;
		} else {
			p->viewMinx = bounds[0];
			p->viewWidth = bounds[2] - bounds[0];
		}
	}
	if (p->viewHeight == 0) {
		if (p->image->height > 0) {
			p->viewHeight = p->image->height;
		} else {
			p->viewMiny = bounds[1];
			p->viewHeight = bounds[3] - bounds[1];
		}
	}
	if (p->image->width == 0)
		p->image->width = p->viewWidth;
	if (p->image->height == 0)
		p->image->height = p->viewHeight;

	tx = -p->viewMinx;
	ty = -p->viewMiny;
	sx = p->viewWidth > 0 ? p->image->width / p->viewWidth : 0;
	sy = p->viewHeight > 0 ? p->image->height / p->viewHeight : 0;
	// Unit scaling
	us = 1.0f / nsvg__convertToPixels(p, nsvg__coord(1.0f, nsvg__parseUnits(units)), 0.0f, 1.0f);

	// Fix aspect ratio
	if (p->alignType == NSVG_ALIGN_MEET) {
		// fit whole image into viewbox
		sx = sy = nsvg__minf(sx, sy);
		tx += nsvg__viewAlign(p->viewWidth*sx, p->image->width, p->alignX) / sx;
		ty += nsvg__viewAlign(p->viewHeight*sy, p->image->height, p->alignY) / sy;
	} else if (p->alignType == NSVG_ALIGN_SLICE) {
		// fill whole viewbox with image
		sx = sy = nsvg__maxf(sx, sy);
		tx += nsvg__viewAlign(p->viewWidth*sx, p->image->width, p->alignX) / sx;
		ty += nsvg__viewAlign(p->viewHeight*sy, p->image->height, p->alignY) / sy;
	}

	// Transform
	sx *= us;
	sy *= us;
	avgs = (sx+sy) / 2.0f;
	for (shape = p->image->shapes; shape != NULL; shape = shape->next) {
		shape->bounds[0] = (shape->bounds[0] + tx) * sx;
		shape->bounds[1] = (shape->bounds[1] + ty) * sy;
		shape->bounds[2] = (shape->bounds[2] + tx) * sx;
		shape->bounds[3] = (shape->bounds[3] + ty) * sy;
		for (path = shape->paths; path != NULL; path = path->next) {
			path->bounds[0] = (path->bounds[0] + tx) * sx;
			path->bounds[1] = (path->bounds[1] + ty) * sy;
			path->bounds[2] = (path->bounds[2] + tx) * sx;
			path->bounds[3] = (path->bounds[3] + ty) * sy;
			for (i =0; i < path->npts; i++) {
				pt = &path->pts[i*2];
				pt[0] = (pt[0] + tx) * sx;
				pt[1] = (pt[1] + ty) * sy;
			}
		}

		if (shape->fill.type == NSVG_PAINT_LINEAR_GRADIENT || shape->fill.type == NSVG_PAINT_RADIAL_GRADIENT) {
			nsvg__scaleGradient(shape->fill.gradient, tx,ty, sx,sy);
			memcpy(t, shape->fill.gradient->xform, sizeof(float)*6);
			nsvg__xformInverse(shape->fill.gradient->xform, t);
		}
		if (shape->stroke.type == NSVG_PAINT_LINEAR_GRADIENT || shape->stroke.type == NSVG_PAINT_RADIAL_GRADIENT) {
			nsvg__scaleGradient(shape->stroke.gradient, tx,ty, sx,sy);
			memcpy(t, shape->stroke.gradient->xform, sizeof(float)*6);
			nsvg__xformInverse(shape->stroke.gradient->xform, t);
		}

		shape->strokeWidth *= avgs;
		shape->strokeDashOffset *= avgs;
		for (i = 0; i < shape->strokeDashCount; i++)
			shape->strokeDashArray[i] *= avgs;
	}
}

NSVGimage* nsvgParse(char* input, const char* units, float dpi)
{
	NSVGparser* p;
	NSVGimage* ret = 0;

	p = nsvg__createParser();
	if (p == NULL) {
		return NULL;
	}
	p->dpi = dpi;

	nsvg__parseXML(input, nsvg__startElement, nsvg__endElement, nsvg__content, p);

	// Scale to viewBox
	nsvg__scaleToViewbox(p, units);

	ret = p->image;
	p->image = NULL;

	nsvg__deleteParser(p);

	return ret;
}

NSVGimage* nsvgParseFromFile(const char* filename, const char* units, float dpi)
{
	FILE* fp = NULL;
	size_t size;
	char* data = NULL;
	NSVGimage* image = NULL;

	fp = fopen(filename, "rb");
	if (!fp) goto error;
	fseek(fp, 0, SEEK_END);
	size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	data = (char*)malloc(size+1);
	if (data == NULL) goto error;
	if (fread(data, 1, size, fp) != size) goto error;
	data[size] = '\0';	// Must be null terminated.
	fclose(fp);
	image = nsvgParse(data, units, dpi);
	free(data);

	return image;

error:
	if (fp) fclose(fp);
	if (data) free(data);
	if (image) nsvgDelete(image);
	return NULL;
}

void nsvgDelete(NSVGimage* image)
{
	NSVGshape *snext, *shape;
	if (image == NULL) return;
	shape = image->shapes;
	while (shape != NULL) {
		snext = shape->next;
		nsvg__deletePaths(shape->paths);
		nsvg__deletePaint(&shape->fill);
		nsvg__deletePaint(&shape->stroke);
		free(shape);
		shape = snext;
	}
	free(image);
}

#endif


//#line 1 "nanosvgrast.h"
#ifndef NANOSVGRAST_H
#define NANOSVGRAST_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct NSVGrasterizer NSVGrasterizer;

/* Example Usage:
	// Load SVG
	struct SNVGImage* image = nsvgParseFromFile("test.svg.");

	// Create rasterizer (can be used to render multiple images).
	struct NSVGrasterizer* rast = nsvgCreateRasterizer();
	// Allocate memory for image
	unsigned char* img = malloc(w*h*4);
	// Rasterize
	nsvgRasterize(rast, image, 0,0,1, img, w, h, w*4);
*/

// Allocated rasterizer context.
NSVGrasterizer* nsvgCreateRasterizer();

// Rasterizes SVG image, returns RGBA image (non-premultiplied alpha)
//   r - pointer to rasterizer context
//   image - pointer to image to rasterize
//   tx,ty - image offset (applied after scaling)
//   scale - image scale
//   dst - pointer to destination image data, 4 bytes per pixel (RGBA)
//   w - width of the image to render
//   h - height of the image to render
//   stride - number of bytes per scaleline in the destination buffer
void nsvgRasterize(NSVGrasterizer* r,
				   NSVGimage* image, float tx, float ty, float scale,
				   unsigned char* dst, int w, int h, int stride);

// Deletes rasterizer context.
void nsvgDeleteRasterizer(NSVGrasterizer*);

#ifdef __cplusplus
};
#endif

#endif // NANOSVGRAST_H

#ifdef NANOSVGRAST_IMPLEMENTATION

#include <math.h>

#define NSVG__SUBSAMPLES	5
#define NSVG__FIXSHIFT		10
#define NSVG__FIX			(1 << NSVG__FIXSHIFT)
#define NSVG__FIXMASK		(NSVG__FIX-1)
#define NSVG__MEMPAGE_SIZE	1024

typedef struct NSVGedge {
	float x0,y0, x1,y1;
	int dir;
	struct NSVGedge* next;
} NSVGedge;

typedef struct NSVGpoint {
	float x, y;
	float dx, dy;
	float len;
	float dmx, dmy;
	unsigned char flags;
} NSVGpoint;

typedef struct NSVGactiveEdge {
	int x,dx;
	float ey;
	int dir;
	struct NSVGactiveEdge *next;
} NSVGactiveEdge;

typedef struct NSVGmemPage {
	unsigned char mem[NSVG__MEMPAGE_SIZE];
	int size;
	struct NSVGmemPage* next;
} NSVGmemPage;

typedef struct NSVGcachedPaint {
	char type;
	char spread;
	float xform[6];
	unsigned int colors[256];
} NSVGcachedPaint;

struct NSVGrasterizer
{
	float px, py;

	float tessTol;
	float distTol;

	NSVGedge* edges;
	int nedges;
	int cedges;

	NSVGpoint* points;
	int npoints;
	int cpoints;

	NSVGpoint* points2;
	int npoints2;
	int cpoints2;

	NSVGactiveEdge* freelist;
	NSVGmemPage* pages;
	NSVGmemPage* curpage;

	unsigned char* scanline;
	int cscanline;

	unsigned char* bitmap;
	int width, height, stride;
};

NSVGrasterizer* nsvgCreateRasterizer()
{
	NSVGrasterizer* r = (NSVGrasterizer*)malloc(sizeof(NSVGrasterizer));
	if (r == NULL) goto error;
	memset(r, 0, sizeof(NSVGrasterizer));

	r->tessTol = 0.25f;
	r->distTol = 0.01f;

	return r;

error:
	nsvgDeleteRasterizer(r);
	return NULL;
}

void nsvgDeleteRasterizer(NSVGrasterizer* r)
{
	NSVGmemPage* p;

	if (r == NULL) return;

	p = r->pages;
	while (p != NULL) {
		NSVGmemPage* next = p->next;
		free(p);
		p = next;
	}

	if (r->edges) free(r->edges);
	if (r->points) free(r->points);
	if (r->points2) free(r->points2);
	if (r->scanline) free(r->scanline);

	free(r);
}

static NSVGmemPage* nsvg__nextPage(NSVGrasterizer* r, NSVGmemPage* cur)
{
	NSVGmemPage *newp;

	// If using existing chain, return the next page in chain
	if (cur != NULL && cur->next != NULL) {
		return cur->next;
	}

	// Alloc new page
	newp = (NSVGmemPage*)malloc(sizeof(NSVGmemPage));
	if (newp == NULL) return NULL;
	memset(newp, 0, sizeof(NSVGmemPage));

	// Add to linked list
	if (cur != NULL)
		cur->next = newp;
	else
		r->pages = newp;

	return newp;
}

static void nsvg__resetPool(NSVGrasterizer* r)
{
	NSVGmemPage* p = r->pages;
	while (p != NULL) {
		p->size = 0;
		p = p->next;
	}
	r->curpage = r->pages;
}

static unsigned char* nsvg__alloc(NSVGrasterizer* r, int size)
{
	unsigned char* buf;
	if (size > NSVG__MEMPAGE_SIZE) return NULL;
	if (r->curpage == NULL || r->curpage->size+size > NSVG__MEMPAGE_SIZE) {
		r->curpage = nsvg__nextPage(r, r->curpage);
	}
	buf = &r->curpage->mem[r->curpage->size];
	r->curpage->size += size;
	return buf;
}

static int nsvg__ptEquals(float x1, float y1, float x2, float y2, float tol)
{
	float dx = x2 - x1;
	float dy = y2 - y1;
	return dx*dx + dy*dy < tol*tol;
}

static void nsvg__addPathPoint(NSVGrasterizer* r, float x, float y, int flags)
{
	NSVGpoint* pt;

	if (r->npoints > 0) {
		pt = &r->points[r->npoints-1];
		if (nsvg__ptEquals(pt->x,pt->y, x,y, r->distTol)) {
			pt->flags |= flags;
			return;
		}
	}

	if (r->npoints+1 > r->cpoints) {
		r->cpoints = r->cpoints > 0 ? r->cpoints * 2 : 64;
		r->points = (NSVGpoint*)realloc(r->points, sizeof(NSVGpoint) * r->cpoints);
		if (r->points == NULL) return;
	}

	pt = &r->points[r->npoints];
	pt->x = x;
	pt->y = y;
	pt->flags = (unsigned char)flags;
	r->npoints++;
}

static void nsvg__appendPathPoint(NSVGrasterizer* r, NSVGpoint pt)
{
	if (r->npoints+1 > r->cpoints) {
		r->cpoints = r->cpoints > 0 ? r->cpoints * 2 : 64;
		r->points = (NSVGpoint*)realloc(r->points, sizeof(NSVGpoint) * r->cpoints);
		if (r->points == NULL) return;
	}
	r->points[r->npoints] = pt;
	r->npoints++;
}

static void nsvg__duplicatePoints(NSVGrasterizer* r)
{
	if (r->npoints > r->cpoints2) {
		r->cpoints2 = r->npoints;
		r->points2 = (NSVGpoint*)realloc(r->points2, sizeof(NSVGpoint) * r->cpoints2);
		if (r->points2 == NULL) return;
	}

	memcpy(r->points2, r->points, sizeof(NSVGpoint) * r->npoints);
	r->npoints2 = r->npoints;
}

static void nsvg__addEdge(NSVGrasterizer* r, float x0, float y0, float x1, float y1)
{
	NSVGedge* e;

	// Skip horizontal edges
	if (y0 == y1)
		return;

	if (r->nedges+1 > r->cedges) {
		r->cedges = r->cedges > 0 ? r->cedges * 2 : 64;
		r->edges = (NSVGedge*)realloc(r->edges, sizeof(NSVGedge) * r->cedges);
		if (r->edges == NULL) return;
	}

	e = &r->edges[r->nedges];
	r->nedges++;

	if (y0 < y1) {
		e->x0 = x0;
		e->y0 = y0;
		e->x1 = x1;
		e->y1 = y1;
		e->dir = 1;
	} else {
		e->x0 = x1;
		e->y0 = y1;
		e->x1 = x0;
		e->y1 = y0;
		e->dir = -1;
	}
}

static float nsvg__normalize(float *x, float* y)
{
	float d = sqrtf((*x)*(*x) + (*y)*(*y));
	if (d > 1e-6f) {
		float id = 1.0f / d;
		*x *= id;
		*y *= id;
	}
	return d;
}

static float nsvg__absf(float x) { return x < 0 ? -x : x; }

static void nsvg__flattenCubicBez(NSVGrasterizer* r,
								  float x1, float y1, float x2, float y2,
								  float x3, float y3, float x4, float y4,
								  int level, int type)
{
	float x12,y12,x23,y23,x34,y34,x123,y123,x234,y234,x1234,y1234;
	float dx,dy,d2,d3;

	if (level > 10) return;

	x12 = (x1+x2)*0.5f;
	y12 = (y1+y2)*0.5f;
	x23 = (x2+x3)*0.5f;
	y23 = (y2+y3)*0.5f;
	x34 = (x3+x4)*0.5f;
	y34 = (y3+y4)*0.5f;
	x123 = (x12+x23)*0.5f;
	y123 = (y12+y23)*0.5f;

	dx = x4 - x1;
	dy = y4 - y1;
	d2 = nsvg__absf(((x2 - x4) * dy - (y2 - y4) * dx));
	d3 = nsvg__absf(((x3 - x4) * dy - (y3 - y4) * dx));

	if ((d2 + d3)*(d2 + d3) < r->tessTol * (dx*dx + dy*dy)) {
		nsvg__addPathPoint(r, x4, y4, type);
		return;
	}

	x234 = (x23+x34)*0.5f;
	y234 = (y23+y34)*0.5f;
	x1234 = (x123+x234)*0.5f;
	y1234 = (y123+y234)*0.5f;

	nsvg__flattenCubicBez(r, x1,y1, x12,y12, x123,y123, x1234,y1234, level+1, 0);
	nsvg__flattenCubicBez(r, x1234,y1234, x234,y234, x34,y34, x4,y4, level+1, type);
}

static void nsvg__flattenShape(NSVGrasterizer* r, NSVGshape* shape, float scale)
{
	int i, j;
	NSVGpath* path;

	for (path = shape->paths; path != NULL; path = path->next) {
		r->npoints = 0;
		// Flatten path
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, 0);
		for (i = 0; i < path->npts-1; i += 3) {
			float* p = &path->pts[i*2];
			nsvg__flattenCubicBez(r, p[0]*scale,p[1]*scale, p[2]*scale,p[3]*scale, p[4]*scale,p[5]*scale, p[6]*scale,p[7]*scale, 0, 0);
		}
		// Close path
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, 0);
		// Build edges
		for (i = 0, j = r->npoints-1; i < r->npoints; j = i++)
			nsvg__addEdge(r, r->points[j].x, r->points[j].y, r->points[i].x, r->points[i].y);
	}
}

enum NSVGpointFlags
{
	NSVG_PT_CORNER = 0x01,
	NSVG_PT_BEVEL = 0x02,
	NSVG_PT_LEFT = 0x04,
};

static void nsvg__initClosed(NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dx = p1->x - p0->x;
	float dy = p1->y - p0->y;
	float len = nsvg__normalize(&dx, &dy);
	float px = p0->x + dx*len*0.5f, py = p0->y + dy*len*0.5f;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__buttCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)
{
	float w = lineWidth * 0.5f;
	float px = p->x, py = p->y;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;

	nsvg__addEdge(r, lx, ly, rx, ry);

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__squareCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int connect)
{
	float w = lineWidth * 0.5f;
	float px = p->x - dx*w, py = p->y - dy*w;
	float dlx = dy, dly = -dx;
	float lx = px - dlx*w, ly = py - dly*w;
	float rx = px + dlx*w, ry = py + dly*w;

	nsvg__addEdge(r, lx, ly, rx, ry);

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}
	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

#ifndef NSVG_PI
#define NSVG_PI (3.14159265358979323846264338327f)
#endif

static void nsvg__roundCap(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p, float dx, float dy, float lineWidth, int ncap, int connect)
{
	int i;
	float w = lineWidth * 0.5f;
	float px = p->x, py = p->y;
	float dlx = dy, dly = -dx;
	float lx = 0, ly = 0, rx = 0, ry = 0, prevx = 0, prevy = 0;

	for (i = 0; i < ncap; i++) {
		float a = i/(float)(ncap-1)*NSVG_PI;
		float ax = cosf(a) * w, ay = sinf(a) * w;
		float x = px - dlx*ax - dx*ay;
		float y = py - dly*ax - dy*ay;

		if (i > 0)
			nsvg__addEdge(r, prevx, prevy, x, y);

		prevx = x;
		prevy = y;

		if (i == 0) {
			lx = x; ly = y;
		} else if (i == ncap-1) {
			rx = x; ry = y;
		}
	}

	if (connect) {
		nsvg__addEdge(r, left->x, left->y, lx, ly);
		nsvg__addEdge(r, rx, ry, right->x, right->y);
	}

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__bevelJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float lx0 = p1->x - (dlx0 * w), ly0 = p1->y - (dly0 * w);
	float rx0 = p1->x + (dlx0 * w), ry0 = p1->y + (dly0 * w);
	float lx1 = p1->x - (dlx1 * w), ly1 = p1->y - (dly1 * w);
	float rx1 = p1->x + (dlx1 * w), ry1 = p1->y + (dly1 * w);

	nsvg__addEdge(r, lx0, ly0, left->x, left->y);
	nsvg__addEdge(r, lx1, ly1, lx0, ly0);

	nsvg__addEdge(r, right->x, right->y, rx0, ry0);
	nsvg__addEdge(r, rx0, ry0, rx1, ry1);

	left->x = lx1; left->y = ly1;
	right->x = rx1; right->y = ry1;
}

static void nsvg__miterJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float lx0, rx0, lx1, rx1;
	float ly0, ry0, ly1, ry1;

	if (p1->flags & NSVG_PT_LEFT) {
		lx0 = lx1 = p1->x - p1->dmx * w;
		ly0 = ly1 = p1->y - p1->dmy * w;
		nsvg__addEdge(r, lx1, ly1, left->x, left->y);

		rx0 = p1->x + (dlx0 * w);
		ry0 = p1->y + (dly0 * w);
		rx1 = p1->x + (dlx1 * w);
		ry1 = p1->y + (dly1 * w);
		nsvg__addEdge(r, right->x, right->y, rx0, ry0);
		nsvg__addEdge(r, rx0, ry0, rx1, ry1);
	} else {
		lx0 = p1->x - (dlx0 * w);
		ly0 = p1->y - (dly0 * w);
		lx1 = p1->x - (dlx1 * w);
		ly1 = p1->y - (dly1 * w);
		nsvg__addEdge(r, lx0, ly0, left->x, left->y);
		nsvg__addEdge(r, lx1, ly1, lx0, ly0);

		rx0 = rx1 = p1->x + p1->dmx * w;
		ry0 = ry1 = p1->y + p1->dmy * w;
		nsvg__addEdge(r, right->x, right->y, rx1, ry1);
	}

	left->x = lx1; left->y = ly1;
	right->x = rx1; right->y = ry1;
}

static void nsvg__roundJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p0, NSVGpoint* p1, float lineWidth, int ncap)
{
	int i, n;
	float w = lineWidth * 0.5f;
	float dlx0 = p0->dy, dly0 = -p0->dx;
	float dlx1 = p1->dy, dly1 = -p1->dx;
	float a0 = atan2f(dly0, dlx0);
	float a1 = atan2f(dly1, dlx1);
	float da = a1 - a0;
	float lx, ly, rx, ry;

	if (da < NSVG_PI) da += NSVG_PI*2;
	if (da > NSVG_PI) da -= NSVG_PI*2;

	n = (int)ceilf((nsvg__absf(da) / NSVG_PI) * ncap);
	if (n < 2) n = 2;
	if (n > ncap) n = ncap;

	lx = left->x;
	ly = left->y;
	rx = right->x;
	ry = right->y;

	for (i = 0; i < n; i++) {
		float u = i/(float)(n-1);
		float a = a0 + u*da;
		float ax = cosf(a) * w, ay = sinf(a) * w;
		float lx1 = p1->x - ax, ly1 = p1->y - ay;
		float rx1 = p1->x + ax, ry1 = p1->y + ay;

		nsvg__addEdge(r, lx1, ly1, lx, ly);
		nsvg__addEdge(r, rx, ry, rx1, ry1);

		lx = lx1; ly = ly1;
		rx = rx1; ry = ry1;
	}

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static void nsvg__straightJoin(NSVGrasterizer* r, NSVGpoint* left, NSVGpoint* right, NSVGpoint* p1, float lineWidth)
{
	float w = lineWidth * 0.5f;
	float lx = p1->x - (p1->dmx * w), ly = p1->y - (p1->dmy * w);
	float rx = p1->x + (p1->dmx * w), ry = p1->y + (p1->dmy * w);

	nsvg__addEdge(r, lx, ly, left->x, left->y);
	nsvg__addEdge(r, right->x, right->y, rx, ry);

	left->x = lx; left->y = ly;
	right->x = rx; right->y = ry;
}

static int nsvg__curveDivs(float r, float arc, float tol)
{
	float da = acosf(r / (r + tol)) * 2.0f;
	int divs = (int)ceilf(arc / da);
	if (divs < 2) divs = 2;
	return divs;
}

static void nsvg__expandStroke(NSVGrasterizer* r, NSVGpoint* points, int npoints, int closed, int lineJoin, int lineCap, float lineWidth)
{
	int ncap = nsvg__curveDivs(lineWidth*0.5f, NSVG_PI, r->tessTol);	// Calculate divisions per half circle.
	NSVGpoint left = {0,0,0,0,0,0,0,0}, right = {0,0,0,0,0,0,0,0}, firstLeft = {0,0,0,0,0,0,0,0}, firstRight = {0,0,0,0,0,0,0,0};
	NSVGpoint* p0, *p1;
	int j, s, e;

	// Build stroke edges
	if (closed) {
		// Looping
		p0 = &points[npoints-1];
		p1 = &points[0];
		s = 0;
		e = npoints;
	} else {
		// Add cap
		p0 = &points[0];
		p1 = &points[1];
		s = 1;
		e = npoints-1;
	}

	if (closed) {
		nsvg__initClosed(&left, &right, p0, p1, lineWidth);
		firstLeft = left;
		firstRight = right;
	} else {
		// Add cap
		float dx = p1->x - p0->x;
		float dy = p1->y - p0->y;
		nsvg__normalize(&dx, &dy);
		if (lineCap == NSVG_CAP_BUTT)
			nsvg__buttCap(r, &left, &right, p0, dx, dy, lineWidth, 0);
		else if (lineCap == NSVG_CAP_SQUARE)
			nsvg__squareCap(r, &left, &right, p0, dx, dy, lineWidth, 0);
		else if (lineCap == NSVG_CAP_ROUND)
			nsvg__roundCap(r, &left, &right, p0, dx, dy, lineWidth, ncap, 0);
	}

	for (j = s; j < e; ++j) {
		if (p1->flags & NSVG_PT_CORNER) {
			if (lineJoin == NSVG_JOIN_ROUND)
				nsvg__roundJoin(r, &left, &right, p0, p1, lineWidth, ncap);
			else if (lineJoin == NSVG_JOIN_BEVEL || (p1->flags & NSVG_PT_BEVEL))
				nsvg__bevelJoin(r, &left, &right, p0, p1, lineWidth);
			else
				nsvg__miterJoin(r, &left, &right, p0, p1, lineWidth);
		} else {
			nsvg__straightJoin(r, &left, &right, p1, lineWidth);
		}
		p0 = p1++;
	}

	if (closed) {
		// Loop it
		nsvg__addEdge(r, firstLeft.x, firstLeft.y, left.x, left.y);
		nsvg__addEdge(r, right.x, right.y, firstRight.x, firstRight.y);
	} else {
		// Add cap
		float dx = p1->x - p0->x;
		float dy = p1->y - p0->y;
		nsvg__normalize(&dx, &dy);
		if (lineCap == NSVG_CAP_BUTT)
			nsvg__buttCap(r, &right, &left, p1, -dx, -dy, lineWidth, 1);
		else if (lineCap == NSVG_CAP_SQUARE)
			nsvg__squareCap(r, &right, &left, p1, -dx, -dy, lineWidth, 1);
		else if (lineCap == NSVG_CAP_ROUND)
			nsvg__roundCap(r, &right, &left, p1, -dx, -dy, lineWidth, ncap, 1);
	}
}

static void nsvg__prepareStroke(NSVGrasterizer* r, float miterLimit, int lineJoin)
{
	int i, j;
	NSVGpoint* p0, *p1;

	p0 = &r->points[r->npoints-1];
	p1 = &r->points[0];
	for (i = 0; i < r->npoints; i++) {
		// Calculate segment direction and length
		p0->dx = p1->x - p0->x;
		p0->dy = p1->y - p0->y;
		p0->len = nsvg__normalize(&p0->dx, &p0->dy);
		// Advance
		p0 = p1++;
	}

	// calculate joins
	p0 = &r->points[r->npoints-1];
	p1 = &r->points[0];
	for (j = 0; j < r->npoints; j++) {
		float dlx0, dly0, dlx1, dly1, dmr2, cross;
		dlx0 = p0->dy;
		dly0 = -p0->dx;
		dlx1 = p1->dy;
		dly1 = -p1->dx;
		// Calculate extrusions
		p1->dmx = (dlx0 + dlx1) * 0.5f;
		p1->dmy = (dly0 + dly1) * 0.5f;
		dmr2 = p1->dmx*p1->dmx + p1->dmy*p1->dmy;
		if (dmr2 > 0.000001f) {
			float s2 = 1.0f / dmr2;
			if (s2 > 600.0f) {
				s2 = 600.0f;
			}
			p1->dmx *= s2;
			p1->dmy *= s2;
		}

		// Clear flags, but keep the corner.
		p1->flags = (p1->flags & NSVG_PT_CORNER) ? NSVG_PT_CORNER : 0;

		// Keep track of left turns.
		cross = p1->dx * p0->dy - p0->dx * p1->dy;
		if (cross > 0.0f)
			p1->flags |= NSVG_PT_LEFT;

		// Check to see if the corner needs to be beveled.
		if (p1->flags & NSVG_PT_CORNER) {
			if ((dmr2 * miterLimit*miterLimit) < 1.0f || lineJoin == NSVG_JOIN_BEVEL || lineJoin == NSVG_JOIN_ROUND) {
				p1->flags |= NSVG_PT_BEVEL;
			}
		}

		p0 = p1++;
	}
}

static void nsvg__flattenShapeStroke(NSVGrasterizer* r, NSVGshape* shape, float scale)
{
	int i, j, closed;
	NSVGpath* path;
	NSVGpoint* p0, *p1;
	float miterLimit = 4;
	int lineJoin = shape->strokeLineJoin;
	int lineCap = shape->strokeLineCap;
	float lineWidth = shape->strokeWidth * scale;

	for (path = shape->paths; path != NULL; path = path->next) {
		// Flatten path
		r->npoints = 0;
		nsvg__addPathPoint(r, path->pts[0]*scale, path->pts[1]*scale, NSVG_PT_CORNER);
		for (i = 0; i < path->npts-1; i += 3) {
			float* p = &path->pts[i*2];
			nsvg__flattenCubicBez(r, p[0]*scale,p[1]*scale, p[2]*scale,p[3]*scale, p[4]*scale,p[5]*scale, p[6]*scale,p[7]*scale, 0, NSVG_PT_CORNER);
		}
		if (r->npoints < 2)
			continue;

		closed = path->closed;

		// If the first and last points are the same, remove the last, mark as closed path.
		p0 = &r->points[r->npoints-1];
		p1 = &r->points[0];
		if (nsvg__ptEquals(p0->x,p0->y, p1->x,p1->y, r->distTol)) {
			r->npoints--;
			p0 = &r->points[r->npoints-1];
			closed = 1;
		}

		if (shape->strokeDashCount > 0) {
			int idash = 0, dashState = 1;
			float totalDist = 0, dashLen, allDashLen, dashOffset;
			NSVGpoint cur;

			if (closed)
				nsvg__appendPathPoint(r, r->points[0]);

			// Duplicate points -> points2.
			nsvg__duplicatePoints(r);

			r->npoints = 0;
 			cur = r->points2[0];
			nsvg__appendPathPoint(r, cur);

			// Figure out dash offset.
			allDashLen = 0;
			for (j = 0; j < shape->strokeDashCount; j++)
				allDashLen += shape->strokeDashArray[j];
			if (shape->strokeDashCount & 1)
				allDashLen *= 2.0f;
			// Find location inside pattern
			dashOffset = fmodf(shape->strokeDashOffset, allDashLen);
			if (dashOffset < 0.0f)
				dashOffset += allDashLen;

			while (dashOffset > shape->strokeDashArray[idash]) {
				dashOffset -= shape->strokeDashArray[idash];
				idash = (idash + 1) % shape->strokeDashCount;
			}
			dashLen = (shape->strokeDashArray[idash] - dashOffset) * scale;

			for (j = 1; j < r->npoints2; ) {
				float dx = r->points2[j].x - cur.x;
				float dy = r->points2[j].y - cur.y;
				float dist = sqrtf(dx*dx + dy*dy);

				if ((totalDist + dist) > dashLen) {
					// Calculate intermediate point
					float d = (dashLen - totalDist) / dist;
					float x = cur.x + dx * d;
					float y = cur.y + dy * d;
					nsvg__addPathPoint(r, x, y, NSVG_PT_CORNER);

					// Stroke
					if (r->npoints > 1 && dashState) {
						nsvg__prepareStroke(r, miterLimit, lineJoin);
						nsvg__expandStroke(r, r->points, r->npoints, 0, lineJoin, lineCap, lineWidth);
					}
					// Advance dash pattern
					dashState = !dashState;
					idash = (idash+1) % shape->strokeDashCount;
					dashLen = shape->strokeDashArray[idash] * scale;
					// Restart
					cur.x = x;
					cur.y = y;
					cur.flags = NSVG_PT_CORNER;
					totalDist = 0.0f;
					r->npoints = 0;
					nsvg__appendPathPoint(r, cur);
				} else {
					totalDist += dist;
					cur = r->points2[j];
					nsvg__appendPathPoint(r, cur);
					j++;
				}
			}
			// Stroke any leftover path
			if (r->npoints > 1 && dashState)
				nsvg__expandStroke(r, r->points, r->npoints, 0, lineJoin, lineCap, lineWidth);
		} else {
			nsvg__prepareStroke(r, miterLimit, lineJoin);
			nsvg__expandStroke(r, r->points, r->npoints, closed, lineJoin, lineCap, lineWidth);
		}
	}
}

static int nsvg__cmpEdge(const void *p, const void *q)
{
	NSVGedge* a = (NSVGedge*)p;
	NSVGedge* b = (NSVGedge*)q;

	if (a->y0 < b->y0) return -1;
	if (a->y0 > b->y0) return  1;
	return 0;
}

static NSVGactiveEdge* nsvg__addActive(NSVGrasterizer* r, NSVGedge* e, float startPoint)
{
	 NSVGactiveEdge* z;

	if (r->freelist != NULL) {
		// Restore from freelist.
		z = r->freelist;
		r->freelist = z->next;
	} else {
		// Alloc new edge.
		z = (NSVGactiveEdge*)nsvg__alloc(r, sizeof(NSVGactiveEdge));
		if (z == NULL) return NULL;
	}

	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
//	STBTT_assert(e->y0 <= start_point);
	// round dx down to avoid going too far
	if (dxdy < 0)
		z->dx = (int)(-floorf(NSVG__FIX * -dxdy));
	else
		z->dx = (int)floorf(NSVG__FIX * dxdy);
	z->x = (int)floorf(NSVG__FIX * (e->x0 + dxdy * (startPoint - e->y0)));
//	z->x -= off_x * FIX;
	z->ey = e->y1;
	z->next = 0;
	z->dir = e->dir;

	return z;
}

static void nsvg__freeActive(NSVGrasterizer* r, NSVGactiveEdge* z)
{
	z->next = r->freelist;
	r->freelist = z;
}

static void nsvg__fillScanline(unsigned char* scanline, int len, int x0, int x1, int maxWeight, int* xmin, int* xmax)
{
	int i = x0 >> NSVG__FIXSHIFT;
	int j = x1 >> NSVG__FIXSHIFT;
	if (i < *xmin) *xmin = i;
	if (j > *xmax) *xmax = j;
	if (i < len && j >= 0) {
		if (i == j) {
			// x0,x1 are the same pixel, so compute combined coverage
			scanline[i] += (unsigned char)((x1 - x0) * maxWeight >> NSVG__FIXSHIFT);
		} else {
			if (i >= 0) // add antialiasing for x0
				scanline[i] += (unsigned char)(((NSVG__FIX - (x0 & NSVG__FIXMASK)) * maxWeight) >> NSVG__FIXSHIFT);
			else
				i = -1; // clip

			if (j < len) // add antialiasing for x1
				scanline[j] += (unsigned char)(((x1 & NSVG__FIXMASK) * maxWeight) >> NSVG__FIXSHIFT);
			else
				j = len; // clip

			for (++i; i < j; ++i) // fill pixels between x0 and x1
				scanline[i] += (unsigned char)maxWeight;
		}
	}
}

// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void nsvg__fillActiveEdges(unsigned char* scanline, int len, NSVGactiveEdge* e, int maxWeight, int* xmin, int* xmax, char fillRule)
{
	// non-zero winding fill
	int x0 = 0, w = 0;

	if (fillRule == NSVG_FILLRULE_NONZERO) {
		// Non-zero
		while (e != NULL) {
			if (w == 0) {
				// if we're currently at zero, we need to record the edge start point
				x0 = e->x; w += e->dir;
			} else {
				int x1 = e->x; w += e->dir;
				// if we went to zero, we need to draw
				if (w == 0)
					nsvg__fillScanline(scanline, len, x0, x1, maxWeight, xmin, xmax);
			}
			e = e->next;
		}
	} else if (fillRule == NSVG_FILLRULE_EVENODD) {
		// Even-odd
		while (e != NULL) {
			if (w == 0) {
				// if we're currently at zero, we need to record the edge start point
				x0 = e->x; w = 1;
			} else {
				int x1 = e->x; w = 0;
				nsvg__fillScanline(scanline, len, x0, x1, maxWeight, xmin, xmax);
			}
			e = e->next;
		}
	}
}

static float nsvg__clampf(float a, float mn, float mx) { return a < mn ? mn : (a > mx ? mx : a); }

static unsigned int nsvg__RGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
	return (r) | (g << 8) | (b << 16) | (a << 24);
}

static unsigned int nsvg__lerpRGBA(unsigned int c0, unsigned int c1, float u)
{
	int iu = (int)(nsvg__clampf(u, 0.0f, 1.0f) * 256.0f);
	int r = (((c0) & 0xff)*(256-iu) + (((c1) & 0xff)*iu)) >> 8;
	int g = (((c0>>8) & 0xff)*(256-iu) + (((c1>>8) & 0xff)*iu)) >> 8;
	int b = (((c0>>16) & 0xff)*(256-iu) + (((c1>>16) & 0xff)*iu)) >> 8;
	int a = (((c0>>24) & 0xff)*(256-iu) + (((c1>>24) & 0xff)*iu)) >> 8;
	return nsvg__RGBA((unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a);
}

static unsigned int nsvg__applyOpacity(unsigned int c, float u)
{
	int iu = (int)(nsvg__clampf(u, 0.0f, 1.0f) * 256.0f);
	int r = (c) & 0xff;
	int g = (c>>8) & 0xff;
	int b = (c>>16) & 0xff;
	int a = (((c>>24) & 0xff)*iu) >> 8;
	return nsvg__RGBA((unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a);
}

static inline int nsvg__div255(int x)
{
	return ((x+1) * 257) >> 16;
}

static void nsvg__scanlineSolid(unsigned char* dst, int count, unsigned char* cover, int x, int y,
								float tx, float ty, float scale, NSVGcachedPaint* cache)
{

	if (cache->type == NSVG_PAINT_COLOR) {
		int i, cr, cg, cb, ca;
		cr = cache->colors[0] & 0xff;
		cg = (cache->colors[0] >> 8) & 0xff;
		cb = (cache->colors[0] >> 16) & 0xff;
		ca = (cache->colors[0] >> 24) & 0xff;

		for (i = 0; i < count; i++) {
			int r,g,b;
			int a = nsvg__div255((int)cover[0] * ca);
			int ia = 255 - a;
			// Premultiply
			r = nsvg__div255(cr * a);
			g = nsvg__div255(cg * a);
			b = nsvg__div255(cb * a);

			// Blend over
			r += nsvg__div255(ia * (int)dst[0]);
			g += nsvg__div255(ia * (int)dst[1]);
			b += nsvg__div255(ia * (int)dst[2]);
			a += nsvg__div255(ia * (int)dst[3]);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
		}
	} else if (cache->type == NSVG_PAINT_LINEAR_GRADIENT) {
		// TODO: spread modes.
		// TODO: plenty of opportunities to optimize.
		float fx, fy, dx, gy;
		float* t = cache->xform;
		int i, cr, cg, cb, ca;
		unsigned int c;

		fx = (x - tx) / scale;
		fy = (y - ty) / scale;
		dx = 1.0f / scale;

		for (i = 0; i < count; i++) {
			int r,g,b,a,ia;
			gy = fx*t[1] + fy*t[3] + t[5];
			c = cache->colors[(int)nsvg__clampf(gy*255.0f, 0, 255.0f)];
			cr = (c) & 0xff;
			cg = (c >> 8) & 0xff;
			cb = (c >> 16) & 0xff;
			ca = (c >> 24) & 0xff;

			a = nsvg__div255((int)cover[0] * ca);
			ia = 255 - a;

			// Premultiply
			r = nsvg__div255(cr * a);
			g = nsvg__div255(cg * a);
			b = nsvg__div255(cb * a);

			// Blend over
			r += nsvg__div255(ia * (int)dst[0]);
			g += nsvg__div255(ia * (int)dst[1]);
			b += nsvg__div255(ia * (int)dst[2]);
			a += nsvg__div255(ia * (int)dst[3]);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
			fx += dx;
		}
	} else if (cache->type == NSVG_PAINT_RADIAL_GRADIENT) {
		// TODO: spread modes.
		// TODO: plenty of opportunities to optimize.
		// TODO: focus (fx,fy)
		float fx, fy, dx, gx, gy, gd;
		float* t = cache->xform;
		int i, cr, cg, cb, ca;
		unsigned int c;

		fx = (x - tx) / scale;
		fy = (y - ty) / scale;
		dx = 1.0f / scale;

		for (i = 0; i < count; i++) {
			int r,g,b,a,ia;
			gx = fx*t[0] + fy*t[2] + t[4];
			gy = fx*t[1] + fy*t[3] + t[5];
			gd = sqrtf(gx*gx + gy*gy);
			c = cache->colors[(int)nsvg__clampf(gd*255.0f, 0, 255.0f)];
			cr = (c) & 0xff;
			cg = (c >> 8) & 0xff;
			cb = (c >> 16) & 0xff;
			ca = (c >> 24) & 0xff;

			a = nsvg__div255((int)cover[0] * ca);
			ia = 255 - a;

			// Premultiply
			r = nsvg__div255(cr * a);
			g = nsvg__div255(cg * a);
			b = nsvg__div255(cb * a);

			// Blend over
			r += nsvg__div255(ia * (int)dst[0]);
			g += nsvg__div255(ia * (int)dst[1]);
			b += nsvg__div255(ia * (int)dst[2]);
			a += nsvg__div255(ia * (int)dst[3]);

			dst[0] = (unsigned char)r;
			dst[1] = (unsigned char)g;
			dst[2] = (unsigned char)b;
			dst[3] = (unsigned char)a;

			cover++;
			dst += 4;
			fx += dx;
		}
	}
}

static void nsvg__rasterizeSortedEdges(NSVGrasterizer *r, float tx, float ty, float scale, NSVGcachedPaint* cache, char fillRule)
{
	NSVGactiveEdge *active = NULL;
	int y, s;
	int e = 0;
	int maxWeight = (255 / NSVG__SUBSAMPLES);  // weight per vertical scanline
	int xmin, xmax;

	for (y = 0; y < r->height; y++) {
		memset(r->scanline, 0, r->width);
		xmin = r->width;
		xmax = 0;
		for (s = 0; s < NSVG__SUBSAMPLES; ++s) {
			// find center of pixel for this scanline
			float scany = y*NSVG__SUBSAMPLES + s + 0.5f;
			NSVGactiveEdge **step = &active;

			// update all active edges;
			// remove all active edges that terminate before the center of this scanline
			while (*step) {
				NSVGactiveEdge *z = *step;
				if (z->ey <= scany) {
					*step = z->next; // delete from list
//					NSVG__assert(z->valid);
					nsvg__freeActive(r, z);
				} else {
					z->x += z->dx; // advance to position for current scanline
					step = &((*step)->next); // advance through list
				}
			}

			// resort the list if needed
			for (;;) {
				int changed = 0;
				step = &active;
				while (*step && (*step)->next) {
					if ((*step)->x > (*step)->next->x) {
						NSVGactiveEdge* t = *step;
						NSVGactiveEdge* q = t->next;
						t->next = q->next;
						q->next = t;
						*step = q;
						changed = 1;
					}
					step = &(*step)->next;
				}
				if (!changed) break;
			}

			// insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
			while (e < r->nedges && r->edges[e].y0 <= scany) {
				if (r->edges[e].y1 > scany) {
					NSVGactiveEdge* z = nsvg__addActive(r, &r->edges[e], scany);
					if (z == NULL) break;
					// find insertion point
					if (active == NULL) {
						active = z;
					} else if (z->x < active->x) {
						// insert at front
						z->next = active;
						active = z;
					} else {
						// find thing to insert AFTER
						NSVGactiveEdge* p = active;
						while (p->next && p->next->x < z->x)
							p = p->next;
						// at this point, p->next->x is NOT < z->x
						z->next = p->next;
						p->next = z;
					}
				}
				e++;
			}

			// now process all active edges in non-zero fashion
			if (active != NULL)
				nsvg__fillActiveEdges(r->scanline, r->width, active, maxWeight, &xmin, &xmax, fillRule);
		}
		// Blit
		if (xmin < 0) xmin = 0;
		if (xmax > r->width-1) xmax = r->width-1;
		if (xmin <= xmax) {
			nsvg__scanlineSolid(&r->bitmap[y * r->stride] + xmin*4, xmax-xmin+1, &r->scanline[xmin], xmin, y, tx,ty, scale, cache);
		}
	}

}

static void nsvg__unpremultiplyAlpha(unsigned char* image, int w, int h, int stride)
{
	int x,y;

	// Unpremultiply
	for (y = 0; y < h; y++) {
		unsigned char *row = &image[y*stride];
		for (x = 0; x < w; x++) {
			int r = row[0], g = row[1], b = row[2], a = row[3];
			if (a != 0) {
				row[0] = (unsigned char)(r*255/a);
				row[1] = (unsigned char)(g*255/a);
				row[2] = (unsigned char)(b*255/a);
			}
			row += 4;
		}
	}

	// Defringe
	for (y = 0; y < h; y++) {
		unsigned char *row = &image[y*stride];
		for (x = 0; x < w; x++) {
			int r = 0, g = 0, b = 0, a = row[3], n = 0;
			if (a == 0) {
				if (x-1 > 0 && row[-1] != 0) {
					r += row[-4];
					g += row[-3];
					b += row[-2];
					n++;
				}
				if (x+1 < w && row[7] != 0) {
					r += row[4];
					g += row[5];
					b += row[6];
					n++;
				}
				if (y-1 > 0 && row[-stride+3] != 0) {
					r += row[-stride];
					g += row[-stride+1];
					b += row[-stride+2];
					n++;
				}
				if (y+1 < h && row[stride+3] != 0) {
					r += row[stride];
					g += row[stride+1];
					b += row[stride+2];
					n++;
				}
				if (n > 0) {
					row[0] = (unsigned char)(r/n);
					row[1] = (unsigned char)(g/n);
					row[2] = (unsigned char)(b/n);
				}
			}
			row += 4;
		}
	}
}

static void nsvg__initPaint(NSVGcachedPaint* cache, NSVGpaint* paint, float opacity)
{
	int i, j;
	NSVGgradient* grad;

	cache->type = paint->type;

	if (paint->type == NSVG_PAINT_COLOR) {
		cache->colors[0] = nsvg__applyOpacity(paint->color, opacity);
		return;
	}

	grad = paint->gradient;

	cache->spread = grad->spread;
	memcpy(cache->xform, grad->xform, sizeof(float)*6);

	if (grad->nstops == 0) {
		for (i = 0; i < 256; i++)
			cache->colors[i] = 0;
	} if (grad->nstops == 1) {
		for (i = 0; i < 256; i++)
			cache->colors[i] = nsvg__applyOpacity(grad->stops[i].color, opacity);
	} else {
		unsigned int ca, cb = 0;
		float ua, ub, du, u;
		int ia, ib, count;

		ca = nsvg__applyOpacity(grad->stops[0].color, opacity);
		ua = nsvg__clampf(grad->stops[0].offset, 0, 1);
		ub = nsvg__clampf(grad->stops[grad->nstops-1].offset, ua, 1);
		ia = (int)(ua * 255.0f);
		ib = (int)(ub * 255.0f);
		for (i = 0; i < ia; i++) {
			cache->colors[i] = ca;
		}

		for (i = 0; i < grad->nstops-1; i++) {
			ca = nsvg__applyOpacity(grad->stops[i].color, opacity);
			cb = nsvg__applyOpacity(grad->stops[i+1].color, opacity);
			ua = nsvg__clampf(grad->stops[i].offset, 0, 1);
			ub = nsvg__clampf(grad->stops[i+1].offset, 0, 1);
			ia = (int)(ua * 255.0f);
			ib = (int)(ub * 255.0f);
			count = ib - ia;
			if (count <= 0) continue;
			u = 0;
			du = 1.0f / (float)count;
			for (j = 0; j < count; j++) {
				cache->colors[ia+j] = nsvg__lerpRGBA(ca,cb,u);
				u += du;
			}
		}

		for (i = ib; i < 256; i++)
			cache->colors[i] = cb;
	}

}

/*
static void dumpEdges(NSVGrasterizer* r, const char* name)
{
	float xmin = 0, xmax = 0, ymin = 0, ymax = 0;
	NSVGedge *e = NULL;
	int i;
	if (r->nedges == 0) return;
	FILE* fp = fopen(name, "w");
	if (fp == NULL) return;

	xmin = xmax = r->edges[0].x0;
	ymin = ymax = r->edges[0].y0;
	for (i = 0; i < r->nedges; i++) {
		e = &r->edges[i];
		xmin = nsvg__minf(xmin, e->x0);
		xmin = nsvg__minf(xmin, e->x1);
		xmax = nsvg__maxf(xmax, e->x0);
		xmax = nsvg__maxf(xmax, e->x1);
		ymin = nsvg__minf(ymin, e->y0);
		ymin = nsvg__minf(ymin, e->y1);
		ymax = nsvg__maxf(ymax, e->y0);
		ymax = nsvg__maxf(ymax, e->y1);
	}

	fprintf(fp, "<svg viewBox=\"%f %f %f %f\" xmlns=\"http://www.w3.org/2000/svg\">", xmin, ymin, (xmax - xmin), (ymax - ymin));

	for (i = 0; i < r->nedges; i++) {
		e = &r->edges[i];
		fprintf(fp ,"<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:#000;\" />", e->x0,e->y0, e->x1,e->y1);
	}

	for (i = 0; i < r->npoints; i++) {
		if (i+1 < r->npoints)
			fprintf(fp ,"<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\" style=\"stroke:#f00;\" />", r->points[i].x, r->points[i].y, r->points[i+1].x, r->points[i+1].y);
		fprintf(fp ,"<circle cx=\"%f\" cy=\"%f\" r=\"1\" style=\"fill:%s;\" />", r->points[i].x, r->points[i].y, r->points[i].flags == 0 ? "#f00" : "#0f0");
	}

	fprintf(fp, "</svg>");
	fclose(fp);
}
*/

void nsvgRasterize(NSVGrasterizer* r,
				   NSVGimage* image, float tx, float ty, float scale,
				   unsigned char* dst, int w, int h, int stride)
{
	NSVGshape *shape = NULL;
	NSVGedge *e = NULL;
	NSVGcachedPaint cache;
	int i;

	r->bitmap = dst;
	r->width = w;
	r->height = h;
	r->stride = stride;

	if (w > r->cscanline) {
		r->cscanline = w;
		r->scanline = (unsigned char*)realloc(r->scanline, w);
		if (r->scanline == NULL) return;
	}

	for (i = 0; i < h; i++)
		memset(&dst[i*stride], 0, w*4);

	for (shape = image->shapes; shape != NULL; shape = shape->next) {
		if (!(shape->flags & NSVG_FLAGS_VISIBLE))
			continue;

		if (shape->fill.type != NSVG_PAINT_NONE) {
			nsvg__resetPool(r);
			r->freelist = NULL;
			r->nedges = 0;

			nsvg__flattenShape(r, shape, scale);

			// Scale and translate edges
			for (i = 0; i < r->nedges; i++) {
				e = &r->edges[i];
				e->x0 = tx + e->x0;
				e->y0 = (ty + e->y0) * NSVG__SUBSAMPLES;
				e->x1 = tx + e->x1;
				e->y1 = (ty + e->y1) * NSVG__SUBSAMPLES;
			}

			// Rasterize edges
			qsort(r->edges, r->nedges, sizeof(NSVGedge), nsvg__cmpEdge);

			// now, traverse the scanlines and find the intersections on each scanline, use non-zero rule
			nsvg__initPaint(&cache, &shape->fill, shape->opacity);

			nsvg__rasterizeSortedEdges(r, tx,ty,scale, &cache, shape->fillRule);
		}
		if (shape->stroke.type != NSVG_PAINT_NONE && (shape->strokeWidth * scale) > 0.01f) {
			nsvg__resetPool(r);
			r->freelist = NULL;
			r->nedges = 0;

			nsvg__flattenShapeStroke(r, shape, scale);

//			dumpEdges(r, "edge.svg");

			// Scale and translate edges
			for (i = 0; i < r->nedges; i++) {
				e = &r->edges[i];
				e->x0 = tx + e->x0;
				e->y0 = (ty + e->y0) * NSVG__SUBSAMPLES;
				e->x1 = tx + e->x1;
				e->y1 = (ty + e->y1) * NSVG__SUBSAMPLES;
			}

			// Rasterize edges
			qsort(r->edges, r->nedges, sizeof(NSVGedge), nsvg__cmpEdge);

			// now, traverse the scanlines and find the intersections on each scanline, use non-zero rule
			nsvg__initPaint(&cache, &shape->stroke, shape->opacity);

			nsvg__rasterizeSortedEdges(r, tx,ty,scale, &cache, NSVG_FILLRULE_NONZERO);
		}
	}

	nsvg__unpremultiplyAlpha(dst, w, h, stride);

	r->bitmap = NULL;
	r->width = 0;
	r->height = 0;
	r->stride = 0;
}

#endif

/*
#define STBI_MALLOC(x)    spot_malloc(x)
#define STBI_FREE(p)      spot_free(p)
#define STBI_REALLOC(p,x) spot_realloc(p,x)
*/
#define STB_IMAGE_STATIC
#define STB_IMAGE_IMPLEMENTATION
#define STBI_NO_STDIO

//#line 1 "stb_image.h"
#ifndef STBI_INCLUDE_STB_IMAGE_H
#define STBI_INCLUDE_STB_IMAGE_H

// DOCUMENTATION
//
// Limitations:
//    - no 16-bit-per-channel PNG
//    - no 12-bit-per-channel JPEG
//    - no JPEGs with arithmetic coding
//    - no 1-bit BMP
//    - GIF always returns *comp=4
//
// Basic usage (see HDR discussion below for HDR usage):
//    int x,y,n;
//    unsigned char *data = stbi_load(filename, &x, &y, &n, 0);
//    // ... process data if not NULL ...
//    // ... x = width, y = height, n = # 8-bit components per pixel ...
//    // ... replace '0' with '1'..'4' to force that many components per pixel
//    // ... but 'n' will always be the number that it would have been if you said 0
//    stbi_image_free(data)
//
// Standard parameters:
//    int *x                 -- outputs image width in pixels
//    int *y                 -- outputs image height in pixels
//    int *channels_in_file  -- outputs # of image components in image file
//    int desired_channels   -- if non-zero, # of image components requested in result
//
// The return value from an image loader is an 'unsigned char *' which points
// to the pixel data, or NULL on an allocation failure or if the image is
// corrupt or invalid. The pixel data consists of *y scanlines of *x pixels,
// with each pixel consisting of N interleaved 8-bit components; the first
// pixel pointed to is top-left-most in the image. There is no padding between
// image scanlines or between pixels, regardless of format. The number of
// components N is 'req_comp' if req_comp is non-zero, or *comp otherwise.
// If req_comp is non-zero, *comp has the number of components that _would_
// have been output otherwise. E.g. if you set req_comp to 4, you will always
// get RGBA output, but you can check *comp to see if it's trivially opaque
// because e.g. there were only 3 channels in the source image.
//
// An output image with N components has the following components interleaved
// in this order in each pixel:
//
//     N=#comp     components
//       1           grey
//       2           grey, alpha
//       3           red, green, blue
//       4           red, green, blue, alpha
//
// If image loading fails for any reason, the return value will be NULL,
// and *x, *y, *comp will be unchanged. The function stbi_failure_reason()
// can be queried for an extremely brief, end-user unfriendly explanation
// of why the load failed. Define STBI_NO_FAILURE_STRINGS to avoid
// compiling these strings at all, and STBI_FAILURE_USERMSG to get slightly
// more user-friendly ones.
//
// Paletted PNG, BMP, GIF, and PIC images are automatically depalettized.
//
// ===========================================================================
//
// Philosophy
//
// stb libraries are designed with the following priorities:
//
//    1. easy to use
//    2. easy to maintain
//    3. good performance
//
// Sometimes I let "good performance" creep up in priority over "easy to maintain",
// and for best performance I may provide less-easy-to-use APIs that give higher
// performance, in addition to the easy to use ones. Nevertheless, it's important
// to keep in mind that from the standpoint of you, a client of this library,
// all you care about is #1 and #3, and stb libraries DO NOT emphasize #3 above all.
//
// Some secondary priorities arise directly from the first two, some of which
// make more explicit reasons why performance can't be emphasized.
//
//    - Portable ("ease of use")
//    - Small source code footprint ("easy to maintain")
//    - No dependencies ("ease of use")
//
// ===========================================================================
//
// I/O callbacks
//
// I/O callbacks allow you to read from arbitrary sources, like packaged
// files or some other source. Data read from callbacks are processed
// through a small internal buffer (currently 128 bytes) to try to reduce
// overhead.
//
// The three functions you must define are "read" (reads some bytes of data),
// "skip" (skips some bytes of data), "eof" (reports if the stream is at the end).
//
// ===========================================================================
//
// SIMD support
//
// The JPEG decoder will try to automatically use SIMD kernels on x86 when
// supported by the compiler. For ARM Neon support, you must explicitly
// request it.
//
// (The old do-it-yourself SIMD API is no longer supported in the current
// code.)
//
// On x86, SSE2 will automatically be used when available based on a run-time
// test; if not, the generic C versions are used as a fall-back. On ARM targets,
// the typical path is to have separate builds for NEON and non-NEON devices
// (at least this is true for iOS and Android). Therefore, the NEON support is
// toggled by a build flag: define STBI_NEON to get NEON loops.
//
// If for some reason you do not want to use any of SIMD code, or if
// you have issues compiling it, you can disable it entirely by
// defining STBI_NO_SIMD.
//
// ===========================================================================
//
// HDR image support   (disable by defining STBI_NO_HDR)
//
// stb_image now supports loading HDR images in general, and currently
// the Radiance .HDR file format, although the support is provided
// generically. You can still load any file through the existing interface;
// if you attempt to load an HDR file, it will be automatically remapped to
// LDR, assuming gamma 2.2 and an arbitrary scale factor defaulting to 1;
// both of these constants can be reconfigured through this interface:
//
//     stbi_hdr_to_ldr_gamma(2.2f);
//     stbi_hdr_to_ldr_scale(1.0f);
//
// (note, do not use _inverse_ constants; stbi_image will invert them
// appropriately).
//
// Additionally, there is a new, parallel interface for loading files as
// (linear) floats to preserve the full dynamic range:
//
//    float *data = stbi_loadf(filename, &x, &y, &n, 0);
//
// If you load LDR images through this interface, those images will
// be promoted to floating point values, run through the inverse of
// constants corresponding to the above:
//
//     stbi_ldr_to_hdr_scale(1.0f);
//     stbi_ldr_to_hdr_gamma(2.2f);
//
// Finally, given a filename (or an open file or memory block--see header
// file for details) containing image data, you can query for the "most
// appropriate" interface to use (that is, whether the image is HDR or
// not), using:
//
//     stbi_is_hdr(char *filename);
//
// ===========================================================================
//
// iPhone PNG support:
//
// By default we convert iphone-formatted PNGs back to RGB, even though
// they are internally encoded differently. You can disable this conversion
// by by calling stbi_convert_iphone_png_to_rgb(0), in which case
// you will always just get the native iphone "format" through (which
// is BGR stored in RGB).
//
// Call stbi_set_unpremultiply_on_load(1) as well to force a divide per
// pixel to remove any premultiplied alpha *only* if the image file explicitly
// says there's premultiplied data (currently only happens in iPhone images,
// and only if iPhone convert-to-rgb processing is on).
//
// ===========================================================================
//
// ADDITIONAL CONFIGURATION
//
//  - You can suppress implementation of any of the decoders to reduce
//    your code footprint by #defining one or more of the following
//    symbols before creating the implementation.
//
//        STBI_NO_JPEG
//        STBI_NO_PNG
//        STBI_NO_BMP
//        STBI_NO_PSD
//        STBI_NO_TGA
//        STBI_NO_GIF
//        STBI_NO_HDR
//        STBI_NO_PIC
//        STBI_NO_PNM   (.ppm and .pgm)
//
//  - You can request *only* certain decoders and suppress all other ones
//    (this will be more forward-compatible, as addition of new decoders
//    doesn't require you to disable them explicitly):
//
//        STBI_ONLY_JPEG
//        STBI_ONLY_PNG
//        STBI_ONLY_BMP
//        STBI_ONLY_PSD
//        STBI_ONLY_TGA
//        STBI_ONLY_GIF
//        STBI_ONLY_HDR
//        STBI_ONLY_PIC
//        STBI_ONLY_PNM   (.ppm and .pgm)
//
//   - If you use STBI_NO_PNG (or _ONLY_ without PNG), and you still
//     want the zlib decoder to be available, #define STBI_SUPPORT_ZLIB
//

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif // STBI_NO_STDIO

#define STBI_VERSION 1

enum
{
   STBI_default = 0, // only used for req_comp

   STBI_grey       = 1,
   STBI_grey_alpha = 2,
   STBI_rgb        = 3,
   STBI_rgb_alpha  = 4
};

typedef unsigned char stbi_uc;
typedef unsigned short stbi_us;

#ifdef __cplusplus
extern "C" {
#endif

#ifdef STB_IMAGE_STATIC
#define STBIDEF static
#else
#define STBIDEF extern
#endif

//////////////////////////////////////////////////////////////////////////////
//
// PRIMARY API - works on images of any type
//

//
// load image by filename, open file, or memory buffer
//

typedef struct
{
   int      (*read)  (void *user,char *data,int size);   // fill 'data' with 'size' bytes.  return number of bytes actually read
   void     (*skip)  (void *user,int n);                 // skip the next 'n' bytes, or 'unget' the last -n bytes if negative
   int      (*eof)   (void *user);                       // returns nonzero if we are at end of file/data
} stbi_io_callbacks;

////////////////////////////////////
//
// 8-bits-per-channel interface
//

STBIDEF stbi_uc *stbi_load               (char              const *filename,           int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_memory   (stbi_uc           const *buffer, int len   , int *x, int *y, int *channels_in_file, int desired_channels);
STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk  , void *user, int *x, int *y, int *channels_in_file, int desired_channels);

#ifndef STBI_NO_STDIO
STBIDEF stbi_uc *stbi_load_from_file   (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
// for stbi_load_from_file, file pointer is left pointing immediately after image
#endif

////////////////////////////////////
//
// 16-bits-per-channel interface
//

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *channels_in_file, int desired_channels);
#ifndef STBI_NO_STDIO
STBIDEF stbi_us *stbi_load_from_file_16(FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
#endif
// @TODO the other variants

////////////////////////////////////
//
// float-per-channel interface
//
#ifndef STBI_NO_LINEAR
   STBIDEF float *stbi_loadf                 (char const *filename,           int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_memory     (stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels);
   STBIDEF float *stbi_loadf_from_callbacks  (stbi_io_callbacks const *clbk, void *user, int *x, int *y,  int *channels_in_file, int desired_channels);

   #ifndef STBI_NO_STDIO
   STBIDEF float *stbi_loadf_from_file  (FILE *f, int *x, int *y, int *channels_in_file, int desired_channels);
   #endif
#endif

#ifndef STBI_NO_HDR
   STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma);
   STBIDEF void   stbi_hdr_to_ldr_scale(float scale);
#endif // STBI_NO_HDR

#ifndef STBI_NO_LINEAR
   STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma);
   STBIDEF void   stbi_ldr_to_hdr_scale(float scale);
#endif // STBI_NO_LINEAR

// stbi_is_hdr is always defined, but always returns false if STBI_NO_HDR
STBIDEF int    stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user);
STBIDEF int    stbi_is_hdr_from_memory(stbi_uc const *buffer, int len);
#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename);
STBIDEF int      stbi_is_hdr_from_file(FILE *f);
#endif // STBI_NO_STDIO

// get a VERY brief reason for failure
// NOT THREADSAFE
STBIDEF const char *stbi_failure_reason  (void);

// free the loaded image -- this is just free()
STBIDEF void     stbi_image_free      (void *retval_from_stbi_load);

// get image dimensions & components without fully decoding
STBIDEF int      stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_info            (char const *filename,     int *x, int *y, int *comp);
STBIDEF int      stbi_info_from_file  (FILE *f,                  int *x, int *y, int *comp);

#endif

// for image formats that explicitly notate that they have premultiplied alpha,
// we just return the colors as stored in the file. set this flag to force
// unpremultiplication. results are undefined if the unpremultiply overflow.
STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply);

// indicate whether we should process iphone images back to canonical format,
// or just pass them through "as-is"
STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert);

// flip the image vertically, so the first pixel in the output array is the bottom left
STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip);

// ZLIB client - used by PNG, available for other purposes

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen);
STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header);
STBIDEF char *stbi_zlib_decode_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

STBIDEF char *stbi_zlib_decode_noheader_malloc(const char *buffer, int len, int *outlen);
STBIDEF int   stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen);

#ifndef STBI_NO_DDS

//#line 1 "stbi_DDS.h"
#ifndef HEADER_STB_IMAGE_DDS_AUGMENTATION
#define HEADER_STB_IMAGE_DDS_AUGMENTATION

/*	is it a DDS file? */
extern int      stbi__dds_test_memory      (stbi_uc const *buffer, int len);
extern int      stbi__dds_test_callbacks   (stbi_io_callbacks const *clbk, void *user);

extern void    *stbi__dds_load_from_path   (const char *filename,           int *x, int *y, int *comp, int req_comp);
extern void    *stbi__dds_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern void    *stbi__dds_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern int      stbi__dds_test_filename    (char const *filename);
extern int      stbi__dds_test_file        (FILE *f);
extern void    *stbi__dds_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

extern int      stbi__dds_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__dds_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int *iscompressed);

#ifndef STBI_NO_STDIO
extern int      stbi__dds_info_from_path   (char const *filename,     int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__dds_info_from_file   (FILE *f,                  int *x, int *y, int *comp, int *iscompressed);
#endif

/*
//
////   end header file   /////////////////////////////////////////////////////*/
#endif /* HEADER_STB_IMAGE_DDS_AUGMENTATION */


#endif

#ifndef STBI_NO_PVR

//#line 1 "stbi_pvr.h"
#ifndef HEADER_STB_IMAGE_PVR_AUGMENTATION
#define HEADER_STB_IMAGE_PVR_AUGMENTATION

/*	is it a PVR file? */
extern int      stbi__pvr_test_memory      (stbi_uc const *buffer, int len);
extern int      stbi__pvr_test_callbacks   (stbi_io_callbacks const *clbk, void *user);

extern void    *stbi__pvr_load_from_path   (char const *filename,           int *x, int *y, int *comp, int req_comp);
extern void    *stbi__pvr_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern void    *stbi__pvr_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern int      stbi__pvr_test_filename    (char const *filename);
extern int      stbi__pvr_test_file        (FILE *f);
extern void    *stbi__pvr_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

extern int      stbi__pvr_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__pvr_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int *iscompressed);

#ifndef STBI_NO_STDIO
extern int      stbi__pvr_info_from_path   (char const *filename,     int *x, int *y, int *comp, int *iscompressed);
extern int      stbi__pvr_info_from_file   (FILE *f,                  int *x, int *y, int *comp, int *iscompressed);
#endif

/*
//
////   end header file   /////////////////////////////////////////////////////*/
#endif /* HEADER_STB_IMAGE_PVR_AUGMENTATION */


#endif

#ifndef STBI_NO_PKM

//#line 1 "stbi_pkm.h"
#ifndef HEADER_STB_IMAGE_PKM_AUGMENTATION
#define HEADER_STB_IMAGE_PKM_AUGMENTATION

/*	is it a PKM file? */
extern int      stbi__pkm_test_memory      (stbi_uc const *buffer, int len);
extern int      stbi__pkm_test_callbacks   (stbi_io_callbacks const *clbk, void *user);

extern void    *stbi__pkm_load_from_path   (char const *filename,           int *x, int *y, int *comp, int req_comp);
extern void    *stbi__pkm_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp);
extern void    *stbi__pkm_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp);

#ifndef STBI_NO_STDIO
extern int      stbi__pkm_test_filename    (char const *filename);
extern int      stbi__pkm_test_file        (FILE *f);
extern void    *stbi__pkm_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp);
#endif

extern int      stbi__pkm_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp);
extern int      stbi__pkm_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp);

#ifndef STBI_NO_STDIO
extern int      stbi__pkm_info_from_path   (char const *filename,     int *x, int *y, int *comp);
extern int      stbi__pkm_info_from_file   (FILE *f,                  int *x, int *y, int *comp);
#endif

/*
//
////   end header file   /////////////////////////////////////////////////////*/
#endif /* HEADER_STB_IMAGE_PKM_AUGMENTATION */


#endif

#ifndef STBI_NO_EXT

//#line 1 "stbi_ext.h"
#ifndef HEADER_STB_IMAGE_EXT
#define HEADER_STB_IMAGE_EXT

enum {
	STBI_unknown= 0,
	STBI_jpeg	= 1,
	STBI_png	= 2,
	STBI_bmp	= 3,
	STBI_gif	= 4,
	STBI_tga	= 5,
	STBI_psd	= 6,
	STBI_pic	= 7,
	STBI_pnm	= 8,
	STBI_dds	= 9,
	STBI_pvr	= 10,
	STBI_pkm	= 11,
	STBI_hdr	= 12
};

extern int      stbi_test_from_memory      (stbi_uc const *buffer, int len);
extern int      stbi_test_from_callbacks   (stbi_io_callbacks const *clbk, void *user);

#ifndef STBI_NO_STDIO
extern int      stbi_test					(char const *filename);
extern int      stbi_test_from_file        (FILE *f);
#endif

#endif /* HEADER_STB_IMAGE_EXT */


#endif

#ifdef __cplusplus
}
#endif

//
//
////   end header file   /////////////////////////////////////////////////////
#endif // STBI_INCLUDE_STB_IMAGE_H

#ifdef STB_IMAGE_IMPLEMENTATION

#if defined(STBI_ONLY_JPEG) || defined(STBI_ONLY_PNG) || defined(STBI_ONLY_BMP) \
  || defined(STBI_ONLY_TGA) || defined(STBI_ONLY_GIF) || defined(STBI_ONLY_PSD) \
  || defined(STBI_ONLY_HDR) || defined(STBI_ONLY_PIC) || defined(STBI_ONLY_PNM) \
  || defined(STBI_ONLY_ZLIB)
   #ifndef STBI_ONLY_JPEG
   #define STBI_NO_JPEG
   #endif
   #ifndef STBI_ONLY_PNG
   #define STBI_NO_PNG
   #endif
   #ifndef STBI_ONLY_BMP
   #define STBI_NO_BMP
   #endif
   #ifndef STBI_ONLY_PSD
   #define STBI_NO_PSD
   #endif
   #ifndef STBI_ONLY_TGA
   #define STBI_NO_TGA
   #endif
   #ifndef STBI_ONLY_GIF
   #define STBI_NO_GIF
   #endif
   #ifndef STBI_ONLY_HDR
   #define STBI_NO_HDR
   #endif
   #ifndef STBI_ONLY_PIC
   #define STBI_NO_PIC
   #endif
   #ifndef STBI_ONLY_PNM
   #define STBI_NO_PNM
   #endif
#endif

#if defined(STBI_NO_PNG) && !defined(STBI_SUPPORT_ZLIB) && !defined(STBI_NO_ZLIB)
#define STBI_NO_ZLIB
#endif

#include <stdarg.h>
#include <stddef.h> // ptrdiff_t on osx
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#if !defined(STBI_NO_LINEAR) || !defined(STBI_NO_HDR)
#include <math.h>  // ldexp
#endif

#ifndef STBI_NO_STDIO
#include <stdio.h>
#endif

#ifndef STBI_ASSERT
#include <assert.h>
#define STBI_ASSERT(x) assert(x)
#endif

#ifndef _MSC_VER
   #ifdef __cplusplus
   #define stbi_inline inline
   #else
   #define stbi_inline
   #endif
#else
   #define stbi_inline __forceinline
#endif

#ifdef _MSC_VER
typedef unsigned short stbi__uint16;
typedef   signed short stbi__int16;
typedef unsigned int   stbi__uint32;
typedef   signed int   stbi__int32;
#else
#include <stdint.h>
typedef uint16_t stbi__uint16;
typedef int16_t  stbi__int16;
typedef uint32_t stbi__uint32;
typedef int32_t  stbi__int32;
#endif

// should produce compiler error if size is wrong
typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];

#ifdef _MSC_VER
#define STBI_NOTUSED(v)  (void)(v)
#else
#define STBI_NOTUSED(v)  (void)sizeof(v)
#endif

#ifdef _MSC_VER
#define STBI_HAS_LROTL
#endif

#ifdef STBI_HAS_LROTL
   #define stbi_lrot(x,y)  _lrotl(x,y)
#else
   #define stbi_lrot(x,y)  (((x) << (y)) | ((x) >> (32 - (y))))
#endif

#if defined(STBI_MALLOC) && defined(STBI_FREE) && (defined(STBI_REALLOC) || defined(STBI_REALLOC_SIZED))
// ok
#elif !defined(STBI_MALLOC) && !defined(STBI_FREE) && !defined(STBI_REALLOC) && !defined(STBI_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBI_MALLOC, STBI_FREE, and STBI_REALLOC (or STBI_REALLOC_SIZED)."
#endif

#ifndef STBI_MALLOC
#define STBI_MALLOC(sz)           malloc(sz)
#define STBI_REALLOC(p,newsz)     realloc(p,newsz)
#define STBI_FREE(p)              free(p)
#endif

#ifndef STBI_REALLOC_SIZED
#define STBI_REALLOC_SIZED(p,oldsz,newsz) STBI_REALLOC(p,newsz)
#endif

// x86/x64 detection
#if defined(__x86_64__) || defined(_M_X64)
#define STBI__X64_TARGET
#elif defined(__i386) || defined(_M_IX86)
#define STBI__X86_TARGET
#endif

#if defined(__GNUC__) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET)) && !defined(__SSE2__) && !defined(STBI_NO_SIMD)
// NOTE: not clear do we actually need this for the 64-bit path?
// gcc doesn't support sse2 intrinsics unless you compile with -msse2,
// (but compiling with -msse2 allows the compiler to use SSE2 everywhere;
// this is just broken and gcc are jerks for not fixing it properly
// http://www.virtualdub.org/blog/pivot/entry.php?id=363 )
#define STBI_NO_SIMD
#endif

#if defined(__MINGW32__) && !defined(__x86_64__) && !defined(STBI_NO_SIMD)
#define STBI_MINGW_ENABLE_SSE2
#define STBI_FORCE_STACK_ALIGN __attribute__((force_align_arg_pointer))
#else
#define STBI_FORCE_STACK_ALIGN
#endif

#if !defined(STBI_NO_SIMD) && (defined(STBI__X86_TARGET) || defined(STBI__X64_TARGET))
#define STBI_SSE2
#include <emmintrin.h>

#ifdef _MSC_VER

#if _MSC_VER >= 1400  // not VC6
#include <intrin.h> // __cpuid
static int stbi__cpuid3(void)
{
   int info[4];
   __cpuid(info,1);
   return info[3];
}
#else
static int stbi__cpuid3(void)
{
   int res;
   __asm {
	  mov  eax,1
	  cpuid
	  mov  res,edx
   }
   return res;
}
#endif

#define STBI_SIMD_ALIGN(type, name) __declspec(align(16)) type name

static int stbi__sse2_available()
{
   int info3 = stbi__cpuid3();
   return ((info3 >> 26) & 1) != 0;
}
#else // assume GCC-style if not VC++
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))

static int stbi__sse2_available()
{
   // If we're even attempting to compile this on GCC/Clang, that means
   // -msse2 is on, which means the compiler is allowed to use SSE2
   // instructions at will, and so are we.
   return 1;
}
#endif
#endif

// ARM NEON
#if defined(STBI_NO_SIMD) && defined(STBI_NEON)
#undef STBI_NEON
#endif

#ifdef STBI_NEON
#include <arm_neon.h>
// assume GCC or Clang on ARM targets
#define STBI_SIMD_ALIGN(type, name) type name __attribute__((aligned(16)))
#endif

#ifndef STBI_SIMD_ALIGN
#define STBI_SIMD_ALIGN(type, name) type name
#endif

///////////////////////////////////////////////
//
//  stbi__context struct and start_xxx functions

// stbi__context structure is our basic context used by all images, so it
// contains all the IO context, plus some basic image information
typedef struct
{
   stbi__uint32 img_x, img_y;
   int img_n, img_out_n;

   stbi_io_callbacks io;
   void *io_user_data;

   int read_from_callbacks;
   int buflen;
   stbi_uc buffer_start[128];

   stbi_uc *img_buffer, *img_buffer_end;
   stbi_uc *img_buffer_original, *img_buffer_original_end;
} stbi__context;

static void stbi__refill_buffer(stbi__context *s);

// initialize a memory-decode context
static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)
{
   s->io.read = NULL;
   s->read_from_callbacks = 0;
   s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;
   s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;
}

// initialize a callback-based context
static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)
{
   s->io = *c;
   s->io_user_data = user;
   s->buflen = sizeof(s->buffer_start);
   s->read_from_callbacks = 1;
   s->img_buffer_original = s->buffer_start;
   stbi__refill_buffer(s);
   s->img_buffer_original_end = s->img_buffer_end;
}

#ifndef STBI_NO_STDIO

static int stbi__stdio_read(void *user, char *data, int size)
{
   return (int) fread(data,1,size,(FILE*) user);
}

static void stbi__stdio_skip(void *user, int n)
{
   fseek((FILE*) user, n, SEEK_CUR);
}

static int stbi__stdio_eof(void *user)
{
   return feof((FILE*) user);
}

static stbi_io_callbacks stbi__stdio_callbacks =
{
   stbi__stdio_read,
   stbi__stdio_skip,
   stbi__stdio_eof,
};

static void stbi__start_file(stbi__context *s, FILE *f)
{
   stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);
}

//static void stop_file(stbi__context *s) { }

#endif // !STBI_NO_STDIO

static void stbi__rewind(stbi__context *s)
{
   // conceptually rewind SHOULD rewind to the beginning of the stream,
   // but we just rewind to the beginning of the initial buffer, because
   // we only use it after doing 'test', which only ever looks at at most 92 bytes
   s->img_buffer = s->img_buffer_original;
   s->img_buffer_end = s->img_buffer_original_end;
}

enum
{
   STBI_ORDER_RGB,
   STBI_ORDER_BGR
};

typedef struct
{
   int bits_per_channel;
   int num_channels;
   int channel_order;
} stbi__result_info;

#ifndef STBI_NO_JPEG
static int      stbi__jpeg_test(stbi__context *s);
static void    *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNG
static int      stbi__png_test(stbi__context *s);
static void    *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__png_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_BMP
static int      stbi__bmp_test(stbi__context *s);
static void    *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_TGA
static int      stbi__tga_test(stbi__context *s);
static void    *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__tga_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PSD
static int      stbi__psd_test(stbi__context *s);
static void    *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc);
static int      stbi__psd_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_HDR
static int      stbi__hdr_test(stbi__context *s);
static float   *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PIC
static int      stbi__pic_test(stbi__context *s);
static void    *stbi__pic_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pic_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_GIF
static int      stbi__gif_test(stbi__context *s);
static void    *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__gif_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_PNM
static int      stbi__pnm_test(stbi__context *s);
static void    *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri);
static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp);
#endif

#ifndef STBI_NO_DDS
static int      stbi__dds_test(stbi__context *s);
static void    *stbi__dds_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__dds_info(stbi__context *s, int *x, int *y, int *comp, int *iscompressed);
#endif

#ifndef STBI_NO_PVR
static int      stbi__pvr_test(stbi__context *s);
static void    *stbi__pvr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__pvr_info(stbi__context *s, int *x, int *y, int *comp, int * iscompressed);
#endif

#ifndef STBI_NO_PKM
static int      stbi__pkm_test(stbi__context *s);
static void    *stbi__pkm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp);
static int      stbi__pkm_info(stbi__context *s, int *x, int *y, int *comp);
#endif

// this is not threadsafe
static const char *stbi__g_failure_reason;

STBIDEF const char *stbi_failure_reason(void)
{
   return stbi__g_failure_reason;
}

static int stbi__err(const char *str)
{
   stbi__g_failure_reason = str;
   return 0;
}

static void *stbi__malloc(size_t size)
{
	return STBI_MALLOC(size);
}

// stb_image uses ints pervasively, including for offset calculations.
// therefore the largest decoded image size we can support with the
// current code, even on 64-bit targets, is INT_MAX. this is not a
// significant limitation for the intended use case.
//
// we do, however, need to make sure our size calculations don't
// overflow. hence a few helper functions for size calculations that
// multiply integers together, making sure that they're non-negative
// and no overflow occurs.

// return 1 if the sum is valid, 0 on overflow.
// negative terms are considered invalid.
static int stbi__addsizes_valid(int a, int b)
{
   if (b < 0) return 0;
   // now 0 <= b <= INT_MAX, hence also
   // 0 <= INT_MAX - b <= INTMAX.
   // And "a + b <= INT_MAX" (which might overflow) is the
   // same as a <= INT_MAX - b (no overflow)
   return a <= INT_MAX - b;
}

// returns 1 if the product is valid, 0 on overflow.
// negative factors are considered invalid.
static int stbi__mul2sizes_valid(int a, int b)
{
   if (a < 0 || b < 0) return 0;
   if (b == 0) return 1; // mul-by-0 is always safe
   // portable way to check for no overflows in a*b
   return a <= INT_MAX/b;
}

// returns 1 if "a*b + add" has no negative terms/factors and doesn't overflow
static int stbi__mad2sizes_valid(int a, int b, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);
}

// returns 1 if "a*b*c + add" has no negative terms/factors and doesn't overflow
static int stbi__mad3sizes_valid(int a, int b, int c, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
	  stbi__addsizes_valid(a*b*c, add);
}

// returns 1 if "a*b*c*d + add" has no negative terms/factors and doesn't overflow
static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)
{
   return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&
	  stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
}

// mallocs with size overflow checking
static void *stbi__malloc_mad2(int a, int b, int add)
{
   if (!stbi__mad2sizes_valid(a, b, add)) return NULL;
   return stbi__malloc(a*b + add);
}

static void *stbi__malloc_mad3(int a, int b, int c, int add)
{
   if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;
   return stbi__malloc(a*b*c + add);
}

static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)
{
   if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;
   return stbi__malloc(a*b*c*d + add);
}

// stbi__err - error
// stbi__errpf - error returning pointer to float
// stbi__errpuc - error returning pointer to unsigned char

#ifdef STBI_NO_FAILURE_STRINGS
   #define stbi__err(x,y)  0
#elif defined(STBI_FAILURE_USERMSG)
   #define stbi__err(x,y)  stbi__err(y)
#else
   #define stbi__err(x,y)  stbi__err(x)
#endif

#define stbi__errpf(x,y)   ((float *)(size_t) (stbi__err(x,y)?NULL:NULL))
#define stbi__errpuc(x,y)  ((unsigned char *)(size_t) (stbi__err(x,y)?NULL:NULL))

STBIDEF void stbi_image_free(void *retval_from_stbi_load)
{
   STBI_FREE(retval_from_stbi_load);
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp);
#endif

#ifndef STBI_NO_HDR
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp);
#endif

static int stbi__vertically_flip_on_load = 0;

STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)
{
	stbi__vertically_flip_on_load = flag_true_if_should_flip;
}

static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields
   ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed
   ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order
   ri->num_channels = 0;

   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);
   #endif
   #ifndef STBI_NO_DDS
   if (stbi__dds_test(s))  return stbi__dds_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_PVR
   if (stbi__pvr_test(s))  return stbi__pvr_load(s,x,y,comp,req_comp);
   #endif
   #ifndef STBI_NO_PKM
   if (stbi__pkm_test(s))  return stbi__pkm_load(s,x,y,comp,req_comp);
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
	  float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);
	  return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);
   }
   #endif

   #ifndef STBI_NO_TGA
   // test tga last because it's a crappy test!
   if (stbi__tga_test(s))
	  return stbi__tga_load(s,x,y,comp,req_comp, ri);
   #endif

   return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");
}

static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi_uc *reduced;

   reduced = (stbi_uc *) stbi__malloc(img_len);
   if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
	  reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

   STBI_FREE(orig);
   return reduced;
}

static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)
{
   int i;
   int img_len = w * h * channels;
   stbi__uint16 *enlarged;

   enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);
   if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

   for (i = 0; i < img_len; ++i)
	  enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

   STBI_FREE(orig);
   return enlarged;
}

static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

   if (result == NULL)
	  return NULL;

   if (ri.bits_per_channel != 8) {
	  STBI_ASSERT(ri.bits_per_channel == 16);
	  result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
	  ri.bits_per_channel = 8;
   }

   // @TODO: move stbi__convert_format to here

   if (stbi__vertically_flip_on_load) {
	  int w = *x, h = *y;
	  int channels = req_comp ? req_comp : *comp;
	  int row,col,z;
	  stbi_uc *image = (stbi_uc *) result;

	  // @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
	  for (row = 0; row < (h>>1); row++) {
		 for (col = 0; col < w; col++) {
			for (z = 0; z < channels; z++) {
			   stbi_uc temp = image[(row * w + col) * channels + z];
			   image[(row * w + col) * channels + z] = image[((h - row - 1) * w + col) * channels + z];
			   image[((h - row - 1) * w + col) * channels + z] = temp;
			}
		 }
	  }
   }

   return (unsigned char *) result;
}

static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   stbi__result_info ri;
   void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

   if (result == NULL)
	  return NULL;

   if (ri.bits_per_channel != 16) {
	  STBI_ASSERT(ri.bits_per_channel == 8);
	  result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);
	  ri.bits_per_channel = 16;
   }

   // @TODO: move stbi__convert_format16 to here
   // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision

   if (stbi__vertically_flip_on_load) {
	  int w = *x, h = *y;
	  int channels = req_comp ? req_comp : *comp;
	  int row,col,z;
	  stbi__uint16 *image = (stbi__uint16 *) result;

	  // @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
	  for (row = 0; row < (h>>1); row++) {
		 for (col = 0; col < w; col++) {
			for (z = 0; z < channels; z++) {
			   stbi__uint16 temp = image[(row * w + col) * channels + z];
			   image[(row * w + col) * channels + z] = image[((h - row - 1) * w + col) * channels + z];
			   image[((h - row - 1) * w + col) * channels + z] = temp;
			}
		 }
	  }
   }

   return (stbi__uint16 *) result;
}

#ifndef STBI_NO_HDR
static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)
{
   if (stbi__vertically_flip_on_load && result != NULL) {
	  int w = *x, h = *y;
	  int depth = req_comp ? req_comp : *comp;
	  int row,col,z;
	  float temp;

	  // @OPTIMIZE: use a bigger temp buffer and memcpy multiple pixels at once
	  for (row = 0; row < (h>>1); row++) {
		 for (col = 0; col < w; col++) {
			for (z = 0; z < depth; z++) {
			   temp = result[(row * w + col) * depth + z];
			   result[(row * w + col) * depth + z] = result[((h - row - 1) * w + col) * depth + z];
			   result[((h - row - 1) * w + col) * depth + z] = temp;
			}
		 }
	  }
   }
}
#endif

#ifndef STBI_NO_STDIO

static FILE *stbi__fopen(char const *filename, char const *mode)
{
   FILE *f;
#if defined(_MSC_VER) && _MSC_VER >= 1400
   if (0 != fopen_s(&f, filename, mode))
	  f=0;
#else
   f = fopen(filename, mode);
#endif
   return f;
}

STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   unsigned char *result;
   if (!f) return stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
   if (result) {
	  // need to 'unget' all the characters in the IO buffer
	  fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__uint16 *result;
   stbi__context s;
   stbi__start_file(&s,f);
   result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);
   if (result) {
	  // need to 'unget' all the characters in the IO buffer
	  fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);
   }
   return result;
}

STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   FILE *f = stbi__fopen(filename, "rb");
   stbi__uint16 *result;
   if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");
   result = stbi_load_from_file_16(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

#endif //!STBI_NO_STDIO

STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_LINEAR
static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
   unsigned char *data;
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s)) {
	  stbi__result_info ri;
	  float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);
	  if (hdr_data)
		 stbi__float_postprocess(hdr_data,x,y,comp,req_comp);
	  return hdr_data;
   }
   #endif
   data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);
   if (data)
	  return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);
   return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");
}

STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}

#ifndef STBI_NO_STDIO
STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)
{
   float *result;
   FILE *f = stbi__fopen(filename, "rb");
   if (!f) return stbi__errpf("can't fopen", "Unable to open file");
   result = stbi_loadf_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return result;
}

STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__loadf_main(&s,x,y,comp,req_comp);
}
#endif // !STBI_NO_STDIO

#endif // !STBI_NO_LINEAR

// these is-hdr-or-not is defined independent of whether STBI_NO_LINEAR is
// defined, for API simplicity; if STBI_NO_LINEAR is defined, it always
// reports false!

STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(buffer);
   STBI_NOTUSED(len);
   return 0;
   #endif
}

#ifndef STBI_NO_STDIO
STBIDEF int      stbi_is_hdr          (char const *filename)
{
   FILE *f = stbi__fopen(filename, "rb");
   int result=0;
   if (f) {
	  result = stbi_is_hdr_from_file(f);
	  fclose(f);
   }
   return result;
}

STBIDEF int      stbi_is_hdr_from_file(FILE *f)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(f);
   return 0;
   #endif
}
#endif // !STBI_NO_STDIO

STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   #ifndef STBI_NO_HDR
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__hdr_test(&s);
   #else
   STBI_NOTUSED(clbk);
   STBI_NOTUSED(user);
   return 0;
   #endif
}

#ifndef STBI_NO_LINEAR
static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;

STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }
STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }
#endif

static float stbi__h2l_gamma_i=1.0f/2.2f, stbi__h2l_scale_i=1.0f;

STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }
STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }

//////////////////////////////////////////////////////////////////////////////
//
// Common code used by all image loaders
//

enum
{
   STBI__SCAN_load=0,
   STBI__SCAN_type,
   STBI__SCAN_header
};

static void stbi__refill_buffer(stbi__context *s)
{
   int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);
   if (n == 0) {
	  // at end of file, treat same as if from memory, but need to handle case
	  // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
	  s->read_from_callbacks = 0;
	  s->img_buffer = s->buffer_start;
	  s->img_buffer_end = s->buffer_start+1;
	  *s->img_buffer = 0;
   } else {
	  s->img_buffer = s->buffer_start;
	  s->img_buffer_end = s->buffer_start + n;
   }
}

stbi_inline static stbi_uc stbi__get8(stbi__context *s)
{
   if (s->img_buffer < s->img_buffer_end)
	  return *s->img_buffer++;
   if (s->read_from_callbacks) {
	  stbi__refill_buffer(s);
	  return *s->img_buffer++;
   }
   return 0;
}

stbi_inline static int stbi__at_eof(stbi__context *s)
{
   if (s->io.read) {
	  if (!(s->io.eof)(s->io_user_data)) return 0;
	  // if feof() is true, check if buffer = end
	  // special case: we've only got the special 0 character at the end
	  if (s->read_from_callbacks == 0) return 1;
   }

   return s->img_buffer >= s->img_buffer_end;
}

static void stbi__skip(stbi__context *s, int n)
{
   if (n < 0) {
	  s->img_buffer = s->img_buffer_end;
	  return;
   }
   if (s->io.read) {
	  int blen = (int) (s->img_buffer_end - s->img_buffer);
	  if (blen < n) {
		 s->img_buffer = s->img_buffer_end;
		 (s->io.skip)(s->io_user_data, n - blen);
		 return;
	  }
   }
   s->img_buffer += n;
}

static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)
{
   if (s->io.read) {
	  int blen = (int) (s->img_buffer_end - s->img_buffer);
	  if (blen < n) {
		 int res, count;

		 memcpy(buffer, s->img_buffer, blen);

		 count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);
		 res = (count == (n-blen));
		 s->img_buffer = s->img_buffer_end;
		 return res;
	  }
   }

   if (s->img_buffer+n <= s->img_buffer_end) {
	  memcpy(buffer, s->img_buffer, n);
	  s->img_buffer += n;
	  return 1;
   } else
	  return 0;
}

static int stbi__get16be(stbi__context *s)
{
   int z = stbi__get8(s);
   return (z << 8) + stbi__get8(s);
}

static stbi__uint32 stbi__get32be(stbi__context *s)
{
   stbi__uint32 z = stbi__get16be(s);
   return (z << 16) + stbi__get16be(s);
}

#if defined(STBI_NO_BMP) && defined(STBI_NO_TGA) && defined(STBI_NO_GIF)
// nothing
#else
static int stbi__get16le(stbi__context *s)
{
   int z = stbi__get8(s);
   return z + (stbi__get8(s) << 8);
}
#endif

#ifndef STBI_NO_BMP
static stbi__uint32 stbi__get32le(stbi__context *s)
{
   stbi__uint32 z = stbi__get16le(s);
   return z + (stbi__get16le(s) << 16);
}
#endif

#define STBI__BYTECAST(x)  ((stbi_uc) ((x) & 255))  // truncate int to byte without warnings

//////////////////////////////////////////////////////////////////////////////
//
//  generic converter from built-in img_n to req_comp
//    individual types do this automatically as much as possible (e.g. jpeg
//    does all cases internally since it needs to colorspace convert anyway,
//    and it never has alpha, so very few cases ). png can automatically
//    interleave an alpha=255 channel, but falls back to this for other cases
//
//  assume data buffer is malloced, so malloc a new one and free that one
//  only failure mode is malloc failing

static stbi_uc stbi__compute_y(int r, int g, int b)
{
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}

static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   unsigned char *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);
   if (good == NULL) {
	  STBI_FREE(data);
	  return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
	  unsigned char *src  = data + j * x * img_n   ;
	  unsigned char *dest = good + j * x * req_comp;

	  #define STBI__COMBO(a,b)  ((a)*8+(b))
	  #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
	  // convert source image with img_n components to one with req_comp components;
	  // avoid switch per pixel, so use switch per scanline and massive macros
	  switch (STBI__COMBO(img_n, req_comp)) {
		 STBI__CASE(1,2) { dest[0]=src[0], dest[1]=255;                                     } break;
		 STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
		 STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=255;                     } break;
		 STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;
		 STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;
		 STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                  } break;
		 STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255;        } break;
		 STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
		 STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255;    } break;
		 STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;
		 STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; } break;
		 STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                    } break;
		 default: STBI_ASSERT(0);
	  }
	  #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}

static stbi__uint16 stbi__compute_y_16(int r, int g, int b)
{
   return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);
}

static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)
{
   int i,j;
   stbi__uint16 *good;

   if (req_comp == img_n) return data;
   STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

   good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);
   if (good == NULL) {
	  STBI_FREE(data);
	  return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
	  stbi__uint16 *src  = data + j * x * img_n   ;
	  stbi__uint16 *dest = good + j * x * req_comp;

	  #define STBI__COMBO(a,b)  ((a)*8+(b))
	  #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
	  // convert source image with img_n components to one with req_comp components;
	  // avoid switch per pixel, so use switch per scanline and massive macros
	  switch (STBI__COMBO(img_n, req_comp)) {
		 STBI__CASE(1,2) { dest[0]=src[0], dest[1]=0xffff;                                     } break;
		 STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
		 STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=0xffff;                     } break;
		 STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;
		 STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;
		 STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1];                     } break;
		 STBI__CASE(3,4) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=0xffff;        } break;
		 STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
		 STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = 0xffff; } break;
		 STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;
		 STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]), dest[1] = src[3]; } break;
		 STBI__CASE(4,3) { dest[0]=src[0],dest[1]=src[1],dest[2]=src[2];                       } break;
		 default: STBI_ASSERT(0);
	  }
	  #undef STBI__CASE
   }

   STBI_FREE(data);
   return good;
}

#ifndef STBI_NO_LINEAR
static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)
{
   int i,k,n;
   float *output;
   if (!data) return NULL;
   output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
	  for (k=0; k < n; ++k) {
		 output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);
	  }
	  if (k < comp) output[i*comp + k] = data[i*comp+k]/255.0f;
   }
   STBI_FREE(data);
   return output;
}
#endif

#ifndef STBI_NO_HDR
#define stbi__float2int(x)   ((int) (x))
static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)
{
   int i,k,n;
   stbi_uc *output;
   if (!data) return NULL;
   output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);
   if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }
   // compute number of non-alpha components
   if (comp & 1) n = comp; else n = comp-1;
   for (i=0; i < x*y; ++i) {
	  for (k=0; k < n; ++k) {
		 float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;
		 if (z < 0) z = 0;
		 if (z > 255) z = 255;
		 output[i*comp + k] = (stbi_uc) stbi__float2int(z);
	  }
	  if (k < comp) {
		 float z = data[i*comp+k] * 255 + 0.5f;
		 if (z < 0) z = 0;
		 if (z > 255) z = 255;
		 output[i*comp + k] = (stbi_uc) stbi__float2int(z);
	  }
   }
   STBI_FREE(data);
   return output;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
//  "baseline" JPEG/JFIF decoder
//
//    simple implementation
//      - doesn't support delayed output of y-dimension
//      - simple interface (only one output format: 8-bit interleaved RGB)
//      - doesn't try to recover corrupt jpegs
//      - doesn't allow partial loading, loading multiple at once
//      - still fast on x86 (copying globals into locals doesn't help x86)
//      - allocates lots of intermediate memory (full size of all components)
//        - non-interleaved case requires this anyway
//        - allows good upsampling (see next)
//    high-quality
//      - upsampled channels are bilinearly interpolated, even across blocks
//      - quality integer IDCT derived from IJG's 'slow'
//    performance
//      - fast huffman; reasonable integer IDCT
//      - some SIMD kernels for common paths on targets with SSE2/NEON
//      - uses a lot of intermediate memory, could cache poorly

#ifndef STBI_NO_JPEG

// huffman decoding acceleration
#define FAST_BITS   9  // larger handles more cases; smaller stomps less cache

typedef struct
{
   stbi_uc  fast[1 << FAST_BITS];
   // weirdly, repacking this into AoS is a 10% speed loss, instead of a win
   stbi__uint16 code[256];
   stbi_uc  values[256];
   stbi_uc  size[257];
   unsigned int maxcode[18];
   int    delta[17];   // old 'firstsymbol' - old 'firstcode'
} stbi__huffman;

typedef struct
{
   stbi__context *s;
   stbi__huffman huff_dc[4];
   stbi__huffman huff_ac[4];
   stbi__uint16 dequant[4][64];
   stbi__int16 fast_ac[4][1 << FAST_BITS];

// sizes for components, interleaved MCUs
   int img_h_max, img_v_max;
   int img_mcu_x, img_mcu_y;
   int img_mcu_w, img_mcu_h;

// definition of jpeg image component
   struct
   {
	  int id;
	  int h,v;
	  int tq;
	  int hd,ha;
	  int dc_pred;

	  int x,y,w2,h2;
	  stbi_uc *data;
	  void *raw_data, *raw_coeff;
	  stbi_uc *linebuf;
	  short   *coeff;   // progressive only
	  int      coeff_w, coeff_h; // number of 8x8 coefficient blocks
   } img_comp[4];

   stbi__uint32   code_buffer; // jpeg entropy-coded buffer
   int            code_bits;   // number of valid bits
   unsigned char  marker;      // marker seen while filling entropy buffer
   int            nomore;      // flag if we saw a marker so must stop

   int            progressive;
   int            spec_start;
   int            spec_end;
   int            succ_high;
   int            succ_low;
   int            eob_run;
   int            jfif;
   int            app14_color_transform; // Adobe APP14 tag
   int            rgb;

   int scan_n, order[4];
   int restart_interval, todo;

// kernels
   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);
   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);
   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);
} stbi__jpeg;

static int stbi__build_huffman(stbi__huffman *h, int *count)
{
   int i,j,k=0,code;
   // build size list for each symbol (from JPEG spec)
   for (i=0; i < 16; ++i)
	  for (j=0; j < count[i]; ++j)
		 h->size[k++] = (stbi_uc) (i+1);
   h->size[k] = 0;

   // compute actual symbols (from jpeg spec)
   code = 0;
   k = 0;
   for(j=1; j <= 16; ++j) {
	  // compute delta to add to code to compute symbol id
	  h->delta[j] = k - code;
	  if (h->size[k] == j) {
		 while (h->size[k] == j)
			h->code[k++] = (stbi__uint16) (code++);
		 if (code-1 >= (1 << j)) return stbi__err("bad code lengths","Corrupt JPEG");
	  }
	  // compute largest code + 1 for this size, preshifted as needed later
	  h->maxcode[j] = code << (16-j);
	  code <<= 1;
   }
   h->maxcode[j] = 0xffffffff;

   // build non-spec acceleration table; 255 is flag for not-accelerated
   memset(h->fast, 255, 1 << FAST_BITS);
   for (i=0; i < k; ++i) {
	  int s = h->size[i];
	  if (s <= FAST_BITS) {
		 int c = h->code[i] << (FAST_BITS-s);
		 int m = 1 << (FAST_BITS-s);
		 for (j=0; j < m; ++j) {
			h->fast[c+j] = (stbi_uc) i;
		 }
	  }
   }
   return 1;
}

// build a table that decodes both magnitude and value of small ACs in
// one go.
static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)
{
   int i;
   for (i=0; i < (1 << FAST_BITS); ++i) {
	  stbi_uc fast = h->fast[i];
	  fast_ac[i] = 0;
	  if (fast < 255) {
		 int rs = h->values[fast];
		 int run = (rs >> 4) & 15;
		 int magbits = rs & 15;
		 int len = h->size[fast];

		 if (magbits && len + magbits <= FAST_BITS) {
			// magnitude code followed by receive_extend code
			int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);
			int m = 1 << (magbits - 1);
			if (k < m) k += (~0U << magbits) + 1;
			// if the result is small enough, we can fit it in fast_ac table
			if (k >= -128 && k <= 127)
			   fast_ac[i] = (stbi__int16) ((k << 8) + (run << 4) + (len + magbits));
		 }
	  }
   }
}

static void stbi__grow_buffer_unsafe(stbi__jpeg *j)
{
   do {
	  int b = j->nomore ? 0 : stbi__get8(j->s);
	  if (b == 0xff) {
		 int c = stbi__get8(j->s);
		 while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes
		 if (c != 0) {
			j->marker = (unsigned char) c;
			j->nomore = 1;
			return;
		 }
	  }
	  j->code_buffer |= b << (24 - j->code_bits);
	  j->code_bits += 8;
   } while (j->code_bits <= 24);
}

// (1 << n) - 1
static stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};

// decode a jpeg huffman value from the bitstream
stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)
{
   unsigned int temp;
   int c,k;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   // look at the top FAST_BITS and determine what symbol ID it is,
   // if the code is <= FAST_BITS
   c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
   k = h->fast[c];
   if (k < 255) {
	  int s = h->size[k];
	  if (s > j->code_bits)
		 return -1;
	  j->code_buffer <<= s;
	  j->code_bits -= s;
	  return h->values[k];
   }

   // naive test is to shift the code_buffer down so k bits are
   // valid, then test against maxcode. To speed this up, we've
   // preshifted maxcode left so that it has (16-k) 0s at the
   // end; in other words, regardless of the number of bits, it
   // wants to be compared against something shifted to have 16;
   // that way we don't need to shift inside the loop.
   temp = j->code_buffer >> 16;
   for (k=FAST_BITS+1 ; ; ++k)
	  if (temp < h->maxcode[k])
		 break;
   if (k == 17) {
	  // error! code not found
	  j->code_bits -= 16;
	  return -1;
   }

   if (k > j->code_bits)
	  return -1;

   // convert the huffman code to the symbol id
   c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];
   STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

   // convert the id to a symbol
   j->code_bits -= k;
   j->code_buffer <<= k;
   return h->values[c];
}

// bias[n] = (-1<<n) + 1
static int const stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};

// combined JPEG 'receive' and JPEG 'extend', since baseline
// always extends everything it receives.
stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)
{
   unsigned int k;
   int sgn;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

   sgn = (stbi__int32)j->code_buffer >> 31; // sign bit is always in MSB
   k = stbi_lrot(j->code_buffer, n);
   STBI_ASSERT(n >= 0 && n < (int) (sizeof(stbi__bmask)/sizeof(*stbi__bmask)));
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k + (stbi__jbias[n] & ~sgn);
}

// get some unsigned bits
stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)
{
   unsigned int k;
   if (j->code_bits < n) stbi__grow_buffer_unsafe(j);
   k = stbi_lrot(j->code_buffer, n);
   j->code_buffer = k & ~stbi__bmask[n];
   k &= stbi__bmask[n];
   j->code_bits -= n;
   return k;
}

stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)
{
   unsigned int k;
   if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);
   k = j->code_buffer;
   j->code_buffer <<= 1;
   --j->code_bits;
   return k & 0x80000000;
}

// given a value that's at position X in the zigzag stream,
// where does it appear in the 8x8 matrix coded as row-major?
static stbi_uc stbi__jpeg_dezigzag[64+15] =
{
	0,  1,  8, 16,  9,  2,  3, 10,
   17, 24, 32, 25, 18, 11,  4,  5,
   12, 19, 26, 33, 40, 48, 41, 34,
   27, 20, 13,  6,  7, 14, 21, 28,
   35, 42, 49, 56, 57, 50, 43, 36,
   29, 22, 15, 23, 30, 37, 44, 51,
   58, 59, 52, 45, 38, 31, 39, 46,
   53, 60, 61, 54, 47, 55, 62, 63,
   // let corrupt input sample past end
   63, 63, 63, 63, 63, 63, 63, 63,
   63, 63, 63, 63, 63, 63, 63
};

// decode one 64-entry block--
static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)
{
   int diff,dc,k;
   int t;

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
   t = stbi__jpeg_huff_decode(j, hdc);
   if (t < 0) return stbi__err("bad huffman code","Corrupt JPEG");

   // 0 all the ac values now so we can do it 32-bits at a time
   memset(data,0,64*sizeof(data[0]));

   diff = t ? stbi__extend_receive(j, t) : 0;
   dc = j->img_comp[b].dc_pred + diff;
   j->img_comp[b].dc_pred = dc;
   data[0] = (short) (dc * dequant[0]);

   // decode AC components, see JPEG spec
   k = 1;
   do {
	  unsigned int zig;
	  int c,r,s;
	  if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
	  c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
	  r = fac[c];
	  if (r) { // fast-AC path
		 k += (r >> 4) & 15; // run
		 s = r & 15; // combined length
		 j->code_buffer <<= s;
		 j->code_bits -= s;
		 // decode into unzigzag'd location
		 zig = stbi__jpeg_dezigzag[k++];
		 data[zig] = (short) ((r >> 8) * dequant[zig]);
	  } else {
		 int rs = stbi__jpeg_huff_decode(j, hac);
		 if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
		 s = rs & 15;
		 r = rs >> 4;
		 if (s == 0) {
			if (rs != 0xf0) break; // end block
			k += 16;
		 } else {
			k += r;
			// decode into unzigzag'd location
			zig = stbi__jpeg_dezigzag[k++];
			data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);
		 }
	  }
   } while (k < 64);
   return 1;
}

static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)
{
   int diff,dc;
   int t;
   if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

   if (j->succ_high == 0) {
	  // first scan for DC coefficient, must be first
	  memset(data,0,64*sizeof(data[0])); // 0 all the ac values now
	  t = stbi__jpeg_huff_decode(j, hdc);
	  diff = t ? stbi__extend_receive(j, t) : 0;

	  dc = j->img_comp[b].dc_pred + diff;
	  j->img_comp[b].dc_pred = dc;
	  data[0] = (short) (dc << j->succ_low);
   } else {
	  // refinement scan for DC coefficient
	  if (stbi__jpeg_get_bit(j))
		 data[0] += (short) (1 << j->succ_low);
   }
   return 1;
}

// @OPTIMIZE: store non-zigzagged during the decode passes,
// and only de-zigzag when dequantizing
static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)
{
   int k;
   if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

   if (j->succ_high == 0) {
	  int shift = j->succ_low;

	  if (j->eob_run) {
		 --j->eob_run;
		 return 1;
	  }

	  k = j->spec_start;
	  do {
		 unsigned int zig;
		 int c,r,s;
		 if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);
		 c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);
		 r = fac[c];
		 if (r) { // fast-AC path
			k += (r >> 4) & 15; // run
			s = r & 15; // combined length
			j->code_buffer <<= s;
			j->code_bits -= s;
			zig = stbi__jpeg_dezigzag[k++];
			data[zig] = (short) ((r >> 8) << shift);
		 } else {
			int rs = stbi__jpeg_huff_decode(j, hac);
			if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
			s = rs & 15;
			r = rs >> 4;
			if (s == 0) {
			   if (r < 15) {
				  j->eob_run = (1 << r);
				  if (r)
					 j->eob_run += stbi__jpeg_get_bits(j, r);
				  --j->eob_run;
				  break;
			   }
			   k += 16;
			} else {
			   k += r;
			   zig = stbi__jpeg_dezigzag[k++];
			   data[zig] = (short) (stbi__extend_receive(j,s) << shift);
			}
		 }
	  } while (k <= j->spec_end);
   } else {
	  // refinement scan for these AC coefficients

	  short bit = (short) (1 << j->succ_low);

	  if (j->eob_run) {
		 --j->eob_run;
		 for (k = j->spec_start; k <= j->spec_end; ++k) {
			short *p = &data[stbi__jpeg_dezigzag[k]];
			if (*p != 0)
			   if (stbi__jpeg_get_bit(j))
				  if ((*p & bit)==0) {
					 if (*p > 0)
						*p += bit;
					 else
						*p -= bit;
				  }
		 }
	  } else {
		 k = j->spec_start;
		 do {
			int r,s;
			int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh
			if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");
			s = rs & 15;
			r = rs >> 4;
			if (s == 0) {
			   if (r < 15) {
				  j->eob_run = (1 << r) - 1;
				  if (r)
					 j->eob_run += stbi__jpeg_get_bits(j, r);
				  r = 64; // force end of block
			   } else {
				  // r=15 s=0 should write 16 0s, so we just do
				  // a run of 15 0s and then write s (which is 0),
				  // so we don't have to do anything special here
			   }
			} else {
			   if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");
			   // sign bit
			   if (stbi__jpeg_get_bit(j))
				  s = bit;
			   else
				  s = -bit;
			}

			// advance by r
			while (k <= j->spec_end) {
			   short *p = &data[stbi__jpeg_dezigzag[k++]];
			   if (*p != 0) {
				  if (stbi__jpeg_get_bit(j))
					 if ((*p & bit)==0) {
						if (*p > 0)
						   *p += bit;
						else
						   *p -= bit;
					 }
			   } else {
				  if (r == 0) {
					 *p = (short) s;
					 break;
				  }
				  --r;
			   }
			}
		 } while (k <= j->spec_end);
	  }
   }
   return 1;
}

// take a -128..127 value and stbi__clamp it and convert to 0..255
stbi_inline static stbi_uc stbi__clamp(int x)
{
   // trick to use a single test to catch both cases
   if ((unsigned int) x > 255) {
	  if (x < 0) return 0;
	  if (x > 255) return 255;
   }
   return (stbi_uc) x;
}

#define stbi__f2f(x)  ((int) (((x) * 4096 + 0.5)))
#define stbi__fsh(x)  ((x) << 12)

// derived from jidctint -- DCT_ISLOW
#define STBI__IDCT_1D(s0,s1,s2,s3,s4,s5,s6,s7) \
   int t0,t1,t2,t3,p1,p2,p3,p4,p5,x0,x1,x2,x3; \
   p2 = s2;                                    \
   p3 = s6;                                    \
   p1 = (p2+p3) * stbi__f2f(0.5411961f);       \
   t2 = p1 + p3*stbi__f2f(-1.847759065f);      \
   t3 = p1 + p2*stbi__f2f( 0.765366865f);      \
   p2 = s0;                                    \
   p3 = s4;                                    \
   t0 = stbi__fsh(p2+p3);                      \
   t1 = stbi__fsh(p2-p3);                      \
   x0 = t0+t3;                                 \
   x3 = t0-t3;                                 \
   x1 = t1+t2;                                 \
   x2 = t1-t2;                                 \
   t0 = s7;                                    \
   t1 = s5;                                    \
   t2 = s3;                                    \
   t3 = s1;                                    \
   p3 = t0+t2;                                 \
   p4 = t1+t3;                                 \
   p1 = t0+t3;                                 \
   p2 = t1+t2;                                 \
   p5 = (p3+p4)*stbi__f2f( 1.175875602f);      \
   t0 = t0*stbi__f2f( 0.298631336f);           \
   t1 = t1*stbi__f2f( 2.053119869f);           \
   t2 = t2*stbi__f2f( 3.072711026f);           \
   t3 = t3*stbi__f2f( 1.501321110f);           \
   p1 = p5 + p1*stbi__f2f(-0.899976223f);      \
   p2 = p5 + p2*stbi__f2f(-2.562915447f);      \
   p3 = p3*stbi__f2f(-1.961570560f);           \
   p4 = p4*stbi__f2f(-0.390180644f);           \
   t3 += p1+p4;                                \
   t2 += p2+p3;                                \
   t1 += p2+p4;                                \
   t0 += p1+p3;

static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])
{
   int i,val[64],*v=val;
   stbi_uc *o;
   short *d = data;

   // columns
   for (i=0; i < 8; ++i,++d, ++v) {
	  // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
	  if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
		   && d[40]==0 && d[48]==0 && d[56]==0) {
		 //    no shortcut                 0     seconds
		 //    (1|2|3|4|5|6|7)==0          0     seconds
		 //    all separate               -0.047 seconds
		 //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
		 int dcterm = d[0] << 2;
		 v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;
	  } else {
		 STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])
		 // constants scaled things up by 1<<12; let's bring them back
		 // down, but keep 2 extra bits of precision
		 x0 += 512; x1 += 512; x2 += 512; x3 += 512;
		 v[ 0] = (x0+t3) >> 10;
		 v[56] = (x0-t3) >> 10;
		 v[ 8] = (x1+t2) >> 10;
		 v[48] = (x1-t2) >> 10;
		 v[16] = (x2+t1) >> 10;
		 v[40] = (x2-t1) >> 10;
		 v[24] = (x3+t0) >> 10;
		 v[32] = (x3-t0) >> 10;
	  }
   }

   for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {
	  // no fast case since the first 1D IDCT spread components out
	  STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])
	  // constants scaled things up by 1<<12, plus we had 1<<2 from first
	  // loop, plus horizontal and vertical each scale by sqrt(8) so together
	  // we've got an extra 1<<3, so 1<<17 total we need to remove.
	  // so we want to round that, which means adding 0.5 * 1<<17,
	  // aka 65536. Also, we'll end up with -128 to 127 that we want
	  // to encode as 0..255 by adding 128, so we'll add that before the shift
	  x0 += 65536 + (128<<17);
	  x1 += 65536 + (128<<17);
	  x2 += 65536 + (128<<17);
	  x3 += 65536 + (128<<17);
	  // tried computing the shifts into temps, or'ing the temps to see
	  // if any were out of range, but that was slower
	  o[0] = stbi__clamp((x0+t3) >> 17);
	  o[7] = stbi__clamp((x0-t3) >> 17);
	  o[1] = stbi__clamp((x1+t2) >> 17);
	  o[6] = stbi__clamp((x1-t2) >> 17);
	  o[2] = stbi__clamp((x2+t1) >> 17);
	  o[5] = stbi__clamp((x2-t1) >> 17);
	  o[3] = stbi__clamp((x3+t0) >> 17);
	  o[4] = stbi__clamp((x3-t0) >> 17);
   }
}

#ifdef STBI_SSE2
// sse2 integer IDCT. not the fastest possible implementation but it
// produces bit-identical results to the generic C version so it's
// fully "transparent".
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   // This is constructed to match our regular (generic) integer IDCT exactly.
   __m128i row0, row1, row2, row3, row4, row5, row6, row7;
   __m128i tmp;

   // dot product constant: even elems=x, odd elems=y
   #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))

   // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
   // out(1) = c1[even]*x + c1[odd]*y
   #define dct_rot(out0,out1, x,y,c0,c1) \
	  __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
	  __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
	  __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
	  __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
	  __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
	  __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)

   // out = in << 12  (in 16-bit, out 32-bit)
   #define dct_widen(out, in) \
	  __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
	  __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)

   // wide add
   #define dct_wadd(out, a, b) \
	  __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
	  __m128i out##_h = _mm_add_epi32(a##_h, b##_h)

   // wide sub
   #define dct_wsub(out, a, b) \
	  __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
	  __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)

   // butterfly a/b, add bias, then shift by "s" and pack
   #define dct_bfly32o(out0, out1, a,b,bias,s) \
	  { \
		 __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
		 __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
		 dct_wadd(sum, abiased, b); \
		 dct_wsub(dif, abiased, b); \
		 out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
		 out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
	  }

   // 8-bit interleave step (for transposes)
   #define dct_interleave8(a, b) \
	  tmp = a; \
	  a = _mm_unpacklo_epi8(a, b); \
	  b = _mm_unpackhi_epi8(tmp, b)

   // 16-bit interleave step (for transposes)
   #define dct_interleave16(a, b) \
	  tmp = a; \
	  a = _mm_unpacklo_epi16(a, b); \
	  b = _mm_unpackhi_epi16(tmp, b)

   #define dct_pass(bias,shift) \
	  { \
		 /* even part */ \
		 dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
		 __m128i sum04 = _mm_add_epi16(row0, row4); \
		 __m128i dif04 = _mm_sub_epi16(row0, row4); \
		 dct_widen(t0e, sum04); \
		 dct_widen(t1e, dif04); \
		 dct_wadd(x0, t0e, t3e); \
		 dct_wsub(x3, t0e, t3e); \
		 dct_wadd(x1, t1e, t2e); \
		 dct_wsub(x2, t1e, t2e); \
		 /* odd part */ \
		 dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
		 dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
		 __m128i sum17 = _mm_add_epi16(row1, row7); \
		 __m128i sum35 = _mm_add_epi16(row3, row5); \
		 dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
		 dct_wadd(x4, y0o, y4o); \
		 dct_wadd(x5, y1o, y5o); \
		 dct_wadd(x6, y2o, y5o); \
		 dct_wadd(x7, y3o, y4o); \
		 dct_bfly32o(row0,row7, x0,x7,bias,shift); \
		 dct_bfly32o(row1,row6, x1,x6,bias,shift); \
		 dct_bfly32o(row2,row5, x2,x5,bias,shift); \
		 dct_bfly32o(row3,row4, x3,x4,bias,shift); \
	  }

   __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));
   __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));
   __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));
   __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));
   __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));
   __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));
   __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));
   __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

   // rounding biases in column/row passes, see stbi__idct_block for explanation.
   __m128i bias_0 = _mm_set1_epi32(512);
   __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

   // load
   row0 = _mm_load_si128((const __m128i *) (data + 0*8));
   row1 = _mm_load_si128((const __m128i *) (data + 1*8));
   row2 = _mm_load_si128((const __m128i *) (data + 2*8));
   row3 = _mm_load_si128((const __m128i *) (data + 3*8));
   row4 = _mm_load_si128((const __m128i *) (data + 4*8));
   row5 = _mm_load_si128((const __m128i *) (data + 5*8));
   row6 = _mm_load_si128((const __m128i *) (data + 6*8));
   row7 = _mm_load_si128((const __m128i *) (data + 7*8));

   // column pass
   dct_pass(bias_0, 10);

   {
	  // 16bit 8x8 transpose pass 1
	  dct_interleave16(row0, row4);
	  dct_interleave16(row1, row5);
	  dct_interleave16(row2, row6);
	  dct_interleave16(row3, row7);

	  // transpose pass 2
	  dct_interleave16(row0, row2);
	  dct_interleave16(row1, row3);
	  dct_interleave16(row4, row6);
	  dct_interleave16(row5, row7);

	  // transpose pass 3
	  dct_interleave16(row0, row1);
	  dct_interleave16(row2, row3);
	  dct_interleave16(row4, row5);
	  dct_interleave16(row6, row7);
   }

   // row pass
   dct_pass(bias_1, 17);

   {
	  // pack
	  __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7
	  __m128i p1 = _mm_packus_epi16(row2, row3);
	  __m128i p2 = _mm_packus_epi16(row4, row5);
	  __m128i p3 = _mm_packus_epi16(row6, row7);

	  // 8bit 8x8 transpose pass 1
	  dct_interleave8(p0, p2); // a0e0a1e1...
	  dct_interleave8(p1, p3); // c0g0c1g1...

	  // transpose pass 2
	  dct_interleave8(p0, p1); // a0c0e0g0...
	  dct_interleave8(p2, p3); // b0d0f0h0...

	  // transpose pass 3
	  dct_interleave8(p0, p2); // a0b0c0d0...
	  dct_interleave8(p1, p3); // a4b4c4d4...

	  // store
	  _mm_storel_epi64((__m128i *) out, p0); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, p2); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, p1); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, p3); out += out_stride;
	  _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));
   }

#undef dct_const
#undef dct_rot
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_interleave8
#undef dct_interleave16
#undef dct_pass
}

#endif // STBI_SSE2

#ifdef STBI_NEON

// NEON integer IDCT. should produce bit-identical
// results to the generic C version.
static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])
{
   int16x8_t row0, row1, row2, row3, row4, row5, row6, row7;

   int16x4_t rot0_0 = vdup_n_s16(stbi__f2f(0.5411961f));
   int16x4_t rot0_1 = vdup_n_s16(stbi__f2f(-1.847759065f));
   int16x4_t rot0_2 = vdup_n_s16(stbi__f2f( 0.765366865f));
   int16x4_t rot1_0 = vdup_n_s16(stbi__f2f( 1.175875602f));
   int16x4_t rot1_1 = vdup_n_s16(stbi__f2f(-0.899976223f));
   int16x4_t rot1_2 = vdup_n_s16(stbi__f2f(-2.562915447f));
   int16x4_t rot2_0 = vdup_n_s16(stbi__f2f(-1.961570560f));
   int16x4_t rot2_1 = vdup_n_s16(stbi__f2f(-0.390180644f));
   int16x4_t rot3_0 = vdup_n_s16(stbi__f2f( 0.298631336f));
   int16x4_t rot3_1 = vdup_n_s16(stbi__f2f( 2.053119869f));
   int16x4_t rot3_2 = vdup_n_s16(stbi__f2f( 3.072711026f));
   int16x4_t rot3_3 = vdup_n_s16(stbi__f2f( 1.501321110f));

#define dct_long_mul(out, inq, coeff) \
   int32x4_t out##_l = vmull_s16(vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmull_s16(vget_high_s16(inq), coeff)

#define dct_long_mac(out, acc, inq, coeff) \
   int32x4_t out##_l = vmlal_s16(acc##_l, vget_low_s16(inq), coeff); \
   int32x4_t out##_h = vmlal_s16(acc##_h, vget_high_s16(inq), coeff)

#define dct_widen(out, inq) \
   int32x4_t out##_l = vshll_n_s16(vget_low_s16(inq), 12); \
   int32x4_t out##_h = vshll_n_s16(vget_high_s16(inq), 12)

// wide add
#define dct_wadd(out, a, b) \
   int32x4_t out##_l = vaddq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vaddq_s32(a##_h, b##_h)

// wide sub
#define dct_wsub(out, a, b) \
   int32x4_t out##_l = vsubq_s32(a##_l, b##_l); \
   int32x4_t out##_h = vsubq_s32(a##_h, b##_h)

// butterfly a/b, then shift using "shiftop" by "s" and pack
#define dct_bfly32o(out0,out1, a,b,shiftop,s) \
   { \
	  dct_wadd(sum, a, b); \
	  dct_wsub(dif, a, b); \
	  out0 = vcombine_s16(shiftop(sum_l, s), shiftop(sum_h, s)); \
	  out1 = vcombine_s16(shiftop(dif_l, s), shiftop(dif_h, s)); \
   }

#define dct_pass(shiftop, shift) \
   { \
	  /* even part */ \
	  int16x8_t sum26 = vaddq_s16(row2, row6); \
	  dct_long_mul(p1e, sum26, rot0_0); \
	  dct_long_mac(t2e, p1e, row6, rot0_1); \
	  dct_long_mac(t3e, p1e, row2, rot0_2); \
	  int16x8_t sum04 = vaddq_s16(row0, row4); \
	  int16x8_t dif04 = vsubq_s16(row0, row4); \
	  dct_widen(t0e, sum04); \
	  dct_widen(t1e, dif04); \
	  dct_wadd(x0, t0e, t3e); \
	  dct_wsub(x3, t0e, t3e); \
	  dct_wadd(x1, t1e, t2e); \
	  dct_wsub(x2, t1e, t2e); \
	  /* odd part */ \
	  int16x8_t sum15 = vaddq_s16(row1, row5); \
	  int16x8_t sum17 = vaddq_s16(row1, row7); \
	  int16x8_t sum35 = vaddq_s16(row3, row5); \
	  int16x8_t sum37 = vaddq_s16(row3, row7); \
	  int16x8_t sumodd = vaddq_s16(sum17, sum35); \
	  dct_long_mul(p5o, sumodd, rot1_0); \
	  dct_long_mac(p1o, p5o, sum17, rot1_1); \
	  dct_long_mac(p2o, p5o, sum35, rot1_2); \
	  dct_long_mul(p3o, sum37, rot2_0); \
	  dct_long_mul(p4o, sum15, rot2_1); \
	  dct_wadd(sump13o, p1o, p3o); \
	  dct_wadd(sump24o, p2o, p4o); \
	  dct_wadd(sump23o, p2o, p3o); \
	  dct_wadd(sump14o, p1o, p4o); \
	  dct_long_mac(x4, sump13o, row7, rot3_0); \
	  dct_long_mac(x5, sump24o, row5, rot3_1); \
	  dct_long_mac(x6, sump23o, row3, rot3_2); \
	  dct_long_mac(x7, sump14o, row1, rot3_3); \
	  dct_bfly32o(row0,row7, x0,x7,shiftop,shift); \
	  dct_bfly32o(row1,row6, x1,x6,shiftop,shift); \
	  dct_bfly32o(row2,row5, x2,x5,shiftop,shift); \
	  dct_bfly32o(row3,row4, x3,x4,shiftop,shift); \
   }

   // load
   row0 = vld1q_s16(data + 0*8);
   row1 = vld1q_s16(data + 1*8);
   row2 = vld1q_s16(data + 2*8);
   row3 = vld1q_s16(data + 3*8);
   row4 = vld1q_s16(data + 4*8);
   row5 = vld1q_s16(data + 5*8);
   row6 = vld1q_s16(data + 6*8);
   row7 = vld1q_s16(data + 7*8);

   // add DC bias
   row0 = vaddq_s16(row0, vsetq_lane_s16(1024, vdupq_n_s16(0), 0));

   // column pass
   dct_pass(vrshrn_n_s32, 10);

   // 16bit 8x8 transpose
   {
// these three map to a single VTRN.16, VTRN.32, and VSWP, respectively.
// whether compilers actually get this is another story, sadly.
#define dct_trn16(x, y) { int16x8x2_t t = vtrnq_s16(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn32(x, y) { int32x4x2_t t = vtrnq_s32(vreinterpretq_s32_s16(x), vreinterpretq_s32_s16(y)); x = vreinterpretq_s16_s32(t.val[0]); y = vreinterpretq_s16_s32(t.val[1]); }
#define dct_trn64(x, y) { int16x8_t x0 = x; int16x8_t y0 = y; x = vcombine_s16(vget_low_s16(x0), vget_low_s16(y0)); y = vcombine_s16(vget_high_s16(x0), vget_high_s16(y0)); }

	  // pass 1
	  dct_trn16(row0, row1); // a0b0a2b2a4b4a6b6
	  dct_trn16(row2, row3);
	  dct_trn16(row4, row5);
	  dct_trn16(row6, row7);

	  // pass 2
	  dct_trn32(row0, row2); // a0b0c0d0a4b4c4d4
	  dct_trn32(row1, row3);
	  dct_trn32(row4, row6);
	  dct_trn32(row5, row7);

	  // pass 3
	  dct_trn64(row0, row4); // a0b0c0d0e0f0g0h0
	  dct_trn64(row1, row5);
	  dct_trn64(row2, row6);
	  dct_trn64(row3, row7);

#undef dct_trn16
#undef dct_trn32
#undef dct_trn64
   }

   // row pass
   // vrshrn_n_s32 only supports shifts up to 16, we need
   // 17. so do a non-rounding shift of 16 first then follow
   // up with a rounding shift by 1.
   dct_pass(vshrn_n_s32, 16);

   {
	  // pack and round
	  uint8x8_t p0 = vqrshrun_n_s16(row0, 1);
	  uint8x8_t p1 = vqrshrun_n_s16(row1, 1);
	  uint8x8_t p2 = vqrshrun_n_s16(row2, 1);
	  uint8x8_t p3 = vqrshrun_n_s16(row3, 1);
	  uint8x8_t p4 = vqrshrun_n_s16(row4, 1);
	  uint8x8_t p5 = vqrshrun_n_s16(row5, 1);
	  uint8x8_t p6 = vqrshrun_n_s16(row6, 1);
	  uint8x8_t p7 = vqrshrun_n_s16(row7, 1);

	  // again, these can translate into one instruction, but often don't.
#define dct_trn8_8(x, y) { uint8x8x2_t t = vtrn_u8(x, y); x = t.val[0]; y = t.val[1]; }
#define dct_trn8_16(x, y) { uint16x4x2_t t = vtrn_u16(vreinterpret_u16_u8(x), vreinterpret_u16_u8(y)); x = vreinterpret_u8_u16(t.val[0]); y = vreinterpret_u8_u16(t.val[1]); }
#define dct_trn8_32(x, y) { uint32x2x2_t t = vtrn_u32(vreinterpret_u32_u8(x), vreinterpret_u32_u8(y)); x = vreinterpret_u8_u32(t.val[0]); y = vreinterpret_u8_u32(t.val[1]); }

	  // sadly can't use interleaved stores here since we only write
	  // 8 bytes to each scan line!

	  // 8x8 8-bit transpose pass 1
	  dct_trn8_8(p0, p1);
	  dct_trn8_8(p2, p3);
	  dct_trn8_8(p4, p5);
	  dct_trn8_8(p6, p7);

	  // pass 2
	  dct_trn8_16(p0, p2);
	  dct_trn8_16(p1, p3);
	  dct_trn8_16(p4, p6);
	  dct_trn8_16(p5, p7);

	  // pass 3
	  dct_trn8_32(p0, p4);
	  dct_trn8_32(p1, p5);
	  dct_trn8_32(p2, p6);
	  dct_trn8_32(p3, p7);

	  // store
	  vst1_u8(out, p0); out += out_stride;
	  vst1_u8(out, p1); out += out_stride;
	  vst1_u8(out, p2); out += out_stride;
	  vst1_u8(out, p3); out += out_stride;
	  vst1_u8(out, p4); out += out_stride;
	  vst1_u8(out, p5); out += out_stride;
	  vst1_u8(out, p6); out += out_stride;
	  vst1_u8(out, p7);

#undef dct_trn8_8
#undef dct_trn8_16
#undef dct_trn8_32
   }

#undef dct_long_mul
#undef dct_long_mac
#undef dct_widen
#undef dct_wadd
#undef dct_wsub
#undef dct_bfly32o
#undef dct_pass
}

#endif // STBI_NEON

#define STBI__MARKER_none  0xff
// if there's a pending marker from the entropy stream, return that
// otherwise, fetch from the stream and get a marker. if there's no
// marker, return 0xff, which is never a valid marker value
static stbi_uc stbi__get_marker(stbi__jpeg *j)
{
   stbi_uc x;
   if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }
   x = stbi__get8(j->s);
   if (x != 0xff) return STBI__MARKER_none;
   while (x == 0xff)
	  x = stbi__get8(j->s); // consume repeated 0xff fill bytes
   return x;
}

// in each scan, we'll have scan_n components, and the order
// of the components is specified by order[]
#define STBI__RESTART(x)     ((x) >= 0xd0 && (x) <= 0xd7)

// after a restart interval, stbi__jpeg_reset the entropy decoder and
// the dc prediction
static void stbi__jpeg_reset(stbi__jpeg *j)
{
   j->code_bits = 0;
   j->code_buffer = 0;
   j->nomore = 0;
   j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;
   j->marker = STBI__MARKER_none;
   j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;
   j->eob_run = 0;
   // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
   // since we don't even allow 1<<30 pixels
}

static int stbi__parse_entropy_coded_data(stbi__jpeg *z)
{
   stbi__jpeg_reset(z);
   if (!z->progressive) {
	  if (z->scan_n == 1) {
		 int i,j;
		 STBI_SIMD_ALIGN(short, data[64]);
		 int n = z->order[0];
		 // non-interleaved data, we just need to process one block at a time,
		 // in trivial scanline order
		 // number of blocks to do just depends on how many actual "pixels" this
		 // component has, independent of interleaved MCU blocking and such
		 int w = (z->img_comp[n].x+7) >> 3;
		 int h = (z->img_comp[n].y+7) >> 3;
		 for (j=0; j < h; ++j) {
			for (i=0; i < w; ++i) {
			   int ha = z->img_comp[n].ha;
			   if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
			   z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
			   // every data block is an MCU, so countdown the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  // if it's NOT a restart, then just bail, so we get corrupt data
				  // rather than no data
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  } else { // interleaved
		 int i,j,k,x,y;
		 STBI_SIMD_ALIGN(short, data[64]);
		 for (j=0; j < z->img_mcu_y; ++j) {
			for (i=0; i < z->img_mcu_x; ++i) {
			   // scan an interleaved mcu... process scan_n components in order
			   for (k=0; k < z->scan_n; ++k) {
				  int n = z->order[k];
				  // scan out an mcu's worth of this component; that's just determined
				  // by the basic H and V specified for the component
				  for (y=0; y < z->img_comp[n].v; ++y) {
					 for (x=0; x < z->img_comp[n].h; ++x) {
						int x2 = (i*z->img_comp[n].h + x)*8;
						int y2 = (j*z->img_comp[n].v + y)*8;
						int ha = z->img_comp[n].ha;
						if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;
						z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);
					 }
				  }
			   }
			   // after all interleaved components, that's an interleaved MCU,
			   // so now count down the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  }
   } else {
	  if (z->scan_n == 1) {
		 int i,j;
		 int n = z->order[0];
		 // non-interleaved data, we just need to process one block at a time,
		 // in trivial scanline order
		 // number of blocks to do just depends on how many actual "pixels" this
		 // component has, independent of interleaved MCU blocking and such
		 int w = (z->img_comp[n].x+7) >> 3;
		 int h = (z->img_comp[n].y+7) >> 3;
		 for (j=0; j < h; ++j) {
			for (i=0; i < w; ++i) {
			   short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
			   if (z->spec_start == 0) {
				  if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
					 return 0;
			   } else {
				  int ha = z->img_comp[n].ha;
				  if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))
					 return 0;
			   }
			   // every data block is an MCU, so countdown the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  } else { // interleaved
		 int i,j,k,x,y;
		 for (j=0; j < z->img_mcu_y; ++j) {
			for (i=0; i < z->img_mcu_x; ++i) {
			   // scan an interleaved mcu... process scan_n components in order
			   for (k=0; k < z->scan_n; ++k) {
				  int n = z->order[k];
				  // scan out an mcu's worth of this component; that's just determined
				  // by the basic H and V specified for the component
				  for (y=0; y < z->img_comp[n].v; ++y) {
					 for (x=0; x < z->img_comp[n].h; ++x) {
						int x2 = (i*z->img_comp[n].h + x);
						int y2 = (j*z->img_comp[n].v + y);
						short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);
						if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))
						   return 0;
					 }
				  }
			   }
			   // after all interleaved components, that's an interleaved MCU,
			   // so now count down the restart interval
			   if (--z->todo <= 0) {
				  if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);
				  if (!STBI__RESTART(z->marker)) return 1;
				  stbi__jpeg_reset(z);
			   }
			}
		 }
		 return 1;
	  }
   }
}

static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)
{
   int i;
   for (i=0; i < 64; ++i)
	  data[i] *= dequant[i];
}

static void stbi__jpeg_finish(stbi__jpeg *z)
{
   if (z->progressive) {
	  // dequantize and idct the data
	  int i,j,n;
	  for (n=0; n < z->s->img_n; ++n) {
		 int w = (z->img_comp[n].x+7) >> 3;
		 int h = (z->img_comp[n].y+7) >> 3;
		 for (j=0; j < h; ++j) {
			for (i=0; i < w; ++i) {
			   short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);
			   stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);
			   z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);
			}
		 }
	  }
   }
}

static int stbi__process_marker(stbi__jpeg *z, int m)
{
   int L;
   switch (m) {
	  case STBI__MARKER_none: // no marker found
		 return stbi__err("expected marker","Corrupt JPEG");

	  case 0xDD: // DRI - specify restart interval
		 if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");
		 z->restart_interval = stbi__get16be(z->s);
		 return 1;

	  case 0xDB: // DQT - define quantization table
		 L = stbi__get16be(z->s)-2;
		 while (L > 0) {
			int q = stbi__get8(z->s);
			int p = q >> 4, sixteen = (p != 0);
			int t = q & 15,i;
			if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");
			if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

			for (i=0; i < 64; ++i)
			   z->dequant[t][stbi__jpeg_dezigzag[i]] = sixteen ? stbi__get16be(z->s) : stbi__get8(z->s);
			L -= (sixteen ? 129 : 65);
		 }
		 return L==0;

	  case 0xC4: // DHT - define huffman table
		 L = stbi__get16be(z->s)-2;
		 while (L > 0) {
			stbi_uc *v;
			int sizes[16],i,n=0;
			int q = stbi__get8(z->s);
			int tc = q >> 4;
			int th = q & 15;
			if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");
			for (i=0; i < 16; ++i) {
			   sizes[i] = stbi__get8(z->s);
			   n += sizes[i];
			}
			L -= 17;
			if (tc == 0) {
			   if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;
			   v = z->huff_dc[th].values;
			} else {
			   if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;
			   v = z->huff_ac[th].values;
			}
			for (i=0; i < n; ++i)
			   v[i] = stbi__get8(z->s);
			if (tc != 0)
			   stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);
			L -= n;
		 }
		 return L==0;
   }

   // check for comment block or APP blocks
   if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {
	  L = stbi__get16be(z->s);
	  if (L < 2) {
		 if (m == 0xFE)
			return stbi__err("bad COM len","Corrupt JPEG");
		 else
			return stbi__err("bad APP len","Corrupt JPEG");
	  }
	  L -= 2;

	  if (m == 0xE0 && L >= 5) { // JFIF APP0 segment
		 static const unsigned char tag[5] = {'J','F','I','F','\0'};
		 int ok = 1;
		 int i;
		 for (i=0; i < 5; ++i)
			if (stbi__get8(z->s) != tag[i])
			   ok = 0;
		 L -= 5;
		 if (ok)
			z->jfif = 1;
	  } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment
		 static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
		 int ok = 1;
		 int i;
		 for (i=0; i < 6; ++i)
			if (stbi__get8(z->s) != tag[i])
			   ok = 0;
		 L -= 6;
		 if (ok) {
			stbi__get8(z->s); // version
			stbi__get16be(z->s); // flags0
			stbi__get16be(z->s); // flags1
			z->app14_color_transform = stbi__get8(z->s); // color transform
			L -= 6;
		 }
	  }

	  stbi__skip(z->s, L);
	  return 1;
   }

   return stbi__err("unknown marker","Corrupt JPEG");
}

// after we see SOS
static int stbi__process_scan_header(stbi__jpeg *z)
{
   int i;
   int Ls = stbi__get16be(z->s);
   z->scan_n = stbi__get8(z->s);
   if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");
   if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");
   for (i=0; i < z->scan_n; ++i) {
	  int id = stbi__get8(z->s), which;
	  int q = stbi__get8(z->s);
	  for (which = 0; which < z->s->img_n; ++which)
		 if (z->img_comp[which].id == id)
			break;
	  if (which == z->s->img_n) return 0; // no match
	  z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");
	  z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");
	  z->order[i] = which;
   }

   {
	  int aa;
	  z->spec_start = stbi__get8(z->s);
	  z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0
	  aa = stbi__get8(z->s);
	  z->succ_high = (aa >> 4);
	  z->succ_low  = (aa & 15);
	  if (z->progressive) {
		 if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)
			return stbi__err("bad SOS", "Corrupt JPEG");
	  } else {
		 if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");
		 if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");
		 z->spec_end = 63;
	  }
   }

   return 1;
}

static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)
{
   int i;
   for (i=0; i < ncomp; ++i) {
	  if (z->img_comp[i].raw_data) {
		 STBI_FREE(z->img_comp[i].raw_data);
		 z->img_comp[i].raw_data = NULL;
		 z->img_comp[i].data = NULL;
	  }
	  if (z->img_comp[i].raw_coeff) {
		 STBI_FREE(z->img_comp[i].raw_coeff);
		 z->img_comp[i].raw_coeff = 0;
		 z->img_comp[i].coeff = 0;
	  }
	  if (z->img_comp[i].linebuf) {
		 STBI_FREE(z->img_comp[i].linebuf);
		 z->img_comp[i].linebuf = NULL;
	  }
   }
   return why;
}

static int stbi__process_frame_header(stbi__jpeg *z, int scan)
{
   stbi__context *s = z->s;
   int Lf,p,i,q, h_max=1,v_max=1,c;
   Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG
   p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline
   s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG
   s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires
   c = stbi__get8(s);
   if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");
   s->img_n = c;
   for (i=0; i < c; ++i) {
	  z->img_comp[i].data = NULL;
	  z->img_comp[i].linebuf = NULL;
   }

   if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

   z->rgb = 0;
   for (i=0; i < s->img_n; ++i) {
	  static unsigned char rgb[3] = { 'R', 'G', 'B' };
	  z->img_comp[i].id = stbi__get8(s);
	  if (s->img_n == 3 && z->img_comp[i].id == rgb[i])
		 ++z->rgb;
	  q = stbi__get8(s);
	  z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");
	  z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");
	  z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");
   }

   if (scan != STBI__SCAN_load) return 1;

   if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

   for (i=0; i < s->img_n; ++i) {
	  if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;
	  if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;
   }

   // compute interleaved mcu info
   z->img_h_max = h_max;
   z->img_v_max = v_max;
   z->img_mcu_w = h_max * 8;
   z->img_mcu_h = v_max * 8;
   // these sizes can't be more than 17 bits
   z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;
   z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

   for (i=0; i < s->img_n; ++i) {
	  // number of effective pixels (e.g. for non-interleaved MCU)
	  z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;
	  z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;
	  // to simplify generation, we'll allocate enough memory to decode
	  // the bogus oversized data from using interleaved MCUs and their
	  // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
	  // discard the extra data until colorspace conversion
	  //
	  // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
	  // so these muls can't overflow with 32-bit ints (which we require)
	  z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;
	  z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;
	  z->img_comp[i].coeff = 0;
	  z->img_comp[i].raw_coeff = 0;
	  z->img_comp[i].linebuf = NULL;
	  z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);
	  if (z->img_comp[i].raw_data == NULL)
		 return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
	  // align blocks for idct using mmx/sse
	  z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);
	  if (z->progressive) {
		 // w2, h2 are multiples of 8 (see above)
		 z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;
		 z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;
		 z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);
		 if (z->img_comp[i].raw_coeff == NULL)
			return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));
		 z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);
	  }
   }

   return 1;
}

// use comparisons since in some cases we handle more than one case (e.g. SOF)
#define stbi__DNL(x)         ((x) == 0xdc)
#define stbi__SOI(x)         ((x) == 0xd8)
#define stbi__EOI(x)         ((x) == 0xd9)
#define stbi__SOF(x)         ((x) == 0xc0 || (x) == 0xc1 || (x) == 0xc2)
#define stbi__SOS(x)         ((x) == 0xda)

#define stbi__SOF_progressive(x)   ((x) == 0xc2)

static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)
{
   int m;
   z->jfif = 0;
   z->app14_color_transform = -1; // valid values are 0,1,2
   z->marker = STBI__MARKER_none; // initialize cached marker to empty
   m = stbi__get_marker(z);
   if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");
   if (scan == STBI__SCAN_type) return 1;
   m = stbi__get_marker(z);
   while (!stbi__SOF(m)) {
	  if (!stbi__process_marker(z,m)) return 0;
	  m = stbi__get_marker(z);
	  while (m == STBI__MARKER_none) {
		 // some files have extra padding after their blocks, so ok, we'll scan
		 if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");
		 m = stbi__get_marker(z);
	  }
   }
   z->progressive = stbi__SOF_progressive(m);
   if (!stbi__process_frame_header(z, scan)) return 0;
   return 1;
}

// decode image to YCbCr format
static int stbi__decode_jpeg_image(stbi__jpeg *j)
{
   int m;
   for (m = 0; m < 4; m++) {
	  j->img_comp[m].raw_data = NULL;
	  j->img_comp[m].raw_coeff = NULL;
   }
   j->restart_interval = 0;
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;
   m = stbi__get_marker(j);
   while (!stbi__EOI(m)) {
	  if (stbi__SOS(m)) {
		 if (!stbi__process_scan_header(j)) return 0;
		 if (!stbi__parse_entropy_coded_data(j)) return 0;
		 if (j->marker == STBI__MARKER_none ) {
			// handle 0s at the end of image data from IP Kamera 9060
			while (!stbi__at_eof(j->s)) {
			   int x = stbi__get8(j->s);
			   if (x == 255) {
				  j->marker = stbi__get8(j->s);
				  break;
			   }
			}
			// if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
		 }
	  } else if (stbi__DNL(m)) {
		 int Ld = stbi__get16be(j->s);
		 stbi__uint32 NL = stbi__get16be(j->s);
		 if (Ld != 4) stbi__err("bad DNL len", "Corrupt JPEG");
		 if (NL != j->s->img_y) stbi__err("bad DNL height", "Corrupt JPEG");
	  } else {
		 if (!stbi__process_marker(j, m)) return 0;
	  }
	  m = stbi__get_marker(j);
   }
   if (j->progressive)
	  stbi__jpeg_finish(j);
   return 1;
}

// static jfif-centered resampling (across block boundaries)

typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,
									int w, int hs);

#define stbi__div4(x) ((stbi_uc) ((x) >> 2))

static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   STBI_NOTUSED(out);
   STBI_NOTUSED(in_far);
   STBI_NOTUSED(w);
   STBI_NOTUSED(hs);
   return in_near;
}

static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples vertically for every one in input
   int i;
   STBI_NOTUSED(hs);
   for (i=0; i < w; ++i)
	  out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);
   return out;
}

static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate two samples horizontally for every one in input
   int i;
   stbi_uc *input = in_near;

   if (w == 1) {
	  // if only one sample, can't do any interpolation
	  out[0] = out[1] = input[0];
	  return out;
   }

   out[0] = input[0];
   out[1] = stbi__div4(input[0]*3 + input[1] + 2);
   for (i=1; i < w-1; ++i) {
	  int n = 3*input[i]+2;
	  out[i*2+0] = stbi__div4(n+input[i-1]);
	  out[i*2+1] = stbi__div4(n+input[i+1]);
   }
   out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);
   out[i*2+1] = input[w-1];

   STBI_NOTUSED(in_far);
   STBI_NOTUSED(hs);

   return out;
}

#define stbi__div16(x) ((stbi_uc) ((x) >> 4))

static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i,t0,t1;
   if (w == 1) {
	  out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
	  return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   out[0] = stbi__div4(t1+2);
   for (i=1; i < w; ++i) {
	  t0 = t1;
	  t1 = 3*in_near[i]+in_far[i];
	  out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
	  out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // need to generate 2x2 samples for every one in input
   int i=0,t0,t1;

   if (w == 1) {
	  out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);
	  return out;
   }

   t1 = 3*in_near[0] + in_far[0];
   // process groups of 8 pixels for as long as we can.
   // note we can't handle the last pixel in a row in this loop
   // because we need to handle the filter boundary conditions.
   for (; i < ((w-1) & ~7); i += 8) {
#if defined(STBI_SSE2)
	  // load and perform the vertical filtering pass
	  // this uses 3*x + y = 4*x + (y - x)
	  __m128i zero  = _mm_setzero_si128();
	  __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));
	  __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));
	  __m128i farw  = _mm_unpacklo_epi8(farb, zero);
	  __m128i nearw = _mm_unpacklo_epi8(nearb, zero);
	  __m128i diff  = _mm_sub_epi16(farw, nearw);
	  __m128i nears = _mm_slli_epi16(nearw, 2);
	  __m128i curr  = _mm_add_epi16(nears, diff); // current row

	  // horizontal filter works the same based on shifted vers of current
	  // row. "prev" is current row shifted right by 1 pixel; we need to
	  // insert the previous pixel value (from t1).
	  // "next" is current row shifted left by 1 pixel, with first pixel
	  // of next block of 8 pixels added in.
	  __m128i prv0 = _mm_slli_si128(curr, 2);
	  __m128i nxt0 = _mm_srli_si128(curr, 2);
	  __m128i prev = _mm_insert_epi16(prv0, t1, 0);
	  __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

	  // horizontal filter, polyphase implementation since it's convenient:
	  // even pixels = 3*cur + prev = cur*4 + (prev - cur)
	  // odd  pixels = 3*cur + next = cur*4 + (next - cur)
	  // note the shared term.
	  __m128i bias  = _mm_set1_epi16(8);
	  __m128i curs = _mm_slli_epi16(curr, 2);
	  __m128i prvd = _mm_sub_epi16(prev, curr);
	  __m128i nxtd = _mm_sub_epi16(next, curr);
	  __m128i curb = _mm_add_epi16(curs, bias);
	  __m128i even = _mm_add_epi16(prvd, curb);
	  __m128i odd  = _mm_add_epi16(nxtd, curb);

	  // interleave even and odd pixels, then undo scaling.
	  __m128i int0 = _mm_unpacklo_epi16(even, odd);
	  __m128i int1 = _mm_unpackhi_epi16(even, odd);
	  __m128i de0  = _mm_srli_epi16(int0, 4);
	  __m128i de1  = _mm_srli_epi16(int1, 4);

	  // pack and write output
	  __m128i outv = _mm_packus_epi16(de0, de1);
	  _mm_storeu_si128((__m128i *) (out + i*2), outv);
#elif defined(STBI_NEON)
	  // load and perform the vertical filtering pass
	  // this uses 3*x + y = 4*x + (y - x)
	  uint8x8_t farb  = vld1_u8(in_far + i);
	  uint8x8_t nearb = vld1_u8(in_near + i);
	  int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
	  int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
	  int16x8_t curr  = vaddq_s16(nears, diff); // current row

	  // horizontal filter works the same based on shifted vers of current
	  // row. "prev" is current row shifted right by 1 pixel; we need to
	  // insert the previous pixel value (from t1).
	  // "next" is current row shifted left by 1 pixel, with first pixel
	  // of next block of 8 pixels added in.
	  int16x8_t prv0 = vextq_s16(curr, curr, 7);
	  int16x8_t nxt0 = vextq_s16(curr, curr, 1);
	  int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
	  int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);

	  // horizontal filter, polyphase implementation since it's convenient:
	  // even pixels = 3*cur + prev = cur*4 + (prev - cur)
	  // odd  pixels = 3*cur + next = cur*4 + (next - cur)
	  // note the shared term.
	  int16x8_t curs = vshlq_n_s16(curr, 2);
	  int16x8_t prvd = vsubq_s16(prev, curr);
	  int16x8_t nxtd = vsubq_s16(next, curr);
	  int16x8_t even = vaddq_s16(curs, prvd);
	  int16x8_t odd  = vaddq_s16(curs, nxtd);

	  // undo scaling and round, then store with even/odd phases interleaved
	  uint8x8x2_t o;
	  o.val[0] = vqrshrun_n_s16(even, 4);
	  o.val[1] = vqrshrun_n_s16(odd,  4);
	  vst2_u8(out + i*2, o);
#endif

	  // "previous" value for next iter
	  t1 = 3*in_near[i+7] + in_far[i+7];
   }

   t0 = t1;
   t1 = 3*in_near[i] + in_far[i];
   out[i*2] = stbi__div16(3*t1 + t0 + 8);

   for (++i; i < w; ++i) {
	  t0 = t1;
	  t1 = 3*in_near[i]+in_far[i];
	  out[i*2-1] = stbi__div16(3*t0 + t1 + 8);
	  out[i*2  ] = stbi__div16(3*t1 + t0 + 8);
   }
   out[w*2-1] = stbi__div4(t1+2);

   STBI_NOTUSED(hs);

   return out;
}
#endif

static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)
{
   // resample with nearest-neighbor
   int i,j;
   STBI_NOTUSED(in_far);
   for (i=0; i < w; ++i)
	  for (j=0; j < hs; ++j)
		 out[i*hs+j] = in_near[i];
   return out;
}

// this is a reduced-precision calculation of YCbCr-to-RGB introduced
// to make sure the code produces the same results in both SIMD and scalar
#define stbi__float2fixed(x)  (((int) ((x) * 4096.0f + 0.5f)) << 8)
static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)
{
   int i;
   for (i=0; i < count; ++i) {
	  int y_fixed = (y[i] << 20) + (1<<19); // rounding
	  int r,g,b;
	  int cr = pcr[i] - 128;
	  int cb = pcb[i] - 128;
	  r = y_fixed +  cr* stbi__float2fixed(1.40200f);
	  g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
	  b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);
	  r >>= 20;
	  g >>= 20;
	  b >>= 20;
	  if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
	  if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
	  if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
	  out[0] = (stbi_uc)r;
	  out[1] = (stbi_uc)g;
	  out[2] = (stbi_uc)b;
	  out[3] = 255;
	  out += step;
   }
}

#if defined(STBI_SSE2) || defined(STBI_NEON)
static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)
{
   int i = 0;

#ifdef STBI_SSE2
   // step == 3 is pretty ugly on the final interleave, and i'm not convinced
   // it's useful in practice (you wouldn't use it for textures, for example).
   // so just accelerate step == 4 case.
   if (step == 4) {
	  // this is a fairly straightforward implementation and not super-optimized.
	  __m128i signflip  = _mm_set1_epi8(-0x80);
	  __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));
	  __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));
	  __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));
	  __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));
	  __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);
	  __m128i xw = _mm_set1_epi16(255); // alpha channel

	  for (; i+7 < count; i += 8) {
		 // load
		 __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));
		 __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));
		 __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));
		 __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128
		 __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

		 // unpack to short (and left-shift cr, cb by 8)
		 __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);
		 __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);
		 __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

		 // color transform
		 __m128i yws = _mm_srli_epi16(yw, 4);
		 __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);
		 __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);
		 __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);
		 __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);
		 __m128i rws = _mm_add_epi16(cr0, yws);
		 __m128i gwt = _mm_add_epi16(cb0, yws);
		 __m128i bws = _mm_add_epi16(yws, cb1);
		 __m128i gws = _mm_add_epi16(gwt, cr1);

		 // descale
		 __m128i rw = _mm_srai_epi16(rws, 4);
		 __m128i bw = _mm_srai_epi16(bws, 4);
		 __m128i gw = _mm_srai_epi16(gws, 4);

		 // back to byte, set up for transpose
		 __m128i brb = _mm_packus_epi16(rw, bw);
		 __m128i gxb = _mm_packus_epi16(gw, xw);

		 // transpose to interleave channels
		 __m128i t0 = _mm_unpacklo_epi8(brb, gxb);
		 __m128i t1 = _mm_unpackhi_epi8(brb, gxb);
		 __m128i o0 = _mm_unpacklo_epi16(t0, t1);
		 __m128i o1 = _mm_unpackhi_epi16(t0, t1);

		 // store
		 _mm_storeu_si128((__m128i *) (out + 0), o0);
		 _mm_storeu_si128((__m128i *) (out + 16), o1);
		 out += 32;
	  }
   }
#endif

#ifdef STBI_NEON
   // in this version, step=3 support would be easy to add. but is there demand?
   if (step == 4) {
	  // this is a fairly straightforward implementation and not super-optimized.
	  uint8x8_t signflip = vdup_n_u8(0x80);
	  int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
	  int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
	  int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
	  int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));

	  for (; i+7 < count; i += 8) {
		 // load
		 uint8x8_t y_bytes  = vld1_u8(y + i);
		 uint8x8_t cr_bytes = vld1_u8(pcr + i);
		 uint8x8_t cb_bytes = vld1_u8(pcb + i);
		 int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
		 int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));

		 // expand to s16
		 int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
		 int16x8_t crw = vshll_n_s8(cr_biased, 7);
		 int16x8_t cbw = vshll_n_s8(cb_biased, 7);

		 // color transform
		 int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
		 int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
		 int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
		 int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
		 int16x8_t rws = vaddq_s16(yws, cr0);
		 int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
		 int16x8_t bws = vaddq_s16(yws, cb1);

		 // undo scaling, round, convert to byte
		 uint8x8x4_t o;
		 o.val[0] = vqrshrun_n_s16(rws, 4);
		 o.val[1] = vqrshrun_n_s16(gws, 4);
		 o.val[2] = vqrshrun_n_s16(bws, 4);
		 o.val[3] = vdup_n_u8(255);

		 // store, interleaving r/g/b/a
		 vst4_u8(out, o);
		 out += 8*4;
	  }
   }
#endif

   for (; i < count; ++i) {
	  int y_fixed = (y[i] << 20) + (1<<19); // rounding
	  int r,g,b;
	  int cr = pcr[i] - 128;
	  int cb = pcb[i] - 128;
	  r = y_fixed + cr* stbi__float2fixed(1.40200f);
	  g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);
	  b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);
	  r >>= 20;
	  g >>= 20;
	  b >>= 20;
	  if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }
	  if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }
	  if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }
	  out[0] = (stbi_uc)r;
	  out[1] = (stbi_uc)g;
	  out[2] = (stbi_uc)b;
	  out[3] = 255;
	  out += step;
   }
}
#endif

// set up the kernels
static void stbi__setup_jpeg(stbi__jpeg *j)
{
   j->idct_block_kernel = stbi__idct_block;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

#ifdef STBI_SSE2
   if (stbi__sse2_available()) {
	  j->idct_block_kernel = stbi__idct_simd;
	  j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
	  j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
   }
#endif

#ifdef STBI_NEON
   j->idct_block_kernel = stbi__idct_simd;
   j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
   j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
#endif
}

// clean up the temporary component buffers
static void stbi__cleanup_jpeg(stbi__jpeg *j)
{
   stbi__free_jpeg_components(j, j->s->img_n, 0);
}

typedef struct
{
   resample_row_func resample;
   stbi_uc *line0,*line1;
   int hs,vs;   // expansion factor in each axis
   int w_lores; // horizontal pixels pre-expansion
   int ystep;   // how far through vertical expansion we are
   int ypos;    // which pre-expansion row we're on
} stbi__resample;

// fast 0..255 * 0..255 => 0..255 rounded multiplication
static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)
{
   unsigned int t = x*y + 128;
   return (stbi_uc) ((t + (t >>8)) >> 8);
}

static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)
{
   int n, decode_n, is_rgb;
   z->s->img_n = 0; // make stbi__cleanup_jpeg safe

   // validate req_comp
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

   // load a jpeg image from whichever source, but leave in YCbCr format
   if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

   // determine actual number of components to generate
   n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

   is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

   if (z->s->img_n == 3 && n < 3 && !is_rgb)
	  decode_n = 1;
   else
	  decode_n = z->s->img_n;

   // resample and color-convert
   {
	  int k;
	  unsigned int i,j;
	  stbi_uc *output;
	  stbi_uc *coutput[4];

	  stbi__resample res_comp[4];

	  for (k=0; k < decode_n; ++k) {
		 stbi__resample *r = &res_comp[k];

		 // allocate line buffer big enough for upsampling off the edges
		 // with upsample factor of 4
		 z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);
		 if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

		 r->hs      = z->img_h_max / z->img_comp[k].h;
		 r->vs      = z->img_v_max / z->img_comp[k].v;
		 r->ystep   = r->vs >> 1;
		 r->w_lores = (z->s->img_x + r->hs-1) / r->hs;
		 r->ypos    = 0;
		 r->line0   = r->line1 = z->img_comp[k].data;

		 if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;
		 else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;
		 else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;
		 else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;
		 else                               r->resample = stbi__resample_row_generic;
	  }

	  // can't error after this so, this is safe
	  output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);
	  if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

	  // now go ahead and resample
	  for (j=0; j < z->s->img_y; ++j) {
		 stbi_uc *out = output + n * z->s->img_x * j;
		 for (k=0; k < decode_n; ++k) {
			stbi__resample *r = &res_comp[k];
			int y_bot = r->ystep >= (r->vs >> 1);
			coutput[k] = r->resample(z->img_comp[k].linebuf,
									 y_bot ? r->line1 : r->line0,
									 y_bot ? r->line0 : r->line1,
									 r->w_lores, r->hs);
			if (++r->ystep >= r->vs) {
			   r->ystep = 0;
			   r->line0 = r->line1;
			   if (++r->ypos < z->img_comp[k].y)
				  r->line1 += z->img_comp[k].w2;
			}
		 }
		 if (n >= 3) {
			stbi_uc *y = coutput[0];
			if (z->s->img_n == 3) {
			   if (is_rgb) {
				  for (i=0; i < z->s->img_x; ++i) {
					 out[0] = y[i];
					 out[1] = coutput[1][i];
					 out[2] = coutput[2][i];
					 out[3] = 255;
					 out += n;
				  }
			   } else {
				  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
			   }
			} else if (z->s->img_n == 4) {
			   if (z->app14_color_transform == 0) { // CMYK
				  for (i=0; i < z->s->img_x; ++i) {
					 stbi_uc k = coutput[3][i];
					 out[0] = stbi__blinn_8x8(coutput[0][i], k);
					 out[1] = stbi__blinn_8x8(coutput[1][i], k);
					 out[2] = stbi__blinn_8x8(coutput[2][i], k);
					 out[3] = 255;
					 out += n;
				  }
			   } else if (z->app14_color_transform == 2) { // YCCK
				  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
				  for (i=0; i < z->s->img_x; ++i) {
					 stbi_uc k = coutput[3][i];
					 out[0] = stbi__blinn_8x8(255 - out[0], k);
					 out[1] = stbi__blinn_8x8(255 - out[1], k);
					 out[2] = stbi__blinn_8x8(255 - out[2], k);
					 out += n;
				  }
			   } else { // YCbCr + alpha?  Ignore the fourth channel for now
				  z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);
			   }
			} else
			   for (i=0; i < z->s->img_x; ++i) {
				  out[0] = out[1] = out[2] = y[i];
				  out[3] = 255; // not used if n==3
				  out += n;
			   }
		 } else {
			if (is_rgb) {
			   if (n == 1)
				  for (i=0; i < z->s->img_x; ++i)
					 *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
			   else {
				  for (i=0; i < z->s->img_x; ++i, out += 2) {
					 out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);
					 out[1] = 255;
				  }
			   }
			} else if (z->s->img_n == 4 && z->app14_color_transform == 0) {
			   for (i=0; i < z->s->img_x; ++i) {
				  stbi_uc k = coutput[3][i];
				  stbi_uc r = stbi__blinn_8x8(coutput[0][i], k);
				  stbi_uc g = stbi__blinn_8x8(coutput[1][i], k);
				  stbi_uc b = stbi__blinn_8x8(coutput[2][i], k);
				  out[0] = stbi__compute_y(r, g, b);
				  out[1] = 255;
				  out += n;
			   }
			} else if (z->s->img_n == 4 && z->app14_color_transform == 2) {
			   for (i=0; i < z->s->img_x; ++i) {
				  out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);
				  out[1] = 255;
				  out += n;
			   }
			} else {
			   stbi_uc *y = coutput[0];
			   if (n == 1)
				  for (i=0; i < z->s->img_x; ++i) out[i] = y[i];
			   else
				  for (i=0; i < z->s->img_x; ++i) *out++ = y[i], *out++ = 255;
			}
		 }
	  }
	  stbi__cleanup_jpeg(z);
	  *out_x = z->s->img_x;
	  *out_y = z->s->img_y;
	  if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output
	  return output;
   }
}

static void * STBI_FORCE_STACK_ALIGN stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   unsigned char* result;
   stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));
   STBI_NOTUSED(ri);
   j->s = s;
   stbi__setup_jpeg(j);
   result = load_jpeg_image(j, x,y,comp,req_comp);
   STBI_FREE(j);
   return result;
}

static int stbi__jpeg_test(stbi__context *s)
{
   int r;
   stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));
   j->s = s;
   stbi__setup_jpeg(j);
   r = stbi__decode_jpeg_header(j, STBI__SCAN_type);
   stbi__rewind(s);
   STBI_FREE(j);
   return r;
}

static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)
{
   if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {
	  stbi__rewind( j->s );
	  return 0;
   }
   if (x) *x = j->s->img_x;
   if (y) *y = j->s->img_y;
   if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;
   return 1;
}

static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)
{
   int result;
   stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));
   j->s = s;
   result = stbi__jpeg_info_raw(j, x, y, comp);
   STBI_FREE(j);
   return result;
}
#endif

// public domain zlib decode    v0.2  Sean Barrett 2006-11-18
//    simple implementation
//      - all input must be provided in an upfront buffer
//      - all output is written to a single output buffer (can malloc/realloc)
//    performance
//      - fast huffman

#ifndef STBI_NO_ZLIB

// fast-way is faster to check than jpeg huffman, but slow way is slower
#define STBI__ZFAST_BITS  9 // accelerate all cases in default tables
#define STBI__ZFAST_MASK  ((1 << STBI__ZFAST_BITS) - 1)

// zlib-style huffman encoding
// (jpegs packs from left, zlib from right, so can't share code)
typedef struct
{
   stbi__uint16 fast[1 << STBI__ZFAST_BITS];
   stbi__uint16 firstcode[16];
   int maxcode[17];
   stbi__uint16 firstsymbol[16];
   stbi_uc  size[288];
   stbi__uint16 value[288];
} stbi__zhuffman;

stbi_inline static int stbi__bitreverse16(int n)
{
  n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);
  n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);
  n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);
  n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);
  return n;
}

stbi_inline static int stbi__bit_reverse(int v, int bits)
{
   STBI_ASSERT(bits <= 16);
   // to bit reverse n bits, reverse 16 and shift
   // e.g. 11 bits, bit reverse and shift away 5
   return stbi__bitreverse16(v) >> (16-bits);
}

static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)
{
   int i,k=0;
   int code, next_code[16], sizes[17];

   // DEFLATE spec for generating codes
   memset(sizes, 0, sizeof(sizes));
   memset(z->fast, 0, sizeof(z->fast));
   for (i=0; i < num; ++i)
	  ++sizes[sizelist[i]];
   sizes[0] = 0;
   for (i=1; i < 16; ++i)
	  if (sizes[i] > (1 << i))
		 return stbi__err("bad sizes", "Corrupt PNG");
   code = 0;
   for (i=1; i < 16; ++i) {
	  next_code[i] = code;
	  z->firstcode[i] = (stbi__uint16) code;
	  z->firstsymbol[i] = (stbi__uint16) k;
	  code = (code + sizes[i]);
	  if (sizes[i])
		 if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");
	  z->maxcode[i] = code << (16-i); // preshift for inner loop
	  code <<= 1;
	  k += sizes[i];
   }
   z->maxcode[16] = 0x10000; // sentinel
   for (i=0; i < num; ++i) {
	  int s = sizelist[i];
	  if (s) {
		 int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];
		 stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);
		 z->size [c] = (stbi_uc     ) s;
		 z->value[c] = (stbi__uint16) i;
		 if (s <= STBI__ZFAST_BITS) {
			int j = stbi__bit_reverse(next_code[s],s);
			while (j < (1 << STBI__ZFAST_BITS)) {
			   z->fast[j] = fastv;
			   j += (1 << s);
			}
		 }
		 ++next_code[s];
	  }
   }
   return 1;
}

// zlib-from-memory implementation for PNG reading
//    because PNG allows splitting the zlib stream arbitrarily,
//    and it's annoying structurally to have PNG call ZLIB call PNG,
//    we require PNG read all the IDATs and combine them into a single
//    memory buffer

typedef struct
{
   stbi_uc *zbuffer, *zbuffer_end;
   int num_bits;
   stbi__uint32 code_buffer;

   char *zout;
   char *zout_start;
   char *zout_end;
   int   z_expandable;

   stbi__zhuffman z_length, z_distance;
} stbi__zbuf;

stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)
{
   if (z->zbuffer >= z->zbuffer_end) return 0;
   return *z->zbuffer++;
}

static void stbi__fill_bits(stbi__zbuf *z)
{
   do {
	  STBI_ASSERT(z->code_buffer < (1U << z->num_bits));
	  z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;
	  z->num_bits += 8;
   } while (z->num_bits <= 24);
}

stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)
{
   unsigned int k;
   if (z->num_bits < n) stbi__fill_bits(z);
   k = z->code_buffer & ((1 << n) - 1);
   z->code_buffer >>= n;
   z->num_bits -= n;
   return k;
}

static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s,k;
   // not resolved by fast table, so compute it the slow way
   // use jpeg approach, which requires MSbits at top
   k = stbi__bit_reverse(a->code_buffer, 16);
   for (s=STBI__ZFAST_BITS+1; ; ++s)
	  if (k < z->maxcode[s])
		 break;
   if (s == 16) return -1; // invalid code!
   // code size is s, so:
   b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];
   STBI_ASSERT(z->size[b] == s);
   a->code_buffer >>= s;
   a->num_bits -= s;
   return z->value[b];
}

stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)
{
   int b,s;
   if (a->num_bits < 16) stbi__fill_bits(a);
   b = z->fast[a->code_buffer & STBI__ZFAST_MASK];
   if (b) {
	  s = b >> 9;
	  a->code_buffer >>= s;
	  a->num_bits -= s;
	  return b & 511;
   }
   return stbi__zhuffman_decode_slowpath(a, z);
}

static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  // need to make room for n bytes
{
   char *q;
   int cur, limit, old_limit;
   z->zout = zout;
   if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");
   cur   = (int) (z->zout     - z->zout_start);
   limit = old_limit = (int) (z->zout_end - z->zout_start);
   while (cur + n > limit)
	  limit *= 2;
   q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);
   STBI_NOTUSED(old_limit);
   if (q == NULL) return stbi__err("outofmem", "Out of memory");
   z->zout_start = q;
   z->zout       = q + cur;
   z->zout_end   = q + limit;
   return 1;
}

static int stbi__zlength_base[31] = {
   3,4,5,6,7,8,9,10,11,13,
   15,17,19,23,27,31,35,43,51,59,
   67,83,99,115,131,163,195,227,258,0,0 };

static int stbi__zlength_extra[31]=
{ 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };

static int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,
257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};

static int stbi__zdist_extra[32] =
{ 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static int stbi__parse_huffman_block(stbi__zbuf *a)
{
   char *zout = a->zout;
   for(;;) {
	  int z = stbi__zhuffman_decode(a, &a->z_length);
	  if (z < 256) {
		 if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes
		 if (zout >= a->zout_end) {
			if (!stbi__zexpand(a, zout, 1)) return 0;
			zout = a->zout;
		 }
		 *zout++ = (char) z;
	  } else {
		 stbi_uc *p;
		 int len,dist;
		 if (z == 256) {
			a->zout = zout;
			return 1;
		 }
		 z -= 257;
		 len = stbi__zlength_base[z];
		 if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);
		 z = stbi__zhuffman_decode(a, &a->z_distance);
		 if (z < 0) return stbi__err("bad huffman code","Corrupt PNG");
		 dist = stbi__zdist_base[z];
		 if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);
		 if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");
		 if (zout + len > a->zout_end) {
			if (!stbi__zexpand(a, zout, len)) return 0;
			zout = a->zout;
		 }
		 p = (stbi_uc *) (zout - dist);
		 if (dist == 1) { // run of one byte; common in images.
			stbi_uc v = *p;
			if (len) { do *zout++ = v; while (--len); }
		 } else {
			if (len) { do *zout++ = *p++; while (--len); }
		 }
	  }
   }
}

static int stbi__compute_huffman_codes(stbi__zbuf *a)
{
   static stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   stbi__zhuffman z_codelength;
   stbi_uc lencodes[286+32+137];//padding for maximum single op
   stbi_uc codelength_sizes[19];
   int i,n;

   int hlit  = stbi__zreceive(a,5) + 257;
   int hdist = stbi__zreceive(a,5) + 1;
   int hclen = stbi__zreceive(a,4) + 4;
   int ntot  = hlit + hdist;

   memset(codelength_sizes, 0, sizeof(codelength_sizes));
   for (i=0; i < hclen; ++i) {
	  int s = stbi__zreceive(a,3);
	  codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;
   }
   if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

   n = 0;
   while (n < ntot) {
	  int c = stbi__zhuffman_decode(a, &z_codelength);
	  if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");
	  if (c < 16)
		 lencodes[n++] = (stbi_uc) c;
	  else {
		 stbi_uc fill = 0;
		 if (c == 16) {
			c = stbi__zreceive(a,2)+3;
			if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");
			fill = lencodes[n-1];
		 } else if (c == 17)
			c = stbi__zreceive(a,3)+3;
		 else {
			STBI_ASSERT(c == 18);
			c = stbi__zreceive(a,7)+11;
		 }
		 if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");
		 memset(lencodes+n, fill, c);
		 n += c;
	  }
   }
   if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");
   if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;
   if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;
   return 1;
}

static int stbi__parse_uncompressed_block(stbi__zbuf *a)
{
   stbi_uc header[4];
   int len,nlen,k;
   if (a->num_bits & 7)
	  stbi__zreceive(a, a->num_bits & 7); // discard
   // drain the bit-packed data into header
   k = 0;
   while (a->num_bits > 0) {
	  header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check
	  a->code_buffer >>= 8;
	  a->num_bits -= 8;
   }
   STBI_ASSERT(a->num_bits == 0);
   // now fill header the normal way
   while (k < 4)
	  header[k++] = stbi__zget8(a);
   len  = header[1] * 256 + header[0];
   nlen = header[3] * 256 + header[2];
   if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");
   if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");
   if (a->zout + len > a->zout_end)
	  if (!stbi__zexpand(a, a->zout, len)) return 0;
   memcpy(a->zout, a->zbuffer, len);
   a->zbuffer += len;
   a->zout += len;
   return 1;
}

static int stbi__parse_zlib_header(stbi__zbuf *a)
{
   int cmf   = stbi__zget8(a);
   int cm    = cmf & 15;
   /* int cinfo = cmf >> 4; */
   int flg   = stbi__zget8(a);
   if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec
   if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png
   if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png
   // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
   return 1;
}

static const stbi_uc stbi__zdefault_length[288] =
{
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8
};
static const stbi_uc stbi__zdefault_distance[32] =
{
   5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5
};
/*
Init algorithm:
{
   int i;   // use <= to match clearly with spec
   for (i=0; i <= 143; ++i)     stbi__zdefault_length[i]   = 8;
   for (   ; i <= 255; ++i)     stbi__zdefault_length[i]   = 9;
   for (   ; i <= 279; ++i)     stbi__zdefault_length[i]   = 7;
   for (   ; i <= 287; ++i)     stbi__zdefault_length[i]   = 8;

   for (i=0; i <=  31; ++i)     stbi__zdefault_distance[i] = 5;
}
*/

static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)
{
   int final, type;
   if (parse_header)
	  if (!stbi__parse_zlib_header(a)) return 0;
   a->num_bits = 0;
   a->code_buffer = 0;
   do {
	  final = stbi__zreceive(a,1);
	  type = stbi__zreceive(a,2);
	  if (type == 0) {
		 if (!stbi__parse_uncompressed_block(a)) return 0;
	  } else if (type == 3) {
		 return 0;
	  } else {
		 if (type == 1) {
			// use fixed code lengths
			if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , 288)) return 0;
			if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;
		 } else {
			if (!stbi__compute_huffman_codes(a)) return 0;
		 }
		 if (!stbi__parse_huffman_block(a)) return 0;
	  }
   } while (!final);
   return 1;
}

static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)
{
   a->zout_start = obuf;
   a->zout       = obuf;
   a->zout_end   = obuf + olen;
   a->z_expandable = exp;

   return stbi__parse_zlib(a, parse_header);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {
	  if (outlen) *outlen = (int) (a.zout - a.zout_start);
	  return a.zout_start;
   } else {
	  STBI_FREE(a.zout_start);
	  return NULL;
   }
}

STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)
{
   return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);
}

STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(initial_size);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer + len;
   if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {
	  if (outlen) *outlen = (int) (a.zout - a.zout_start);
	  return a.zout_start;
   } else {
	  STBI_FREE(a.zout_start);
	  return NULL;
   }
}

STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 1))
	  return (int) (a.zout - a.zout_start);
   else
	  return -1;
}

STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)
{
   stbi__zbuf a;
   char *p = (char *) stbi__malloc(16384);
   if (p == NULL) return NULL;
   a.zbuffer = (stbi_uc *) buffer;
   a.zbuffer_end = (stbi_uc *) buffer+len;
   if (stbi__do_zlib(&a, p, 16384, 1, 0)) {
	  if (outlen) *outlen = (int) (a.zout - a.zout_start);
	  return a.zout_start;
   } else {
	  STBI_FREE(a.zout_start);
	  return NULL;
   }
}

STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)
{
   stbi__zbuf a;
   a.zbuffer = (stbi_uc *) ibuffer;
   a.zbuffer_end = (stbi_uc *) ibuffer + ilen;
   if (stbi__do_zlib(&a, obuffer, olen, 0, 0))
	  return (int) (a.zout - a.zout_start);
   else
	  return -1;
}
#endif

// public domain "baseline" PNG decoder   v0.10  Sean Barrett 2006-11-18
//    simple implementation
//      - only 8-bit samples
//      - no CRC checking
//      - allocates lots of intermediate memory
//        - avoids problem of streaming data between subsystems
//        - avoids explicit window management
//    performance
//      - uses stb_zlib, a PD zlib implementation with fast huffman decoding

#ifndef STBI_NO_PNG
typedef struct
{
   stbi__uint32 length;
   stbi__uint32 type;
} stbi__pngchunk;

static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)
{
   stbi__pngchunk c;
   c.length = stbi__get32be(s);
   c.type   = stbi__get32be(s);
   return c;
}

static int stbi__check_png_header(stbi__context *s)
{
   static stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
   int i;
   for (i=0; i < 8; ++i)
	  if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");
   return 1;
}

typedef struct
{
   stbi__context *s;
   stbi_uc *idata, *expanded, *out;
   int depth;
} stbi__png;

enum {
   STBI__F_none=0,
   STBI__F_sub=1,
   STBI__F_up=2,
   STBI__F_avg=3,
   STBI__F_paeth=4,
   // synthetic filters used for first scanline to avoid needing a dummy row of 0s
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static stbi_uc first_row_filter[5] =
{
   STBI__F_none,
   STBI__F_sub,
   STBI__F_none,
   STBI__F_avg_first,
   STBI__F_paeth_first
};

static int stbi__paeth(int a, int b, int c)
{
   int p = a + b - c;
   int pa = abs(p-a);
   int pb = abs(p-b);
   int pc = abs(p-c);
   if (pa <= pb && pa <= pc) return a;
   if (pb <= pc) return b;
   return c;
}

static stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };

// create the png data from post-deflated data
static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)
{
   int bytes = (depth == 16? 2 : 1);
   stbi__context *s = a->s;
   stbi__uint32 i,j,stride = x*out_n*bytes;
   stbi__uint32 img_len, img_width_bytes;
   int k;
   int img_n = s->img_n; // copy it into a local for later

   int output_bytes = out_n*bytes;
   int filter_bytes = img_n*bytes;
   int width = x;

   STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);
   a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into
   if (!a->out) return stbi__err("outofmem", "Out of memory");

   img_width_bytes = (((img_n * x * depth) + 7) >> 3);
   img_len = (img_width_bytes + 1) * y;
   if (s->img_x == x && s->img_y == y) {
	  if (raw_len != img_len) return stbi__err("not enough pixels","Corrupt PNG");
   } else { // interlaced:
	  if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");
   }

   for (j=0; j < y; ++j) {
	  stbi_uc *cur = a->out + stride*j;
	  stbi_uc *prior;
	  int filter = *raw++;

	  if (filter > 4)
		 return stbi__err("invalid filter","Corrupt PNG");

	  if (depth < 8) {
		 STBI_ASSERT(img_width_bytes <= x);
		 cur += x*out_n - img_width_bytes; // store output to the rightmost img_len bytes, so we can decode in place
		 filter_bytes = 1;
		 width = img_width_bytes;
	  }
	  prior = cur - stride; // bugfix: need to compute this after 'cur +=' computation above

	  // if first row, use special filter that doesn't sample previous row
	  if (j == 0) filter = first_row_filter[filter];

	  // handle first byte explicitly
	  for (k=0; k < filter_bytes; ++k) {
		 switch (filter) {
			case STBI__F_none       : cur[k] = raw[k]; break;
			case STBI__F_sub        : cur[k] = raw[k]; break;
			case STBI__F_up         : cur[k] = STBI__BYTECAST(raw[k] + prior[k]); break;
			case STBI__F_avg        : cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1)); break;
			case STBI__F_paeth      : cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(0,prior[k],0)); break;
			case STBI__F_avg_first  : cur[k] = raw[k]; break;
			case STBI__F_paeth_first: cur[k] = raw[k]; break;
		 }
	  }

	  if (depth == 8) {
		 if (img_n != out_n)
			cur[img_n] = 255; // first pixel
		 raw += img_n;
		 cur += out_n;
		 prior += out_n;
	  } else if (depth == 16) {
		 if (img_n != out_n) {
			cur[filter_bytes]   = 255; // first pixel top byte
			cur[filter_bytes+1] = 255; // first pixel bottom byte
		 }
		 raw += filter_bytes;
		 cur += output_bytes;
		 prior += output_bytes;
	  } else {
		 raw += 1;
		 cur += 1;
		 prior += 1;
	  }

	  // this is a little gross, so that we don't switch per-pixel or per-component
	  if (depth < 8 || img_n == out_n) {
		 int nk = (width - 1)*filter_bytes;
		 #define STBI__CASE(f) \
			 case f:     \
				for (k=0; k < nk; ++k)
		 switch (filter) {
			// "none" filter turns into a memcpy here; make that explicit.
			case STBI__F_none:         memcpy(cur, raw, nk); break;
			STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]); } break;
			STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
			STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1)); } break;
			STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],prior[k],prior[k-filter_bytes])); } break;
			STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1)); } break;
			STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes],0,0)); } break;
		 }
		 #undef STBI__CASE
		 raw += nk;
	  } else {
		 STBI_ASSERT(img_n+1 == out_n);
		 #define STBI__CASE(f) \
			 case f:     \
				for (i=x-1; i >= 1; --i, cur[filter_bytes]=255,raw+=filter_bytes,cur+=output_bytes,prior+=output_bytes) \
				   for (k=0; k < filter_bytes; ++k)
		 switch (filter) {
			STBI__CASE(STBI__F_none)         { cur[k] = raw[k]; } break;
			STBI__CASE(STBI__F_sub)          { cur[k] = STBI__BYTECAST(raw[k] + cur[k- output_bytes]); } break;
			STBI__CASE(STBI__F_up)           { cur[k] = STBI__BYTECAST(raw[k] + prior[k]); } break;
			STBI__CASE(STBI__F_avg)          { cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k- output_bytes])>>1)); } break;
			STBI__CASE(STBI__F_paeth)        { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],prior[k],prior[k- output_bytes])); } break;
			STBI__CASE(STBI__F_avg_first)    { cur[k] = STBI__BYTECAST(raw[k] + (cur[k- output_bytes] >> 1)); } break;
			STBI__CASE(STBI__F_paeth_first)  { cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k- output_bytes],0,0)); } break;
		 }
		 #undef STBI__CASE

		 // the loop above sets the high byte of the pixels' alpha, but for
		 // 16 bit png files we also need the low byte set. we'll do that here.
		 if (depth == 16) {
			cur = a->out + stride*j; // start at the beginning of the row again
			for (i=0; i < x; ++i,cur+=output_bytes) {
			   cur[filter_bytes+1] = 255;
			}
		 }
	  }
   }

   // we make a separate pass to expand bits to pixels; for performance,
   // this could run two scanlines behind the above code, so it won't
   // intefere with filtering but will still be in the cache.
   if (depth < 8) {
	  for (j=0; j < y; ++j) {
		 stbi_uc *cur = a->out + stride*j;
		 stbi_uc *in  = a->out + stride*j + x*out_n - img_width_bytes;
		 // unpack 1/2/4-bit into a 8-bit buffer. allows us to keep the common 8-bit path optimal at minimal cost for 1/2/4-bit
		 // png guarante byte alignment, if width is not multiple of 8/4/2 we'll decode dummy trailing data that will be skipped in the later loop
		 stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

		 // note that the final byte might overshoot and write more data than desired.
		 // we can allocate enough data that this never writes out of memory, but it
		 // could also overwrite the next scanline. can it overwrite non-empty data
		 // on the next scanline? yes, consider 1-pixel-wide scanlines with 1-bit-per-pixel.
		 // so we need to explicitly clamp the final ones

		 if (depth == 4) {
			for (k=x*img_n; k >= 2; k-=2, ++in) {
			   *cur++ = scale * ((*in >> 4)       );
			   *cur++ = scale * ((*in     ) & 0x0f);
			}
			if (k > 0) *cur++ = scale * ((*in >> 4)       );
		 } else if (depth == 2) {
			for (k=x*img_n; k >= 4; k-=4, ++in) {
			   *cur++ = scale * ((*in >> 6)       );
			   *cur++ = scale * ((*in >> 4) & 0x03);
			   *cur++ = scale * ((*in >> 2) & 0x03);
			   *cur++ = scale * ((*in     ) & 0x03);
			}
			if (k > 0) *cur++ = scale * ((*in >> 6)       );
			if (k > 1) *cur++ = scale * ((*in >> 4) & 0x03);
			if (k > 2) *cur++ = scale * ((*in >> 2) & 0x03);
		 } else if (depth == 1) {
			for (k=x*img_n; k >= 8; k-=8, ++in) {
			   *cur++ = scale * ((*in >> 7)       );
			   *cur++ = scale * ((*in >> 6) & 0x01);
			   *cur++ = scale * ((*in >> 5) & 0x01);
			   *cur++ = scale * ((*in >> 4) & 0x01);
			   *cur++ = scale * ((*in >> 3) & 0x01);
			   *cur++ = scale * ((*in >> 2) & 0x01);
			   *cur++ = scale * ((*in >> 1) & 0x01);
			   *cur++ = scale * ((*in     ) & 0x01);
			}
			if (k > 0) *cur++ = scale * ((*in >> 7)       );
			if (k > 1) *cur++ = scale * ((*in >> 6) & 0x01);
			if (k > 2) *cur++ = scale * ((*in >> 5) & 0x01);
			if (k > 3) *cur++ = scale * ((*in >> 4) & 0x01);
			if (k > 4) *cur++ = scale * ((*in >> 3) & 0x01);
			if (k > 5) *cur++ = scale * ((*in >> 2) & 0x01);
			if (k > 6) *cur++ = scale * ((*in >> 1) & 0x01);
		 }
		 if (img_n != out_n) {
			int q;
			// insert alpha = 255
			cur = a->out + stride*j;
			if (img_n == 1) {
			   for (q=x-1; q >= 0; --q) {
				  cur[q*2+1] = 255;
				  cur[q*2+0] = cur[q];
			   }
			} else {
			   STBI_ASSERT(img_n == 3);
			   for (q=x-1; q >= 0; --q) {
				  cur[q*4+3] = 255;
				  cur[q*4+2] = cur[q*3+2];
				  cur[q*4+1] = cur[q*3+1];
				  cur[q*4+0] = cur[q*3+0];
			   }
			}
		 }
	  }
   } else if (depth == 16) {
	  // force the image data from big-endian to platform-native.
	  // this is done in a separate pass due to the decoding relying
	  // on the data being untouched, but could probably be done
	  // per-line during decode if care is taken.
	  stbi_uc *cur = a->out;
	  stbi__uint16 *cur16 = (stbi__uint16*)cur;

	  for(i=0; i < x*y*out_n; ++i,cur16++,cur+=2) {
		 *cur16 = (cur[0] << 8) | cur[1];
	  }
   }

   return 1;
}

static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)
{
   int bytes = (depth == 16 ? 2 : 1);
   int out_bytes = out_n * bytes;
   stbi_uc *final;
   int p;
   if (!interlaced)
	  return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

   // de-interlacing
   final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);
   for (p=0; p < 7; ++p) {
	  int xorig[] = { 0,4,0,2,0,1,0 };
	  int yorig[] = { 0,0,4,0,2,0,1 };
	  int xspc[]  = { 8,8,4,4,2,2,1 };
	  int yspc[]  = { 8,8,8,4,4,2,2 };
	  int i,j,x,y;
	  // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
	  x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];
	  y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];
	  if (x && y) {
		 stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;
		 if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {
			STBI_FREE(final);
			return 0;
		 }
		 for (j=0; j < y; ++j) {
			for (i=0; i < x; ++i) {
			   int out_y = j*yspc[p]+yorig[p];
			   int out_x = i*xspc[p]+xorig[p];
			   memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,
					  a->out + (j*x+i)*out_bytes, out_bytes);
			}
		 }
		 STBI_FREE(a->out);
		 image_data += img_len;
		 image_data_len -= img_len;
	  }
   }
   a->out = final;

   return 1;
}

static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   // compute color-based transparency, assuming we've
   // already got 255 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
	  for (i=0; i < pixel_count; ++i) {
		 p[1] = (p[0] == tc[0] ? 0 : 255);
		 p += 2;
	  }
   } else {
	  for (i=0; i < pixel_count; ++i) {
		 if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
			p[3] = 0;
		 p += 4;
	  }
   }
   return 1;
}

static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi__uint16 *p = (stbi__uint16*) z->out;

   // compute color-based transparency, assuming we've
   // already got 65535 as the alpha value in the output
   STBI_ASSERT(out_n == 2 || out_n == 4);

   if (out_n == 2) {
	  for (i = 0; i < pixel_count; ++i) {
		 p[1] = (p[0] == tc[0] ? 0 : 65535);
		 p += 2;
	  }
   } else {
	  for (i = 0; i < pixel_count; ++i) {
		 if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])
			p[3] = 0;
		 p += 4;
	  }
   }
   return 1;
}

static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)
{
   stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;
   stbi_uc *p, *temp_out, *orig = a->out;

   p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);
   if (p == NULL) return stbi__err("outofmem", "Out of memory");

   // between here and free(out) below, exitting would leak
   temp_out = p;

   if (pal_img_n == 3) {
	  for (i=0; i < pixel_count; ++i) {
		 int n = orig[i]*4;
		 p[0] = palette[n  ];
		 p[1] = palette[n+1];
		 p[2] = palette[n+2];
		 p += 3;
	  }
   } else {
	  for (i=0; i < pixel_count; ++i) {
		 int n = orig[i]*4;
		 p[0] = palette[n  ];
		 p[1] = palette[n+1];
		 p[2] = palette[n+2];
		 p[3] = palette[n+3];
		 p += 4;
	  }
   }
   STBI_FREE(a->out);
   a->out = temp_out;

   STBI_NOTUSED(len);

   return 1;
}

static int stbi__unpremultiply_on_load = 0;
static int stbi__de_iphone_flag = 0;

STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)
{
   stbi__unpremultiply_on_load = flag_true_if_should_unpremultiply;
}

STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)
{
   stbi__de_iphone_flag = flag_true_if_should_convert;
}

static void stbi__de_iphone(stbi__png *z)
{
   stbi__context *s = z->s;
   stbi__uint32 i, pixel_count = s->img_x * s->img_y;
   stbi_uc *p = z->out;

   if (s->img_out_n == 3) {  // convert bgr to rgb
	  for (i=0; i < pixel_count; ++i) {
		 stbi_uc t = p[0];
		 p[0] = p[2];
		 p[2] = t;
		 p += 3;
	  }
   } else {
	  STBI_ASSERT(s->img_out_n == 4);
	  if (stbi__unpremultiply_on_load) {
		 // convert bgr to rgb and unpremultiply
		 for (i=0; i < pixel_count; ++i) {
			stbi_uc a = p[3];
			stbi_uc t = p[0];
			if (a) {
			   p[0] = p[2] * 255 / a;
			   p[1] = p[1] * 255 / a;
			   p[2] =  t   * 255 / a;
			} else {
			   p[0] = p[2];
			   p[2] = t;
			}
			p += 4;
		 }
	  } else {
		 // convert bgr to rgb
		 for (i=0; i < pixel_count; ++i) {
			stbi_uc t = p[0];
			p[0] = p[2];
			p[2] = t;
			p += 4;
		 }
	  }
   }
}

#define STBI__PNG_TYPE(a,b,c,d)  (((a) << 24) + ((b) << 16) + ((c) << 8) + (d))

static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)
{
   stbi_uc palette[1024], pal_img_n=0;
   stbi_uc has_trans=0, tc[3];
   stbi__uint16 tc16[3];
   stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;
   int first=1,k,interlace=0, color=0, is_iphone=0;
   stbi__context *s = z->s;

   z->expanded = NULL;
   z->idata = NULL;
   z->out = NULL;

   if (!stbi__check_png_header(s)) return 0;

   if (scan == STBI__SCAN_type) return 1;

   for (;;) {
	  stbi__pngchunk c = stbi__get_chunk_header(s);
	  switch (c.type) {
		 case STBI__PNG_TYPE('C','g','B','I'):
			is_iphone = 1;
			stbi__skip(s, c.length);
			break;
		 case STBI__PNG_TYPE('I','H','D','R'): {
			int comp,filter;
			if (!first) return stbi__err("multiple IHDR","Corrupt PNG");
			first = 0;
			if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");
			s->img_x = stbi__get32be(s); if (s->img_x > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
			s->img_y = stbi__get32be(s); if (s->img_y > (1 << 24)) return stbi__err("too large","Very large image (corrupt?)");
			z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");
			color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");
			if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");
			if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");
			comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");
			filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");
			interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");
			if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");
			if (!pal_img_n) {
			   s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);
			   if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");
			   if (scan == STBI__SCAN_header) return 1;
			} else {
			   // if paletted, then pal_n is our final components, and
			   // img_n is # components to decompress/filter.
			   s->img_n = 1;
			   if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");
			   // if SCAN_header, have to scan to see if we have a tRNS
			}
			break;
		 }

		 case STBI__PNG_TYPE('P','L','T','E'):  {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");
			pal_len = c.length / 3;
			if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");
			for (i=0; i < pal_len; ++i) {
			   palette[i*4+0] = stbi__get8(s);
			   palette[i*4+1] = stbi__get8(s);
			   palette[i*4+2] = stbi__get8(s);
			   palette[i*4+3] = 255;
			}
			break;
		 }

		 case STBI__PNG_TYPE('t','R','N','S'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");
			if (pal_img_n) {
			   if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }
			   if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");
			   if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");
			   pal_img_n = 4;
			   for (i=0; i < c.length; ++i)
				  palette[i*4+3] = stbi__get8(s);
			} else {
			   if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");
			   if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");
			   has_trans = 1;
			   if (z->depth == 16) {
				  for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is
			   } else {
				  for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger
			   }
			}
			break;
		 }

		 case STBI__PNG_TYPE('I','D','A','T'): {
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");
			if (scan == STBI__SCAN_header) { s->img_n = pal_img_n; return 1; }
			if ((int)(ioff + c.length) < (int)ioff) return 0;
			if (ioff + c.length > idata_limit) {
			   stbi__uint32 idata_limit_old = idata_limit;
			   stbi_uc *p;
			   if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;
			   while (ioff + c.length > idata_limit)
				  idata_limit *= 2;
			   STBI_NOTUSED(idata_limit_old);
			   p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");
			   z->idata = p;
			}
			if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");
			ioff += c.length;
			break;
		 }

		 case STBI__PNG_TYPE('I','E','N','D'): {
			stbi__uint32 raw_len, bpl;
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if (scan != STBI__SCAN_load) return 1;
			if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");
			// initial guess for decoded data size to avoid unnecessary reallocs
			bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component
			raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;
			z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);
			if (z->expanded == NULL) return 0; // zlib should set error
			STBI_FREE(z->idata); z->idata = NULL;
			if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)
			   s->img_out_n = s->img_n+1;
			else
			   s->img_out_n = s->img_n;
			if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;
			if (has_trans) {
			   if (z->depth == 16) {
				  if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;
			   } else {
				  if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;
			   }
			}
			if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)
			   stbi__de_iphone(z);
			if (pal_img_n) {
			   // pal_img_n == 3 or 4
			   s->img_n = pal_img_n; // record the actual colors we had
			   s->img_out_n = pal_img_n;
			   if (req_comp >= 3) s->img_out_n = req_comp;
			   if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))
				  return 0;
			}
			STBI_FREE(z->expanded); z->expanded = NULL;
			return 1;
		 }

		 default:
			// if critical, fail
			if (first) return stbi__err("first not IHDR", "Corrupt PNG");
			if ((c.type & (1 << 29)) == 0) {
			   #ifndef STBI_NO_FAILURE_STRINGS
			   // not threadsafe
			   static char invalid_chunk[] = "XXXX PNG chunk not known";
			   invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);
			   invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);
			   invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);
			   invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);
			   #endif
			   return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");
			}
			stbi__skip(s, c.length);
			break;
	  }
	  // end of PNG chunk, read and skip CRC
	  stbi__get32be(s);
   }
}

static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)
{
   void *result=NULL;
   if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");
   if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {
	  if (p->depth < 8)
		 ri->bits_per_channel = 8;
	  else
		 ri->bits_per_channel = p->depth;
	  result = p->out;
	  p->out = NULL;
	  if (req_comp && req_comp != p->s->img_out_n) {
		 if (ri->bits_per_channel == 8)
			result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
		 else
			result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);
		 p->s->img_out_n = req_comp;
		 if (result == NULL) return result;
	  }
	  *x = p->s->img_x;
	  *y = p->s->img_y;
	  if (n) *n = p->s->img_n;
   }
   STBI_FREE(p->out);      p->out      = NULL;
   STBI_FREE(p->expanded); p->expanded = NULL;
   STBI_FREE(p->idata);    p->idata    = NULL;

   return result;
}

static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi__png p;
   p.s = s;
   return stbi__do_png(&p, x,y,comp,req_comp, ri);
}

static int stbi__png_test(stbi__context *s)
{
   int r;
   r = stbi__check_png_header(s);
   stbi__rewind(s);
   return r;
}

static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)
{
   if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {
	  stbi__rewind( p->s );
	  return 0;
   }
   if (x) *x = p->s->img_x;
   if (y) *y = p->s->img_y;
   if (comp) *comp = p->s->img_n;
   return 1;
}

static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__png p;
   p.s = s;
   return stbi__png_info_raw(&p, x, y, comp);
}
#endif

// Microsoft/Windows BMP image

#ifndef STBI_NO_BMP
static int stbi__bmp_test_raw(stbi__context *s)
{
   int r;
   int sz;
   if (stbi__get8(s) != 'B') return 0;
   if (stbi__get8(s) != 'M') return 0;
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   stbi__get32le(s); // discard data offset
   sz = stbi__get32le(s);
   r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);
   return r;
}

static int stbi__bmp_test(stbi__context *s)
{
   int r = stbi__bmp_test_raw(s);
   stbi__rewind(s);
   return r;
}

// returns 0..31 for the highest set bit
static int stbi__high_bit(unsigned int z)
{
   int n=0;
   if (z == 0) return -1;
   if (z >= 0x10000) n += 16, z >>= 16;
   if (z >= 0x00100) n +=  8, z >>=  8;
   if (z >= 0x00010) n +=  4, z >>=  4;
   if (z >= 0x00004) n +=  2, z >>=  2;
   if (z >= 0x00002) n +=  1, z >>=  1;
   return n;
}

static int stbi__bitcount(unsigned int a)
{
   a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2
   a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4
   a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits
   a = (a + (a >> 8)); // max 16 per 8 bits
   a = (a + (a >> 16)); // max 32 per 8 bits
   return a & 0xff;
}

static int stbi__shiftsigned(int v, int shift, int bits)
{
   int result;
   int z=0;

   if (shift < 0) v <<= -shift;
   else v >>= shift;
   result = v;

   z = bits;
   while (z < 8) {
	  result += v >> z;
	  z += bits;
   }
   return result;
}

typedef struct
{
   int bpp, offset, hsz;
   unsigned int mr,mg,mb,ma, all_a;
} stbi__bmp_data;

static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)
{
   int hsz;
   if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");
   stbi__get32le(s); // discard filesize
   stbi__get16le(s); // discard reserved
   stbi__get16le(s); // discard reserved
   info->offset = stbi__get32le(s);
   info->hsz = hsz = stbi__get32le(s);
   info->mr = info->mg = info->mb = info->ma = 0;

   if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");
   if (hsz == 12) {
	  s->img_x = stbi__get16le(s);
	  s->img_y = stbi__get16le(s);
   } else {
	  s->img_x = stbi__get32le(s);
	  s->img_y = stbi__get32le(s);
   }
   if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");
   info->bpp = stbi__get16le(s);
   if (info->bpp == 1) return stbi__errpuc("monochrome", "BMP type not supported: 1-bit");
   if (hsz != 12) {
	  int compress = stbi__get32le(s);
	  if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");
	  stbi__get32le(s); // discard sizeof
	  stbi__get32le(s); // discard hres
	  stbi__get32le(s); // discard vres
	  stbi__get32le(s); // discard colorsused
	  stbi__get32le(s); // discard max important
	  if (hsz == 40 || hsz == 56) {
		 if (hsz == 56) {
			stbi__get32le(s);
			stbi__get32le(s);
			stbi__get32le(s);
			stbi__get32le(s);
		 }
		 if (info->bpp == 16 || info->bpp == 32) {
			if (compress == 0) {
			   if (info->bpp == 32) {
				  info->mr = 0xffu << 16;
				  info->mg = 0xffu <<  8;
				  info->mb = 0xffu <<  0;
				  info->ma = 0xffu << 24;
				  info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0
			   } else {
				  info->mr = 31u << 10;
				  info->mg = 31u <<  5;
				  info->mb = 31u <<  0;
			   }
			} else if (compress == 3) {
			   info->mr = stbi__get32le(s);
			   info->mg = stbi__get32le(s);
			   info->mb = stbi__get32le(s);
			   // not documented, but generated by photoshop and handled by mspaint
			   if (info->mr == info->mg && info->mg == info->mb) {
				  // ?!?!?
				  return stbi__errpuc("bad BMP", "bad BMP");
			   }
			} else
			   return stbi__errpuc("bad BMP", "bad BMP");
		 }
	  } else {
		 int i;
		 if (hsz != 108 && hsz != 124)
			return stbi__errpuc("bad BMP", "bad BMP");
		 info->mr = stbi__get32le(s);
		 info->mg = stbi__get32le(s);
		 info->mb = stbi__get32le(s);
		 info->ma = stbi__get32le(s);
		 stbi__get32le(s); // discard color space
		 for (i=0; i < 12; ++i)
			stbi__get32le(s); // discard color space parameters
		 if (hsz == 124) {
			stbi__get32le(s); // discard rendering intent
			stbi__get32le(s); // discard offset of profile data
			stbi__get32le(s); // discard size of profile data
			stbi__get32le(s); // discard reserved
		 }
	  }
   }
   return (void *) 1;
}

static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   unsigned int mr=0,mg=0,mb=0,ma=0, all_a;
   stbi_uc pal[256][4];
   int psize=0,i,j,width;
   int flip_vertically, pad, target;
   stbi__bmp_data info;
   STBI_NOTUSED(ri);

   info.all_a = 255;
   if (stbi__bmp_parse_header(s, &info) == NULL)
	  return NULL; // error code already set

   flip_vertically = ((int) s->img_y) > 0;
   s->img_y = abs((int) s->img_y);

   mr = info.mr;
   mg = info.mg;
   mb = info.mb;
   ma = info.ma;
   all_a = info.all_a;

   if (info.hsz == 12) {
	  if (info.bpp < 24)
		 psize = (info.offset - 14 - 24) / 3;
   } else {
	  if (info.bpp < 16)
		 psize = (info.offset - 14 - info.hsz) >> 2;
   }

   s->img_n = ma ? 4 : 3;
   if (req_comp && req_comp >= 3) // we can directly decode 3 or 4
	  target = req_comp;
   else
	  target = s->img_n; // if they want monochrome, we'll post-convert

   // sanity-check size
   if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))
	  return stbi__errpuc("too large", "Corrupt BMP");

   out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   if (info.bpp < 16) {
	  int z=0;
	  if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }
	  for (i=0; i < psize; ++i) {
		 pal[i][2] = stbi__get8(s);
		 pal[i][1] = stbi__get8(s);
		 pal[i][0] = stbi__get8(s);
		 if (info.hsz != 12) stbi__get8(s);
		 pal[i][3] = 255;
	  }
	  stbi__skip(s, info.offset - 14 - info.hsz - psize * (info.hsz == 12 ? 3 : 4));
	  if (info.bpp == 4) width = (s->img_x + 1) >> 1;
	  else if (info.bpp == 8) width = s->img_x;
	  else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }
	  pad = (-width)&3;
	  for (j=0; j < (int) s->img_y; ++j) {
		 for (i=0; i < (int) s->img_x; i += 2) {
			int v=stbi__get8(s),v2=0;
			if (info.bpp == 4) {
			   v2 = v & 15;
			   v >>= 4;
			}
			out[z++] = pal[v][0];
			out[z++] = pal[v][1];
			out[z++] = pal[v][2];
			if (target == 4) out[z++] = 255;
			if (i+1 == (int) s->img_x) break;
			v = (info.bpp == 8) ? stbi__get8(s) : v2;
			out[z++] = pal[v][0];
			out[z++] = pal[v][1];
			out[z++] = pal[v][2];
			if (target == 4) out[z++] = 255;
		 }
		 stbi__skip(s, pad);
	  }
   } else {
	  int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;
	  int z = 0;
	  int easy=0;
	  stbi__skip(s, info.offset - 14 - info.hsz);
	  if (info.bpp == 24) width = 3 * s->img_x;
	  else if (info.bpp == 16) width = 2*s->img_x;
	  else /* bpp = 32 and pad = 0 */ width=0;
	  pad = (-width) & 3;
	  if (info.bpp == 24) {
		 easy = 1;
	  } else if (info.bpp == 32) {
		 if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)
			easy = 2;
	  }
	  if (!easy) {
		 if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }
		 // right shift amt to put high bit in position #7
		 rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);
		 gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);
		 bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);
		 ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);
	  }
	  for (j=0; j < (int) s->img_y; ++j) {
		 if (easy) {
			for (i=0; i < (int) s->img_x; ++i) {
			   unsigned char a;
			   out[z+2] = stbi__get8(s);
			   out[z+1] = stbi__get8(s);
			   out[z+0] = stbi__get8(s);
			   z += 3;
			   a = (easy == 2 ? stbi__get8(s) : 255);
			   all_a |= a;
			   if (target == 4) out[z++] = a;
			}
		 } else {
			int bpp = info.bpp;
			for (i=0; i < (int) s->img_x; ++i) {
			   stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));
			   int a;
			   out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));
			   out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));
			   out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));
			   a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);
			   all_a |= a;
			   if (target == 4) out[z++] = STBI__BYTECAST(a);
			}
		 }
		 stbi__skip(s, pad);
	  }
   }

   // if alpha channel is all 0s, replace with all 255s
   if (target == 4 && all_a == 0)
	  for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)
		 out[i] = 255;

   if (flip_vertically) {
	  stbi_uc t;
	  for (j=0; j < (int) s->img_y>>1; ++j) {
		 stbi_uc *p1 = out +      j     *s->img_x*target;
		 stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;
		 for (i=0; i < (int) s->img_x*target; ++i) {
			t = p1[i], p1[i] = p2[i], p2[i] = t;
		 }
	  }
   }

   if (req_comp && req_comp != target) {
	  out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);
	  if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;
   return out;
}
#endif

// Targa Truevision - TGA
// by Jonathan Dummer
#ifndef STBI_NO_TGA
// returns STBI_rgb or whatever, 0 on error
static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)
{
   // only RGB or RGBA (incl. 16bit) or grey allowed
   if(is_rgb16) *is_rgb16 = 0;
   switch(bits_per_pixel) {
	  case 8:  return STBI_grey;
	  case 16: if(is_grey) return STBI_grey_alpha;
			// else: fall-through
	  case 15: if(is_rgb16) *is_rgb16 = 1;
			return STBI_rgb;
	  case 24: // fall-through
	  case 32: return bits_per_pixel/8;
	  default: return 0;
   }
}

static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)
{
	int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
	int sz, tga_colormap_type;
	stbi__get8(s);                   // discard Offset
	tga_colormap_type = stbi__get8(s); // colormap type
	if( tga_colormap_type > 1 ) {
		stbi__rewind(s);
		return 0;      // only RGB or indexed allowed
	}
	tga_image_type = stbi__get8(s); // image type
	if ( tga_colormap_type == 1 ) { // colormapped (paletted) image
		if (tga_image_type != 1 && tga_image_type != 9) {
			stbi__rewind(s);
			return 0;
		}
		stbi__skip(s,4);       // skip index of first colormap entry and number of entries
		sz = stbi__get8(s);    //   check bits per palette color entry
		if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {
			stbi__rewind(s);
			return 0;
		}
		stbi__skip(s,4);       // skip image x and y origin
		tga_colormap_bpp = sz;
	} else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE
		if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {
			stbi__rewind(s);
			return 0; // only RGB or grey allowed, +/- RLE
		}
		stbi__skip(s,9); // skip colormap specification and image x/y origin
		tga_colormap_bpp = 0;
	}
	tga_w = stbi__get16le(s);
	if( tga_w < 1 ) {
		stbi__rewind(s);
		return 0;   // test width
	}
	tga_h = stbi__get16le(s);
	if( tga_h < 1 ) {
		stbi__rewind(s);
		return 0;   // test height
	}
	tga_bits_per_pixel = stbi__get8(s); // bits per pixel
	stbi__get8(s); // ignore alpha bits
	if (tga_colormap_bpp != 0) {
		if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {
			// when using a colormap, tga_bits_per_pixel is the size of the indexes
			// I don't think anything but 8 or 16bit indexes makes sense
			stbi__rewind(s);
			return 0;
		}
		tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);
	} else {
		tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);
	}
	if(!tga_comp) {
	  stbi__rewind(s);
	  return 0;
	}
	if (x) *x = tga_w;
	if (y) *y = tga_h;
	if (comp) *comp = tga_comp;
	return 1;                   // seems to have passed everything
}

static int stbi__tga_test(stbi__context *s)
{
   int res = 0;
   int sz, tga_color_type;
   stbi__get8(s);      //   discard Offset
   tga_color_type = stbi__get8(s);   //   color type
   if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed
   sz = stbi__get8(s);   //   image type
   if ( tga_color_type == 1 ) { // colormapped (paletted) image
	  if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9
	  stbi__skip(s,4);       // skip index of first colormap entry and number of entries
	  sz = stbi__get8(s);    //   check bits per palette color entry
	  if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;
	  stbi__skip(s,4);       // skip image x and y origin
   } else { // "normal" image w/o colormap
	  if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE
	  stbi__skip(s,9); // skip colormap specification and image x/y origin
   }
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width
   if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height
   sz = stbi__get8(s);   //   bits per pixel
   if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index
   if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

   res = 1; // if we got this far, everything's good and we can return 1 instead of 0

errorEnd:
   stbi__rewind(s);
   return res;
}

// read 16bit value and convert to 24bit RGB
static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)
{
   stbi__uint16 px = (stbi__uint16)stbi__get16le(s);
   stbi__uint16 fiveBitMask = 31;
   // we have 3 channels with 5bits each
   int r = (px >> 10) & fiveBitMask;
   int g = (px >> 5) & fiveBitMask;
   int b = px & fiveBitMask;
   // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
   out[0] = (stbi_uc)((r * 255)/31);
   out[1] = (stbi_uc)((g * 255)/31);
   out[2] = (stbi_uc)((b * 255)/31);

   // some people claim that the most significant bit might be used for alpha
   // (possibly if an alpha-bit is set in the "image descriptor byte")
   // but that only made 16bit test images completely translucent..
   // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
}

static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   //   read in the TGA header stuff
   int tga_offset = stbi__get8(s);
   int tga_indexed = stbi__get8(s);
   int tga_image_type = stbi__get8(s);
   int tga_is_RLE = 0;
   int tga_palette_start = stbi__get16le(s);
   int tga_palette_len = stbi__get16le(s);
   int tga_palette_bits = stbi__get8(s);
   int tga_x_origin = stbi__get16le(s);
   int tga_y_origin = stbi__get16le(s);
   int tga_width = stbi__get16le(s);
   int tga_height = stbi__get16le(s);
   int tga_bits_per_pixel = stbi__get8(s);
   int tga_comp, tga_rgb16=0;
   int tga_inverted = stbi__get8(s);
   // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
   //   image data
   unsigned char *tga_data;
   unsigned char *tga_palette = NULL;
   int i, j;
   unsigned char raw_data[4] = {0};
   int RLE_count = 0;
   int RLE_repeating = 0;
   int read_next_pixel = 1;
   STBI_NOTUSED(ri);

   //   do a tiny bit of precessing
   if ( tga_image_type >= 8 )
   {
	  tga_image_type -= 8;
	  tga_is_RLE = 1;
   }
   tga_inverted = 1 - ((tga_inverted >> 5) & 1);

   //   If I'm paletted, then I'll use the number of bits from the palette
   if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);
   else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

   if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency
	  return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

   //   tga info
   *x = tga_width;
   *y = tga_height;
   if (comp) *comp = tga_comp;

   if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))
	  return stbi__errpuc("too large", "Corrupt TGA");

   tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);
   if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

   // skip to the data's starting position (offset usually = 0)
   stbi__skip(s, tga_offset );

   if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {
	  for (i=0; i < tga_height; ++i) {
		 int row = tga_inverted ? tga_height -i - 1 : i;
		 stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;
		 stbi__getn(s, tga_row, tga_width * tga_comp);
	  }
   } else  {
	  //   do I need to load a palette?
	  if ( tga_indexed)
	  {
		 //   any data to skip? (offset usually = 0)
		 stbi__skip(s, tga_palette_start );
		 //   load the palette
		 tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);
		 if (!tga_palette) {
			STBI_FREE(tga_data);
			return stbi__errpuc("outofmem", "Out of memory");
		 }
		 if (tga_rgb16) {
			stbi_uc *pal_entry = tga_palette;
			STBI_ASSERT(tga_comp == STBI_rgb);
			for (i=0; i < tga_palette_len; ++i) {
			   stbi__tga_read_rgb16(s, pal_entry);
			   pal_entry += tga_comp;
			}
		 } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {
			   STBI_FREE(tga_data);
			   STBI_FREE(tga_palette);
			   return stbi__errpuc("bad palette", "Corrupt TGA");
		 }
	  }
	  //   load the data
	  for (i=0; i < tga_width * tga_height; ++i)
	  {
		 //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
		 if ( tga_is_RLE )
		 {
			if ( RLE_count == 0 )
			{
			   //   yep, get the next byte as a RLE command
			   int RLE_cmd = stbi__get8(s);
			   RLE_count = 1 + (RLE_cmd & 127);
			   RLE_repeating = RLE_cmd >> 7;
			   read_next_pixel = 1;
			} else if ( !RLE_repeating )
			{
			   read_next_pixel = 1;
			}
		 } else
		 {
			read_next_pixel = 1;
		 }
		 //   OK, if I need to read a pixel, do it now
		 if ( read_next_pixel )
		 {
			//   load however much data we did have
			if ( tga_indexed )
			{
			   // read in index, then perform the lookup
			   int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);
			   if ( pal_idx >= tga_palette_len ) {
				  // invalid index
				  pal_idx = 0;
			   }
			   pal_idx *= tga_comp;
			   for (j = 0; j < tga_comp; ++j) {
				  raw_data[j] = tga_palette[pal_idx+j];
			   }
			} else if(tga_rgb16) {
			   STBI_ASSERT(tga_comp == STBI_rgb);
			   stbi__tga_read_rgb16(s, raw_data);
			} else {
			   //   read in the data raw
			   for (j = 0; j < tga_comp; ++j) {
				  raw_data[j] = stbi__get8(s);
			   }
			}
			//   clear the reading flag for the next pixel
			read_next_pixel = 0;
		 } // end of reading a pixel

		 // copy data
		 for (j = 0; j < tga_comp; ++j)
		   tga_data[i*tga_comp+j] = raw_data[j];

		 //   in case we're in RLE mode, keep counting down
		 --RLE_count;
	  }
	  //   do I need to invert the image?
	  if ( tga_inverted )
	  {
		 for (j = 0; j*2 < tga_height; ++j)
		 {
			int index1 = j * tga_width * tga_comp;
			int index2 = (tga_height - 1 - j) * tga_width * tga_comp;
			for (i = tga_width * tga_comp; i > 0; --i)
			{
			   unsigned char temp = tga_data[index1];
			   tga_data[index1] = tga_data[index2];
			   tga_data[index2] = temp;
			   ++index1;
			   ++index2;
			}
		 }
	  }
	  //   clear my palette, if I had one
	  if ( tga_palette != NULL )
	  {
		 STBI_FREE( tga_palette );
	  }
   }

   // swap RGB - if the source data was RGB16, it already is in the right order
   if (tga_comp >= 3 && !tga_rgb16)
   {
	  unsigned char* tga_pixel = tga_data;
	  for (i=0; i < tga_width * tga_height; ++i)
	  {
		 unsigned char temp = tga_pixel[0];
		 tga_pixel[0] = tga_pixel[2];
		 tga_pixel[2] = temp;
		 tga_pixel += tga_comp;
	  }
   }

   // convert to target component count
   if (req_comp && req_comp != tga_comp)
	  tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

   //   the things I do to get rid of an error message, and yet keep
   //   Microsoft's C compilers happy... [8^(
   tga_palette_start = tga_palette_len = tga_palette_bits =
		 tga_x_origin = tga_y_origin = 0;
   //   OK, done
   return tga_data;
}
#endif

// *************************************************************************************************
// Photoshop PSD loader -- PD by Thatcher Ulrich, integration by Nicolas Schulz, tweaked by STB

#ifndef STBI_NO_PSD
static int stbi__psd_test(stbi__context *s)
{
   int r = (stbi__get32be(s) == 0x38425053);
   stbi__rewind(s);
   return r;
}

static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)
{
   int count, nleft, len;

   count = 0;
   while ((nleft = pixelCount - count) > 0) {
	  len = stbi__get8(s);
	  if (len == 128) {
		 // No-op.
	  } else if (len < 128) {
		 // Copy next len+1 bytes literally.
		 len++;
		 if (len > nleft) return 0; // corrupt data
		 count += len;
		 while (len) {
			*p = stbi__get8(s);
			p += 4;
			len--;
		 }
	  } else if (len > 128) {
		 stbi_uc   val;
		 // Next -len+1 bytes in the dest are replicated from next source byte.
		 // (Interpret len as a negative 8-bit int.)
		 len = 257 - len;
		 if (len > nleft) return 0; // corrupt data
		 val = stbi__get8(s);
		 count += len;
		 while (len) {
			*p = val;
			p += 4;
			len--;
		 }
	  }
   }

   return 1;
}

static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)
{
   int pixelCount;
   int channelCount, compression;
   int channel, i;
   int bitdepth;
   int w,h;
   stbi_uc *out;
   STBI_NOTUSED(ri);

   // Check identifier
   if (stbi__get32be(s) != 0x38425053)   // "8BPS"
	  return stbi__errpuc("not PSD", "Corrupt PSD image");

   // Check file type version.
   if (stbi__get16be(s) != 1)
	  return stbi__errpuc("wrong version", "Unsupported version of PSD image");

   // Skip 6 reserved bytes.
   stbi__skip(s, 6 );

   // Read the number of channels (R, G, B, A, etc).
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16)
	  return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

   // Read the rows and columns of the image.
   h = stbi__get32be(s);
   w = stbi__get32be(s);

   // Make sure the depth is 8 bits.
   bitdepth = stbi__get16be(s);
   if (bitdepth != 8 && bitdepth != 16)
	  return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

   // Make sure the color mode is RGB.
   // Valid options are:
   //   0: Bitmap
   //   1: Grayscale
   //   2: Indexed color
   //   3: RGB color
   //   4: CMYK color
   //   7: Multichannel
   //   8: Duotone
   //   9: Lab color
   if (stbi__get16be(s) != 3)
	  return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

   // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
   stbi__skip(s,stbi__get32be(s) );

   // Skip the image resources.  (resolution, pen tool paths, etc)
   stbi__skip(s, stbi__get32be(s) );

   // Skip the reserved data.
   stbi__skip(s, stbi__get32be(s) );

   // Find out if the data is compressed.
   // Known values:
   //   0: no compression
   //   1: RLE compressed
   compression = stbi__get16be(s);
   if (compression > 1)
	  return stbi__errpuc("bad compression", "PSD has an unknown compression format");

   // Check size
   if (!stbi__mad3sizes_valid(4, w, h, 0))
	  return stbi__errpuc("too large", "Corrupt PSD");

   // Create the destination image.

   if (!compression && bitdepth == 16 && bpc == 16) {
	  out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);
	  ri->bits_per_channel = 16;
   } else
	  out = (stbi_uc *) stbi__malloc(4 * w*h);

   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   pixelCount = w*h;

   // Initialize the data to zero.
   //memset( out, 0, pixelCount * 4 );

   // Finally, the image data.
   if (compression) {
	  // RLE as used by .PSD and .TIFF
	  // Loop until you get the number of unpacked bytes you are expecting:
	  //     Read the next source byte into n.
	  //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
	  //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
	  //     Else if n is 128, noop.
	  // Endloop

	  // The RLE-compressed data is preceeded by a 2-byte data count for each row in the data,
	  // which we're going to just skip.
	  stbi__skip(s, h * channelCount * 2 );

	  // Read the RLE data by channel.
	  for (channel = 0; channel < 4; channel++) {
		 stbi_uc *p;

		 p = out+channel;
		 if (channel >= channelCount) {
			// Fill this channel with default data.
			for (i = 0; i < pixelCount; i++, p += 4)
			   *p = (channel == 3 ? 255 : 0);
		 } else {
			// Read the RLE data.
			if (!stbi__psd_decode_rle(s, p, pixelCount)) {
			   STBI_FREE(out);
			   return stbi__errpuc("corrupt", "bad RLE data");
			}
		 }
	  }

   } else {
	  // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
	  // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.

	  // Read the data by channel.
	  for (channel = 0; channel < 4; channel++) {
		 if (channel >= channelCount) {
			// Fill this channel with default data.
			if (bitdepth == 16 && bpc == 16) {
			   stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
			   stbi__uint16 val = channel == 3 ? 65535 : 0;
			   for (i = 0; i < pixelCount; i++, q += 4)
				  *q = val;
			} else {
			   stbi_uc *p = out+channel;
			   stbi_uc val = channel == 3 ? 255 : 0;
			   for (i = 0; i < pixelCount; i++, p += 4)
				  *p = val;
			}
		 } else {
			if (ri->bits_per_channel == 16) {    // output bpc
			   stbi__uint16 *q = ((stbi__uint16 *) out) + channel;
			   for (i = 0; i < pixelCount; i++, q += 4)
				  *q = (stbi__uint16) stbi__get16be(s);
			} else {
			   stbi_uc *p = out+channel;
			   if (bitdepth == 16) {  // input bpc
				  for (i = 0; i < pixelCount; i++, p += 4)
					 *p = (stbi_uc) (stbi__get16be(s) >> 8);
			   } else {
				  for (i = 0; i < pixelCount; i++, p += 4)
					 *p = stbi__get8(s);
			   }
			}
		 }
	  }
   }

   // remove weird white matte from PSD
   if (channelCount >= 4) {
	  if (ri->bits_per_channel == 16) {
		 for (i=0; i < w*h; ++i) {
			stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;
			if (pixel[3] != 0 && pixel[3] != 65535) {
			   float a = pixel[3] / 65535.0f;
			   float ra = 1.0f / a;
			   float inv_a = 65535.0f * (1 - ra);
			   pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);
			   pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);
			   pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);
			}
		 }
	  } else {
		 for (i=0; i < w*h; ++i) {
			unsigned char *pixel = out + 4*i;
			if (pixel[3] != 0 && pixel[3] != 255) {
			   float a = pixel[3] / 255.0f;
			   float ra = 1.0f / a;
			   float inv_a = 255.0f * (1 - ra);
			   pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);
			   pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);
			   pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);
			}
		 }
	  }
   }

   // convert to desired output format
   if (req_comp && req_comp != 4) {
	  if (ri->bits_per_channel == 16)
		 out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);
	  else
		 out = stbi__convert_format(out, 4, req_comp, w, h);
	  if (out == NULL) return out; // stbi__convert_format frees input on failure
   }

   if (comp) *comp = 4;
   *y = h;
   *x = w;

   return out;
}
#endif

// *************************************************************************************************
// Softimage PIC loader
// by Tom Seddon
//
// See http://softimage.wiki.softimage.com/index.php/INFO:_PIC_file_format
// See http://ozviz.wasp.uwa.edu.au/~pbourke/dataformats/softimagepic/

#ifndef STBI_NO_PIC
static int stbi__pic_is4(stbi__context *s,const char *str)
{
   int i;
   for (i=0; i<4; ++i)
	  if (stbi__get8(s) != (stbi_uc)str[i])
		 return 0;

   return 1;
}

static int stbi__pic_test_core(stbi__context *s)
{
   int i;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))
	  return 0;

   for(i=0;i<84;++i)
	  stbi__get8(s);

   if (!stbi__pic_is4(s,"PICT"))
	  return 0;

   return 1;
}

typedef struct
{
   stbi_uc size,type,channel;
} stbi__pic_packet;

static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)
{
   int mask=0x80, i;

   for (i=0; i<4; ++i, mask>>=1) {
	  if (channel & mask) {
		 if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");
		 dest[i]=stbi__get8(s);
	  }
   }

   return dest;
}

static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)
{
   int mask=0x80,i;

   for (i=0;i<4; ++i, mask>>=1)
	  if (channel&mask)
		 dest[i]=src[i];
}

static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)
{
   int act_comp=0,num_packets=0,y,chained;
   stbi__pic_packet packets[10];

   // this will (should...) cater for even some bizarre stuff like having data
	// for the same channel in multiple packets.
   do {
	  stbi__pic_packet *packet;

	  if (num_packets==sizeof(packets)/sizeof(packets[0]))
		 return stbi__errpuc("bad format","too many packets");

	  packet = &packets[num_packets++];

	  chained = stbi__get8(s);
	  packet->size    = stbi__get8(s);
	  packet->type    = stbi__get8(s);
	  packet->channel = stbi__get8(s);

	  act_comp |= packet->channel;

	  if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");
	  if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

   for(y=0; y<height; ++y) {
	  int packet_idx;

	  for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {
		 stbi__pic_packet *packet = &packets[packet_idx];
		 stbi_uc *dest = result+y*width*4;

		 switch (packet->type) {
			default:
			   return stbi__errpuc("bad format","packet has bad compression type");

			case 0: {//uncompressed
			   int x;

			   for(x=0;x<width;++x, dest+=4)
				  if (!stbi__readval(s,packet->channel,dest))
					 return 0;
			   break;
			}

			case 1://Pure RLE
			   {
				  int left=width, i;

				  while (left>0) {
					 stbi_uc count,value[4];

					 count=stbi__get8(s);
					 if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

					 if (count > left)
						count = (stbi_uc) left;

					 if (!stbi__readval(s,packet->channel,value))  return 0;

					 for(i=0; i<count; ++i,dest+=4)
						stbi__copyval(packet->channel,dest,value);
					 left -= count;
				  }
			   }
			   break;

			case 2: {//Mixed RLE
			   int left=width;
			   while (left>0) {
				  int count = stbi__get8(s), i;
				  if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

				  if (count >= 128) { // Repeated
					 stbi_uc value[4];

					 if (count==128)
						count = stbi__get16be(s);
					 else
						count -= 127;
					 if (count > left)
						return stbi__errpuc("bad file","scanline overrun");

					 if (!stbi__readval(s,packet->channel,value))
						return 0;

					 for(i=0;i<count;++i, dest += 4)
						stbi__copyval(packet->channel,dest,value);
				  } else { // Raw
					 ++count;
					 if (count>left) return stbi__errpuc("bad file","scanline overrun");

					 for(i=0;i<count;++i, dest+=4)
						if (!stbi__readval(s,packet->channel,dest))
						   return 0;
				  }
				  left-=count;
			   }
			   break;
			}
		 }
	  }
   }

   return result;
}

static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)
{
   stbi_uc *result;
   int i, x,y, internal_comp;
   STBI_NOTUSED(ri);

   if (!comp) comp = &internal_comp;

   for (i=0; i<92; ++i)
	  stbi__get8(s);

   x = stbi__get16be(s);
   y = stbi__get16be(s);
   if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");
   if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

   stbi__get32be(s); //skip `ratio'
   stbi__get16be(s); //skip `fields'
   stbi__get16be(s); //skip `pad'

   // intermediate buffer is RGBA
   result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);
   memset(result, 0xff, x*y*4);

   if (!stbi__pic_load_core(s,x,y,comp, result)) {
	  STBI_FREE(result);
	  result=0;
   }
   *px = x;
   *py = y;
   if (req_comp == 0) req_comp = *comp;
   result=stbi__convert_format(result,4,req_comp,x,y);

   return result;
}

static int stbi__pic_test(stbi__context *s)
{
   int r = stbi__pic_test_core(s);
   stbi__rewind(s);
   return r;
}
#endif

// *************************************************************************************************
// GIF loader -- public domain by Jean-Marc Lienher -- simplified/shrunk by stb

#ifndef STBI_NO_GIF
typedef struct
{
   stbi__int16 prefix;
   stbi_uc first;
   stbi_uc suffix;
} stbi__gif_lzw;

typedef struct
{
   int w,h;
   stbi_uc *out, *old_out;             // output buffer (always 4 components)
   int flags, bgindex, ratio, transparent, eflags, delay;
   stbi_uc  pal[256][4];
   stbi_uc lpal[256][4];
   stbi__gif_lzw codes[4096];
   stbi_uc *color_table;
   int parse, step;
   int lflags;
   int start_x, start_y;
   int max_x, max_y;
   int cur_x, cur_y;
   int line_size;
} stbi__gif;

static int stbi__gif_test_raw(stbi__context *s)
{
   int sz;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;
   sz = stbi__get8(s);
   if (sz != '9' && sz != '7') return 0;
   if (stbi__get8(s) != 'a') return 0;
   return 1;
}

static int stbi__gif_test(stbi__context *s)
{
   int r = stbi__gif_test_raw(s);
   stbi__rewind(s);
   return r;
}

static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)
{
   int i;
   for (i=0; i < num_entries; ++i) {
	  pal[i][2] = stbi__get8(s);
	  pal[i][1] = stbi__get8(s);
	  pal[i][0] = stbi__get8(s);
	  pal[i][3] = transp == i ? 0 : 255;
   }
}

static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)
{
   stbi_uc version;
   if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')
	  return stbi__err("not GIF", "Corrupt GIF");

   version = stbi__get8(s);
   if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");
   if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

   stbi__g_failure_reason = "";
   g->w = stbi__get16le(s);
   g->h = stbi__get16le(s);
   g->flags = stbi__get8(s);
   g->bgindex = stbi__get8(s);
   g->ratio = stbi__get8(s);
   g->transparent = -1;

   if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

   if (is_info) return 1;

   if (g->flags & 0x80)
	  stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

   return 1;
}

static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)
{
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   if (!stbi__gif_header(s, g, comp, 1)) {
	  STBI_FREE(g);
	  stbi__rewind( s );
	  return 0;
   }
   if (x) *x = g->w;
   if (y) *y = g->h;
   STBI_FREE(g);
   return 1;
}

static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)
{
   stbi_uc *p, *c;

   // recurse to decode the prefixes, since the linked-list is backwards,
   // and working backwards through an interleaved image would be nasty
   if (g->codes[code].prefix >= 0)
	  stbi__out_gif_code(g, g->codes[code].prefix);

   if (g->cur_y >= g->max_y) return;

   p = &g->out[g->cur_x + g->cur_y];
   c = &g->color_table[g->codes[code].suffix * 4];

   if (c[3] >= 128) {
	  p[0] = c[2];
	  p[1] = c[1];
	  p[2] = c[0];
	  p[3] = c[3];
   }
   g->cur_x += 4;

   if (g->cur_x >= g->max_x) {
	  g->cur_x = g->start_x;
	  g->cur_y += g->step;

	  while (g->cur_y >= g->max_y && g->parse > 0) {
		 g->step = (1 << g->parse) * g->line_size;
		 g->cur_y = g->start_y + (g->step >> 1);
		 --g->parse;
	  }
   }
}

static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)
{
   stbi_uc lzw_cs;
   stbi__int32 len, init_code;
   stbi__uint32 first;
   stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
   stbi__gif_lzw *p;

   lzw_cs = stbi__get8(s);
   if (lzw_cs > 12) return NULL;
   clear = 1 << lzw_cs;
   first = 1;
   codesize = lzw_cs + 1;
   codemask = (1 << codesize) - 1;
   bits = 0;
   valid_bits = 0;
   for (init_code = 0; init_code < clear; init_code++) {
	  g->codes[init_code].prefix = -1;
	  g->codes[init_code].first = (stbi_uc) init_code;
	  g->codes[init_code].suffix = (stbi_uc) init_code;
   }

   // support no starting clear code
   avail = clear+2;
   oldcode = -1;

   len = 0;
   for(;;) {
	  if (valid_bits < codesize) {
		 if (len == 0) {
			len = stbi__get8(s); // start new block
			if (len == 0)
			   return g->out;
		 }
		 --len;
		 bits |= (stbi__int32) stbi__get8(s) << valid_bits;
		 valid_bits += 8;
	  } else {
		 stbi__int32 code = bits & codemask;
		 bits >>= codesize;
		 valid_bits -= codesize;
		 // @OPTIMIZE: is there some way we can accelerate the non-clear path?
		 if (code == clear) {  // clear code
			codesize = lzw_cs + 1;
			codemask = (1 << codesize) - 1;
			avail = clear + 2;
			oldcode = -1;
			first = 0;
		 } else if (code == clear + 1) { // end of stream code
			stbi__skip(s, len);
			while ((len = stbi__get8(s)) > 0)
			   stbi__skip(s,len);
			return g->out;
		 } else if (code <= avail) {
			if (first) return stbi__errpuc("no clear code", "Corrupt GIF");

			if (oldcode >= 0) {
			   p = &g->codes[avail++];
			   if (avail > 4096)        return stbi__errpuc("too many codes", "Corrupt GIF");
			   p->prefix = (stbi__int16) oldcode;
			   p->first = g->codes[oldcode].first;
			   p->suffix = (code == avail) ? p->first : g->codes[code].first;
			} else if (code == avail)
			   return stbi__errpuc("illegal code in raster", "Corrupt GIF");

			stbi__out_gif_code(g, (stbi__uint16) code);

			if ((avail & codemask) == 0 && avail <= 0x0FFF) {
			   codesize++;
			   codemask = (1 << codesize) - 1;
			}

			oldcode = code;
		 } else {
			return stbi__errpuc("illegal code in raster", "Corrupt GIF");
		 }
	  }
   }
}

static void stbi__fill_gif_background(stbi__gif *g, int x0, int y0, int x1, int y1)
{
   int x, y;
   stbi_uc *c = g->pal[g->bgindex];
   for (y = y0; y < y1; y += 4 * g->w) {
	  for (x = x0; x < x1; x += 4) {
		 stbi_uc *p  = &g->out[y + x];
		 p[0] = c[2];
		 p[1] = c[1];
		 p[2] = c[0];
		 p[3] = 0;
	  }
   }
}

// this function is designed to support animated gifs, although stb_image doesn't support it
static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp)
{
   int i;
   stbi_uc *prev_out = 0;

   if (g->out == 0 && !stbi__gif_header(s, g, comp,0))
	  return 0; // stbi__g_failure_reason set by stbi__gif_header

   if (!stbi__mad3sizes_valid(g->w, g->h, 4, 0))
	  return stbi__errpuc("too large", "GIF too large");

   prev_out = g->out;
   g->out = (stbi_uc *) stbi__malloc_mad3(4, g->w, g->h, 0);
   if (g->out == 0) return stbi__errpuc("outofmem", "Out of memory");

   switch ((g->eflags & 0x1C) >> 2) {
	  case 0: // unspecified (also always used on 1st frame)
		 stbi__fill_gif_background(g, 0, 0, 4 * g->w, 4 * g->w * g->h);
		 break;
	  case 1: // do not dispose
		 if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);
		 g->old_out = prev_out;
		 break;
	  case 2: // dispose to background
		 if (prev_out) memcpy(g->out, prev_out, 4 * g->w * g->h);
		 stbi__fill_gif_background(g, g->start_x, g->start_y, g->max_x, g->max_y);
		 break;
	  case 3: // dispose to previous
		 if (g->old_out) {
			for (i = g->start_y; i < g->max_y; i += 4 * g->w)
			   memcpy(&g->out[i + g->start_x], &g->old_out[i + g->start_x], g->max_x - g->start_x);
		 }
		 break;
   }

   for (;;) {
	  switch (stbi__get8(s)) {
		 case 0x2C: /* Image Descriptor */
		 {
			int prev_trans = -1;
			stbi__int32 x, y, w, h;
			stbi_uc *o;

			x = stbi__get16le(s);
			y = stbi__get16le(s);
			w = stbi__get16le(s);
			h = stbi__get16le(s);
			if (((x + w) > (g->w)) || ((y + h) > (g->h)))
			   return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

			g->line_size = g->w * 4;
			g->start_x = x * 4;
			g->start_y = y * g->line_size;
			g->max_x   = g->start_x + w * 4;
			g->max_y   = g->start_y + h * g->line_size;
			g->cur_x   = g->start_x;
			g->cur_y   = g->start_y;

			g->lflags = stbi__get8(s);

			if (g->lflags & 0x40) {
			   g->step = 8 * g->line_size; // first interlaced spacing
			   g->parse = 3;
			} else {
			   g->step = g->line_size;
			   g->parse = 0;
			}

			if (g->lflags & 0x80) {
			   stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);
			   g->color_table = (stbi_uc *) g->lpal;
			} else if (g->flags & 0x80) {
			   if (g->transparent >= 0 && (g->eflags & 0x01)) {
				  prev_trans = g->pal[g->transparent][3];
				  g->pal[g->transparent][3] = 0;
			   }
			   g->color_table = (stbi_uc *) g->pal;
			} else
			   return stbi__errpuc("missing color table", "Corrupt GIF");

			o = stbi__process_gif_raster(s, g);
			if (o == NULL) return NULL;

			if (prev_trans != -1)
			   g->pal[g->transparent][3] = (stbi_uc) prev_trans;

			return o;
		 }

		 case 0x21: // Comment Extension.
		 {
			int len;
			if (stbi__get8(s) == 0xF9) { // Graphic Control Extension.
			   len = stbi__get8(s);
			   if (len == 4) {
				  g->eflags = stbi__get8(s);
				  g->delay = stbi__get16le(s);
				  g->transparent = stbi__get8(s);
			   } else {
				  stbi__skip(s, len);
				  break;
			   }
			}
			while ((len = stbi__get8(s)) != 0)
			   stbi__skip(s, len);
			break;
		 }

		 case 0x3B: // gif stream termination code
			return (stbi_uc *) s; // using '1' causes warning on some compilers

		 default:
			return stbi__errpuc("unknown code", "Corrupt GIF");
	  }
   }

   STBI_NOTUSED(req_comp);
}

static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *u = 0;
   stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));
   memset(g, 0, sizeof(*g));
   STBI_NOTUSED(ri);

   u = stbi__gif_load_next(s, g, comp, req_comp);
   if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker
   if (u) {
	  *x = g->w;
	  *y = g->h;
	  if (req_comp && req_comp != 4)
		 u = stbi__convert_format(u, 4, req_comp, g->w, g->h);
   }
   else if (g->out)
	  STBI_FREE(g->out);
   STBI_FREE(g);
   return u;
}

static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)
{
   return stbi__gif_info_raw(s,x,y,comp);
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR loader
// originally by Nicolas Schulz
#ifndef STBI_NO_HDR
static int stbi__hdr_test_core(stbi__context *s, const char *signature)
{
   int i;
   for (i=0; signature[i]; ++i)
	  if (stbi__get8(s) != signature[i])
		  return 0;
   stbi__rewind(s);
   return 1;
}

static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, "#?RADIANCE\n");
   stbi__rewind(s);
   if(!r) {
	   r = stbi__hdr_test_core(s, "#?RGBE\n");
	   stbi__rewind(s);
   }
   return r;
}

#define STBI__HDR_BUFLEN  1024
static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)
{
   int len=0;
   char c = '\0';

   c = (char) stbi__get8(z);

   while (!stbi__at_eof(z) && c != '\n') {
	  buffer[len++] = c;
	  if (len == STBI__HDR_BUFLEN-1) {
		 // flush to end of line
		 while (!stbi__at_eof(z) && stbi__get8(z) != '\n')
			;
		 break;
	  }
	  c = (char) stbi__get8(z);
   }

   buffer[len] = 0;
   return buffer;
}

static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
	  float f1;
	  // Exponent
	  f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
	  if (req_comp <= 2)
		 output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
	  else {
		 output[0] = input[0] * f1;
		 output[1] = input[1] * f1;
		 output[2] = input[2] * f1;
	  }
	  if (req_comp == 2) output[1] = 1;
	  if (req_comp == 4) output[3] = 1;
   } else {
	  switch (req_comp) {
		 case 4: output[3] = 1; /* fallthrough */
		 case 3: output[0] = output[1] = output[2] = 0;
				 break;
		 case 2: output[1] = 1; /* fallthrough */
		 case 1: output[0] = 0;
				 break;
	  }
   }
}

static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int width, height;
   stbi_uc *scanline;
   float *hdr_data;
   int len;
   unsigned char count, value;
   int i, j, k, c1,c2, z;
   const char *headerToken;
   STBI_NOTUSED(ri);

   // Check identifier
   headerToken = stbi__hdr_gettoken(s,buffer);
   if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)
	  return stbi__errpf("not HDR", "Corrupt HDR image");

   // Parse header
   for(;;) {
	  token = stbi__hdr_gettoken(s,buffer);
	  if (token[0] == 0) break;
	  if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

   // Parse width and height
   // can't use sscanf() if we're not using stdio!
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   height = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");
   token += 3;
   width = (int) strtol(token, NULL, 10);

   *x = width;
   *y = height;

   if (comp) *comp = 3;
   if (req_comp == 0) req_comp = 3;

   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))
	  return stbi__errpf("too large", "HDR image is too large");

   // Read data
   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);
   if (!hdr_data)
	  return stbi__errpf("outofmem", "Out of memory");

   // Load image data
   // image data is stored as some number of sca
   if ( width < 8 || width >= 32768) {
	  // Read flat data
	  for (j=0; j < height; ++j) {
		 for (i=0; i < width; ++i) {
			stbi_uc rgbe[4];
		   main_decode_loop:
			stbi__getn(s, rgbe, 4);
			stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);
		 }
	  }
   } else {
	  // Read RLE-encoded data
	  scanline = NULL;

	  for (j = 0; j < height; ++j) {
		 c1 = stbi__get8(s);
		 c2 = stbi__get8(s);
		 len = stbi__get8(s);
		 if (c1 != 2 || c2 != 2 || (len & 0x80)) {
			// not run-length encoded, so we have to actually use THIS data as a decoded
			// pixel (note this can't be a valid pixel--one of RGB must be >= 128)
			stbi_uc rgbe[4];
			rgbe[0] = (stbi_uc) c1;
			rgbe[1] = (stbi_uc) c2;
			rgbe[2] = (stbi_uc) len;
			rgbe[3] = (stbi_uc) stbi__get8(s);
			stbi__hdr_convert(hdr_data, rgbe, req_comp);
			i = 1;
			j = 0;
			STBI_FREE(scanline);
			goto main_decode_loop; // yes, this makes no sense
		 }
		 len <<= 8;
		 len |= stbi__get8(s);
		 if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }
		 if (scanline == NULL) {
			scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);
			if (!scanline) {
			   STBI_FREE(hdr_data);
			   return stbi__errpf("outofmem", "Out of memory");
			}
		 }

		 for (k = 0; k < 4; ++k) {
			int nleft;
			i = 0;
			while ((nleft = width - i) > 0) {
			   count = stbi__get8(s);
			   if (count > 128) {
				  // Run
				  value = stbi__get8(s);
				  count -= 128;
				  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
				  for (z = 0; z < count; ++z)
					 scanline[i++ * 4 + k] = value;
			   } else {
				  // Dump
				  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }
				  for (z = 0; z < count; ++z)
					 scanline[i++ * 4 + k] = stbi__get8(s);
			   }
			}
		 }
		 for (i=0; i < width; ++i)
			stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);
	  }
	  if (scanline)
		 STBI_FREE(scanline);
   }

   return hdr_data;
}

static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)
{
   char buffer[STBI__HDR_BUFLEN];
   char *token;
   int valid = 0;
   int dummy;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (stbi__hdr_test(s) == 0) {
	   stbi__rewind( s );
	   return 0;
   }

   for(;;) {
	  token = stbi__hdr_gettoken(s,buffer);
	  if (token[0] == 0) break;
	  if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;
   }

   if (!valid) {
	   stbi__rewind( s );
	   return 0;
   }
   token = stbi__hdr_gettoken(s,buffer);
   if (strncmp(token, "-Y ", 3)) {
	   stbi__rewind( s );
	   return 0;
   }
   token += 3;
   *y = (int) strtol(token, &token, 10);
   while (*token == ' ') ++token;
   if (strncmp(token, "+X ", 3)) {
	   stbi__rewind( s );
	   return 0;
   }
   token += 3;
   *x = (int) strtol(token, NULL, 10);
   *comp = 3;
   return 1;
}
#endif // STBI_NO_HDR

#ifndef STBI_NO_BMP
static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)
{
   void *p;
   stbi__bmp_data info;

   info.all_a = 255;
   p = stbi__bmp_parse_header(s, &info);
   stbi__rewind( s );
   if (p == NULL)
	  return 0;
   if (x) *x = s->img_x;
   if (y) *y = s->img_y;
   if (comp) *comp = info.ma ? 4 : 3;
   return 1;
}
#endif

#ifndef STBI_NO_PSD
static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)
{
   int channelCount, dummy;
   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;
   if (stbi__get32be(s) != 0x38425053) {
	   stbi__rewind( s );
	   return 0;
   }
   if (stbi__get16be(s) != 1) {
	   stbi__rewind( s );
	   return 0;
   }
   stbi__skip(s, 6);
   channelCount = stbi__get16be(s);
   if (channelCount < 0 || channelCount > 16) {
	   stbi__rewind( s );
	   return 0;
   }
   *y = stbi__get32be(s);
   *x = stbi__get32be(s);
   if (stbi__get16be(s) != 8) {
	   stbi__rewind( s );
	   return 0;
   }
   if (stbi__get16be(s) != 3) {
	   stbi__rewind( s );
	   return 0;
   }
   *comp = 4;
   return 1;
}
#endif

#ifndef STBI_NO_PIC
static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)
{
   int act_comp=0,num_packets=0,chained,dummy;
   stbi__pic_packet packets[10];

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {
	  stbi__rewind(s);
	  return 0;
   }

   stbi__skip(s, 88);

   *x = stbi__get16be(s);
   *y = stbi__get16be(s);
   if (stbi__at_eof(s)) {
	  stbi__rewind( s);
	  return 0;
   }
   if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {
	  stbi__rewind( s );
	  return 0;
   }

   stbi__skip(s, 8);

   do {
	  stbi__pic_packet *packet;

	  if (num_packets==sizeof(packets)/sizeof(packets[0]))
		 return 0;

	  packet = &packets[num_packets++];
	  chained = stbi__get8(s);
	  packet->size    = stbi__get8(s);
	  packet->type    = stbi__get8(s);
	  packet->channel = stbi__get8(s);
	  act_comp |= packet->channel;

	  if (stbi__at_eof(s)) {
		  stbi__rewind( s );
		  return 0;
	  }
	  if (packet->size != 8) {
		  stbi__rewind( s );
		  return 0;
	  }
   } while (chained);

   *comp = (act_comp & 0x10 ? 4 : 3);

   return 1;
}
#endif

// *************************************************************************************************
// Portable Gray Map and Portable Pixel Map loader
// by Ken Miller
//
// PGM: http://netpbm.sourceforge.net/doc/pgm.html
// PPM: http://netpbm.sourceforge.net/doc/ppm.html
//
// Known limitations:
//    Does not support comments in the header section
//    Does not support ASCII image data (formats P2 and P3)
//    Does not support 16-bit-per-channel

#ifndef STBI_NO_PNM

static int      stbi__pnm_test(stbi__context *s)
{
   char p, t;
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
	   stbi__rewind( s );
	   return 0;
   }
   return 1;
}

static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)
{
   stbi_uc *out;
   STBI_NOTUSED(ri);

   if (!stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n))
	  return 0;

   *x = s->img_x;
   *y = s->img_y;
   if (comp) *comp = s->img_n;

   if (!stbi__mad3sizes_valid(s->img_n, s->img_x, s->img_y, 0))
	  return stbi__errpuc("too large", "PNM too large");

   out = (stbi_uc *) stbi__malloc_mad3(s->img_n, s->img_x, s->img_y, 0);
   if (!out) return stbi__errpuc("outofmem", "Out of memory");
   stbi__getn(s, out, s->img_n * s->img_x * s->img_y);

   if (req_comp && req_comp != s->img_n) {
	  out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);
	  if (out == NULL) return out; // stbi__convert_format frees input on failure
   }
   return out;
}

static int      stbi__pnm_isspace(char c)
{
   return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';
}

static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)
{
   for (;;) {
	  while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))
		 *c = (char) stbi__get8(s);

	  if (stbi__at_eof(s) || *c != '#')
		 break;

	  while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )
		 *c = (char) stbi__get8(s);
   }
}

static int      stbi__pnm_isdigit(char c)
{
   return c >= '0' && c <= '9';
}

static int      stbi__pnm_getinteger(stbi__context *s, char *c)
{
   int value = 0;

   while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {
	  value = value*10 + (*c - '0');
	  *c = (char) stbi__get8(s);
   }

   return value;
}

static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)
{
   int maxv, dummy;
   char c, p, t;

   if (!x) x = &dummy;
   if (!y) y = &dummy;
   if (!comp) comp = &dummy;

   stbi__rewind(s);

   // Get identifier
   p = (char) stbi__get8(s);
   t = (char) stbi__get8(s);
   if (p != 'P' || (t != '5' && t != '6')) {
	   stbi__rewind(s);
	   return 0;
   }

   *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

   c = (char) stbi__get8(s);
   stbi__pnm_skip_whitespace(s, &c);

   *x = stbi__pnm_getinteger(s, &c); // read width
   stbi__pnm_skip_whitespace(s, &c);

   *y = stbi__pnm_getinteger(s, &c); // read height
   stbi__pnm_skip_whitespace(s, &c);

   maxv = stbi__pnm_getinteger(s, &c);  // read max value

   if (maxv > 255)
	  return stbi__err("max value > 255", "PPM image not 8-bit");
   else
	  return 1;
}
#endif

static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_info(s, x, y, comp)) return 1;
   #endif

   #ifndef STBI_NO_PNG
   if (stbi__png_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_GIF
   if (stbi__gif_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_BMP
   if (stbi__bmp_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PSD
   if (stbi__psd_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PIC
   if (stbi__pic_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_PNM
   if (stbi__pnm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_DDS
   if (stbi__dds_info(s, x, y, comp, NULL))  return 1;
   #endif

   #ifndef STBI_NO_PVR
   if (stbi__pvr_info(s, x, y, comp, NULL))  return 1;
   #endif

   #ifndef STBI_NO_PKM
   if (stbi__pkm_info(s, x, y, comp))  return 1;
   #endif

   #ifndef STBI_NO_HDR
   if (stbi__hdr_info(s, x, y, comp))  return 1;
   #endif

   // test tga last because it's a crappy test!
   #ifndef STBI_NO_TGA
   if (stbi__tga_info(s, x, y, comp))
	   return 1;
   #endif
   return stbi__err("unknown image type", "Image not of any known type, or corrupt");
}

#ifndef STBI_NO_STDIO
STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)
{
	FILE *f = stbi__fopen(filename, "rb");
	int result;
	if (!f) return stbi__err("can't fopen", "Unable to open file");
	result = stbi_info_from_file(f, x, y, comp);
	fclose(f);
	return result;
}

STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)
{
   int r;
   stbi__context s;
   long pos = ftell(f);
   stbi__start_file(&s, f);
   r = stbi__info_main(&s,x,y,comp);
   fseek(f,pos,SEEK_SET);
   return r;
}
#endif // !STBI_NO_STDIO

STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi__info_main(&s,x,y,comp);
}

STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);
   return stbi__info_main(&s,x,y,comp);
}

// add in my DDS loading support
#ifndef STBI_NO_DDS

//#line 1 "stbi_DDS_c.h"
///	DDS file support, does decoding, _not_ direct uploading
///	(use SOIL for that ;-)


//#line 1 "image_DXT.h"
#ifndef HEADER_IMAGE_DXT
#define HEADER_IMAGE_DXT

/**
	Converts an image from an array of unsigned chars (RGB or RGBA) to
	DXT1 or DXT5, then saves the converted image to disk.
	\return 0 if failed, otherwise returns 1
**/
int
save_image_as_DDS
(
	const char *filename,
	int width, int height, int channels,
	const unsigned char *const data
);

/**
	take an image and convert it to DXT1 (no alpha)
**/
unsigned char*
convert_image_to_DXT1
(
	const unsigned char *const uncompressed,
	int width, int height, int channels,
	int *out_size
);

/**
	take an image and convert it to DXT5 (with alpha)
**/
unsigned char*
convert_image_to_DXT5
(
	const unsigned char *const uncompressed,
	int width, int height, int channels,
	int *out_size
);

/**	A bunch of DirectDraw Surface structures and flags **/
typedef struct
{
	unsigned int    dwMagic;
	unsigned int    dwSize;
	unsigned int    dwFlags;
	unsigned int    dwHeight;
	unsigned int    dwWidth;
	unsigned int    dwPitchOrLinearSize;
	unsigned int    dwDepth;
	unsigned int    dwMipMapCount;
	unsigned int    dwReserved1[ 11 ];

	/*  DDPIXELFORMAT	*/
	struct
	{
		unsigned int    dwSize;
		unsigned int    dwFlags;
		unsigned int    dwFourCC;
		unsigned int    dwRGBBitCount;
		unsigned int    dwRBitMask;
		unsigned int    dwGBitMask;
		unsigned int    dwBBitMask;
		unsigned int    dwAlphaBitMask;
	}
	sPixelFormat;

	/*  DDCAPS2	*/
	struct
	{
		unsigned int    dwCaps1;
		unsigned int    dwCaps2;
		unsigned int    dwDDSX;
		unsigned int    dwReserved;
	}
	sCaps;
	unsigned int    dwReserved2;
}
DDS_header ;

/*	the following constants were copied directly off the MSDN website	*/

/*	The dwFlags member of the original DDSURFACEDESC2 structure
	can be set to one or more of the following values.	*/
#define DDSD_CAPS	0x00000001
#define DDSD_HEIGHT	0x00000002
#define DDSD_WIDTH	0x00000004
#define DDSD_PITCH	0x00000008
#define DDSD_PIXELFORMAT	0x00001000
#define DDSD_MIPMAPCOUNT	0x00020000
#define DDSD_LINEARSIZE	0x00080000
#define DDSD_DEPTH	0x00800000

/*	DirectDraw Pixel Format	*/
#define DDPF_ALPHAPIXELS	0x00000001
#define DDPF_FOURCC	0x00000004
#define DDPF_RGB	0x00000040

/*	The dwCaps1 member of the DDSCAPS2 structure can be
	set to one or more of the following values.	*/
#define DDSCAPS_COMPLEX	0x00000008
#define DDSCAPS_TEXTURE	0x00001000
#define DDSCAPS_MIPMAP	0x00400000

/*	The dwCaps2 member of the DDSCAPS2 structure can be
	set to one or more of the following values.		*/
#define DDSCAPS2_CUBEMAP	0x00000200
#define DDSCAPS2_CUBEMAP_POSITIVEX	0x00000400
#define DDSCAPS2_CUBEMAP_NEGATIVEX	0x00000800
#define DDSCAPS2_CUBEMAP_POSITIVEY	0x00001000
#define DDSCAPS2_CUBEMAP_NEGATIVEY	0x00002000
#define DDSCAPS2_CUBEMAP_POSITIVEZ	0x00004000
#define DDSCAPS2_CUBEMAP_NEGATIVEZ	0x00008000
#define DDSCAPS2_VOLUME	0x00200000

#endif /* HEADER_IMAGE_DXT	*/

static int stbi__dds_test(stbi__context *s)
{
	//	check the magic number
	if (stbi__get8(s) != 'D') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'D') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'S') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != ' ') {
		stbi__rewind(s);
		return 0;
	}

	//	check header size
	if (stbi__get32le(s) != 124) {
		stbi__rewind(s);
		return 0;
	}

	// Also rewind because the loader needs to read the header
	stbi__rewind(s);

	return 1;
}
#ifndef STBI_NO_STDIO

int      stbi__dds_test_filename        		(char const *filename)
{
   int r;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   r = stbi__dds_test_file(f);
   fclose(f);
   return r;
}

int      stbi__dds_test_file        (FILE *f)
{
   stbi__context s;
   int r,n = ftell(f);
   stbi__start_file(&s,f);
   r = stbi__dds_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi__dds_test_memory      (stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__dds_test(&s);
}

int      stbi__dds_test_callbacks      (stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__dds_test(&s);
}

//	helper functions
int stbi_convert_bit_range( int c, int from_bits, int to_bits )
{
	int b = (1 << (from_bits - 1)) + c * ((1 << to_bits) - 1);
	return (b + (b >> from_bits)) >> from_bits;
}
void stbi_rgb_888_from_565( unsigned int c, int *r, int *g, int *b )
{
	*r = stbi_convert_bit_range( (c >> 11) & 31, 5, 8 );
	*g = stbi_convert_bit_range( (c >> 05) & 63, 6, 8 );
	*b = stbi_convert_bit_range( (c >> 00) & 31, 5, 8 );
}
void stbi_decode_DXT1_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int next_bit = 4*8;
	int i, r, g, b;
	int c0, c1;
	unsigned char decode_colors[4*4];
	//	find the 2 primary colors
	c0 = compressed[0] + (compressed[1] << 8);
	c1 = compressed[2] + (compressed[3] << 8);
	stbi_rgb_888_from_565( c0, &r, &g, &b );
	decode_colors[0] = r;
	decode_colors[1] = g;
	decode_colors[2] = b;
	decode_colors[3] = 255;
	stbi_rgb_888_from_565( c1, &r, &g, &b );
	decode_colors[4] = r;
	decode_colors[5] = g;
	decode_colors[6] = b;
	decode_colors[7] = 255;
	if( c0 > c1 )
	{
		//	no alpha, 2 interpolated colors
		decode_colors[8] = (2*decode_colors[0] + decode_colors[4]) / 3;
		decode_colors[9] = (2*decode_colors[1] + decode_colors[5]) / 3;
		decode_colors[10] = (2*decode_colors[2] + decode_colors[6]) / 3;
		decode_colors[11] = 255;
		decode_colors[12] = (decode_colors[0] + 2*decode_colors[4]) / 3;
		decode_colors[13] = (decode_colors[1] + 2*decode_colors[5]) / 3;
		decode_colors[14] = (decode_colors[2] + 2*decode_colors[6]) / 3;
		decode_colors[15] = 255;
	} else
	{
		//	1 interpolated color, alpha
		decode_colors[8] = (decode_colors[0] + decode_colors[4]) / 2;
		decode_colors[9] = (decode_colors[1] + decode_colors[5]) / 2;
		decode_colors[10] = (decode_colors[2] + decode_colors[6]) / 2;
		decode_colors[11] = 255;
		decode_colors[12] = 0;
		decode_colors[13] = 0;
		decode_colors[14] = 0;
		decode_colors[15] = 0;
	}
	//	decode the block
	for( i = 0; i < 16*4; i += 4 )
	{
		int idx = ((compressed[next_bit>>3] >> (next_bit & 7)) & 3) * 4;
		next_bit += 2;
		uncompressed[i+0] = decode_colors[idx+0];
		uncompressed[i+1] = decode_colors[idx+1];
		uncompressed[i+2] = decode_colors[idx+2];
		uncompressed[i+3] = decode_colors[idx+3];
	}
	//	done
}
void stbi_decode_DXT23_alpha_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int i, next_bit = 0;
	//	each alpha value gets 4 bits
	for( i = 3; i < 16*4; i += 4 )
	{
		uncompressed[i] = stbi_convert_bit_range(
				(compressed[next_bit>>3] >> (next_bit&7)) & 15,
				4, 8 );
		next_bit += 4;
	}
}
void stbi_decode_DXT45_alpha_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int i, next_bit = 8*2;
	unsigned char decode_alpha[8];
	//	each alpha value gets 3 bits, and the 1st 2 bytes are the range
	decode_alpha[0] = compressed[0];
	decode_alpha[1] = compressed[1];
	if( decode_alpha[0] > decode_alpha[1] )
	{
		//	6 step intermediate
		decode_alpha[2] = (6*decode_alpha[0] + 1*decode_alpha[1]) / 7;
		decode_alpha[3] = (5*decode_alpha[0] + 2*decode_alpha[1]) / 7;
		decode_alpha[4] = (4*decode_alpha[0] + 3*decode_alpha[1]) / 7;
		decode_alpha[5] = (3*decode_alpha[0] + 4*decode_alpha[1]) / 7;
		decode_alpha[6] = (2*decode_alpha[0] + 5*decode_alpha[1]) / 7;
		decode_alpha[7] = (1*decode_alpha[0] + 6*decode_alpha[1]) / 7;
	} else
	{
		//	4 step intermediate, pluss full and none
		decode_alpha[2] = (4*decode_alpha[0] + 1*decode_alpha[1]) / 5;
		decode_alpha[3] = (3*decode_alpha[0] + 2*decode_alpha[1]) / 5;
		decode_alpha[4] = (2*decode_alpha[0] + 3*decode_alpha[1]) / 5;
		decode_alpha[5] = (1*decode_alpha[0] + 4*decode_alpha[1]) / 5;
		decode_alpha[6] = 0;
		decode_alpha[7] = 255;
	}
	for( i = 3; i < 16*4; i += 4 )
	{
		int idx = 0, bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 0;
		++next_bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 1;
		++next_bit;
		bit = (compressed[next_bit>>3] >> (next_bit&7)) & 1;
		idx += bit << 2;
		++next_bit;
		uncompressed[i] = decode_alpha[idx & 7];
	}
	//	done
}
void stbi_decode_DXT_color_block(
			unsigned char uncompressed[16*4],
			unsigned char compressed[8] )
{
	int next_bit = 4*8;
	int i, r, g, b;
	int c0, c1;
	unsigned char decode_colors[4*3];
	//	find the 2 primary colors
	c0 = compressed[0] + (compressed[1] << 8);
	c1 = compressed[2] + (compressed[3] << 8);
	stbi_rgb_888_from_565( c0, &r, &g, &b );
	decode_colors[0] = r;
	decode_colors[1] = g;
	decode_colors[2] = b;
	stbi_rgb_888_from_565( c1, &r, &g, &b );
	decode_colors[3] = r;
	decode_colors[4] = g;
	decode_colors[5] = b;
	//	Like DXT1, but no choicees:
	//	no alpha, 2 interpolated colors
	decode_colors[6] = (2*decode_colors[0] + decode_colors[3]) / 3;
	decode_colors[7] = (2*decode_colors[1] + decode_colors[4]) / 3;
	decode_colors[8] = (2*decode_colors[2] + decode_colors[5]) / 3;
	decode_colors[9] = (decode_colors[0] + 2*decode_colors[3]) / 3;
	decode_colors[10] = (decode_colors[1] + 2*decode_colors[4]) / 3;
	decode_colors[11] = (decode_colors[2] + 2*decode_colors[5]) / 3;
	//	decode the block
	for( i = 0; i < 16*4; i += 4 )
	{
		int idx = ((compressed[next_bit>>3] >> (next_bit & 7)) & 3) * 3;
		next_bit += 2;
		uncompressed[i+0] = decode_colors[idx+0];
		uncompressed[i+1] = decode_colors[idx+1];
		uncompressed[i+2] = decode_colors[idx+2];
	}
	//	done
}

static int stbi__dds_info( stbi__context *s, int *x, int *y, int *comp, int *iscompressed ) {
	int flags,is_compressed,has_alpha;
	DDS_header header={0};

	if( sizeof( DDS_header ) != 128 )
	{
		return 0;
	}

	stbi__getn( s, (stbi_uc*)(&header), 128 );

	if( header.dwMagic != (('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24)) ) {
	   stbi__rewind( s );
	   return 0;
	}
	if( header.dwSize != 124 ) {
	   stbi__rewind( s );
	   return 0;
	}
	flags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flags) != flags ) {
	   stbi__rewind( s );
	   return 0;
	}
	if( header.sPixelFormat.dwSize != 32 ) {
	   stbi__rewind( s );
	   return 0;
	}
	flags = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flags) == 0 ) {
	   stbi__rewind( s );
	   return 0;
	}
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) {
	   stbi__rewind( s );
	   return 0;
	}

	is_compressed = (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	has_alpha = (header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS) / DDPF_ALPHAPIXELS;

	*x = header.dwWidth;
	*y = header.dwHeight;

	if ( !is_compressed ) {
		*comp = 3;

		if ( has_alpha )
			*comp = 4;
	}
	else
		*comp = 4;

	if ( iscompressed )
		*iscompressed = is_compressed;

	return 1;
}

int stbi__dds_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int *iscompressed)
{
	stbi__context s;
	stbi__start_mem(&s,buffer, len);
	return stbi__dds_info( &s, x, y, comp, iscompressed );
}

int stbi__dds_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int *iscompressed)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
	return stbi__dds_info( &s, x, y, comp, iscompressed );
}

#ifndef STBI_NO_STDIO
int stbi__dds_info_from_path(char const *filename,     int *x, int *y, int *comp, int *iscompressed)
{
   int res;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   res = stbi__dds_info_from_file( f, x, y, comp, iscompressed );
   fclose(f);
   return res;
}

int stbi__dds_info_from_file(FILE *f,                  int *x, int *y, int *comp, int *iscompressed)
{
   stbi__context s;
   int res;
   long n = ftell(f);
   stbi__start_file(&s, f);
   res = stbi__dds_info(&s, x, y, comp, iscompressed);
   fseek(f, n, SEEK_SET);
   return res;
}
#endif

static void * stbi__dds_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	//	all variables go up front
	stbi_uc *dds_data = NULL;
	stbi_uc block[16*4];
	stbi_uc compressed[8];
	int flags, DXT_family;
	int has_alpha, has_mipmap;
	int is_compressed, cubemap_faces;
	int block_pitch, num_blocks;
	DDS_header header={0};
	int i, sz, cf;
	//	load the header
	if( sizeof( DDS_header ) != 128 )
	{
		return NULL;
	}
	stbi__getn( s, (stbi_uc*)(&header), 128 );
	//	and do some checking
	if( header.dwMagic != (('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24)) ) return NULL;
	if( header.dwSize != 124 ) return NULL;
	flags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flags) != flags ) return NULL;
	/*	According to the MSDN spec, the dwFlags should contain
		DDSD_LINEARSIZE if it's compressed, or DDSD_PITCH if
		uncompressed.  Some DDS writers do not conform to the
		spec, so I need to make my reader more tolerant	*/
	if( header.sPixelFormat.dwSize != 32 ) return NULL;
	flags = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flags) == 0 ) return NULL;
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) return NULL;
	//	get the image data
	s->img_x = header.dwWidth;
	s->img_y = header.dwHeight;
	s->img_n = 4;
	is_compressed = (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	has_alpha = (header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS) / DDPF_ALPHAPIXELS;
	has_mipmap = (header.sCaps.dwCaps1 & DDSCAPS_MIPMAP) && (header.dwMipMapCount > 1);
	cubemap_faces = (header.sCaps.dwCaps2 & DDSCAPS2_CUBEMAP) / DDSCAPS2_CUBEMAP;
	/*	I need cubemaps to have square faces	*/
	cubemap_faces &= (s->img_x == s->img_y);
	cubemap_faces *= 5;
	cubemap_faces += 1;
	block_pitch = (s->img_x+3) >> 2;
	num_blocks = block_pitch * ((s->img_y+3) >> 2);
	/*	let the user know what's going on	*/
	*x = s->img_x;
	*y = s->img_y;
	*comp = s->img_n;
	/*	is this uncompressed?	*/
	if( is_compressed )
	{
		/*	compressed	*/
		//	note: header.sPixelFormat.dwFourCC is something like (('D'<<0)|('X'<<8)|('T'<<16)|('1'<<24))
		DXT_family = 1 + (header.sPixelFormat.dwFourCC >> 24) - '1';
		if( (DXT_family < 1) || (DXT_family > 5) ) return NULL;
		/*	check the expected size...oops, nevermind...
			those non-compliant writers leave
			dwPitchOrLinearSize == 0	*/
		//	passed all the tests, get the RAM for decoding
		sz = (s->img_x)*(s->img_y)*4*cubemap_faces;
		dds_data = (unsigned char*)malloc( sz );
		/*	do this once for each face	*/
		for( cf = 0; cf < cubemap_faces; ++ cf )
		{
			//	now read and decode all the blocks
			for( i = 0; i < num_blocks; ++i )
			{
				//	where are we?
				int bx, by, bw=4, bh=4;
				int ref_x = 4 * (i % block_pitch);
				int ref_y = 4 * (i / block_pitch);
				//	get the next block's worth of compressed data, and decompress it
				if( DXT_family == 1 )
				{
					//	DXT1
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT1_block( block, compressed );
				} else if( DXT_family < 4 )
				{
					//	DXT2/3
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT23_alpha_block ( block, compressed );
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT_color_block ( block, compressed );
				} else
				{
					//	DXT4/5
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT45_alpha_block ( block, compressed );
					stbi__getn( s, compressed, 8 );
					stbi_decode_DXT_color_block ( block, compressed );
				}
				//	is this a partial block?
				if( ref_x + 4 > (int)s->img_x )
				{
					bw = s->img_x - ref_x;
				}
				if( ref_y + 4 > (int)s->img_y )
				{
					bh = s->img_y - ref_y;
				}
				//	now drop our decompressed data into the buffer
				for( by = 0; by < bh; ++by )
				{
					int idx = 4*((ref_y+by+cf*s->img_x)*s->img_x + ref_x);
					for( bx = 0; bx < bw*4; ++bx )
					{

						dds_data[idx+bx] = block[by*16+bx];
					}
				}
			}
			/*	done reading and decoding the main image...
				stbi__skip MIPmaps if present	*/
			if( has_mipmap )
			{
				int block_size = 16;
				if( DXT_family == 1 )
				{
					block_size = 8;
				}
				for( i = 1; i < (int)header.dwMipMapCount; ++i )
				{
					int mx = s->img_x >> (i + 2);
					int my = s->img_y >> (i + 2);
					if( mx < 1 )
					{
						mx = 1;
					}
					if( my < 1 )
					{
						my = 1;
					}
					stbi__skip( s, mx*my*block_size );
				}
			}
		}/* per cubemap face */
	} else
	{
		/*	uncompressed	*/
		DXT_family = 0;
		s->img_n = 3;
		if( has_alpha )
		{
			s->img_n = 4;
		}
		*comp = s->img_n;
		sz = s->img_x*s->img_y*s->img_n*cubemap_faces;
		dds_data = (unsigned char*)malloc( sz );
		/*	do this once for each face	*/
		for( cf = 0; cf < cubemap_faces; ++ cf )
		{
			/*	read the main image for this face	*/
			stbi__getn( s, &dds_data[cf*s->img_x*s->img_y*s->img_n], s->img_x*s->img_y*s->img_n );
			/*	done reading and decoding the main image...
				stbi__skip MIPmaps if present	*/
			if( has_mipmap )
			{
				for( i = 1; i < (int)header.dwMipMapCount; ++i )
				{
					int mx = s->img_x >> i;
					int my = s->img_y >> i;
					if( mx < 1 )
					{
						mx = 1;
					}
					if( my < 1 )
					{
						my = 1;
					}
					stbi__skip( s, mx*my*s->img_n );
				}
			}
		}
		/*	data was BGR, I need it RGB	*/
		for( i = 0; i < sz; i += s->img_n )
		{
			unsigned char temp = dds_data[i];
			dds_data[i] = dds_data[i+2];
			dds_data[i+2] = temp;
		}
	}
	/*	finished decompressing into RGBA,
		adjust the y size if we have a cubemap
		note: sz is already up to date	*/
	s->img_y *= cubemap_faces;
	*y = s->img_y;
	//	did the user want something else, or
	//	see if all the alpha values are 255 (i.e. no transparency)
	has_alpha = 0;
	if( s->img_n == 4)
	{
		for( i = 3; (i < sz) && (has_alpha == 0); i += 4 )
		{
			has_alpha |= (dds_data[i] < 255);
		}
	}
	if( (req_comp <= 4) && (req_comp >= 1) )
	{
		//	user has some requirements, meet them
		if( req_comp != s->img_n )
		{
			dds_data = stbi__convert_format( dds_data, s->img_n, req_comp, s->img_x, s->img_y );
			*comp = req_comp;
		}
	} else
	{
		//	user had no requirements, only drop to RGB is no alpha
		if( (has_alpha == 0) && (s->img_n == 4) )
		{
			dds_data = stbi__convert_format( dds_data, 4, 3, s->img_x, s->img_y );
			*comp = 3;
		}
	}
	//	OK, done
	return dds_data;
}

#ifndef STBI_NO_STDIO
void *stbi__dds_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s,f);
	return stbi__dds_load(&s,x,y,comp,req_comp);
}

void *stbi__dds_load_from_path             (const char *filename,           int *x, int *y, int *comp, int req_comp)
{
   void *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi__dds_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

void *stbi__dds_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__dds_load(&s,x,y,comp,req_comp);
}

void *stbi__dds_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__dds_load(&s,x,y,comp,req_comp);
}


#endif

// add in my pvr loading support
#ifndef STBI_NO_PVR

//#line 1 "stbi_pvr_c.h"

//#line 1 "pvr_helper.h"
#ifndef PVR_HELPER_H
#define PVR_HELPER_H

// Taken from PowerVR SDK

/*!***************************************************************************
 Describes the header of a PVR header-texture
 *****************************************************************************/
typedef struct
{
	unsigned int dwHeaderSize;			/*!< size of the structure */
	unsigned int dwHeight;				/*!< height of surface to be created */
	unsigned int dwWidth;				/*!< width of input surface */
	unsigned int dwMipMapCount;			/*!< number of mip-map levels requested */
	unsigned int dwpfFlags;				/*!< pixel format flags */
	unsigned int dwTextureDataSize;		/*!< Total size in bytes */
	unsigned int dwBitCount;			/*!< number of bits per pixel  */
	unsigned int dwRBitMask;			/*!< mask for red bit */
	unsigned int dwGBitMask;			/*!< mask for green bits */
	unsigned int dwBBitMask;			/*!< mask for blue bits */
	unsigned int dwAlphaBitMask;		/*!< mask for alpha channel */
	unsigned int dwPVR;					/*!< magic number identifying pvr file */
	unsigned int dwNumSurfs;			/*!< the number of surfaces present in the pvr */
} PVR_Texture_Header;

/*****************************************************************************
 * ENUMS
 *****************************************************************************/

enum PixelType
{
	MGLPT_ARGB_4444 = 0x00,
	MGLPT_ARGB_1555,
	MGLPT_RGB_565,
	MGLPT_RGB_555,
	MGLPT_RGB_888,
	MGLPT_ARGB_8888,
	MGLPT_ARGB_8332,
	MGLPT_I_8,
	MGLPT_AI_88,
	MGLPT_1_BPP,
	MGLPT_VY1UY0,
	MGLPT_Y1VY0U,
	MGLPT_PVRTC2,
	MGLPT_PVRTC4,
	MGLPT_PVRTC2_2,
	MGLPT_PVRTC2_4,

	OGL_RGBA_4444= 0x10,
	OGL_RGBA_5551,
	OGL_RGBA_8888,
	OGL_RGB_565,
	OGL_RGB_555,
	OGL_RGB_888,
	OGL_I_8,
	OGL_AI_88,
	OGL_PVRTC2,
	OGL_PVRTC4,

	// OGL_BGRA_8888 extension
	OGL_BGRA_8888,

	D3D_DXT1 = 0x20,
	D3D_DXT2,
	D3D_DXT3,
	D3D_DXT4,
	D3D_DXT5,

	D3D_RGB_332,
	D3D_AI_44,
	D3D_LVU_655,
	D3D_XLVU_8888,
	D3D_QWVU_8888,

	//10 bits per channel
	D3D_ABGR_2101010,
	D3D_ARGB_2101010,
	D3D_AWVU_2101010,

	//16 bits per channel
	D3D_GR_1616,
	D3D_VU_1616,
	D3D_ABGR_16161616,

	//HDR formats
	D3D_R16F,
	D3D_GR_1616F,
	D3D_ABGR_16161616F,

	//32 bits per channel
	D3D_R32F,
	D3D_GR_3232F,
	D3D_ABGR_32323232F,

	// Ericsson
	ETC_RGB_4BPP,
	ETC_RGBA_EXPLICIT,
	ETC_RGBA_INTERPOLATED,

	// DX10

	ePT_DX10_R32G32B32A32_FLOAT= 0x50,
	ePT_DX10_R32G32B32A32_UINT ,
	ePT_DX10_R32G32B32A32_SINT,

	ePT_DX10_R32G32B32_FLOAT,
	ePT_DX10_R32G32B32_UINT,
	ePT_DX10_R32G32B32_SINT,

	ePT_DX10_R16G16B16A16_FLOAT ,
	ePT_DX10_R16G16B16A16_UNORM,
	ePT_DX10_R16G16B16A16_UINT ,
	ePT_DX10_R16G16B16A16_SNORM ,
	ePT_DX10_R16G16B16A16_SINT ,

	ePT_DX10_R32G32_FLOAT ,
	ePT_DX10_R32G32_UINT ,
	ePT_DX10_R32G32_SINT ,

	ePT_DX10_R10G10B10A2_UNORM ,
	ePT_DX10_R10G10B10A2_UINT ,

	ePT_DX10_R11G11B10_FLOAT ,

	ePT_DX10_R8G8B8A8_UNORM ,
	ePT_DX10_R8G8B8A8_UNORM_SRGB ,
	ePT_DX10_R8G8B8A8_UINT ,
	ePT_DX10_R8G8B8A8_SNORM ,
	ePT_DX10_R8G8B8A8_SINT ,

	ePT_DX10_R16G16_FLOAT ,
	ePT_DX10_R16G16_UNORM ,
	ePT_DX10_R16G16_UINT ,
	ePT_DX10_R16G16_SNORM ,
	ePT_DX10_R16G16_SINT ,

	ePT_DX10_R32_FLOAT ,
	ePT_DX10_R32_UINT ,
	ePT_DX10_R32_SINT ,

	ePT_DX10_R8G8_UNORM ,
	ePT_DX10_R8G8_UINT ,
	ePT_DX10_R8G8_SNORM ,
	ePT_DX10_R8G8_SINT ,

	ePT_DX10_R16_FLOAT ,
	ePT_DX10_R16_UNORM ,
	ePT_DX10_R16_UINT ,
	ePT_DX10_R16_SNORM ,
	ePT_DX10_R16_SINT ,

	ePT_DX10_R8_UNORM,
	ePT_DX10_R8_UINT,
	ePT_DX10_R8_SNORM,
	ePT_DX10_R8_SINT,

	ePT_DX10_A8_UNORM,
	ePT_DX10_R1_UNORM,
	ePT_DX10_R9G9B9E5_SHAREDEXP,
	ePT_DX10_R8G8_B8G8_UNORM,
	ePT_DX10_G8R8_G8B8_UNORM,

	ePT_DX10_BC1_UNORM,
	ePT_DX10_BC1_UNORM_SRGB,

	ePT_DX10_BC2_UNORM,
	ePT_DX10_BC2_UNORM_SRGB,

	ePT_DX10_BC3_UNORM,
	ePT_DX10_BC3_UNORM_SRGB,

	ePT_DX10_BC4_UNORM,
	ePT_DX10_BC4_SNORM,

	ePT_DX10_BC5_UNORM,
	ePT_DX10_BC5_SNORM,

	//ePT_DX10_B5G6R5_UNORM,			// defined but obsolete - won't actually load in DX10
	//ePT_DX10_B5G5R5A1_UNORM,
	//ePT_DX10_B8G8R8A8_UNORM,
	//ePT_DX10_B8G8R8X8_UNORM,

	// OpenVG

	/* RGB{A,X} channel ordering */
	ePT_VG_sRGBX_8888  = 0x90,
	ePT_VG_sRGBA_8888,
	ePT_VG_sRGBA_8888_PRE,
	ePT_VG_sRGB_565,
	ePT_VG_sRGBA_5551,
	ePT_VG_sRGBA_4444,
	ePT_VG_sL_8,
	ePT_VG_lRGBX_8888,
	ePT_VG_lRGBA_8888,
	ePT_VG_lRGBA_8888_PRE,
	ePT_VG_lL_8,
	ePT_VG_A_8,
	ePT_VG_BW_1,

	/* {A,X}RGB channel ordering */
	ePT_VG_sXRGB_8888,
	ePT_VG_sARGB_8888,
	ePT_VG_sARGB_8888_PRE,
	ePT_VG_sARGB_1555,
	ePT_VG_sARGB_4444,
	ePT_VG_lXRGB_8888,
	ePT_VG_lARGB_8888,
	ePT_VG_lARGB_8888_PRE,

	/* BGR{A,X} channel ordering */
	ePT_VG_sBGRX_8888,
	ePT_VG_sBGRA_8888,
	ePT_VG_sBGRA_8888_PRE,
	ePT_VG_sBGR_565,
	ePT_VG_sBGRA_5551,
	ePT_VG_sBGRA_4444,
	ePT_VG_lBGRX_8888,
	ePT_VG_lBGRA_8888,
	ePT_VG_lBGRA_8888_PRE,

	/* {A,X}BGR channel ordering */
	ePT_VG_sXBGR_8888,
	ePT_VG_sABGR_8888 ,
	ePT_VG_sABGR_8888_PRE,
	ePT_VG_sABGR_1555,
	ePT_VG_sABGR_4444,
	ePT_VG_lXBGR_8888,
	ePT_VG_lABGR_8888,
	ePT_VG_lABGR_8888_PRE,

	// max cap for iterating
	END_OF_PIXEL_TYPES,

	MGLPT_NOTYPE = 0xff

};

/*****************************************************************************
 * constants
 *****************************************************************************/

#define PVRTEX_MIPMAP		(1<<8)		// has mip map levels
#define PVRTEX_TWIDDLE		(1<<9)		// is twiddled
#define PVRTEX_BUMPMAP		(1<<10)		// has normals encoded for a bump map
#define PVRTEX_TILING		(1<<11)		// is bordered for tiled pvr
#define PVRTEX_CUBEMAP		(1<<12)		// is a cubemap/skybox
#define PVRTEX_FALSEMIPCOL	(1<<13)		//
#define PVRTEX_VOLUME		(1<<14)
#define PVRTEX_PIXELTYPE	0xff			// pixel type is always in the last 16bits of the flags
#define PVRTEX_IDENTIFIER	0x21525650	// the pvr identifier is the characters 'P','V','R'

#define PVRTEX_V1_HEADER_SIZE 44			// old header size was 44 for identification purposes

#define PVRTC2_MIN_TEXWIDTH		16
#define PVRTC2_MIN_TEXHEIGHT	8
#define PVRTC4_MIN_TEXWIDTH		8
#define PVRTC4_MIN_TEXHEIGHT	8
#define ETC_MIN_TEXWIDTH		4
#define ETC_MIN_TEXHEIGHT		4
#define DXT_MIN_TEXWIDTH		4
#define DXT_MIN_TEXHEIGHT		4

#endif

static int stbi__pvr_test(stbi__context *s)
{
	//	check header size
	if (stbi__get32le(s) != sizeof(PVR_Texture_Header)) {
		stbi__rewind(s);
		return 0;
	}

	// stbi__skip until the magic number
	stbi__skip(s, 10*4);

	// check the magic number
	if ( stbi__get32le(s) != PVRTEX_IDENTIFIER ) {
		stbi__rewind(s);
		return 0;
	}

	// Also rewind because the loader needs to read the header
	stbi__rewind(s);

	return 1;
}

#ifndef STBI_NO_STDIO

int      stbi__pvr_test_filename        		(char const *filename)
{
   int r;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   r = stbi__pvr_test_file(f);
   fclose(f);
   return r;
}

int      stbi__pvr_test_file        (FILE *f)
{
   stbi__context s;
   int r,n = ftell(f);
   stbi__start_file(&s,f);
   r = stbi__pvr_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi__pvr_test_memory      (stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pvr_test(&s);
}

int      stbi__pvr_test_callbacks      (stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pvr_test(&s);
}

static int stbi__pvr_info(stbi__context *s, int *x, int *y, int *comp, int * iscompressed )
{
	PVR_Texture_Header header={0};

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PVR_Texture_Header) );

	// Check the header size
	if ( header.dwHeaderSize != sizeof(PVR_Texture_Header) ) {
		stbi__rewind( s );
		return 0;
	}

	// Check the magic identifier
	if ( header.dwPVR != PVRTEX_IDENTIFIER ) {
		stbi__rewind(s);
		return 0;
	}

	*x = s->img_x = header.dwWidth;
	*y = s->img_y = header.dwHeight;
	*comp = s->img_n = ( header.dwBitCount + 7 ) / 8;

	if ( iscompressed )
		*iscompressed = 0;

	switch ( header.dwpfFlags & PVRTEX_PIXELTYPE )
	{
		case OGL_RGBA_4444:
			s->img_n = 2;
			break;
		case OGL_RGBA_5551:
			s->img_n = 2;
			break;
		case OGL_RGBA_8888:
			s->img_n = 4;
			break;
		case OGL_RGB_565:
			s->img_n = 2;
			break;
		case OGL_RGB_888:
			s->img_n = 3;
			break;
		case OGL_I_8:
			s->img_n = 1;
			break;
		case OGL_AI_88:
			s->img_n = 2;
			break;
		case OGL_PVRTC2:
			s->img_n = 4;
			if ( iscompressed )
				*iscompressed = 1;
			break;
		case OGL_PVRTC4:
			s->img_n = 4;
			if ( iscompressed )
				*iscompressed = 1;
			break;
		case OGL_RGB_555:
		default:
			stbi__rewind(s);
			return 0;
	}

	*comp = s->img_n;

	return 1;
}

int stbi__pvr_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int * iscompressed )
{
	stbi__context s;
	stbi__start_mem(&s,buffer, len);
	return stbi__pvr_info( &s, x, y, comp, iscompressed );
}

int stbi__pvr_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int * iscompressed)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
	return stbi__pvr_info( &s, x, y, comp, iscompressed );
}

#ifndef STBI_NO_STDIO
int stbi__pvr_info_from_path(char const *filename,     int *x, int *y, int *comp, int * iscompressed)
{
   int res;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   res = stbi__pvr_info_from_file( f, x, y, comp, iscompressed );
   fclose(f);
   return res;
}

int stbi__pvr_info_from_file(FILE *f,                  int *x, int *y, int *comp, int * iscompressed)
{
   stbi__context s;
   int res;
   long n = ftell(f);
   stbi__start_file(&s, f);
   res = stbi__pvr_info(&s, x, y, comp, iscompressed);
   fseek(f, n, SEEK_SET);
   return res;
}
#endif

/******************************************************************************
 Taken from:
 @File         PVRTDecompress.cpp
 @Title        PVRTDecompress
 @Copyright    Copyright (C)  Imagination Technologies Limited.
 @Platform     ANSI compatible
 @Description  PVRTC Texture Decompression.
******************************************************************************/

typedef unsigned char      PVRTuint8;
typedef unsigned short     PVRTuint16;
typedef unsigned int       PVRTuint32;

/*****************************************************************************
 * defines and consts
 *****************************************************************************/
#define PT_INDEX (2)	// The Punch-through index

#define BLK_Y_SIZE 	(4) // always 4 for all 2D block types

#define BLK_X_MAX	(8)	// Max X dimension for blocks

#define BLK_X_2BPP	(8) // dimensions for the two formats
#define BLK_X_4BPP	(4)

#define WRAP_COORD(Val, Size) ((Val) & ((Size)-1))

#define POWER_OF_2(X)   util_number_is_power_2(X)

/*
	Define an expression to either wrap or clamp large or small vals to the
	legal coordinate range
*/
#define PVRT_MIN(a,b)            (((a) < (b)) ? (a) : (b))
#define PVRT_MAX(a,b)            (((a) > (b)) ? (a) : (b))
#define PVRT_CLAMP(x, l, h)      (PVRT_MIN((h), PVRT_MAX((x), (l))))

#define LIMIT_COORD(Val, Size, AssumeImageTiles) \
	  ((AssumeImageTiles)? WRAP_COORD((Val), (Size)): PVRT_CLAMP((Val), 0, (Size)-1))

/*****************************************************************************
 * Useful typedefs
 *****************************************************************************/
typedef PVRTuint32 U32;
typedef PVRTuint8 U8;

/***********************************************************
				DECOMPRESSION ROUTINES
************************************************************/

/*!***********************************************************************
 @Struct	AMTC_BLOCK_STRUCT
 @Brief
*************************************************************************/
typedef struct
{
	// Uses 64 bits pre block
	U32 PackedData[2];
}AMTC_BLOCK_STRUCT;

 /*!***********************************************************************
  @Function		util_number_is_power_2
  @Input		input A number
  @Returns		TRUE if the number is an integer power of two, else FALSE.
  @Description	Check that a number is an integer power of two, i.e.
				1, 2, 4, 8, ... etc.
				Returns FALSE for zero.
*************************************************************************/
int util_number_is_power_2( unsigned  input )
{
  unsigned minus1;

  if( !input ) return 0;

  minus1 = input - 1;
  return ( (input | minus1) == (input ^ minus1) ) ? 1 : 0;
}

/*!***********************************************************************
 @Function		Unpack5554Colour
 @Input			pBlock
 @Input			ABColours
 @Description	Given a block, extract the colour information and convert
				to 5554 formats
*************************************************************************/
static void Unpack5554Colour(const AMTC_BLOCK_STRUCT *pBlock,
							 int   ABColours[2][4])
{
	U32 RawBits[2];

	int i;

	// Extract A and B
	RawBits[0] = pBlock->PackedData[1] & (0xFFFE); // 15 bits (shifted up by one)
	RawBits[1] = pBlock->PackedData[1] >> 16;	   // 16 bits

	// step through both colours
	for(i = 0; i < 2; i++)
	{
		// If completely opaque
		if(RawBits[i] & (1<<15))
		{
			// Extract R and G (both 5 bit)
			ABColours[i][0] = (RawBits[i] >> 10) & 0x1F;
			ABColours[i][1] = (RawBits[i] >>  5) & 0x1F;

			/*
				The precision of Blue depends on  A or B. If A then we need to
				replicate the top bit to get 5 bits in total
			*/
			ABColours[i][2] = RawBits[i] & 0x1F;
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// set 4bit alpha fully on...
			ABColours[i][3] = 0xF;
		}
		else // Else if colour has variable translucency
		{
			/*
				Extract R and G (both 4 bit).
				(Leave a space on the end for the replication of bits
			*/
			ABColours[i][0] = (RawBits[i] >>  (8-1)) & 0x1E;
			ABColours[i][1] = (RawBits[i] >>  (4-1)) & 0x1E;

			// replicate bits to truly expand to 5 bits
			ABColours[i][0] |= ABColours[i][0] >> 4;
			ABColours[i][1] |= ABColours[i][1] >> 4;

			// grab the 3(+padding) or 4 bits of blue and add an extra padding bit
			ABColours[i][2] = (RawBits[i] & 0xF) << 1;

			/*
				expand from 3 to 5 bits if this is from colour A, or 4 to 5 bits if from
				colour B
			*/
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 3;
			}
			else
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// Set the alpha bits to be 3 + a zero on the end
			ABColours[i][3] = (RawBits[i] >> 11) & 0xE;
		}
	}
}

/*!***********************************************************************
 @Function		UnpackModulations
 @Input			pBlock
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			StartX
 @Input			StartY
 @Description	Given the block and the texture type and it's relative
				position in the 2x2 group of blocks, extract the bit
				patterns for the fully defined pixels.
*************************************************************************/
static void	UnpackModulations(const AMTC_BLOCK_STRUCT *pBlock,
							  const int Do2bitMode,
							  int ModulationVals[8][16],
							  int ModulationModes[8][16],
							  int StartX,
							  int StartY)
{
	int BlockModMode;
	U32 ModulationBits;

	int x, y;

	BlockModMode= pBlock->PackedData[1] & 1;
	ModulationBits	= pBlock->PackedData[0];

	// if it's in an interpolated mode
	if(Do2bitMode && BlockModMode)
	{
		/*
			run through all the pixels in the block. Note we can now treat all the
			"stored" values as if they have 2bits (even when they didn't!)
		*/
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// if this is a stored value...
				if(((x^y)&1) == 0)
				{
					ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
					ModulationBits >>= 2;
				}
			}
		}
	}
	else if(Do2bitMode) // else if direct encoded 2bit mode - i.e. 1 mode bit per pixel
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// double the bits so 0=> 00, and 1=>11
				if(ModulationBits & 1)
				{
					ModulationVals[y+StartY][x+StartX] = 0x3;
				}
				else
				{
					ModulationVals[y+StartY][x+StartX] = 0x0;
				}
				ModulationBits >>= 1;
			}
		}
	}
	else // else its the 4bpp mode so each value has 2 bits
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_4BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
				ModulationBits >>= 2;
			}
		}
	}

	// make sure nothing is left over
	assert(ModulationBits==0);
}

/*!***********************************************************************
 @Function		InterpolateColours
 @Input			ColourP
 @Input			ColourQ
 @Input			ColourR
 @Input			ColourS
 @Input			Do2bitMode
 @Input			x
 @Input			y
 @Modified		Result
 @Description	This performs a HW bit accurate interpolation of either the
				A or B colours for a particular pixel.

				NOTE: It is assumed that the source colours are in ARGB 5554
				format - This means that some "preparation" of the values will
				be necessary.
*************************************************************************/
static void InterpolateColours(const int ColourP[4],
						  const int ColourQ[4],
						  const int ColourR[4],
						  const int ColourS[4],
						  const int Do2bitMode,
						  const int x,
						  const int y,
						  int Result[4])
{
	int u, v, uscale;
	int k;

	int tmp1, tmp2;

	int P[4], Q[4], R[4], S[4];

	// Copy the colours
	for(k = 0; k < 4; k++)
	{
		P[k] = ColourP[k];
		Q[k] = ColourQ[k];
		R[k] = ColourR[k];
		S[k] = ColourS[k];
	}

	// put the x and y values into the right range
	v = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		u = (x & 0x7) | ((~x & 0x4) << 1);
	else
		u = (x & 0x3) | ((~x & 0x2) << 1);

	// get the u and v scale amounts
	v  = v - BLK_Y_SIZE/2;

	if(Do2bitMode)
	{
		u = u - BLK_X_2BPP/2;
		uscale = 8;
	}
	else
	{
		u = u - BLK_X_4BPP/2;
		uscale = 4;
	}

	for(k = 0; k < 4; k++)
	{
		tmp1 = P[k] * uscale + u * (Q[k] - P[k]);
		tmp2 = R[k] * uscale + u * (S[k] - R[k]);

		tmp1 = tmp1 * 4 + v * (tmp2 - tmp1);

		Result[k] = tmp1;
	}

	// Lop off the appropriate number of bits to get us to 8 bit precision
	if(Do2bitMode)
	{
		// do RGB
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 2;
		}

		Result[3] >>= 1;
	}
	else
	{
		// do RGB  (A is ok)
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 1;
		}
	}

	// sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

	/*
		Convert from 5554 to 8888

		do RGB 5.3 => 8
	*/
	for(k = 0; k < 3; k++)
	{
		Result[k] += Result[k] >> 5;
	}

	Result[3] += Result[3] >> 4;

	// 2nd sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

}

/*!***********************************************************************
 @Function		GetModulationValue
 @Input			x
 @Input			y
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			Mod
 @Input			DoPT
 @Description	Get the modulation value as a numerator of a fraction of 8ths
*************************************************************************/
static void GetModulationValue(int x,
							   int y,
							   const int Do2bitMode,
							   const int ModulationVals[8][16],
							   const int ModulationModes[8][16],
							   int *Mod,
							   int *DoPT)
{
	static const int RepVals0[4] = {0, 3, 5, 8};
	static const int RepVals1[4] = {0, 4, 4, 8};

	int ModVal;

	// Map X and Y into the local 2x2 block
	y = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		x = (x & 0x7) | ((~x & 0x4) << 1);
	else
		x = (x & 0x3) | ((~x & 0x2) << 1);

	// assume no PT for now
	*DoPT = 0;

	// extract the modulation value. If a simple encoding
	if(ModulationModes[y][x]==0)
	{
		ModVal = RepVals0[ModulationVals[y][x]];
	}
	else if(Do2bitMode)
	{
		// if this is a stored value
		if(((x^y)&1)==0)
			ModVal = RepVals0[ModulationVals[y][x]];
		else if(ModulationModes[y][x] == 1) // else average from the neighbours if H&V interpolation..
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] +
					  RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 2) / 4;
		}
		else if(ModulationModes[y][x] == 2) // else if H-Only
		{
			ModVal = (RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 1) / 2;
		}
		else // else it's V-Only
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] + 1) / 2;
		}
	}
	else // else it's 4BPP and PT encoding
	{
		ModVal = RepVals1[ModulationVals[y][x]];

		*DoPT = ModulationVals[y][x] == PT_INDEX;
	}

	*Mod =ModVal;
}

/*!***********************************************************************
 @Function		TwiddleUV
 @Input			YSize	Y dimension of the texture in pixels
 @Input			XSize	X dimension of the texture in pixels
 @Input			YPos	Pixel Y position
 @Input			XPos	Pixel X position
 @Returns		The twiddled offset of the pixel
 @Description	Given the Block (or pixel) coordinates and the dimension of
				the texture in blocks (or pixels) this returns the twiddled
				offset of the block (or pixel) from the start of the map.

				NOTE the dimensions of the texture must be a power of 2
*************************************************************************/
static int DisableTwiddlingRoutine = 0;

static U32 TwiddleUV(U32 YSize, U32 XSize, U32 YPos, U32 XPos)
{
	U32 Twiddled;

	U32 MinDimension;
	U32 MaxValue;

	U32 SrcBitPos;
	U32 DstBitPos;

	int ShiftCount;

	assert(YPos < YSize);
	assert(XPos < XSize);

	assert(POWER_OF_2(YSize));
	assert(POWER_OF_2(XSize));

	if(YSize < XSize)
	{
		MinDimension = YSize;
		MaxValue	 = XPos;
	}
	else
	{
		MinDimension = XSize;
		MaxValue	 = YPos;
	}

	// Nasty hack to disable twiddling
	if(DisableTwiddlingRoutine)
		return (YPos* XSize + XPos);

	// Step through all the bits in the "minimum" dimension
	SrcBitPos = 1;
	DstBitPos = 1;
	Twiddled  = 0;
	ShiftCount = 0;

	while(SrcBitPos < MinDimension)
	{
		if(YPos & SrcBitPos)
		{
			Twiddled |= DstBitPos;
		}

		if(XPos & SrcBitPos)
		{
			Twiddled |= (DstBitPos << 1);
		}

		SrcBitPos <<= 1;
		DstBitPos <<= 2;
		ShiftCount += 1;

	}

	// prepend any unused bits
	MaxValue >>= ShiftCount;

	Twiddled |=  (MaxValue << (2*ShiftCount));

	return Twiddled;
}

/***********************************************************/
/*
// Decompress
//
// Takes the compressed input data and outputs the equivalent decompressed
// image.
*/
/***********************************************************/

static void Decompress(AMTC_BLOCK_STRUCT *pCompressedData,
					   const int Do2bitMode,
					   const int XDim,
					   const int YDim,
					   const int AssumeImageTiles,
					   unsigned char* pResultImage)
{
	int x, y;
	int i, j;

	int BlkX, BlkY;
	int BlkXp1, BlkYp1;
	int XBlockSize;
	int BlkXDim, BlkYDim;

	int StartX, StartY;

	int ModulationVals[8][16];
	int ModulationModes[8][16];

	int Mod, DoPT;

	unsigned int uPosition;

	/*
	// local neighbourhood of blocks
	*/
	AMTC_BLOCK_STRUCT *pBlocks[2][2];

	AMTC_BLOCK_STRUCT *pPrevious[2][2] = {{NULL, NULL}, {NULL, NULL}};

	/*
	// Low precision colours extracted from the blocks
	*/
	struct
	{
		int Reps[2][4];
	}Colours5554[2][2];

	/*
	// Interpolated A and B colours for the pixel
	*/
	int ASig[4], BSig[4];

	int Result[4];

	if(Do2bitMode)
	{
		XBlockSize = BLK_X_2BPP;
	}
	else
	{
		XBlockSize = BLK_X_4BPP;
	}

	/*
	// For MBX don't allow the sizes to get too small
	*/
	BlkXDim = PVRT_MAX(2, XDim / XBlockSize);
	BlkYDim = PVRT_MAX(2, YDim / BLK_Y_SIZE);

	/*
	// Step through the pixels of the image decompressing each one in turn
	//
	// Note that this is a hideously inefficient way to do this!
	*/
	for(y = 0; y < YDim; y++)
	{
		for(x = 0; x < XDim; x++)
		{
			/*
			// map this pixel to the top left neighbourhood of blocks
			*/
			BlkX = (x - XBlockSize/2);
			BlkY = (y - BLK_Y_SIZE/2);

			BlkX = LIMIT_COORD(BlkX, XDim, AssumeImageTiles);
			BlkY = LIMIT_COORD(BlkY, YDim, AssumeImageTiles);

			BlkX /= XBlockSize;
			BlkY /= BLK_Y_SIZE;

			//BlkX = LIMIT_COORD(BlkX, BlkXDim, AssumeImageTiles);
			//BlkY = LIMIT_COORD(BlkY, BlkYDim, AssumeImageTiles);

			/*
			// compute the positions of the other 3 blocks
			*/
			BlkXp1 = LIMIT_COORD(BlkX+1, BlkXDim, AssumeImageTiles);
			BlkYp1 = LIMIT_COORD(BlkY+1, BlkYDim, AssumeImageTiles);

			/*
			// Map to block memory locations
			*/
			pBlocks[0][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkX);
			pBlocks[0][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkXp1);
			pBlocks[1][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkX);
			pBlocks[1][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkXp1);

			/*
			// extract the colours and the modulation information IF the previous values
			// have changed.
			*/
			if(memcmp(pPrevious, pBlocks, 4*sizeof(void*)) != 0)
			{
				StartY = 0;
				for(i = 0; i < 2; i++)
				{
					StartX = 0;
					for(j = 0; j < 2; j++)
					{
						Unpack5554Colour(pBlocks[i][j], Colours5554[i][j].Reps);

						UnpackModulations(pBlocks[i][j],
							Do2bitMode,
							ModulationVals,
							ModulationModes,
							StartX, StartY);

						StartX += XBlockSize;
					}/*end for j*/

					StartY += BLK_Y_SIZE;
				}/*end for i*/

				/*
				// make a copy of the new pointers
				*/
				memcpy(pPrevious, pBlocks, 4*sizeof(void*));
			}/*end if the blocks have changed*/

			/*
			// decompress the pixel.  First compute the interpolated A and B signals
			*/
			InterpolateColours(Colours5554[0][0].Reps[0],
				Colours5554[0][1].Reps[0],
				Colours5554[1][0].Reps[0],
				Colours5554[1][1].Reps[0],
				Do2bitMode, x, y,
				ASig);

			InterpolateColours(Colours5554[0][0].Reps[1],
				Colours5554[0][1].Reps[1],
				Colours5554[1][0].Reps[1],
				Colours5554[1][1].Reps[1],
				Do2bitMode, x, y,
				BSig);

			GetModulationValue(x,y, Do2bitMode, (const int (*)[16])ModulationVals, (const int (*)[16])ModulationModes,
				&Mod, &DoPT);

			/*
			// compute the modulated colour
			*/
			for(i = 0; i < 4; i++)
			{
				Result[i] = ASig[i] * 8 + Mod * (BSig[i] - ASig[i]);
				Result[i] >>= 3;
			}
			if(DoPT)
			{
				Result[3] = 0;
			}

			/*
			// Store the result in the output image
			*/
			uPosition = (x+y*XDim)<<2;
			pResultImage[uPosition+0] = (unsigned char)Result[0];
			pResultImage[uPosition+1] = (unsigned char)Result[1];
			pResultImage[uPosition+2] = (unsigned char)Result[2];
			pResultImage[uPosition+3] = (unsigned char)Result[3];

		}/*end for x*/
	}/*end for y*/

}

static void * stbi__pvr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi_uc *pvr_data = NULL;
	stbi_uc *pvr_res_data = NULL;
	PVR_Texture_Header header={0};
	int iscompressed = 0;
	int bitmode = 0;
	unsigned int levelSize = 0;

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PVR_Texture_Header) );

	// Check the header size
	if ( header.dwHeaderSize != sizeof(PVR_Texture_Header) ) {
		return NULL;
	}

	// Check the magic identifier
	if ( header.dwPVR != PVRTEX_IDENTIFIER ) {
		return NULL;
	}

	*x = s->img_x = header.dwWidth;
	*y = s->img_y = header.dwHeight;

	/* Get if the texture is compressed and the texture mode ( 2bpp or 4bpp ) */
	switch ( header.dwpfFlags & PVRTEX_PIXELTYPE )
	{
		case OGL_RGBA_4444:
			s->img_n = 2;
			break;
		case OGL_RGBA_5551:
			s->img_n = 2;
			break;
		case OGL_RGBA_8888:
			s->img_n = 4;
			break;
		case OGL_RGB_565:
			s->img_n = 2;
			break;
		case OGL_RGB_888:
			s->img_n = 3;
			break;
		case OGL_I_8:
			s->img_n = 1;
			break;
		case OGL_AI_88:
			s->img_n = 2;
			break;
		case OGL_PVRTC2:
			bitmode = 1;
			s->img_n = 4;
			iscompressed = 1;
			break;
		case OGL_PVRTC4:
			s->img_n = 4;
			iscompressed = 1;
			break;
		case OGL_RGB_555:
		default:
			return NULL;
	}

	*comp = s->img_n;

	// Load only the first mip map level
	levelSize = (s->img_x * s->img_y * header.dwBitCount + 7) / 8;

	// get the raw data
	pvr_data = (stbi_uc *)malloc( levelSize );
	stbi__getn( s, pvr_data, levelSize );

	// if compressed decompress as RGBA
	if ( iscompressed ) {
		pvr_res_data = (stbi_uc *)malloc( s->img_x * s->img_y * 4 );
		Decompress( (AMTC_BLOCK_STRUCT*)pvr_data, bitmode, s->img_x, s->img_y, 1, (unsigned char*)pvr_res_data );
		free( pvr_data );
	} else {
		// otherwise use the raw data
		pvr_res_data = pvr_data;
	}

	if( (req_comp <= 4) && (req_comp >= 1) ) {
		//	user has some requirements, meet them
		if( req_comp != s->img_n ) {
			pvr_res_data = stbi__convert_format( pvr_res_data, s->img_n, req_comp, s->img_x, s->img_y );
			*comp = req_comp;
		}
	}

	return pvr_res_data;
}

#ifndef STBI_NO_STDIO
void *stbi__pvr_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s,f);
	return stbi__pvr_load(&s,x,y,comp,req_comp);
}

void *stbi__pvr_load_from_path             (char const*filename,           int *x, int *y, int *comp, int req_comp)
{
   void *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi__pvr_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

void *stbi__pvr_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pvr_load(&s,x,y,comp,req_comp);
}

void *stbi__pvr_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pvr_load(&s,x,y,comp,req_comp);
}


#endif

// add in my pkm ( ETC1 ) loading support
#ifndef STBI_NO_PKM

//#line 1 "stbi_pkm_c.h"

//#line 1 "pkm_helper.h"
#ifndef PKM_HELPER_H
#define PKM_HELPER_H

typedef struct {
	char aName[6];
	unsigned short iBlank;
	unsigned char iPaddedWidthMSB;
	unsigned char iPaddedWidthLSB;
	unsigned char iPaddedHeightMSB;
	unsigned char iPaddedHeightLSB;
	unsigned char iWidthMSB;
	unsigned char iWidthLSB;
	unsigned char iHeightMSB;
	unsigned char iHeightLSB;
} PKMHeader;

#define PKM_HEADER_SIZE 16

#endif


//#line 1 "etc1_utils.h"
// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef __etc1_h__
#define __etc1_h__

#define ETC1_ENCODED_BLOCK_SIZE 8
#define ETC1_DECODED_BLOCK_SIZE 48

#ifndef ETC1_RGB8_OES
#define ETC1_RGB8_OES 0x8D64
#endif

typedef unsigned char etc1_byte;
typedef int etc1_bool;
typedef unsigned int etc1_uint32;

#ifdef __cplusplus
extern "C" {
#endif

// Encode a block of pixels.
//
// pIn is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).
//
// validPixelMask is a 16-bit mask where bit (1 << (x + y * 4)) indicates whether
// the corresponding (x,y) pixel is valid. Invalid pixel color values are ignored when compressing.
//
// pOut is an ETC1 compressed version of the data.

void etc1_encode_block(const etc1_byte* pIn, etc1_uint32 validPixelMask, etc1_byte* pOut);

// Decode a block of pixels.
//
// pIn is an ETC1 compressed version of the data.
//
// pOut is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).

void etc1_decode_block(const etc1_byte* pIn, etc1_byte* pOut);

// Return the size of the encoded image data (does not include size of PKM header).

etc1_uint32 etc1_get_encoded_data_size(etc1_uint32 width, etc1_uint32 height);

// Encode an entire image.
// pIn - pointer to the image data. Formatted such that
//       pixel (x,y) is at pIn + pixelSize * x + stride * y;
// pOut - pointer to encoded data. Must be large enough to store entire encoded image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_encode_image(const etc1_byte* pIn, etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride, etc1_byte* pOut);

// Decode an entire image.
// pIn - pointer to encoded data.
// pOut - pointer to the image data. Will be written such that
//        pixel (x,y) is at pIn + pixelSize * x + stride * y. Must be
//        large enough to store entire image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_decode_image(const etc1_byte* pIn, etc1_byte* pOut,
		etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride);

// Size of a PKM header, in bytes.

#define ETC_PKM_HEADER_SIZE 16

// Format a PKM header

void etc1_pkm_format_header(etc1_byte* pHeader, etc1_uint32 width, etc1_uint32 height);

// Check if a PKM header is correctly formatted.

etc1_bool etc1_pkm_is_valid(const etc1_byte* pHeader);

// Read the image width from a PKM header

etc1_uint32 etc1_pkm_get_width(const etc1_byte* pHeader);

// Read the image height from a PKM header

etc1_uint32 etc1_pkm_get_height(const etc1_byte* pHeader);

#ifdef __cplusplus
}
#endif

#endif
static int stbi__pkm_test(stbi__context *s)
{
	//	check the magic number
	if (stbi__get8(s) != 'P') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'K') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != 'M') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != ' ') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != '1') {
		stbi__rewind(s);
		return 0;
	}

	if (stbi__get8(s) != '0') {
		stbi__rewind(s);
		return 0;
	}

	stbi__rewind(s);
	return 1;
}

#ifndef STBI_NO_STDIO

int      stbi__pkm_test_filename        		(char const *filename)
{
   int r;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   r = stbi__pkm_test_file(f);
   fclose(f);
   return r;
}

int      stbi__pkm_test_file        (FILE *f)
{
   stbi__context s;
   int r,n = ftell(f);
   stbi__start_file(&s,f);
   r = stbi__pkm_test(&s);
   fseek(f,n,SEEK_SET);
   return r;
}
#endif

int      stbi__pkm_test_memory      (stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pkm_test(&s);
}

int      stbi__pkm_test_callbacks      (stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pkm_test(&s);
}

static int stbi__pkm_info(stbi__context *s, int *x, int *y, int *comp )
{
	PKMHeader header;
	unsigned int width, height;

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PKMHeader) );

	if ( 0 != strcmp( header.aName, "PKM 10" ) ) {
		stbi__rewind(s);
		return 0;
	}

	width = (header.iWidthMSB << 8) | header.iWidthLSB;
	height = (header.iHeightMSB << 8) | header.iHeightLSB;

	*x = s->img_x = width;
	*y = s->img_y = height;
	*comp = s->img_n = 3;

	stbi__rewind(s);

	return 1;
}

int stbi__pkm_info_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp )
{
	stbi__context s;
	stbi__start_mem(&s,buffer, len);
	return stbi__pkm_info( &s, x, y, comp );
}

int stbi__pkm_info_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp)
{
	stbi__context s;
	stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
	return stbi__pkm_info( &s, x, y, comp );
}

#ifndef STBI_NO_STDIO
int stbi__pkm_info_from_path(char const *filename,     int *x, int *y, int *comp)
{
   int res;
   FILE *f = fopen(filename, "rb");
   if (!f) return 0;
   res = stbi__pkm_info_from_file( f, x, y, comp );
   fclose(f);
   return res;
}

int stbi__pkm_info_from_file(FILE *f,                  int *x, int *y, int *comp)
{
   stbi__context s;
   int res;
   long n = ftell(f);
   stbi__start_file(&s, f);
   res = stbi__pkm_info(&s, x, y, comp);
   fseek(f, n, SEEK_SET);
   return res;
}
#endif

static void * stbi__pkm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp)
{
	stbi_uc *pkm_data = NULL;
	stbi_uc *pkm_res_data = NULL;
	PKMHeader header;
	unsigned int width;
	unsigned int height;
	unsigned int align = 0;
	unsigned int bpr;
	unsigned int size;
	unsigned int compressedSize;

	int res;

	stbi__getn( s, (stbi_uc*)(&header), sizeof(PKMHeader) );

	if ( 0 != strcmp( header.aName, "PKM 10" ) ) {
		return NULL;
	}

	width = (header.iWidthMSB << 8) | header.iWidthLSB;
	height = (header.iHeightMSB << 8) | header.iHeightLSB;

	*x = s->img_x = width;
	*y = s->img_y = height;
	*comp = s->img_n = 3;

	compressedSize = etc1_get_encoded_data_size(width, height);

	pkm_data = (stbi_uc *)malloc(compressedSize);
	stbi__getn( s, pkm_data, compressedSize );

	bpr = ((width * 3) + align) & ~align;
	size = bpr * height;
	pkm_res_data = (stbi_uc *)malloc(size);

	res = etc1_decode_image((const etc1_byte*)pkm_data, (etc1_byte*)pkm_res_data, width, height, 3, bpr);

	free( pkm_data );

	if ( 0 == res ) {
		if( (req_comp <= 4) && (req_comp >= 1) ) {
			//	user has some requirements, meet them
			if( req_comp != s->img_n ) {
				pkm_res_data = stbi__convert_format( pkm_res_data, s->img_n, req_comp, s->img_x, s->img_y );
				*comp = req_comp;
			}
		}

		return (stbi_uc *)pkm_res_data;
	} else {
		free( pkm_res_data );
	}

	return NULL;
}

#ifndef STBI_NO_STDIO
void *stbi__pkm_load_from_file   (FILE *f,                  int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
	stbi__start_file(&s,f);
	return stbi__pkm_load(&s,x,y,comp,req_comp);
}

void *stbi__pkm_load_from_path             (char const*filename,           int *x, int *y, int *comp, int req_comp)
{
   void *data;
   FILE *f = fopen(filename, "rb");
   if (!f) return NULL;
   data = stbi__pkm_load_from_file(f,x,y,comp,req_comp);
   fclose(f);
   return data;
}
#endif

void *stbi__pkm_load_from_memory (stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)
{
   stbi__context s;
   stbi__start_mem(&s,buffer, len);
   return stbi__pkm_load(&s,x,y,comp,req_comp);
}

void *stbi__pkm_load_from_callbacks (stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)
{
	stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi__pkm_load(&s,x,y,comp,req_comp);
}


#endif

#ifndef STBI_NO_EXT

//#line 1 "stbi_ext_c.h"
static int stbi_test_main(stbi__context *s)
{
   #ifndef STBI_NO_JPEG
   if (stbi__jpeg_test(s)) return STBI_jpeg;
   #endif
   #ifndef STBI_NO_PNG
   if (stbi__png_test(s))  return STBI_png;
   #endif
   #ifndef STBI_NO_BMP
   if (stbi__bmp_test(s))  return STBI_bmp;
   #endif
   #ifndef STBI_NO_GIF
   if (stbi__gif_test(s))  return STBI_gif;
   #endif
   #ifndef STBI_NO_PSD
   if (stbi__psd_test(s))  return STBI_psd;
   #endif
   #ifndef STBI_NO_PIC
   if (stbi__pic_test(s))  return STBI_pic;
   #endif
   #ifndef STBI_NO_PNM
   if (stbi__pnm_test(s))  return STBI_pnm;
   #endif
   #ifndef STBI_NO_DDS
   if (stbi__dds_test(s))  return STBI_dds;
   #endif
   #ifndef STBI_NO_PVR
   if (stbi__pvr_test(s))  return STBI_pvr;
   #endif
   #ifndef STBI_NO_PKM
   if (stbi__pkm_test(s))  return STBI_pkm;
   #endif
   #ifndef STBI_NO_HDR
   if (stbi__hdr_test(s))  return STBI_hdr;
   #endif
   #ifndef STBI_NO_TGA
   if (stbi__tga_test(s))  return STBI_tga;
   #endif
   return STBI_unknown;
}

#ifndef STBI_NO_STDIO
int stbi_test_from_file(FILE *f)
{
   stbi__context s;
   stbi__start_file(&s,f);
   return stbi_test_main(&s);
}

int stbi_test(char const *filename)
{
   FILE *f = fopen(filename, "rb");
   int result;
   if (!f) return STBI_unknown;
   result = stbi_test_from_file(f);
   fclose(f);
   return result;
}
#endif //!STBI_NO_STDIO

int stbi_test_from_memory(stbi_uc const *buffer, int len)
{
   stbi__context s;
   stbi__start_mem(&s,buffer,len);
   return stbi_test_main(&s);
}

int stbi_test_from_callbacks(stbi_io_callbacks const *clbk, void *user)
{
   stbi__context s;
   stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);
   return stbi_test_main(&s);
}


#endif

#endif // STB_IMAGE_IMPLEMENTATION

/*
   revision history:
	  2.15  (2017-03-18) fix png-1,2,4 bug; now all Imagenet JPGs decode;
						 warning fixes; disable run-time SSE detection on gcc;
						 uniform handling of optional "return" values;
						 thread-safe initialization of zlib tables
	  2.14  (2017-03-03) remove deprecated STBI_JPEG_OLD; fixes for Imagenet JPGs
	  2.13  (2016-11-29) add 16-bit API, only supported for PNG right now
	  2.12  (2016-04-02) fix typo in 2.11 PSD fix that caused crashes
	  2.11  (2016-04-02) allocate large structures on the stack
						 remove white matting for transparent PSD
						 fix reported channel count for PNG & BMP
						 re-enable SSE2 in non-gcc 64-bit
						 support RGB-formatted JPEG
						 read 16-bit PNGs (only as 8-bit)
	  2.10  (2016-01-22) avoid warning introduced in 2.09 by STBI_REALLOC_SIZED
	  2.09  (2016-01-16) allow comments in PNM files
						 16-bit-per-pixel TGA (not bit-per-component)
						 info() for TGA could break due to .hdr handling
						 info() for BMP to shares code instead of sloppy parse
						 can use STBI_REALLOC_SIZED if allocator doesn't support realloc
						 code cleanup
	  2.08  (2015-09-13) fix to 2.07 cleanup, reading RGB PSD as RGBA
	  2.07  (2015-09-13) fix compiler warnings
						 partial animated GIF support
						 limited 16-bpc PSD support
						 #ifdef unused functions
						 bug with < 92 byte PIC,PNM,HDR,TGA
	  2.06  (2015-04-19) fix bug where PSD returns wrong '*comp' value
	  2.05  (2015-04-19) fix bug in progressive JPEG handling, fix warning
	  2.04  (2015-04-15) try to re-enable SIMD on MinGW 64-bit
	  2.03  (2015-04-12) extra corruption checking (mmozeiko)
						 stbi_set_flip_vertically_on_load (nguillemot)
						 fix NEON support; fix mingw support
	  2.02  (2015-01-19) fix incorrect assert, fix warning
	  2.01  (2015-01-17) fix various warnings; suppress SIMD on gcc 32-bit without -msse2
	  2.00b (2014-12-25) fix STBI_MALLOC in progressive JPEG
	  2.00  (2014-12-25) optimize JPG, including x86 SSE2 & NEON SIMD (ryg)
						 progressive JPEG (stb)
						 PGM/PPM support (Ken Miller)
						 STBI_MALLOC,STBI_REALLOC,STBI_FREE
						 GIF bugfix -- seemingly never worked
						 STBI_NO_*, STBI_ONLY_*
	  1.48  (2014-12-14) fix incorrectly-named assert()
	  1.47  (2014-12-14) 1/2/4-bit PNG support, both direct and paletted (Omar Cornut & stb)
						 optimize PNG (ryg)
						 fix bug in interlaced PNG with user-specified channel count (stb)
	  1.46  (2014-08-26)
			  fix broken tRNS chunk (colorkey-style transparency) in non-paletted PNG
	  1.45  (2014-08-16)
			  fix MSVC-ARM internal compiler error by wrapping malloc
	  1.44  (2014-08-07)
			  various warning fixes from Ronny Chevalier
	  1.43  (2014-07-15)
			  fix MSVC-only compiler problem in code changed in 1.42
	  1.42  (2014-07-09)
			  don't define _CRT_SECURE_NO_WARNINGS (affects user code)
			  fixes to stbi__cleanup_jpeg path
			  added STBI_ASSERT to avoid requiring assert.h
	  1.41  (2014-06-25)
			  fix search&replace from 1.36 that messed up comments/error messages
	  1.40  (2014-06-22)
			  fix gcc struct-initialization warning
	  1.39  (2014-06-15)
			  fix to TGA optimization when req_comp != number of components in TGA;
			  fix to GIF loading because BMP wasn't rewinding (whoops, no GIFs in my test suite)
			  add support for BMP version 5 (more ignored fields)
	  1.38  (2014-06-06)
			  suppress MSVC warnings on integer casts truncating values
			  fix accidental rename of 'skip' field of I/O
	  1.37  (2014-06-04)
			  remove duplicate typedef
	  1.36  (2014-06-03)
			  convert to header file single-file library
			  if de-iphone isn't set, load iphone images color-swapped instead of returning NULL
	  1.35  (2014-05-27)
			  various warnings
			  fix broken STBI_SIMD path
			  fix bug where stbi_load_from_file no longer left file pointer in correct place
			  fix broken non-easy path for 32-bit BMP (possibly never used)
			  TGA optimization by Arseny Kapoulkine
	  1.34  (unknown)
			  use STBI_NOTUSED in stbi__resample_row_generic(), fix one more leak in tga failure case
	  1.33  (2011-07-14)
			  make stbi_is_hdr work in STBI_NO_HDR (as specified), minor compiler-friendly improvements
	  1.32  (2011-07-13)
			  support for "info" function for all supported filetypes (SpartanJ)
	  1.31  (2011-06-20)
			  a few more leak fixes, bug in PNG handling (SpartanJ)
	  1.30  (2011-06-11)
			  added ability to load files via callbacks to accomidate custom input streams (Ben Wenger)
			  removed deprecated format-specific test/load functions
			  removed support for installable file formats (stbi_loader) -- would have been broken for IO callbacks anyway
			  error cases in bmp and tga give messages and don't leak (Raymond Barbiero, grisha)
			  fix inefficiency in decoding 32-bit BMP (David Woo)
	  1.29  (2010-08-16)
			  various warning fixes from Aurelien Pocheville
	  1.28  (2010-08-01)
			  fix bug in GIF palette transparency (SpartanJ)
	  1.27  (2010-08-01)
			  cast-to-stbi_uc to fix warnings
	  1.26  (2010-07-24)
			  fix bug in file buffering for PNG reported by SpartanJ
	  1.25  (2010-07-17)
			  refix trans_data warning (Won Chun)
	  1.24  (2010-07-12)
			  perf improvements reading from files on platforms with lock-heavy fgetc()
			  minor perf improvements for jpeg
			  deprecated type-specific functions so we'll get feedback if they're needed
			  attempt to fix trans_data warning (Won Chun)
	  1.23    fixed bug in iPhone support
	  1.22  (2010-07-10)
			  removed image *writing* support
			  stbi_info support from Jetro Lauha
			  GIF support from Jean-Marc Lienher
			  iPhone PNG-extensions from James Brown
			  warning-fixes from Nicolas Schulz and Janez Zemva (i.stbi__err. Janez (U+017D)emva)
	  1.21    fix use of 'stbi_uc' in header (reported by jon blow)
	  1.20    added support for Softimage PIC, by Tom Seddon
	  1.19    bug in interlaced PNG corruption check (found by ryg)
	  1.18  (2008-08-02)
			  fix a threading bug (local mutable static)
	  1.17    support interlaced PNG
	  1.16    major bugfix - stbi__convert_format converted one too many pixels
	  1.15    initialize some fields for thread safety
	  1.14    fix threadsafe conversion bug
			  header-file-only version (#define STBI_HEADER_FILE_ONLY before including)
	  1.13    threadsafe
	  1.12    const qualifiers in the API
	  1.11    Support installable IDCT, colorspace conversion routines
	  1.10    Fixes for 64-bit (don't use "unsigned long")
			  optimized upsampling by Fabian "ryg" Giesen
	  1.09    Fix format-conversion for PSD code (bad global variables!)
	  1.08    Thatcher Ulrich's PSD code integrated by Nicolas Schulz
	  1.07    attempt to fix C++ warning/errors again
	  1.06    attempt to fix C++ warning/errors again
	  1.05    fix TGA loading to return correct *comp and use good luminance calc
	  1.04    default float alpha is 1, not 255; use 'void *' for stbi_image_free
	  1.03    bugfixes to STBI_NO_STDIO, STBI_NO_HDR
	  1.02    support for (subset of) HDR files, float interface for preferred access to them
	  1.01    fix bug: possible bug in handling right-side up bmps... not sure
			  fix bug: the stbi__bmp_load() and stbi__tga_load() functions didn't work at all
	  1.00    interface to zlib that skips zlib header
	  0.99    correct handling of alpha in palette
	  0.98    TGA loader by lonesock; dynamically add loaders (untested)
	  0.97    jpeg errors on too large a file; also catch another malloc failure
	  0.96    fix detection of invalid v value - particleman@mollyrocket forum
	  0.95    during header scan, seek to markers in case of padding
	  0.94    STBI_NO_STDIO to disable stdio usage; rename all #defines the same
	  0.93    handle jpegtran output; verbose errors
	  0.92    read 4,8,16,24,32-bit BMP files of several formats
	  0.91    output 24-bit Windows 3.0 BMP files
	  0.90    fix a few more warnings; bump version number to approach 1.0
	  0.61    bugfixes due to Marc LeBlanc, Christopher Lloyd
	  0.60    fix compiling as c++
	  0.59    fix warnings: merge Dave Moore's -Wall fixes
	  0.58    fix bug: zlib uncompressed mode len/nlen was wrong endian
	  0.57    fix bug: jpg last huffman symbol before marker was >9 bits but less than 16 available
	  0.56    fix bug: zlib uncompressed mode len vs. nlen
	  0.55    fix bug: restart_interval not initialized to 0
	  0.54    allow NULL for 'int *comp'
	  0.53    fix bug in png 3->4; speedup png decoding
	  0.52    png handles req_comp=3,4 directly; minor cleanup; jpeg comments
	  0.51    obey req_comp requests, 1-component jpegs return as 1-component,
			  on 'test' only check type, not whether we support this variant
	  0.50  (2006-11-19)
			  first released version
*/

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/


#define STB_IMAGE_WRITE_IMPLEMENTATION

//#line 1 "stb_image_write.h"
#ifndef INCLUDE_STB_IMAGE_WRITE_H
#define INCLUDE_STB_IMAGE_WRITE_H

#ifdef __cplusplus
extern "C" {
#endif

#ifdef STB_IMAGE_WRITE_STATIC
#define STBIWDEF static
#else
#define STBIWDEF extern
extern int stbi_write_tga_with_rle;
#endif

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_png(char const *filename, int w, int h, int comp, const void  *data, int stride_in_bytes);
STBIWDEF int stbi_write_bmp(char const *filename, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_tga(char const *filename, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_hdr(char const *filename, int w, int h, int comp, const float *data);
#endif

typedef void stbi_write_func(void *context, void *data, int size);

STBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data, int stride_in_bytes);
STBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_tga_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const void  *data);
STBIWDEF int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int w, int h, int comp, const float *data);

#ifdef __cplusplus
}
#endif

#endif//INCLUDE_STB_IMAGE_WRITE_H

#ifdef STB_IMAGE_WRITE_IMPLEMENTATION

#ifdef _WIN32
   #ifndef _CRT_SECURE_NO_WARNINGS
   #define _CRT_SECURE_NO_WARNINGS
   #endif
   #ifndef _CRT_NONSTDC_NO_DEPRECATE
   #define _CRT_NONSTDC_NO_DEPRECATE
   #endif
#endif

#ifndef STBI_WRITE_NO_STDIO
#include <stdio.h>
#endif // STBI_WRITE_NO_STDIO

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#if defined(STBIW_MALLOC) && defined(STBIW_FREE) && (defined(STBIW_REALLOC) || defined(STBIW_REALLOC_SIZED))
// ok
#elif !defined(STBIW_MALLOC) && !defined(STBIW_FREE) && !defined(STBIW_REALLOC) && !defined(STBIW_REALLOC_SIZED)
// ok
#else
#error "Must define all or none of STBIW_MALLOC, STBIW_FREE, and STBIW_REALLOC (or STBIW_REALLOC_SIZED)."
#endif

#ifndef STBIW_MALLOC
#define STBIW_MALLOC(sz)        malloc(sz)
#define STBIW_REALLOC(p,newsz)  realloc(p,newsz)
#define STBIW_FREE(p)           free(p)
#endif

#ifndef STBIW_REALLOC_SIZED
#define STBIW_REALLOC_SIZED(p,oldsz,newsz) STBIW_REALLOC(p,newsz)
#endif

#ifndef STBIW_MEMMOVE
#define STBIW_MEMMOVE(a,b,sz) memmove(a,b,sz)
#endif

#ifndef STBIW_ASSERT
#include <assert.h>
#define STBIW_ASSERT(x) assert(x)
#endif

#define STBIW_UCHAR(x) (unsigned char) ((x) & 0xff)

typedef struct
{
   stbi_write_func *func;
   void *context;
} stbi__write_context;

// initialize a callback-based context
static void stbi__start_write_callbacks(stbi__write_context *s, stbi_write_func *c, void *context)
{
   s->func    = c;
   s->context = context;
}

#ifndef STBI_WRITE_NO_STDIO

static void stbi__stdio_write(void *context, void *data, int size)
{
   fwrite(data,1,size,(FILE*) context);
}

static int stbi__start_write_file(stbi__write_context *s, const char *filename)
{
   FILE *f = fopen(filename, "wb");
   stbi__start_write_callbacks(s, stbi__stdio_write, (void *) f);
   return f != NULL;
}

static void stbi__end_write_file(stbi__write_context *s)
{
   fclose((FILE *)s->context);
}

#endif // !STBI_WRITE_NO_STDIO

typedef unsigned int stbiw_uint32;
typedef int stb_image_write_test[sizeof(stbiw_uint32)==4 ? 1 : -1];

#ifdef STB_IMAGE_WRITE_STATIC
static int stbi_write_tga_with_rle = 1;
#else
int stbi_write_tga_with_rle = 1;
#endif

static void stbiw__writefv(stbi__write_context *s, const char *fmt, va_list v)
{
   while (*fmt) {
	  switch (*fmt++) {
		 case ' ': break;
		 case '1': { unsigned char x = STBIW_UCHAR(va_arg(v, int));
					 s->func(s->context,&x,1);
					 break; }
		 case '2': { int x = va_arg(v,int);
					 unsigned char b[2];
					 b[0] = STBIW_UCHAR(x);
					 b[1] = STBIW_UCHAR(x>>8);
					 s->func(s->context,b,2);
					 break; }
		 case '4': { stbiw_uint32 x = va_arg(v,int);
					 unsigned char b[4];
					 b[0]=STBIW_UCHAR(x);
					 b[1]=STBIW_UCHAR(x>>8);
					 b[2]=STBIW_UCHAR(x>>16);
					 b[3]=STBIW_UCHAR(x>>24);
					 s->func(s->context,b,4);
					 break; }
		 default:
			STBIW_ASSERT(0);
			return;
	  }
   }
}

static void stbiw__writef(stbi__write_context *s, const char *fmt, ...)
{
   va_list v;
   va_start(v, fmt);
   stbiw__writefv(s, fmt, v);
   va_end(v);
}

static void stbiw__write3(stbi__write_context *s, unsigned char a, unsigned char b, unsigned char c)
{
   unsigned char arr[3];
   arr[0] = a, arr[1] = b, arr[2] = c;
   s->func(s->context, arr, 3);
}

static void stbiw__write_pixel(stbi__write_context *s, int rgb_dir, int comp, int write_alpha, int expand_mono, unsigned char *d)
{
   unsigned char bg[3] = { 255, 0, 255}, px[3];
   int k;

   if (write_alpha < 0)
	  s->func(s->context, &d[comp - 1], 1);

   switch (comp) {
	  case 2: // 2 pixels = mono + alpha, alpha is written separately, so same as 1-channel case
	  case 1:
		 if (expand_mono)
			stbiw__write3(s, d[0], d[0], d[0]); // monochrome bmp
		 else
			s->func(s->context, d, 1);  // monochrome TGA
		 break;
	  case 4:
		 if (!write_alpha) {
			// composite against pink background
			for (k = 0; k < 3; ++k)
			   px[k] = bg[k] + ((d[k] - bg[k]) * d[3]) / 255;
			stbiw__write3(s, px[1 - rgb_dir], px[1], px[1 + rgb_dir]);
			break;
		 }
		 /* FALLTHROUGH */
	  case 3:
		 stbiw__write3(s, d[1 - rgb_dir], d[1], d[1 + rgb_dir]);
		 break;
   }
   if (write_alpha > 0)
	  s->func(s->context, &d[comp - 1], 1);
}

static void stbiw__write_pixels(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, void *data, int write_alpha, int scanline_pad, int expand_mono)
{
   stbiw_uint32 zero = 0;
   int i,j, j_end;

   if (y <= 0)
	  return;

   if (vdir < 0)
	  j_end = -1, j = y-1;
   else
	  j_end =  y, j = 0;

   for (; j != j_end; j += vdir) {
	  for (i=0; i < x; ++i) {
		 unsigned char *d = (unsigned char *) data + (j*x+i)*comp;
		 stbiw__write_pixel(s, rgb_dir, comp, write_alpha, expand_mono, d);
	  }
	  s->func(s->context, &zero, scanline_pad);
   }
}

static int stbiw__outfile(stbi__write_context *s, int rgb_dir, int vdir, int x, int y, int comp, int expand_mono, void *data, int alpha, int pad, const char *fmt, ...)
{
   if (y < 0 || x < 0) {
	  return 0;
   } else {
	  va_list v;
	  va_start(v, fmt);
	  stbiw__writefv(s, fmt, v);
	  va_end(v);
	  stbiw__write_pixels(s,rgb_dir,vdir,x,y,comp,data,alpha,pad, expand_mono);
	  return 1;
   }
}

static int stbi_write_bmp_core(stbi__write_context *s, int x, int y, int comp, const void *data)
{
   int pad = (-x*3) & 3;
   return stbiw__outfile(s,-1,-1,x,y,comp,1,(void *) data,0,pad,
		   "11 4 22 4" "4 44 22 444444",
		   'B', 'M', 14+40+(x*3+pad)*y, 0,0, 14+40,  // file header
			40, x,y, 1,24, 0,0,0,0,0,0);             // bitmap header
}

STBIWDEF int stbi_write_bmp_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_bmp_core(&s, x, y, comp, data);
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_bmp(char const *filename, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   if (stbi__start_write_file(&s,filename)) {
	  int r = stbi_write_bmp_core(&s, x, y, comp, data);
	  stbi__end_write_file(&s);
	  return r;
   } else
	  return 0;
}
#endif //!STBI_WRITE_NO_STDIO

static int stbi_write_tga_core(stbi__write_context *s, int x, int y, int comp, void *data)
{
   int has_alpha = (comp == 2 || comp == 4);
   int colorbytes = has_alpha ? comp-1 : comp;
   int format = colorbytes < 2 ? 3 : 2; // 3 color channels (RGB/RGBA) = 2, 1 color channel (Y/YA) = 3

   if (y < 0 || x < 0)
	  return 0;

   if (!stbi_write_tga_with_rle) {
	  return stbiw__outfile(s, -1, -1, x, y, comp, 0, (void *) data, has_alpha, 0,
		 "111 221 2222 11", 0, 0, format, 0, 0, 0, 0, 0, x, y, (colorbytes + has_alpha) * 8, has_alpha * 8);
   } else {
	  int i,j,k;

	  stbiw__writef(s, "111 221 2222 11", 0,0,format+8, 0,0,0, 0,0,x,y, (colorbytes + has_alpha) * 8, has_alpha * 8);

	  for (j = y - 1; j >= 0; --j) {
		  unsigned char *row = (unsigned char *) data + j * x * comp;
		 int len;

		 for (i = 0; i < x; i += len) {
			unsigned char *begin = row + i * comp;
			int diff = 1;
			len = 1;

			if (i < x - 1) {
			   ++len;
			   diff = memcmp(begin, row + (i + 1) * comp, comp);
			   if (diff) {
				  const unsigned char *prev = begin;
				  for (k = i + 2; k < x && len < 128; ++k) {
					 if (memcmp(prev, row + k * comp, comp)) {
						prev += comp;
						++len;
					 } else {
						--len;
						break;
					 }
				  }
			   } else {
				  for (k = i + 2; k < x && len < 128; ++k) {
					 if (!memcmp(begin, row + k * comp, comp)) {
						++len;
					 } else {
						break;
					 }
				  }
			   }
			}

			if (diff) {
			   unsigned char header = STBIW_UCHAR(len - 1);
			   s->func(s->context, &header, 1);
			   for (k = 0; k < len; ++k) {
				  stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin + k * comp);
			   }
			} else {
			   unsigned char header = STBIW_UCHAR(len - 129);
			   s->func(s->context, &header, 1);
			   stbiw__write_pixel(s, -1, comp, has_alpha, 0, begin);
			}
		 }
	  }
   }
   return 1;
}

int stbi_write_tga_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_tga_core(&s, x, y, comp, (void *) data);
}

#ifndef STBI_WRITE_NO_STDIO
int stbi_write_tga(char const *filename, int x, int y, int comp, const void *data)
{
   stbi__write_context s;
   if (stbi__start_write_file(&s,filename)) {
	  int r = stbi_write_tga_core(&s, x, y, comp, (void *) data);
	  stbi__end_write_file(&s);
	  return r;
   } else
	  return 0;
}
#endif

// *************************************************************************************************
// Radiance RGBE HDR writer
// by Baldur Karlsson

#define stbiw__max(a, b)  ((a) > (b) ? (a) : (b))

void stbiw__linear_to_rgbe(unsigned char *rgbe, float *linear)
{
   int exponent;
   float maxcomp = stbiw__max(linear[0], stbiw__max(linear[1], linear[2]));

   if (maxcomp < 1e-32f) {
	  rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;
   } else {
	  float normalize = (float) frexp(maxcomp, &exponent) * 256.0f/maxcomp;

	  rgbe[0] = (unsigned char)(linear[0] * normalize);
	  rgbe[1] = (unsigned char)(linear[1] * normalize);
	  rgbe[2] = (unsigned char)(linear[2] * normalize);
	  rgbe[3] = (unsigned char)(exponent + 128);
   }
}

void stbiw__write_run_data(stbi__write_context *s, int length, unsigned char databyte)
{
   unsigned char lengthbyte = STBIW_UCHAR(length+128);
   STBIW_ASSERT(length+128 <= 255);
   s->func(s->context, &lengthbyte, 1);
   s->func(s->context, &databyte, 1);
}

void stbiw__write_dump_data(stbi__write_context *s, int length, unsigned char *data)
{
   unsigned char lengthbyte = STBIW_UCHAR(length);
   STBIW_ASSERT(length <= 128); // inconsistent with spec but consistent with official code
   s->func(s->context, &lengthbyte, 1);
   s->func(s->context, data, length);
}

void stbiw__write_hdr_scanline(stbi__write_context *s, int width, int ncomp, unsigned char *scratch, float *scanline)
{
   unsigned char scanlineheader[4] = { 2, 2, 0, 0 };
   unsigned char rgbe[4];
   float linear[3];
   int x;

   scanlineheader[2] = (width&0xff00)>>8;
   scanlineheader[3] = (width&0x00ff);

   /* skip RLE for images too small or large */
   if (width < 8 || width >= 32768) {
	  for (x=0; x < width; x++) {
		 switch (ncomp) {
			case 4: /* fallthrough */
			case 3: linear[2] = scanline[x*ncomp + 2];
					linear[1] = scanline[x*ncomp + 1];
					linear[0] = scanline[x*ncomp + 0];
					break;
			default:
					linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
					break;
		 }
		 stbiw__linear_to_rgbe(rgbe, linear);
		 s->func(s->context, rgbe, 4);
	  }
   } else {
	  int c,r;
	  /* encode into scratch buffer */
	  for (x=0; x < width; x++) {
		 switch(ncomp) {
			case 4: /* fallthrough */
			case 3: linear[2] = scanline[x*ncomp + 2];
					linear[1] = scanline[x*ncomp + 1];
					linear[0] = scanline[x*ncomp + 0];
					break;
			default:
					linear[0] = linear[1] = linear[2] = scanline[x*ncomp + 0];
					break;
		 }
		 stbiw__linear_to_rgbe(rgbe, linear);
		 scratch[x + width*0] = rgbe[0];
		 scratch[x + width*1] = rgbe[1];
		 scratch[x + width*2] = rgbe[2];
		 scratch[x + width*3] = rgbe[3];
	  }

	  s->func(s->context, scanlineheader, 4);

	  /* RLE each component separately */
	  for (c=0; c < 4; c++) {
		 unsigned char *comp = &scratch[width*c];

		 x = 0;
		 while (x < width) {
			// find first run
			r = x;
			while (r+2 < width) {
			   if (comp[r] == comp[r+1] && comp[r] == comp[r+2])
				  break;
			   ++r;
			}
			if (r+2 >= width)
			   r = width;
			// dump up to first run
			while (x < r) {
			   int len = r-x;
			   if (len > 128) len = 128;
			   stbiw__write_dump_data(s, len, &comp[x]);
			   x += len;
			}
			// if there's a run, output it
			if (r+2 < width) { // same test as what we break out of in search loop, so only true if we break'd
			   // find next byte after run
			   while (r < width && comp[r] == comp[x])
				  ++r;
			   // output run up to r
			   while (x < r) {
				  int len = r-x;
				  if (len > 127) len = 127;
				  stbiw__write_run_data(s, len, comp[x]);
				  x += len;
			   }
			}
		 }
	  }
   }
}

static int stbi_write_hdr_core(stbi__write_context *s, int x, int y, int comp, float *data)
{
   if (y <= 0 || x <= 0 || data == NULL)
	  return 0;
   else {
	  // Each component is stored separately. Allocate scratch space for full output scanline.
	  unsigned char *scratch = (unsigned char *) STBIW_MALLOC(x*4);
	  int i, len;
	  char buffer[128];
	  char header[] = "#?RADIANCE\n# Written by stb_image_write.h\nFORMAT=32-bit_rle_rgbe\n";
	  s->func(s->context, header, sizeof(header)-1);

	  len = sprintf(buffer, "EXPOSURE=          1.0000000000000\n\n-Y %d +X %d\n", y, x);
	  s->func(s->context, buffer, len);

	  for(i=0; i < y; i++)
		 stbiw__write_hdr_scanline(s, x, comp, scratch, data + comp*i*x);
	  STBIW_FREE(scratch);
	  return 1;
   }
}

int stbi_write_hdr_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const float *data)
{
   stbi__write_context s;
   stbi__start_write_callbacks(&s, func, context);
   return stbi_write_hdr_core(&s, x, y, comp, (float *) data);
}

#ifndef STBI_WRITE_NO_STDIO
int stbi_write_hdr(char const *filename, int x, int y, int comp, const float *data)
{
   stbi__write_context s;
   if (stbi__start_write_file(&s,filename)) {
	  int r = stbi_write_hdr_core(&s, x, y, comp, (float *) data);
	  stbi__end_write_file(&s);
	  return r;
   } else
	  return 0;
}
#endif // STBI_WRITE_NO_STDIO

//////////////////////////////////////////////////////////////////////////////
//
// PNG writer
//

// stretchy buffer; stbiw__sbpush() == vector<>::push_back() -- stbiw__sbcount() == vector<>::size()
#define stbiw__sbraw(a) ((int *) (a) - 2)
#define stbiw__sbm(a)   stbiw__sbraw(a)[0]
#define stbiw__sbn(a)   stbiw__sbraw(a)[1]

#define stbiw__sbneedgrow(a,n)  ((a)==0 || stbiw__sbn(a)+n >= stbiw__sbm(a))
#define stbiw__sbmaybegrow(a,n) (stbiw__sbneedgrow(a,(n)) ? stbiw__sbgrow(a,n) : 0)
#define stbiw__sbgrow(a,n)  stbiw__sbgrowf((void **) &(a), (n), sizeof(*(a)))

#define stbiw__sbpush(a, v)      (stbiw__sbmaybegrow(a,1), (a)[stbiw__sbn(a)++] = (v))
#define stbiw__sbcount(a)        ((a) ? stbiw__sbn(a) : 0)
#define stbiw__sbfree(a)         ((a) ? STBIW_FREE(stbiw__sbraw(a)),0 : 0)

static void *stbiw__sbgrowf(void **arr, int increment, int itemsize)
{
   int m = *arr ? 2*stbiw__sbm(*arr)+increment : increment+1;
   void *p = STBIW_REALLOC_SIZED(*arr ? stbiw__sbraw(*arr) : 0, *arr ? (stbiw__sbm(*arr)*itemsize + sizeof(int)*2) : 0, itemsize * m + sizeof(int)*2);
   STBIW_ASSERT(p);
   if (p) {
	  if (!*arr) ((int *) p)[1] = 0;
	  *arr = (void *) ((int *) p + 2);
	  stbiw__sbm(*arr) = m;
   }
   return *arr;
}

static unsigned char *stbiw__zlib_flushf(unsigned char *data, unsigned int *bitbuffer, int *bitcount)
{
   while (*bitcount >= 8) {
	  stbiw__sbpush(data, STBIW_UCHAR(*bitbuffer));
	  *bitbuffer >>= 8;
	  *bitcount -= 8;
   }
   return data;
}

static int stbiw__zlib_bitrev(int code, int codebits)
{
   int res=0;
   while (codebits--) {
	  res = (res << 1) | (code & 1);
	  code >>= 1;
   }
   return res;
}

static unsigned int stbiw__zlib_countm(unsigned char *a, unsigned char *b, int limit)
{
   int i;
   for (i=0; i < limit && i < 258; ++i)
	  if (a[i] != b[i]) break;
   return i;
}

static unsigned int stbiw__zhash(unsigned char *data)
{
   stbiw_uint32 hash = data[0] + (data[1] << 8) + (data[2] << 16);
   hash ^= hash << 3;
   hash += hash >> 5;
   hash ^= hash << 4;
   hash += hash >> 17;
   hash ^= hash << 25;
   hash += hash >> 6;
   return hash;
}

#define stbiw__zlib_flush() (out = stbiw__zlib_flushf(out, &bitbuf, &bitcount))
#define stbiw__zlib_add(code,codebits) \
	  (bitbuf |= (code) << bitcount, bitcount += (codebits), stbiw__zlib_flush())
#define stbiw__zlib_huffa(b,c)  stbiw__zlib_add(stbiw__zlib_bitrev(b,c),c)
// default huffman tables
#define stbiw__zlib_huff1(n)  stbiw__zlib_huffa(0x30 + (n), 8)
#define stbiw__zlib_huff2(n)  stbiw__zlib_huffa(0x190 + (n)-144, 9)
#define stbiw__zlib_huff3(n)  stbiw__zlib_huffa(0 + (n)-256,7)
#define stbiw__zlib_huff4(n)  stbiw__zlib_huffa(0xc0 + (n)-280,8)
#define stbiw__zlib_huff(n)  ((n) <= 143 ? stbiw__zlib_huff1(n) : (n) <= 255 ? stbiw__zlib_huff2(n) : (n) <= 279 ? stbiw__zlib_huff3(n) : stbiw__zlib_huff4(n))
#define stbiw__zlib_huffb(n) ((n) <= 143 ? stbiw__zlib_huff1(n) : stbiw__zlib_huff2(n))

#define stbiw__ZHASH   16384

unsigned char * stbi_zlib_compress(unsigned char *data, int data_len, int *out_len, int quality)
{
   static unsigned short lengthc[] = { 3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258, 259 };
   static unsigned char  lengtheb[]= { 0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0 };
   static unsigned short distc[]   = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 32768 };
   static unsigned char  disteb[]  = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13 };
   unsigned int bitbuf=0;
   int i,j, bitcount=0;
   unsigned char *out = NULL;
   unsigned char ***hash_table = (unsigned char***) STBIW_MALLOC(stbiw__ZHASH * sizeof(char**));
   if (quality < 5) quality = 5;

   stbiw__sbpush(out, 0x78);   // DEFLATE 32K window
   stbiw__sbpush(out, 0x5e);   // FLEVEL = 1
   stbiw__zlib_add(1,1);  // BFINAL = 1
   stbiw__zlib_add(1,2);  // BTYPE = 1 -- fixed huffman

   for (i=0; i < stbiw__ZHASH; ++i)
	  hash_table[i] = NULL;

   i=0;
   while (i < data_len-3) {
	  // hash next 3 bytes of data to be compressed
	  int h = stbiw__zhash(data+i)&(stbiw__ZHASH-1), best=3;
	  unsigned char *bestloc = 0;
	  unsigned char **hlist = hash_table[h];
	  int n = stbiw__sbcount(hlist);
	  for (j=0; j < n; ++j) {
		 if (hlist[j]-data > i-32768) { // if entry lies within window
			int d = stbiw__zlib_countm(hlist[j], data+i, data_len-i);
			if (d >= best) best=d,bestloc=hlist[j];
		 }
	  }
	  // when hash table entry is too long, delete half the entries
	  if (hash_table[h] && stbiw__sbn(hash_table[h]) == 2*quality) {
		 STBIW_MEMMOVE(hash_table[h], hash_table[h]+quality, sizeof(hash_table[h][0])*quality);
		 stbiw__sbn(hash_table[h]) = quality;
	  }
	  stbiw__sbpush(hash_table[h],data+i);

	  if (bestloc) {
		 // "lazy matching" - check match at *next* byte, and if it's better, do cur byte as literal
		 h = stbiw__zhash(data+i+1)&(stbiw__ZHASH-1);
		 hlist = hash_table[h];
		 n = stbiw__sbcount(hlist);
		 for (j=0; j < n; ++j) {
			if (hlist[j]-data > i-32767) {
			   int e = stbiw__zlib_countm(hlist[j], data+i+1, data_len-i-1);
			   if (e > best) { // if next match is better, bail on current match
				  bestloc = NULL;
				  break;
			   }
			}
		 }
	  }

	  if (bestloc) {
		 int d = (int) (data+i - bestloc); // distance back
		 STBIW_ASSERT(d <= 32767 && best <= 258);
		 for (j=0; best > lengthc[j+1]-1; ++j);
		 stbiw__zlib_huff(j+257);
		 if (lengtheb[j]) stbiw__zlib_add(best - lengthc[j], lengtheb[j]);
		 for (j=0; d > distc[j+1]-1; ++j);
		 stbiw__zlib_add(stbiw__zlib_bitrev(j,5),5);
		 if (disteb[j]) stbiw__zlib_add(d - distc[j], disteb[j]);
		 i += best;
	  } else {
		 stbiw__zlib_huffb(data[i]);
		 ++i;
	  }
   }
   // write out final bytes
   for (;i < data_len; ++i)
	  stbiw__zlib_huffb(data[i]);
   stbiw__zlib_huff(256); // end of block
   // pad with 0 bits to byte boundary
   while (bitcount)
	  stbiw__zlib_add(0,1);

   for (i=0; i < stbiw__ZHASH; ++i)
	  (void) stbiw__sbfree(hash_table[i]);
   STBIW_FREE(hash_table);

   {
	  // compute adler32 on input
	  unsigned int s1=1, s2=0;
	  int blocklen = (int) (data_len % 5552);
	  j=0;
	  while (j < data_len) {
		 for (i=0; i < blocklen; ++i) s1 += data[j+i], s2 += s1;
		 s1 %= 65521, s2 %= 65521;
		 j += blocklen;
		 blocklen = 5552;
	  }
	  stbiw__sbpush(out, STBIW_UCHAR(s2 >> 8));
	  stbiw__sbpush(out, STBIW_UCHAR(s2));
	  stbiw__sbpush(out, STBIW_UCHAR(s1 >> 8));
	  stbiw__sbpush(out, STBIW_UCHAR(s1));
   }
   *out_len = stbiw__sbn(out);
   // make returned pointer freeable
   STBIW_MEMMOVE(stbiw__sbraw(out), out, *out_len);
   return (unsigned char *) stbiw__sbraw(out);
}

static unsigned int stbiw__crc32(unsigned char *buffer, int len)
{
   static unsigned int crc_table[256] =
   {
	  0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
	  0x0eDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
	  0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
	  0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
	  0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
	  0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	  0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
	  0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
	  0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
	  0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	  0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
	  0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	  0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
	  0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
	  0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
	  0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
	  0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
	  0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	  0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
	  0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	  0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
	  0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
	  0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
	  0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	  0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
	  0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
	  0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
	  0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
	  0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
	  0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	  0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
	  0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
   };

   unsigned int crc = ~0u;
   int i;
   for (i=0; i < len; ++i)
	  crc = (crc >> 8) ^ crc_table[buffer[i] ^ (crc & 0xff)];
   return ~crc;
}

#define stbiw__wpng4(o,a,b,c,d) ((o)[0]=STBIW_UCHAR(a),(o)[1]=STBIW_UCHAR(b),(o)[2]=STBIW_UCHAR(c),(o)[3]=STBIW_UCHAR(d),(o)+=4)
#define stbiw__wp32(data,v) stbiw__wpng4(data, (v)>>24,(v)>>16,(v)>>8,(v));
#define stbiw__wptag(data,s) stbiw__wpng4(data, s[0],s[1],s[2],s[3])

static void stbiw__wpcrc(unsigned char **data, int len)
{
   unsigned int crc = stbiw__crc32(*data - len - 4, len+4);
   stbiw__wp32(*data, crc);
}

static unsigned char stbiw__paeth(int a, int b, int c)
{
   int p = a + b - c, pa = abs(p-a), pb = abs(p-b), pc = abs(p-c);
   if (pa <= pb && pa <= pc) return STBIW_UCHAR(a);
   if (pb <= pc) return STBIW_UCHAR(b);
   return STBIW_UCHAR(c);
}

// @OPTIMIZE: provide an option that always forces left-predict or paeth predict
unsigned char *stbi_write_png_to_mem(unsigned char *pixels, int stride_bytes, int x, int y, int n, int *out_len)
{
   int ctype[5] = { -1, 0, 4, 2, 6 };
   unsigned char sig[8] = { 137,80,78,71,13,10,26,10 };
   unsigned char *out,*o, *filt, *zlib;
   signed char *line_buffer;
   int i,j,k,p,zlen;

   if (stride_bytes == 0)
	  stride_bytes = x * n;

   filt = (unsigned char *) STBIW_MALLOC((x*n+1) * y); if (!filt) return 0;
   line_buffer = (signed char *) STBIW_MALLOC(x * n); if (!line_buffer) { STBIW_FREE(filt); return 0; }
   for (j=0; j < y; ++j) {
	  static int mapping[] = { 0,1,2,3,4 };
	  static int firstmap[] = { 0,1,0,5,6 };
	  int *mymap = (j != 0) ? mapping : firstmap;
	  int best = 0, bestval = 0x7fffffff;
	  for (p=0; p < 2; ++p) {
		 for (k= p?best:0; k < 5; ++k) { // @TODO: clarity: rewrite this to go 0..5, and 'continue' the unwanted ones during 2nd pass
			int type = mymap[k],est=0;
			unsigned char *z = pixels + stride_bytes*j;
			for (i=0; i < n; ++i)
			   switch (type) {
				  case 0: line_buffer[i] = z[i]; break;
				  case 1: line_buffer[i] = z[i]; break;
				  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;
				  case 3: line_buffer[i] = z[i] - (z[i-stride_bytes]>>1); break;
				  case 4: line_buffer[i] = (signed char) (z[i] - stbiw__paeth(0,z[i-stride_bytes],0)); break;
				  case 5: line_buffer[i] = z[i]; break;
				  case 6: line_buffer[i] = z[i]; break;
			   }
			for (i=n; i < x*n; ++i) {
			   switch (type) {
				  case 0: line_buffer[i] = z[i]; break;
				  case 1: line_buffer[i] = z[i] - z[i-n]; break;
				  case 2: line_buffer[i] = z[i] - z[i-stride_bytes]; break;
				  case 3: line_buffer[i] = z[i] - ((z[i-n] + z[i-stride_bytes])>>1); break;
				  case 4: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], z[i-stride_bytes], z[i-stride_bytes-n]); break;
				  case 5: line_buffer[i] = z[i] - (z[i-n]>>1); break;
				  case 6: line_buffer[i] = z[i] - stbiw__paeth(z[i-n], 0,0); break;
			   }
			}
			if (p) break;
			for (i=0; i < x*n; ++i)
			   est += abs((signed char) line_buffer[i]);
			if (est < bestval) { bestval = est; best = k; }
		 }
	  }
	  // when we get here, best contains the filter type, and line_buffer contains the data
	  filt[j*(x*n+1)] = (unsigned char) best;
	  STBIW_MEMMOVE(filt+j*(x*n+1)+1, line_buffer, x*n);
   }
   STBIW_FREE(line_buffer);
   zlib = stbi_zlib_compress(filt, y*( x*n+1), &zlen, 8); // increase 8 to get smaller but use more memory
   STBIW_FREE(filt);
   if (!zlib) return 0;

   // each tag requires 12 bytes of overhead
   out = (unsigned char *) STBIW_MALLOC(8 + 12+13 + 12+zlen + 12);
   if (!out) return 0;
   *out_len = 8 + 12+13 + 12+zlen + 12;

   o=out;
   STBIW_MEMMOVE(o,sig,8); o+= 8;
   stbiw__wp32(o, 13); // header length
   stbiw__wptag(o, "IHDR");
   stbiw__wp32(o, x);
   stbiw__wp32(o, y);
   *o++ = 8;
   *o++ = STBIW_UCHAR(ctype[n]);
   *o++ = 0;
   *o++ = 0;
   *o++ = 0;
   stbiw__wpcrc(&o,13);

   stbiw__wp32(o, zlen);
   stbiw__wptag(o, "IDAT");
   STBIW_MEMMOVE(o, zlib, zlen);
   o += zlen;
   STBIW_FREE(zlib);
   stbiw__wpcrc(&o, zlen);

   stbiw__wp32(o,0);
   stbiw__wptag(o, "IEND");
   stbiw__wpcrc(&o,0);

   STBIW_ASSERT(o == out + *out_len);

   return out;
}

#ifndef STBI_WRITE_NO_STDIO
STBIWDEF int stbi_write_png(char const *filename, int x, int y, int comp, const void *data, int stride_bytes)
{
   FILE *f;
   int len;
   unsigned char *png = stbi_write_png_to_mem((unsigned char *) data, stride_bytes, x, y, comp, &len);
   if (png == NULL) return 0;
   f = fopen(filename, "wb");
   if (!f) { STBIW_FREE(png); return 0; }
   fwrite(png, 1, len, f);
   fclose(f);
   STBIW_FREE(png);
   return 1;
}
#endif

STBIWDEF int stbi_write_png_to_func(stbi_write_func *func, void *context, int x, int y, int comp, const void *data, int stride_bytes)
{
   int len;
   unsigned char *png = stbi_write_png_to_mem((unsigned char *) data, stride_bytes, x, y, comp, &len);
   if (png == NULL) return 0;
   func(context, png, len);
   STBIW_FREE(png);
   return 1;
}

#endif // STB_IMAGE_WRITE_IMPLEMENTATION

/* Revision history
	  1.04 (2017-03-03)
			 monochrome BMP expansion
	  1.03   ???
	  1.02 (2016-04-02)
			 avoid allocating large structures on the stack
	  1.01 (2016-01-16)
			 STBIW_REALLOC_SIZED: support allocators with no realloc support
			 avoid race-condition in crc initialization
			 minor compile issues
	  1.00 (2015-09-14)
			 installable file IO function
	  0.99 (2015-09-13)
			 warning fixes; TGA rle support
	  0.98 (2015-04-08)
			 added STBIW_MALLOC, STBIW_ASSERT etc
	  0.97 (2015-01-18)
			 fixed HDR asserts, rewrote HDR rle logic
	  0.96 (2015-01-17)
			 add HDR output
			 fix monochrome BMP
	  0.95 (2014-08-17)
		       add monochrome TGA output
	  0.94 (2014-05-31)
			 rename private functions to avoid conflicts with stb_image.h
	  0.93 (2014-05-27)
			 warning fixes
	  0.92 (2010-08-01)
			 casts to unsigned char to fix warnings
	  0.91 (2010-07-17)
			 first public release
	  0.90   first internal release
*/

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/


//#define DDS_header DDS_header2


//#line 1 "image_DXT.c"
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/*	set this =1 if you want to use the covarince matrix method...
	which is better than my method of using standard deviations
	overall, except on the infintesimal chance that the power
	method fails for finding the largest eigenvector	*/
#define USE_COV_MAT	1

/********* Function Prototypes *********/
/*
	Takes a 4x4 block of pixels and compresses it into 8 bytes
	in DXT1 format (color only, no alpha).  Speed is valued
	over prettyness, at least for now.
*/
void compress_DDS_color_block(
				int channels,
				const unsigned char *const uncompressed,
				unsigned char compressed[8] );
/*
	Takes a 4x4 block of pixels and compresses the alpha
	component it into 8 bytes for use in DXT5 DDS files.
	Speed is valued over prettyness, at least for now.
*/
void compress_DDS_alpha_block(
				const unsigned char *const uncompressed,
				unsigned char compressed[8] );

/********* Actual Exposed Functions *********/
int
	save_image_as_DDS
	(
		const char *filename,
		int width, int height, int channels,
		const unsigned char *const data
	)
{
	/*	variables	*/
	FILE *fout;
	unsigned char *DDS_data;
	DDS_header header;
	int DDS_size;
	/*	error check	*/
	if( (NULL == filename) ||
		(width < 1) || (height < 1) ||
		(channels < 1) || (channels > 4) ||
		(data == NULL ) )
	{
		return 0;
	}
	/*	Convert the image	*/
	if( (channels & 1) == 1 )
	{
		/*	no alpha, just use DXT1	*/
		DDS_data = convert_image_to_DXT1( data, width, height, channels, &DDS_size );
	} else
	{
		/*	has alpha, so use DXT5	*/
		DDS_data = convert_image_to_DXT5( data, width, height, channels, &DDS_size );
	}
	/*	save it	*/
	memset( &header, 0, sizeof( DDS_header ) );
	header.dwMagic = ('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24);
	header.dwSize = 124;
	header.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE;
	header.dwWidth = width;
	header.dwHeight = height;
	header.dwPitchOrLinearSize = DDS_size;
	header.sPixelFormat.dwSize = 32;
	header.sPixelFormat.dwFlags = DDPF_FOURCC;
	if( (channels & 1) == 1 )
	{
		header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('1' << 24);
	} else
	{
		header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('5' << 24);
	}
	header.sCaps.dwCaps1 = DDSCAPS_TEXTURE;
	/*	write it out	*/
	fout = fopen( filename, "wb");
	fwrite( &header, sizeof( DDS_header ), 1, fout );
	fwrite( DDS_data, 1, DDS_size, fout );
	fclose( fout );
	/*	done	*/
	free( DDS_data );
	return 1;
}

unsigned char* convert_image_to_DXT1(
		const unsigned char *const uncompressed,
		int width, int height, int channels,
		int *out_size )
{
	unsigned char *compressed;
	int i, j, x, y;
	unsigned char ublock[16*3];
	unsigned char cblock[8];
	int index = 0, chan_step = 1;
	int block_count = 0;
	/*	error check	*/
	*out_size = 0;
	if( (width < 1) || (height < 1) ||
		(NULL == uncompressed) ||
		(channels < 1) || (channels > 4) )
	{
		return NULL;
	}
	/*	for channels == 1 or 2, I do not step forward for R,G,B values	*/
	if( channels < 3 )
	{
		chan_step = 0;
	}
	/*	get the RAM for the compressed image
		(8 bytes per 4x4 pixel block)	*/
	*out_size = ((width+3) >> 2) * ((height+3) >> 2) * 8;
	compressed = (unsigned char*)malloc( *out_size );
	/*	go through each block	*/
	for( j = 0; j < height; j += 4 )
	{
		for( i = 0; i < width; i += 4 )
		{
			/*	copy this block into a new one	*/
			int idx = 0;
			int mx = 4, my = 4;
			if( j+4 >= height )
			{
				my = height - j;
			}
			if( i+4 >= width )
			{
				mx = width - i;
			}
			for( y = 0; y < my; ++y )
			{
				for( x = 0; x < mx; ++x )
				{
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step+chan_step];
				}
				for( x = mx; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
				}
			}
			for( y = my; y < 4; ++y )
			{
				for( x = 0; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
				}
			}
			/*	compress the block	*/
			++block_count;
			compress_DDS_color_block( 3, ublock, cblock );
			/*	copy the data from the block into the main block	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
		}
	}
	return compressed;
}

unsigned char* convert_image_to_DXT5(
		const unsigned char *const uncompressed,
		int width, int height, int channels,
		int *out_size )
{
	unsigned char *compressed;
	int i, j, x, y;
	unsigned char ublock[16*4];
	unsigned char cblock[8];
	int index = 0, chan_step = 1;
	int block_count = 0, has_alpha;
	/*	error check	*/
	*out_size = 0;
	if( (width < 1) || (height < 1) ||
		(NULL == uncompressed) ||
		(channels < 1) || ( channels > 4) )
	{
		return NULL;
	}
	/*	for channels == 1 or 2, I do not step forward for R,G,B vales	*/
	if( channels < 3 )
	{
		chan_step = 0;
	}
	/*	# channels = 1 or 3 have no alpha, 2 & 4 do have alpha	*/
	has_alpha = 1 - (channels & 1);
	/*	get the RAM for the compressed image
		(16 bytes per 4x4 pixel block)	*/
	*out_size = ((width+3) >> 2) * ((height+3) >> 2) * 16;
	compressed = (unsigned char*)malloc( *out_size );
	/*	go through each block	*/
	for( j = 0; j < height; j += 4 )
	{
		for( i = 0; i < width; i += 4 )
		{
			/*	local variables, and my block counter	*/
			int idx = 0;
			int mx = 4, my = 4;
			if( j+4 >= height )
			{
				my = height - j;
			}
			if( i+4 >= width )
			{
				mx = width - i;
			}
			for( y = 0; y < my; ++y )
			{
				for( x = 0; x < mx; ++x )
				{
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step];
					ublock[idx++] = uncompressed[(j+y)*width*channels+(i+x)*channels+chan_step+chan_step];
					ublock[idx++] =
						has_alpha * uncompressed[(j+y)*width*channels+(i+x)*channels+channels-1]
						+ (1-has_alpha)*255;
				}
				for( x = mx; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
					ublock[idx++] = ublock[3];
				}
			}
			for( y = my; y < 4; ++y )
			{
				for( x = 0; x < 4; ++x )
				{
					ublock[idx++] = ublock[0];
					ublock[idx++] = ublock[1];
					ublock[idx++] = ublock[2];
					ublock[idx++] = ublock[3];
				}
			}
			/*	now compress the alpha block	*/
			compress_DDS_alpha_block( ublock, cblock );
			/*	copy the data from the compressed alpha block into the main buffer	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
			/*	then compress the color block	*/
			++block_count;
			compress_DDS_color_block( 4, ublock, cblock );
			/*	copy the data from the compressed color block into the main buffer	*/
			for( x = 0; x < 8; ++x )
			{
				compressed[index++] = cblock[x];
			}
		}
	}
	return compressed;
}

/********* Helper Functions *********/
int convert_bit_range( int c, int from_bits, int to_bits )
{
	int b = (1 << (from_bits - 1)) + c * ((1 << to_bits) - 1);
	return (b + (b >> from_bits)) >> from_bits;
}

int rgb_to_565( int r, int g, int b )
{
	return
		(convert_bit_range( r, 8, 5 ) << 11) |
		(convert_bit_range( g, 8, 6 ) << 05) |
		(convert_bit_range( b, 8, 5 ) << 00);
}

void rgb_888_from_565( unsigned int c, int *r, int *g, int *b )
{
	*r = convert_bit_range( (c >> 11) & 31, 5, 8 );
	*g = convert_bit_range( (c >> 05) & 63, 6, 8 );
	*b = convert_bit_range( (c >> 00) & 31, 5, 8 );
}

void compute_color_line_STDEV(
		const unsigned char *const uncompressed,
		int channels,
		float point[3], float direction[3] )
{
	const float inv_16 = 1.0f / 16.0f;
	int i;
	float sum_r = 0.0f, sum_g = 0.0f, sum_b = 0.0f;
	float sum_rr = 0.0f, sum_gg = 0.0f, sum_bb = 0.0f;
	float sum_rg = 0.0f, sum_rb = 0.0f, sum_gb = 0.0f;
	/*	calculate all data needed for the covariance matrix
		( to compare with _rygdxt code)	*/
	for( i = 0; i < 16*channels; i += channels )
	{
		sum_r += uncompressed[i+0];
		sum_rr += uncompressed[i+0] * uncompressed[i+0];
		sum_g += uncompressed[i+1];
		sum_gg += uncompressed[i+1] * uncompressed[i+1];
		sum_b += uncompressed[i+2];
		sum_bb += uncompressed[i+2] * uncompressed[i+2];
		sum_rg += uncompressed[i+0] * uncompressed[i+1];
		sum_rb += uncompressed[i+0] * uncompressed[i+2];
		sum_gb += uncompressed[i+1] * uncompressed[i+2];
	}
	/*	convert the sums to averages	*/
	sum_r *= inv_16;
	sum_g *= inv_16;
	sum_b *= inv_16;
	/*	and convert the squares to the squares of the value - avg_value	*/
	sum_rr -= 16.0f * sum_r * sum_r;
	sum_gg -= 16.0f * sum_g * sum_g;
	sum_bb -= 16.0f * sum_b * sum_b;
	sum_rg -= 16.0f * sum_r * sum_g;
	sum_rb -= 16.0f * sum_r * sum_b;
	sum_gb -= 16.0f * sum_g * sum_b;
	/*	the point on the color line is the average	*/
	point[0] = sum_r;
	point[1] = sum_g;
	point[2] = sum_b;
	#if USE_COV_MAT
	/*
		The following idea was from ryg.
		(https://mollyrocket.com/forums/viewtopic.php?t=392)
		The method worked great (less RMSE than mine) most of
		the time, but had some issues handling some simple
		boundary cases, like full green next to full red,
		which would generate a covariance matrix like this:

		| 1  -1  0 |
		| -1  1  0 |
		| 0   0  0 |

		For a given starting vector, the power method can
		generate all zeros!  So no starting with {1,1,1}
		as I was doing!  This kind of error is still a
		slight posibillity, but will be very rare.
	*/
	/*	use the covariance matrix directly
		(1st iteration, don't use all 1.0 values!)	*/
	sum_r = 1.0f;
	sum_g = 2.718281828f;
	sum_b = 3.141592654f;
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	/*	2nd iteration, use results from the 1st guy	*/
	sum_r = direction[0];
	sum_g = direction[1];
	sum_b = direction[2];
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	/*	3rd iteration, use results from the 2nd guy	*/
	sum_r = direction[0];
	sum_g = direction[1];
	sum_b = direction[2];
	direction[0] = sum_r*sum_rr + sum_g*sum_rg + sum_b*sum_rb;
	direction[1] = sum_r*sum_rg + sum_g*sum_gg + sum_b*sum_gb;
	direction[2] = sum_r*sum_rb + sum_g*sum_gb + sum_b*sum_bb;
	#else
	/*	use my standard deviation method
		(very robust, a tiny bit slower and less accurate)	*/
	direction[0] = sqrt( sum_rr );
	direction[1] = sqrt( sum_gg );
	direction[2] = sqrt( sum_bb );
	/*	which has a greater component	*/
	if( sum_gg > sum_rr )
	{
		/*	green has greater component, so base the other signs off of green	*/
		if( sum_rg < 0.0f )
		{
			direction[0] = -direction[0];
		}
		if( sum_gb < 0.0f )
		{
			direction[2] = -direction[2];
		}
	} else
	{
		/*	red has a greater component	*/
		if( sum_rg < 0.0f )
		{
			direction[1] = -direction[1];
		}
		if( sum_rb < 0.0f )
		{
			direction[2] = -direction[2];
		}
	}
	#endif
}

void LSE_master_colors_max_min(
		int *cmax, int *cmin,
		int channels,
		const unsigned char *const uncompressed )
{
	int i, j;
	/*	the master colors	*/
	int c0[3], c1[3];
	/*	used for fitting the line	*/
	float sum_x[] = { 0.0f, 0.0f, 0.0f };
	float sum_x2[] = { 0.0f, 0.0f, 0.0f };
	float dot_max = 1.0f, dot_min = -1.0f;
	float vec_len2 = 0.0f;
	float dot;
	/*	error check	*/
	if( (channels < 3) || (channels > 4) )
	{
		return;
	}
	compute_color_line_STDEV( uncompressed, channels, sum_x, sum_x2 );
	vec_len2 = 1.0f / ( 0.00001f +
			sum_x2[0]*sum_x2[0] + sum_x2[1]*sum_x2[1] + sum_x2[2]*sum_x2[2] );
	/*	finding the max and min vector values	*/
	dot_max =
			(
				sum_x2[0] * uncompressed[0] +
				sum_x2[1] * uncompressed[1] +
				sum_x2[2] * uncompressed[2]
			);
	dot_min = dot_max;
	for( i = 1; i < 16; ++i )
	{
		dot =
			(
				sum_x2[0] * uncompressed[i*channels+0] +
				sum_x2[1] * uncompressed[i*channels+1] +
				sum_x2[2] * uncompressed[i*channels+2]
			);
		if( dot < dot_min )
		{
			dot_min = dot;
		} else if( dot > dot_max )
		{
			dot_max = dot;
		}
	}
	/*	and the offset (from the average location)	*/
	dot = sum_x2[0]*sum_x[0] + sum_x2[1]*sum_x[1] + sum_x2[2]*sum_x[2];
	dot_min -= dot;
	dot_max -= dot;
	/*	post multiply by the scaling factor	*/
	dot_min *= vec_len2;
	dot_max *= vec_len2;
	/*	OK, build the master colors	*/
	for( i = 0; i < 3; ++i )
	{
		/*	color 0	*/
		c0[i] = (int)(0.5f + sum_x[i] + dot_max * sum_x2[i]);
		if( c0[i] < 0 )
		{
			c0[i] = 0;
		} else if( c0[i] > 255 )
		{
			c0[i] = 255;
		}
		/*	color 1	*/
		c1[i] = (int)(0.5f + sum_x[i] + dot_min * sum_x2[i]);
		if( c1[i] < 0 )
		{
			c1[i] = 0;
		} else if( c1[i] > 255 )
		{
			c1[i] = 255;
		}
	}
	/*	down_sample (with rounding?)	*/
	i = rgb_to_565( c0[0], c0[1], c0[2] );
	j = rgb_to_565( c1[0], c1[1], c1[2] );
	if( i > j )
	{
		*cmax = i;
		*cmin = j;
	} else
	{
		*cmax = j;
		*cmin = i;
	}
}

void
	compress_DDS_color_block
	(
		int channels,
		const unsigned char *const uncompressed,
		unsigned char compressed[8]
	)
{
	/*	variables	*/
	int i;
	int next_bit;
	int enc_c0, enc_c1;
	int c0[4], c1[4];
	float color_line[] = { 0.0f, 0.0f, 0.0f, 0.0f };
	float vec_len2 = 0.0f, dot_offset = 0.0f;
	/*	stupid order	*/
	int swizzle4[] = { 0, 2, 3, 1 };
	/*	get the master colors	*/
	LSE_master_colors_max_min( &enc_c0, &enc_c1, channels, uncompressed );
	/*	store the 565 color 0 and color 1	*/
	compressed[0] = (enc_c0 >> 0) & 255;
	compressed[1] = (enc_c0 >> 8) & 255;
	compressed[2] = (enc_c1 >> 0) & 255;
	compressed[3] = (enc_c1 >> 8) & 255;
	/*	zero out the compressed data	*/
	compressed[4] = 0;
	compressed[5] = 0;
	compressed[6] = 0;
	compressed[7] = 0;
	/*	reconstitute the master color vectors	*/
	rgb_888_from_565( enc_c0, &c0[0], &c0[1], &c0[2] );
	rgb_888_from_565( enc_c1, &c1[0], &c1[1], &c1[2] );
	/*	the new vector	*/
	vec_len2 = 0.0f;
	for( i = 0; i < 3; ++i )
	{
		color_line[i] = (float)(c1[i] - c0[i]);
		vec_len2 += color_line[i] * color_line[i];
	}
	if( vec_len2 > 0.0f )
	{
		vec_len2 = 1.0f / vec_len2;
	}
	/*	pre-proform the scaling	*/
	color_line[0] *= vec_len2;
	color_line[1] *= vec_len2;
	color_line[2] *= vec_len2;
	/*	compute the offset (constant) portion of the dot product	*/
	dot_offset = color_line[0]*c0[0] + color_line[1]*c0[1] + color_line[2]*c0[2];
	/*	store the rest of the bits	*/
	next_bit = 8*4;
	for( i = 0; i < 16; ++i )
	{
		/*	find the dot product of this color, to place it on the line
			(should be [-1,1])	*/
		int next_value = 0;
		float dot_product =
			color_line[0] * uncompressed[i*channels+0] +
			color_line[1] * uncompressed[i*channels+1] +
			color_line[2] * uncompressed[i*channels+2] -
			dot_offset;
		/*	map to [0,3]	*/
		next_value = (int)( dot_product * 3.0f + 0.5f );
		if( next_value > 3 )
		{
			next_value = 3;
		} else if( next_value < 0 )
		{
			next_value = 0;
		}
		/*	OK, store this value	*/
		compressed[next_bit >> 3] |= swizzle4[ next_value ] << (next_bit & 7);
		next_bit += 2;
	}
	/*	done compressing to DXT1	*/
}

void
	compress_DDS_alpha_block
	(
		const unsigned char *const uncompressed,
		unsigned char compressed[8]
	)
{
	/*	variables	*/
	int i;
	int next_bit;
	int a0, a1;
	float scale_me;
	/*	stupid order	*/
	int swizzle8[] = { 1, 7, 6, 5, 4, 3, 2, 0 };
	/*	get the alpha limits (a0 > a1)	*/
	a0 = a1 = uncompressed[3];
	for( i = 4+3; i < 16*4; i += 4 )
	{
		if( uncompressed[i] > a0 )
		{
			a0 = uncompressed[i];
		} else if( uncompressed[i] < a1 )
		{
			a1 = uncompressed[i];
		}
	}
	/*	store those limits, and zero the rest of the compressed dataset	*/
	compressed[0] = a0;
	compressed[1] = a1;
	/*	zero out the compressed data	*/
	compressed[2] = 0;
	compressed[3] = 0;
	compressed[4] = 0;
	compressed[5] = 0;
	compressed[6] = 0;
	compressed[7] = 0;
	/*	store the all of the alpha values	*/
	next_bit = 8*2;
	scale_me = 7.9999f / (a0 - a1);
	for( i = 3; i < 16*4; i += 4 )
	{
		/*	convert this alpha value to a 3 bit number	*/
		int svalue;
		int value = (int)((uncompressed[i] - a1) * scale_me);
		svalue = swizzle8[ value&7 ];
		/*	OK, store this value, start with the 1st byte	*/
		compressed[next_bit >> 3] |= svalue << (next_bit & 7);
		if( (next_bit & 7) > 5 )
		{
			/*	spans 2 bytes, fill in the start of the 2nd byte	*/
			compressed[1 + (next_bit >> 3)] |= svalue >> (8 - (next_bit & 7) );
		}
		next_bit += 3;
	}
	/*	done compressing to DXT1	*/
}

#define clamp clamp2

//#line 1 "etc1_utils.c"
// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


//#line 1 "etc1_utils.h"
// Copyright 2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef __etc1_h__
#define __etc1_h__

#define ETC1_ENCODED_BLOCK_SIZE 8
#define ETC1_DECODED_BLOCK_SIZE 48

#ifndef ETC1_RGB8_OES
#define ETC1_RGB8_OES 0x8D64
#endif

typedef unsigned char etc1_byte;
typedef int etc1_bool;
typedef unsigned int etc1_uint32;

#ifdef __cplusplus
extern "C" {
#endif

// Encode a block of pixels.
//
// pIn is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).
//
// validPixelMask is a 16-bit mask where bit (1 << (x + y * 4)) indicates whether
// the corresponding (x,y) pixel is valid. Invalid pixel color values are ignored when compressing.
//
// pOut is an ETC1 compressed version of the data.

void etc1_encode_block(const etc1_byte* pIn, etc1_uint32 validPixelMask, etc1_byte* pOut);

// Decode a block of pixels.
//
// pIn is an ETC1 compressed version of the data.
//
// pOut is a pointer to a ETC_DECODED_BLOCK_SIZE array of bytes that represent a
// 4 x 4 square of 3-byte pixels in form R, G, B. Byte (3 * (x + 4 * y) is the R
// value of pixel (x, y).

void etc1_decode_block(const etc1_byte* pIn, etc1_byte* pOut);

// Return the size of the encoded image data (does not include size of PKM header).

etc1_uint32 etc1_get_encoded_data_size(etc1_uint32 width, etc1_uint32 height);

// Encode an entire image.
// pIn - pointer to the image data. Formatted such that
//       pixel (x,y) is at pIn + pixelSize * x + stride * y;
// pOut - pointer to encoded data. Must be large enough to store entire encoded image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_encode_image(const etc1_byte* pIn, etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride, etc1_byte* pOut);

// Decode an entire image.
// pIn - pointer to encoded data.
// pOut - pointer to the image data. Will be written such that
//        pixel (x,y) is at pIn + pixelSize * x + stride * y. Must be
//        large enough to store entire image.
// pixelSize can be 2 or 3. 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
// returns non-zero if there is an error.

int etc1_decode_image(const etc1_byte* pIn, etc1_byte* pOut,
		etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride);

// Size of a PKM header, in bytes.

#define ETC_PKM_HEADER_SIZE 16

// Format a PKM header

void etc1_pkm_format_header(etc1_byte* pHeader, etc1_uint32 width, etc1_uint32 height);

// Check if a PKM header is correctly formatted.

etc1_bool etc1_pkm_is_valid(const etc1_byte* pHeader);

// Read the image width from a PKM header

etc1_uint32 etc1_pkm_get_width(const etc1_byte* pHeader);

// Read the image height from a PKM header

etc1_uint32 etc1_pkm_get_height(const etc1_byte* pHeader);

#ifdef __cplusplus
}
#endif

#endif
#include <string.h>

/* From http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt

 The number of bits that represent a 4x4 texel block is 64 bits if
 <internalformat> is given by ETC1_RGB8_OES.

 The data for a block is a number of bytes,

 {q0, q1, q2, q3, q4, q5, q6, q7}

 where byte q0 is located at the lowest memory address and q7 at
 the highest. The 64 bits specifying the block is then represented
 by the following 64 bit integer:

 int64bit = 256*(256*(256*(256*(256*(256*(256*q0+q1)+q2)+q3)+q4)+q5)+q6)+q7;

 ETC1_RGB8_OES:

 a) bit layout in bits 63 through 32 if diffbit = 0

 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48
 -----------------------------------------------
 | base col1 | base col2 | base col1 | base col2 |
 | R1 (4bits)| R2 (4bits)| G1 (4bits)| G2 (4bits)|
 -----------------------------------------------

 47 46 45 44 43 42 41 40 39 38 37 36 35 34  33  32
 ---------------------------------------------------
 | base col1 | base col2 | table  | table  |diff|flip|
 | B1 (4bits)| B2 (4bits)| cw 1   | cw 2   |bit |bit |
 ---------------------------------------------------

 b) bit layout in bits 63 through 32 if diffbit = 1

 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48
 -----------------------------------------------
 | base col1    | dcol 2 | base col1    | dcol 2 |
 | R1' (5 bits) | dR2    | G1' (5 bits) | dG2    |
 -----------------------------------------------

 47 46 45 44 43 42 41 40 39 38 37 36 35 34  33  32
 ---------------------------------------------------
 | base col 1   | dcol 2 | table  | table  |diff|flip|
 | B1' (5 bits) | dB2    | cw 1   | cw 2   |bit |bit |
 ---------------------------------------------------

 c) bit layout in bits 31 through 0 (in both cases)

 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
 -----------------------------------------------
 |       most significant pixel index bits       |
 | p| o| n| m| l| k| j| i| h| g| f| e| d| c| b| a|
 -----------------------------------------------

 15 14 13 12 11 10  9  8  7  6  5  4  3   2   1  0
 --------------------------------------------------
 |         least significant pixel index bits       |
 | p| o| n| m| l| k| j| i| h| g| f| e| d| c | b | a |
 --------------------------------------------------

 Add table 3.17.2: Intensity modifier sets for ETC1 compressed textures:

 table codeword                modifier table
 ------------------        ----------------------
 0                     -8  -2  2   8
 1                    -17  -5  5  17
 2                    -29  -9  9  29
 3                    -42 -13 13  42
 4                    -60 -18 18  60
 5                    -80 -24 24  80
 6                   -106 -33 33 106
 7                   -183 -47 47 183

 Add table 3.17.3 Mapping from pixel index values to modifier values for
 ETC1 compressed textures:

 pixel index value
 ---------------
 msb     lsb           resulting modifier value
 -----   -----          -------------------------
 1       1            -b (large negative value)
 1       0            -a (small negative value)
 0       0             a (small positive value)
 0       1             b (large positive value)

 */

static const int kModifierTable[] = {
/* 0 */2, 8, -2, -8,
/* 1 */5, 17, -5, -17,
/* 2 */9, 29, -9, -29,
/* 3 */13, 42, -13, -42,
/* 4 */18, 60, -18, -60,
/* 5 */24, 80, -24, -80,
/* 6 */33, 106, -33, -106,
/* 7 */47, 183, -47, -183 };

static const int kLookup[8] = { 0, 1, 2, 3, -4, -3, -2, -1 };

static inline etc1_byte clamp(int x) {
	return (etc1_byte) (x >= 0 ? (x < 255 ? x : 255) : 0);
}

static
inline int convert4To8(int b) {
	int c = b & 0xf;
	return (c << 4) | c;
}

static
inline int convert5To8(int b) {
	int c = b & 0x1f;
	return (c << 3) | (c >> 2);
}

static
inline int convert6To8(int b) {
	int c = b & 0x3f;
	return (c << 2) | (c >> 4);
}

static
inline int divideBy255(int d) {
	return (d + 128 + (d >> 8)) >> 8;
}

static
inline int convert8To4(int b) {
	//int c = b & 0xff;
	return divideBy255(b * 15);
}

static
inline int convert8To5(int b) {
	//int c = b & 0xff;
	return divideBy255(b * 31);
}

static
inline int convertDiff(int base, int diff) {
	return convert5To8((0x1f & base) + kLookup[0x7 & diff]);
}

static
void decode_subblock(etc1_byte* pOut, int r, int g, int b, const int* table,
		etc1_uint32 low, etc1_bool second, etc1_bool flipped) {
	int baseX = 0;
	int baseY = 0;
	int i;

	if (second) {
		if (flipped) {
			baseY = 2;
		} else {
			baseX = 2;
		}
	}
	for (i = 0; i < 8; i++) {
		int x, y;
		if (flipped) {
			x = baseX + (i >> 1);
			y = baseY + (i & 1);
		} else {
			x = baseX + (i >> 2);
			y = baseY + (i & 3);
		}
		int k = y + (x * 4);
		int offset = ((low >> k) & 1) | ((low >> (k + 15)) & 2);
		int delta = table[offset];
		etc1_byte* q = pOut + 3 * (x + 4 * y);
		*q++ = clamp(r + delta);
		*q++ = clamp(g + delta);
		*q++ = clamp(b + delta);
	}
}

// Input is an ETC1 compressed version of the data.
// Output is a 4 x 4 square of 3-byte pixels in form R, G, B

void etc1_decode_block(const etc1_byte* pIn, etc1_byte* pOut) {
	etc1_uint32 high = (pIn[0] << 24) | (pIn[1] << 16) | (pIn[2] << 8) | pIn[3];
	etc1_uint32 low = (pIn[4] << 24) | (pIn[5] << 16) | (pIn[6] << 8) | pIn[7];
	int r1, r2, g1, g2, b1, b2;
	if (high & 2) {
		// differential
		int rBase = high >> 27;
		int gBase = high >> 19;
		int bBase = high >> 11;
		r1 = convert5To8(rBase);
		r2 = convertDiff(rBase, high >> 24);
		g1 = convert5To8(gBase);
		g2 = convertDiff(gBase, high >> 16);
		b1 = convert5To8(bBase);
		b2 = convertDiff(bBase, high >> 8);
	} else {
		// not differential
		r1 = convert4To8(high >> 28);
		r2 = convert4To8(high >> 24);
		g1 = convert4To8(high >> 20);
		g2 = convert4To8(high >> 16);
		b1 = convert4To8(high >> 12);
		b2 = convert4To8(high >> 8);
	}
	int tableIndexA = 7 & (high >> 5);
	int tableIndexB = 7 & (high >> 2);
	const int* tableA = kModifierTable + tableIndexA * 4;
	const int* tableB = kModifierTable + tableIndexB * 4;
	etc1_bool flipped = (high & 1) != 0;
	decode_subblock(pOut, r1, g1, b1, tableA, low, 0, flipped);
	decode_subblock(pOut, r2, g2, b2, tableB, low, 1, flipped);
}

typedef struct {
	etc1_uint32 high;
	etc1_uint32 low;
	etc1_uint32 score; // Lower is more accurate
} etc_compressed;

static
inline void take_best(etc_compressed* a, const etc_compressed* b) {
	if (a->score > b->score) {
		*a = *b;
	}
}

static
void etc_average_colors_subblock(const etc1_byte* pIn, etc1_uint32 inMask,
		etc1_byte* pColors, etc1_bool flipped, etc1_bool second) {
	int r = 0;
	int g = 0;
	int b = 0;
	int y, x;

	if (flipped) {
		int by = 0;
		if (second) {
			by = 2;
		}
		for ( y = 0; y < 2; y++) {
			int yy = by + y;
			for ( x = 0; x < 4; x++) {
				int i = x + 4 * yy;
				if (inMask & (1 << i)) {
					const etc1_byte* p = pIn + i * 3;
					r += *(p++);
					g += *(p++);
					b += *(p++);
				}
			}
		}
	} else {
		int bx = 0;
		if (second) {
			bx = 2;
		}
		for ( y = 0; y < 4; y++) {
			for ( x = 0; x < 2; x++) {
				int xx = bx + x;
				int i = xx + 4 * y;
				if (inMask & (1 << i)) {
					const etc1_byte* p = pIn + i * 3;
					r += *(p++);
					g += *(p++);
					b += *(p++);
				}
			}
		}
	}
	pColors[0] = (etc1_byte)((r + 4) >> 3);
	pColors[1] = (etc1_byte)((g + 4) >> 3);
	pColors[2] = (etc1_byte)((b + 4) >> 3);
}

static
inline int square(int x) {
	return x * x;
}

static etc1_uint32 chooseModifier(const etc1_byte* pBaseColors,
		const etc1_byte* pIn, etc1_uint32 *pLow, int bitIndex,
		const int* pModifierTable) {
	etc1_uint32 bestScore = ~0;
	int bestIndex = 0;
	int pixelR = pIn[0];
	int pixelG = pIn[1];
	int pixelB = pIn[2];
	int r = pBaseColors[0];
	int g = pBaseColors[1];
	int b = pBaseColors[2];
	int i;
	for ( i = 0; i < 4; i++) {
		int modifier = pModifierTable[i];
		int decodedG = clamp(g + modifier);
		etc1_uint32 score = (etc1_uint32) (6 * square(decodedG - pixelG));
		if (score >= bestScore) {
			continue;
		}
		int decodedR = clamp(r + modifier);
		score += (etc1_uint32) (3 * square(decodedR - pixelR));
		if (score >= bestScore) {
			continue;
		}
		int decodedB = clamp(b + modifier);
		score += (etc1_uint32) square(decodedB - pixelB);
		if (score < bestScore) {
			bestScore = score;
			bestIndex = i;
		}
	}
	etc1_uint32 lowMask = (((bestIndex >> 1) << 16) | (bestIndex & 1))
			<< bitIndex;
	*pLow |= lowMask;
	return bestScore;
}

static
void etc_encode_subblock_helper(const etc1_byte* pIn, etc1_uint32 inMask,
		etc_compressed* pCompressed, etc1_bool flipped, etc1_bool second,
		const etc1_byte* pBaseColors, const int* pModifierTable) {
	int score = pCompressed->score;
	int y, x;
	if (flipped) {
		int by = 0;
		if (second) {
			by = 2;
		}
		for ( y = 0; y < 2; y++) {
			int yy = by + y;
			for ( x = 0; x < 4; x++) {
				int i = x + 4 * yy;
				if (inMask & (1 << i)) {
					score += chooseModifier(pBaseColors, pIn + i * 3,
							&pCompressed->low, yy + x * 4, pModifierTable);
				}
			}
		}
	} else {
		int bx = 0;
		if (second) {
			bx = 2;
		}
		for ( y = 0; y < 4; y++) {
			for ( x = 0; x < 2; x++) {
				int xx = bx + x;
				int i = xx + 4 * y;
				if (inMask & (1 << i)) {
					score += chooseModifier(pBaseColors, pIn + i * 3,
							&pCompressed->low, y + xx * 4, pModifierTable);
				}
			}
		}
	}
	pCompressed->score = score;
}

static etc1_bool inRange4bitSigned(int color) {
	return color >= -4 && color <= 3;
}

static void etc_encodeBaseColors(etc1_byte* pBaseColors,
		const etc1_byte* pColors, etc_compressed* pCompressed) {
	int r1, g1, b1, r2 = 0, g2 = 0, b2 = 0; // 8 bit base colors for sub-blocks
	etc1_bool differential;
	{
		int r51 = convert8To5(pColors[0]);
		int g51 = convert8To5(pColors[1]);
		int b51 = convert8To5(pColors[2]);
		int r52 = convert8To5(pColors[3]);
		int g52 = convert8To5(pColors[4]);
		int b52 = convert8To5(pColors[5]);

		r1 = convert5To8(r51);
		g1 = convert5To8(g51);
		b1 = convert5To8(b51);

		int dr = r52 - r51;
		int dg = g52 - g51;
		int db = b52 - b51;

		differential = inRange4bitSigned(dr) && inRange4bitSigned(dg)
				&& inRange4bitSigned(db);
		if (differential) {
			r2 = convert5To8(r51 + dr);
			g2 = convert5To8(g51 + dg);
			b2 = convert5To8(b51 + db);
			pCompressed->high |= (r51 << 27) | ((7 & dr) << 24) | (g51 << 19)
					| ((7 & dg) << 16) | (b51 << 11) | ((7 & db) << 8) | 2;
		}
	}

	if (!differential) {
		int r41 = convert8To4(pColors[0]);
		int g41 = convert8To4(pColors[1]);
		int b41 = convert8To4(pColors[2]);
		int r42 = convert8To4(pColors[3]);
		int g42 = convert8To4(pColors[4]);
		int b42 = convert8To4(pColors[5]);
		r1 = convert4To8(r41);
		g1 = convert4To8(g41);
		b1 = convert4To8(b41);
		r2 = convert4To8(r42);
		g2 = convert4To8(g42);
		b2 = convert4To8(b42);
		pCompressed->high |= (r41 << 28) | (r42 << 24) | (g41 << 20) | (g42
				<< 16) | (b41 << 12) | (b42 << 8);
	}
	pBaseColors[0] = r1;
	pBaseColors[1] = g1;
	pBaseColors[2] = b1;
	pBaseColors[3] = r2;
	pBaseColors[4] = g2;
	pBaseColors[5] = b2;
}

static
void etc_encode_block_helper(const etc1_byte* pIn, etc1_uint32 inMask,
		const etc1_byte* pColors, etc_compressed* pCompressed, etc1_bool flipped) {
	int i;

	pCompressed->score = ~0;
	pCompressed->high = (flipped ? 1 : 0);
	pCompressed->low = 0;

	etc1_byte pBaseColors[6];

	etc_encodeBaseColors(pBaseColors, pColors, pCompressed);

	int originalHigh = pCompressed->high;

	const int* pModifierTable = kModifierTable;
	for ( i = 0; i < 8; i++, pModifierTable += 4) {
		etc_compressed temp;
		temp.score = 0;
		temp.high = originalHigh | (i << 5);
		temp.low = 0;
		etc_encode_subblock_helper(pIn, inMask, &temp, flipped, 0,
				pBaseColors, pModifierTable);
		take_best(pCompressed, &temp);
	}
	pModifierTable = kModifierTable;
	etc_compressed firstHalf = *pCompressed;
	for ( i = 0; i < 8; i++, pModifierTable += 4) {
		etc_compressed temp;
		temp.score = firstHalf.score;
		temp.high = firstHalf.high | (i << 2);
		temp.low = firstHalf.low;
		etc_encode_subblock_helper(pIn, inMask, &temp, flipped, 1,
				pBaseColors + 3, pModifierTable);
		if (i == 0) {
			*pCompressed = temp;
		} else {
			take_best(pCompressed, &temp);
		}
	}
}

static void writeBigEndian(etc1_byte* pOut, etc1_uint32 d) {
	pOut[0] = (etc1_byte)(d >> 24);
	pOut[1] = (etc1_byte)(d >> 16);
	pOut[2] = (etc1_byte)(d >> 8);
	pOut[3] = (etc1_byte) d;
}

// Input is a 4 x 4 square of 3-byte pixels in form R, G, B
// inmask is a 16-bit mask where bit (1 << (x + y * 4)) tells whether the corresponding (x,y)
// pixel is valid or not. Invalid pixel color values are ignored when compressing.
// Output is an ETC1 compressed version of the data.

void etc1_encode_block(const etc1_byte* pIn, etc1_uint32 inMask,
		etc1_byte* pOut) {
	etc1_byte colors[6];
	etc1_byte flippedColors[6];
	etc_average_colors_subblock(pIn, inMask, colors, 0, 0);
	etc_average_colors_subblock(pIn, inMask, colors + 3, 0, 1);
	etc_average_colors_subblock(pIn, inMask, flippedColors, 1, 0);
	etc_average_colors_subblock(pIn, inMask, flippedColors + 3, 1, 1);

	etc_compressed a, b;
	etc_encode_block_helper(pIn, inMask, colors, &a, 0);
	etc_encode_block_helper(pIn, inMask, flippedColors, &b, 1);
	take_best(&a, &b);
	writeBigEndian(pOut, a.high);
	writeBigEndian(pOut + 4, a.low);
}

// Return the size of the encoded image data (does not include size of PKM header).

etc1_uint32 etc1_get_encoded_data_size(etc1_uint32 width, etc1_uint32 height) {
	return (((width + 3) & ~3) * ((height + 3) & ~3)) >> 1;
}

// Encode an entire image.
// pIn - pointer to the image data. Formatted such that the Red component of
//       pixel (x,y) is at pIn + pixelSize * x + stride * y + redOffset;
// pOut - pointer to encoded data. Must be large enough to store entire encoded image.

int etc1_encode_image(const etc1_byte* pIn, etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride, etc1_byte* pOut) {
	if (pixelSize < 2 || pixelSize > 3) {
		return -1;
	}
	static const unsigned short kYMask[] = { 0x0, 0xf, 0xff, 0xfff, 0xffff };
	static const unsigned short kXMask[] = { 0x0, 0x1111, 0x3333, 0x7777,
			0xffff };
	etc1_byte block[ETC1_DECODED_BLOCK_SIZE];
	etc1_byte encoded[ETC1_ENCODED_BLOCK_SIZE];
	etc1_uint32 y, x, cy, cx;

	etc1_uint32 encodedWidth = (width + 3) & ~3;
	etc1_uint32 encodedHeight = (height + 3) & ~3;

	for ( y = 0; y < encodedHeight; y += 4) {
		etc1_uint32 yEnd = height - y;
		if (yEnd > 4) {
			yEnd = 4;
		}
		int ymask = kYMask[yEnd];
		for ( x = 0; x < encodedWidth; x += 4) {
			etc1_uint32 xEnd = width - x;
			if (xEnd > 4) {
				xEnd = 4;
			}
			int mask = ymask & kXMask[xEnd];
			for ( cy = 0; cy < yEnd; cy++) {
				etc1_byte* q = block + (cy * 4) * 3;
				const etc1_byte* p = pIn + pixelSize * x + stride * (y + cy);
				if (pixelSize == 3) {
					memcpy(q, p, xEnd * 3);
				} else {
					for ( cx = 0; cx < xEnd; cx++) {
						int pixel = (p[1] << 8) | p[0];
						*q++ = convert5To8(pixel >> 11);
						*q++ = convert6To8(pixel >> 5);
						*q++ = convert5To8(pixel);
						p += pixelSize;
					}
				}
			}
			etc1_encode_block(block, mask, encoded);
			memcpy(pOut, encoded, sizeof(encoded));
			pOut += sizeof(encoded);
		}
	}
	return 0;
}

// Decode an entire image.
// pIn - pointer to encoded data.
// pOut - pointer to the image data. Will be written such that the Red component of
//       pixel (x,y) is at pIn + pixelSize * x + stride * y + redOffset. Must be
//        large enough to store entire image.

int etc1_decode_image(const etc1_byte* pIn, etc1_byte* pOut,
		etc1_uint32 width, etc1_uint32 height,
		etc1_uint32 pixelSize, etc1_uint32 stride) {
	if (pixelSize < 2 || pixelSize > 3) {
		return -1;
	}
	etc1_byte block[ETC1_DECODED_BLOCK_SIZE];

	etc1_uint32 encodedWidth = (width + 3) & ~3;
	etc1_uint32 encodedHeight = (height + 3) & ~3;

	etc1_uint32 y, x, cy, cx;

	for ( y = 0; y < encodedHeight; y += 4) {
		etc1_uint32 yEnd = height - y;
		if (yEnd > 4) {
			yEnd = 4;
		}
		for ( x = 0; x < encodedWidth; x += 4) {
			etc1_uint32 xEnd = width - x;
			if (xEnd > 4) {
				xEnd = 4;
			}
			etc1_decode_block(pIn, block);
			pIn += ETC1_ENCODED_BLOCK_SIZE;
			for ( cy = 0; cy < yEnd; cy++) {
				const etc1_byte* q = block + (cy * 4) * 3;
				etc1_byte* p = pOut + pixelSize * x + stride * (y + cy);
				if (pixelSize == 3) {
					memcpy(p, q, xEnd * 3);
				} else {
					for ( cx = 0; cx < xEnd; cx++) {
						etc1_byte r = *q++;
						etc1_byte g = *q++;
						etc1_byte b = *q++;
						etc1_uint32 pixel = ((r >> 3) << 11) | ((g >> 2) << 5) | (b >> 3);
						*p++ = (etc1_byte) pixel;
						*p++ = (etc1_byte) (pixel >> 8);
					}
				}
			}
		}
	}
	return 0;
}

static const char kMagic[] = { 'P', 'K', 'M', ' ', '1', '0' };

static const etc1_uint32 ETC1_PKM_FORMAT_OFFSET = 6;
static const etc1_uint32 ETC1_PKM_ENCODED_WIDTH_OFFSET = 8;
static const etc1_uint32 ETC1_PKM_ENCODED_HEIGHT_OFFSET = 10;
static const etc1_uint32 ETC1_PKM_WIDTH_OFFSET = 12;
static const etc1_uint32 ETC1_PKM_HEIGHT_OFFSET = 14;

static const etc1_uint32 ETC1_RGB_NO_MIPMAPS = 0;

static void writeBEUint16(etc1_byte* pOut, etc1_uint32 data) {
	pOut[0] = (etc1_byte) (data >> 8);
	pOut[1] = (etc1_byte) data;
}

static etc1_uint32 readBEUint16(const etc1_byte* pIn) {
	return (pIn[0] << 8) | pIn[1];
}

// Format a PKM header

void etc1_pkm_format_header(etc1_byte* pHeader, etc1_uint32 width, etc1_uint32 height) {
	memcpy(pHeader, kMagic, sizeof(kMagic));
	etc1_uint32 encodedWidth = (width + 3) & ~3;
	etc1_uint32 encodedHeight = (height + 3) & ~3;
	writeBEUint16(pHeader + ETC1_PKM_FORMAT_OFFSET, ETC1_RGB_NO_MIPMAPS);
	writeBEUint16(pHeader + ETC1_PKM_ENCODED_WIDTH_OFFSET, encodedWidth);
	writeBEUint16(pHeader + ETC1_PKM_ENCODED_HEIGHT_OFFSET, encodedHeight);
	writeBEUint16(pHeader + ETC1_PKM_WIDTH_OFFSET, width);
	writeBEUint16(pHeader + ETC1_PKM_HEIGHT_OFFSET, height);
}

// Check if a PKM header is correctly formatted.

etc1_bool etc1_pkm_is_valid(const etc1_byte* pHeader) {
	if (memcmp(pHeader, kMagic, sizeof(kMagic))) {
		return 0;
	}
	etc1_uint32 format = readBEUint16(pHeader + ETC1_PKM_FORMAT_OFFSET);
	etc1_uint32 encodedWidth = readBEUint16(pHeader + ETC1_PKM_ENCODED_WIDTH_OFFSET);
	etc1_uint32 encodedHeight = readBEUint16(pHeader + ETC1_PKM_ENCODED_HEIGHT_OFFSET);
	etc1_uint32 width = readBEUint16(pHeader + ETC1_PKM_WIDTH_OFFSET);
	etc1_uint32 height = readBEUint16(pHeader + ETC1_PKM_HEIGHT_OFFSET);
	return format == ETC1_RGB_NO_MIPMAPS &&
			encodedWidth >= width && encodedWidth - width < 4 &&
			encodedHeight >= height && encodedHeight - height < 4;
}

// Read the image width from a PKM header

etc1_uint32 etc1_pkm_get_width(const etc1_byte* pHeader) {
	return readBEUint16(pHeader + ETC1_PKM_WIDTH_OFFSET);
}

// Read the image height from a PKM header

etc1_uint32 etc1_pkm_get_height(const etc1_byte* pHeader){
	return readBEUint16(pHeader + ETC1_PKM_HEIGHT_OFFSET);
}



//#line 1 "image_helper.c"

//#line 1 "image_helper.h"
#ifndef HEADER_IMAGE_HELPER
#define HEADER_IMAGE_HELPER

#ifdef __cplusplus
extern "C" {
#endif

/**
	This function upscales an image.
	Not to be used to create MIPmaps,
	but to make it square,
	or to make it a power-of-two sized.
**/
int
	up_scale_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int resampled_width, int resampled_height
	);

/**
	This function downscales an image.
	Used for creating MIPmaps,
	the incoming image should be a
	power-of-two sized.
**/
int
	mipmap_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int block_size_x, int block_size_y
	);

/**
	This function takes the RGB components of the image
	and scales each channel from [0,255] to [16,235].
	This makes the colors "Safe" for display on NTSC
	displays.  Note that this is _NOT_ a good idea for
	loading images like normal- or height-maps!
**/
int
	scale_image_RGB_to_NTSC_safe
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	This function takes the RGB components of the image
	and converts them into YCoCg.  3 components will be
	re-ordered to CoYCg (for optimum DXT1 compression),
	while 4 components will be ordered CoCgAY (for DXT5
	compression).
**/
int
	convert_RGB_to_YCoCg
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	This function takes the YCoCg components of the image
	and converts them into RGB.  See above.
**/
int
	convert_YCoCg_to_RGB
	(
		unsigned char* orig,
		int width, int height, int channels
	);

/**
	Converts an HDR image from an array
	of unsigned chars (RGBE) to RGBdivA
	\return 0 if failed, otherwise returns 1
**/
int
	RGBE_to_RGBdivA
	(
		unsigned char *image,
		int width, int height,
		int rescale_to_max
	);

/**
	Converts an HDR image from an array
	of unsigned chars (RGBE) to RGBdivA2
	\return 0 if failed, otherwise returns 1
**/
int
	RGBE_to_RGBdivA2
	(
		unsigned char *image,
		int width, int height,
		int rescale_to_max
	);

#ifdef __cplusplus
}
#endif

#endif /* HEADER_IMAGE_HELPER	*/

#include <stdlib.h>
#include <math.h>

/*	Upscaling the image uses simple bilinear interpolation	*/
int
	up_scale_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int resampled_width, int resampled_height
	)
{
	float dx, dy;
	int x, y, c;

	/* error(s) check	*/
	if ( 	(width < 1) || (height < 1) ||
			(resampled_width < 2) || (resampled_height < 2) ||
			(channels < 1) ||
			(NULL == orig) || (NULL == resampled) )
	{
		/*	signify badness	*/
		return 0;
	}
	/*
		for each given pixel in the new map, find the exact location
		from the original map which would contribute to this guy
	*/
	dx = (width - 1.0f) / (resampled_width - 1.0f);
	dy = (height - 1.0f) / (resampled_height - 1.0f);
	for ( y = 0; y < resampled_height; ++y )
	{
		/* find the base y index and fractional offset from that	*/
		float sampley = y * dy;
		int inty = (int)sampley;
		/*	if( inty < 0 ) { inty = 0; } else	*/
		if( inty > height - 2 ) { inty = height - 2; }
		sampley -= inty;
		for ( x = 0; x < resampled_width; ++x )
		{
			float samplex = x * dx;
			int intx = (int)samplex;
			int base_index;
			/* find the base x index and fractional offset from that	*/
			/*	if( intx < 0 ) { intx = 0; } else	*/
			if( intx > width - 2 ) { intx = width - 2; }
			samplex -= intx;
			/*	base index into the original image	*/
			base_index = (inty * width + intx) * channels;
			for ( c = 0; c < channels; ++c )
			{
				/*	do the sampling	*/
				float value = 0.5f;
				value += orig[base_index]
							*(1.0f-samplex)*(1.0f-sampley);
				value += orig[base_index+channels]
							*(samplex)*(1.0f-sampley);
				value += orig[base_index+width*channels]
							*(1.0f-samplex)*(sampley);
				value += orig[base_index+width*channels+channels]
							*(samplex)*(sampley);
				/*	move to the next channel	*/
				++base_index;
				/*	save the new value	*/
				resampled[y*resampled_width*channels+x*channels+c] =
						(unsigned char)(value);
			}
		}
	}
	/*	done	*/
	return 1;
}

int
	mipmap_image
	(
		const unsigned char* const orig,
		int width, int height, int channels,
		unsigned char* resampled,
		int block_size_x, int block_size_y
	)
{
	int mip_width, mip_height;
	int i, j, c;

	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (orig == NULL) ||
		(resampled == NULL) ||
		(block_size_x < 1) || (block_size_y < 1) )
	{
		/*	nothing to do	*/
		return 0;
	}
	mip_width = width / block_size_x;
	mip_height = height / block_size_y;
	if( mip_width < 1 )
	{
		mip_width = 1;
	}
	if( mip_height < 1 )
	{
		mip_height = 1;
	}
	for( j = 0; j < mip_height; ++j )
	{
		for( i = 0; i < mip_width; ++i )
		{
			for( c = 0; c < channels; ++c )
			{
				const int index = (j*block_size_y)*width*channels + (i*block_size_x)*channels + c;
				int sum_value;
				int u,v;
				int u_block = block_size_x;
				int v_block = block_size_y;
				int block_area;
				/*	do a bit of checking so we don't over-run the boundaries
					(necessary for non-square textures!)	*/
				if( block_size_x * (i+1) > width )
				{
					u_block = width - i*block_size_y;
				}
				if( block_size_y * (j+1) > height )
				{
					v_block = height - j*block_size_y;
				}
				block_area = u_block*v_block;
				/*	for this pixel, see what the average
					of all the values in the block are.
					note: start the sum at the rounding value, not at 0	*/
				sum_value = block_area >> 1;
				for( v = 0; v < v_block; ++v )
				for( u = 0; u < u_block; ++u )
				{
					sum_value += orig[index + v*width*channels + u*channels];
				}
				resampled[j*mip_width*channels + i*channels + c] = sum_value / block_area;
			}
		}
	}
	return 1;
}

int
	scale_image_RGB_to_NTSC_safe
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	const float scale_lo = 16.0f - 0.499f;
	const float scale_hi = 235.0f + 0.499f;
	int i, j;
	int nc = channels;
	unsigned char scale_LUT[256];
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (orig == NULL) )
	{
		/*	nothing to do	*/
		return 0;
	}
	/*	set up the scaling Look Up Table	*/
	for( i = 0; i < 256; ++i )
	{
		scale_LUT[i] = (unsigned char)((scale_hi - scale_lo) * i / 255.0f + scale_lo);
	}
	/*	for channels = 2 or 4, ignore the alpha component	*/
	nc -= 1 - (channels & 1);
	/*	OK, go through the image and scale any non-alpha components	*/
	for( i = 0; i < width*height*channels; i += channels )
	{
		for( j = 0; j < nc; ++j )
		{
			orig[i+j] = scale_LUT[orig[i+j]];
		}
	}
	return 1;
}

unsigned char clamp_byte( int x ) { return ( (x) < 0 ? (0) : ( (x) > 255 ? 255 : (x) ) ); }

/*
	This function takes the RGB components of the image
	and converts them into YCoCg.  3 components will be
	re-ordered to CoYCg (for optimum DXT1 compression),
	while 4 components will be ordered CoCgAY (for DXT5
	compression).
*/
int
	convert_RGB_to_YCoCg
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	int i;
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 3) || (channels > 4) ||
		(orig == NULL) )
	{
		/*	nothing to do	*/
		return -1;
	}
	/*	do the conversion	*/
	if( channels == 3 )
	{
		for( i = 0; i < width*height*3; i += 3 )
		{
			int r = orig[i+0];
			int g = (orig[i+1] + 1) >> 1;
			int b = orig[i+2];
			int tmp = (2 + r + b) >> 2;
			/*	Co	*/
			orig[i+0] = clamp_byte( 128 + ((r - b + 1) >> 1) );
			/*	Y	*/
			orig[i+1] = clamp_byte( g + tmp );
			/*	Cg	*/
			orig[i+2] = clamp_byte( 128 + g - tmp );
		}
	} else
	{
		for( i = 0; i < width*height*4; i += 4 )
		{
			int r = orig[i+0];
			int g = (orig[i+1] + 1) >> 1;
			int b = orig[i+2];
			unsigned char a = orig[i+3];
			int tmp = (2 + r + b) >> 2;
			/*	Co	*/
			orig[i+0] = clamp_byte( 128 + ((r - b + 1) >> 1) );
			/*	Cg	*/
			orig[i+1] = clamp_byte( 128 + g - tmp );
			/*	Alpha	*/
			orig[i+2] = a;
			/*	Y	*/
			orig[i+3] = clamp_byte( g + tmp );
		}
	}
	/*	done	*/
	return 0;
}

/*
	This function takes the YCoCg components of the image
	and converts them into RGB.  See above.
*/
int
	convert_YCoCg_to_RGB
	(
		unsigned char* orig,
		int width, int height, int channels
	)
{
	int i;
	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 3) || (channels > 4) ||
		(orig == NULL) )
	{
		/*	nothing to do	*/
		return -1;
	}
	/*	do the conversion	*/
	if( channels == 3 )
	{
		for( i = 0; i < width*height*3; i += 3 )
		{
			int co = orig[i+0] - 128;
			int y  = orig[i+1];
			int cg = orig[i+2] - 128;
			/*	R	*/
			orig[i+0] = clamp_byte( y + co - cg );
			/*	G	*/
			orig[i+1] = clamp_byte( y + cg );
			/*	B	*/
			orig[i+2] = clamp_byte( y - co - cg );
		}
	} else
	{
		for( i = 0; i < width*height*4; i += 4 )
		{
			int co = orig[i+0] - 128;
			int cg = orig[i+1] - 128;
			unsigned char a  = orig[i+2];
			int y  = orig[i+3];
			/*	R	*/
			orig[i+0] = clamp_byte( y + co - cg );
			/*	G	*/
			orig[i+1] = clamp_byte( y + cg );
			/*	B	*/
			orig[i+2] = clamp_byte( y - co - cg );
			/*	A	*/
			orig[i+3] = a;
		}
	}
	/*	done	*/
	return 0;
}

float
find_max_RGBE
(
	unsigned char *image,
	int width, int height
)
{
	float max_val = 0.0f;
	unsigned char *img = image;
	int i, j;
	for( i = width * height; i > 0; --i )
	{
		/* float scale = powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		float scale = (float)ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		for( j = 0; j < 3; ++j )
		{
			if( img[j] * scale > max_val )
			{
				max_val = img[j] * scale;
			}
		}
		/* next pixel */
		img += 4;
	}
	return max_val;
}

int
RGBE_to_RGBdivA
(
	unsigned char *image,
	int width, int height,
	int rescale_to_max
)
{
	/* local variables */
	int i, iv;
	unsigned char *img = image;
	float scale = 1.0f;
	/* error check */
	if( (!image) || (width < 1) || (height < 1) )
	{
		return 0;
	}
	/* convert (note: no negative numbers, but 0.0 is possible) */
	if( rescale_to_max )
	{
		scale = 255.0f / find_max_RGBE( image, width, height );
	}
	for( i = width * height; i > 0; --i )
	{
		/* decode this pixel, and find the max */
		float r,g,b,e, m;
		/* e = scale * powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		e = scale * (float)ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		r = e * img[0];
		g = e * img[1];
		b = e * img[2];
		m = (r > g) ? r : g;
		m = (b > m) ? b : m;
		/* and encode it into RGBdivA */
		iv = (m != 0.0f) ? (int)(255.0f / m) : 1;
		iv = (iv < 1) ? 1 : iv;
		img[3] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * r + 0.5f);
		img[0] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * g + 0.5f);
		img[1] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * b + 0.5f);
		img[2] = (iv > 255) ? 255 : iv;
		/* and on to the next pixel */
		img += 4;
	}
	return 1;
}

int
RGBE_to_RGBdivA2
(
	unsigned char *image,
	int width, int height,
	int rescale_to_max
)
{
	/* local variables */
	int i, iv;
	unsigned char *img = image;
	float scale = 1.0f;
	/* error check */
	if( (!image) || (width < 1) || (height < 1) )
	{
		return 0;
	}
	/* convert (note: no negative numbers, but 0.0 is possible) */
	if( rescale_to_max )
	{
		scale = 255.0f * 255.0f / find_max_RGBE( image, width, height );
	}
	for( i = width * height; i > 0; --i )
	{
		/* decode this pixel, and find the max */
		float r,g,b,e, m;
		/* e = scale * powf( 2.0f, img[3] - 128.0f ) / 255.0f; */
		e = scale * (float)ldexp( 1.0f / 255.0f, (int)(img[3]) - 128 );
		r = e * img[0];
		g = e * img[1];
		b = e * img[2];
		m = (r > g) ? r : g;
		m = (b > m) ? b : m;
		/* and encode it into RGBdivA */
		iv = (m != 0.0f) ? (int)sqrtf( 255.0f * 255.0f / m ) : 1;
		iv = (iv < 1) ? 1 : iv;
		img[3] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * r / 255.0f + 0.5f);
		img[0] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * g / 255.0f + 0.5f);
		img[1] = (iv > 255) ? 255 : iv;
		iv = (int)(img[3] * img[3] * b / 255.0f + 0.5f);
		img[2] = (iv > 255) ? 255 : iv;
		/* and on to the next pixel */
		img += 4;
	}
	return 1;
}


//#line 1 "rg_etc1.cpp"
// File: rg_etc1.cpp - Fast, high quality ETC1 block packer/unpacker - Rich Geldreich <richgel99@gmail.com>
// Please see ZLIB license at the end of rg_etc1.h.
//
// For more information Ericsson Texture Compression (ETC/ETC1), see:
// http://www.khronos.org/registry/gles/extensions/OES/OES_compressed_ETC1_RGB8_texture.txt
//
// v1.04 - 5/15/14 - Fix signed vs. unsigned subtraction problem (noticed when compiled with gcc) in pack_etc1_block_init().
//         This issue would cause an assert when this func. was called in debug. (Note this module was developed/testing with MSVC,
//         I still need to test it throughly when compiled with gcc.)
//
// v1.03 - 5/12/13 - Initial public release

//#line 1 "rg_etc1.h"
// File: rg_etc1.h - Fast, high quality ETC1 block packer/unpacker - Rich Geldreich <richgel99@gmail.com>
// Please see ZLIB license at the end of this file.
//#pragma once

namespace rg_etc1
{
   // Unpacks an 8-byte ETC1 compressed block to a block of 4x4 32bpp RGBA pixels.
   // Returns false if the block is invalid. Invalid blocks will still be unpacked with clamping.
   // This function is thread safe, and does not dynamically allocate any memory.
   // If preserve_alpha is true, the alpha channel of the destination pixels will not be overwritten. Otherwise, alpha will be set to 255.
   bool unpack_etc1_block(const void *pETC1_block, unsigned int* pDst_pixels_rgba, bool preserve_alpha = false);

   // Quality setting = the higher the quality, the slower.
   // To pack large textures, it is highly recommended to call pack_etc1_block() in parallel, on different blocks, from multiple threads (particularly when using cHighQuality).
   enum etc1_quality
   {
	  cLowQuality,
	  cMediumQuality,
	  cHighQuality,
   };

   struct etc1_pack_params
   {
	  etc1_quality m_quality;
	  bool m_dithering;

	  inline etc1_pack_params()
	  {
		 clear();
	  }

	  void clear()
	  {
		 m_quality = cHighQuality;
		 m_dithering = false;
	  }
   };

   // Important: pack_etc1_block_init() must be called before calling pack_etc1_block().
   void pack_etc1_block_init();

   // Packs a 4x4 block of 32bpp RGBA pixels to an 8-byte ETC1 block.
   // 32-bit RGBA pixels must always be arranged as (R,G,B,A) (R first, A last) in memory, independent of platform endianness. A should always be 255.
   // Returns squared error of result.
   // This function is thread safe, and does not dynamically allocate any memory.
   // pack_etc1_block() does not currently support "perceptual" colorspace metrics - it primarily optimizes for RGB RMSE.
   unsigned int pack_etc1_block(void* pETC1_block, const unsigned int* pSrc_pixels_rgba, etc1_pack_params& pack_params);

} // namespace rg_etc1

//------------------------------------------------------------------------------
//
// rg_etc1 uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2012 Rich Geldreich
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------


#include <stdlib.h>
#include <memory.h>
#include <assert.h>
//#include <stdio.h>
#include <math.h>

#pragma warning (disable: 4201) //  nonstandard extension used : nameless struct/union

#if defined(_DEBUG) || defined(DEBUG)
#define RG_ETC1_BUILD_DEBUG
#endif

#define RG_ETC1_ASSERT assert

namespace rg_etc1
{
   typedef unsigned char uint8;
   typedef unsigned short uint16;
   typedef unsigned int uint;
   typedef unsigned int uint32;
   typedef long long int64;
   typedef unsigned long long uint64;

   const uint32 cUINT32_MAX = 0xFFFFFFFFU;
   const uint64 cUINT64_MAX = 0xFFFFFFFFFFFFFFFFULL; //0xFFFFFFFFFFFFFFFFui64;

   template<typename T> inline T minimum(T a, T b) { return (a < b) ? a : b; }
   template<typename T> inline T minimum(T a, T b, T c) { return minimum(minimum(a, b), c); }
   template<typename T> inline T maximum(T a, T b) { return (a > b) ? a : b; }
   template<typename T> inline T maximum(T a, T b, T c) { return maximum(maximum(a, b), c); }
   template<typename T> inline T clamp(T value, T low, T high) { return (value < low) ? low : ((value > high) ? high : value); }
   template<typename T> inline T square(T value) { return value * value; }
   template<typename T> inline void zero_object(T& obj) { memset((void*)&obj, 0, sizeof(obj)); }
   template<typename T> inline void zero_this(T* pObj) { memset((void*)pObj, 0, sizeof(*pObj)); }

   template<class T, size_t N> T decay_array_to_subtype(T (&a)[N]);

#define RG_ETC1_ARRAY_SIZE(X) (sizeof(X) / sizeof(decay_array_to_subtype(X)))

   enum eNoClamp { cNoClamp };

   struct color_quad_u8
   {
	  static inline int clamp(int v) { if (v & 0xFFFFFF00U) v = (~(static_cast<int>(v) >> 31)) & 0xFF; return v; }

	  struct component_traits { enum { cSigned = false, cFloat = false, cMin = 0U, cMax = 255U }; };

   public:
	  typedef unsigned char component_t;
	  typedef int parameter_t;

	  enum { cNumComps = 4 };

	  union
	  {
		 struct
		 {
			component_t r;
			component_t g;
			component_t b;
			component_t a;
		 };

		 component_t c[cNumComps];

		 uint32 m_u32;
	  };

	  inline color_quad_u8()
	  {
	  }

	  inline color_quad_u8(const color_quad_u8& other) : m_u32(other.m_u32)
	  {
	  }

	  explicit inline color_quad_u8(parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 set(y, alpha);
	  }

	  inline color_quad_u8(parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha = component_traits::cMax)
	  {
		 set(red, green, blue, alpha);
	  }

	  explicit inline color_quad_u8(eNoClamp, parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 set_noclamp_y_alpha(y, alpha);
	  }

	  inline color_quad_u8(eNoClamp, parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha = component_traits::cMax)
	  {
		 set_noclamp_rgba(red, green, blue, alpha);
	  }

	  inline void clear()
	  {
		 m_u32 = 0;
	  }

	  inline color_quad_u8& operator= (const color_quad_u8& other)
	  {
		 m_u32 = other.m_u32;
		 return *this;
	  }

	  inline color_quad_u8& set_rgb(const color_quad_u8& other)
	  {
		 r = other.r;
		 g = other.g;
		 b = other.b;
		 return *this;
	  }

	  inline color_quad_u8& operator= (parameter_t y)
	  {
		 set(y, component_traits::cMax);
		 return *this;
	  }

	  inline color_quad_u8& set(parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 y = clamp(y);
		 alpha = clamp(alpha);
		 r = static_cast<component_t>(y);
		 g = static_cast<component_t>(y);
		 b = static_cast<component_t>(y);
		 a = static_cast<component_t>(alpha);
		 return *this;
	  }

	  inline color_quad_u8& set_noclamp_y_alpha(parameter_t y, parameter_t alpha = component_traits::cMax)
	  {
		 RG_ETC1_ASSERT( (y >= component_traits::cMin) && (y <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (alpha >= component_traits::cMin) && (alpha <= component_traits::cMax) );

		 r = static_cast<component_t>(y);
		 g = static_cast<component_t>(y);
		 b = static_cast<component_t>(y);
		 a = static_cast<component_t>(alpha);
		 return *this;
	  }

	  inline color_quad_u8& set(parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha = component_traits::cMax)
	  {
		 r = static_cast<component_t>(clamp(red));
		 g = static_cast<component_t>(clamp(green));
		 b = static_cast<component_t>(clamp(blue));
		 a = static_cast<component_t>(clamp(alpha));
		 return *this;
	  }

	  inline color_quad_u8& set_noclamp_rgba(parameter_t red, parameter_t green, parameter_t blue, parameter_t alpha)
	  {
		 RG_ETC1_ASSERT( (red >= component_traits::cMin) && (red <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (green >= component_traits::cMin) && (green <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (blue >= component_traits::cMin) && (blue <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (alpha >= component_traits::cMin) && (alpha <= component_traits::cMax) );

		 r = static_cast<component_t>(red);
		 g = static_cast<component_t>(green);
		 b = static_cast<component_t>(blue);
		 a = static_cast<component_t>(alpha);
		 return *this;
	  }

	  inline color_quad_u8& set_noclamp_rgb(parameter_t red, parameter_t green, parameter_t blue)
	  {
		 RG_ETC1_ASSERT( (red >= component_traits::cMin) && (red <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (green >= component_traits::cMin) && (green <= component_traits::cMax) );
		 RG_ETC1_ASSERT( (blue >= component_traits::cMin) && (blue <= component_traits::cMax) );

		 r = static_cast<component_t>(red);
		 g = static_cast<component_t>(green);
		 b = static_cast<component_t>(blue);
		 return *this;
	  }

	  static inline parameter_t get_min_comp() { return component_traits::cMin; }
	  static inline parameter_t get_max_comp() { return component_traits::cMax; }
	  static inline bool get_comps_are_signed() { return component_traits::cSigned; }

	  inline component_t operator[] (uint i) const { RG_ETC1_ASSERT(i < cNumComps); return c[i]; }
	  inline component_t& operator[] (uint i) { RG_ETC1_ASSERT(i < cNumComps); return c[i]; }

	  inline color_quad_u8& set_component(uint i, parameter_t f)
	  {
		 RG_ETC1_ASSERT(i < cNumComps);

		 c[i] = static_cast<component_t>(clamp(f));

		 return *this;
	  }

	  inline color_quad_u8& set_grayscale(parameter_t l)
	  {
		 component_t x = static_cast<component_t>(clamp(l));
		 c[0] = x;
		 c[1] = x;
		 c[2] = x;
		 return *this;
	  }

	  inline color_quad_u8& clamp(const color_quad_u8& l, const color_quad_u8& h)
	  {
		 for (uint i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_t>(rg_etc1::clamp<parameter_t>(c[i], l[i], h[i]));
		 return *this;
	  }

	  inline color_quad_u8& clamp(parameter_t l, parameter_t h)
	  {
		 for (uint i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_t>(rg_etc1::clamp<parameter_t>(c[i], l, h));
		 return *this;
	  }

	  // Returns CCIR 601 luma (consistent with color_utils::RGB_To_Y).
	  inline parameter_t get_luma() const
	  {
		 return static_cast<parameter_t>((19595U * r + 38470U * g + 7471U * b + 32768U) >> 16U);
	  }

	  // Returns REC 709 luma.
	  inline parameter_t get_luma_rec709() const
	  {
		 return static_cast<parameter_t>((13938U * r + 46869U * g + 4729U * b + 32768U) >> 16U);
	  }

	  inline uint squared_distance_rgb(const color_quad_u8& c) const
	  {
		 return rg_etc1::square(r - c.r) + rg_etc1::square(g - c.g) + rg_etc1::square(b - c.b);
	  }

	  inline uint squared_distance_rgba(const color_quad_u8& c) const
	  {
		 return rg_etc1::square(r - c.r) + rg_etc1::square(g - c.g) + rg_etc1::square(b - c.b) + rg_etc1::square(a - c.a);
	  }

	  inline bool rgb_equals(const color_quad_u8& rhs) const
	  {
		 return (r == rhs.r) && (g == rhs.g) && (b == rhs.b);
	  }

	  inline bool operator== (const color_quad_u8& rhs) const
	  {
		 return m_u32 == rhs.m_u32;
	  }

	  color_quad_u8& operator+= (const color_quad_u8& other)
	  {
		 for (uint i = 0; i < 4; i++)
			c[i] = static_cast<component_t>(clamp(c[i] + other.c[i]));
		 return *this;
	  }

	  color_quad_u8& operator-= (const color_quad_u8& other)
	  {
		 for (uint i = 0; i < 4; i++)
			c[i] = static_cast<component_t>(clamp(c[i] - other.c[i]));
		 return *this;
	  }

	  friend color_quad_u8 operator+ (const color_quad_u8& lhs, const color_quad_u8& rhs)
	  {
		 color_quad_u8 result(lhs);
		 result += rhs;
		 return result;
	  }

	  friend color_quad_u8 operator- (const color_quad_u8& lhs, const color_quad_u8& rhs)
	  {
		 color_quad_u8 result(lhs);
		 result -= rhs;
		 return result;
	  }
   }; // class color_quad_u8

   struct vec3F
   {
	  float m_s[3];

	  inline vec3F() { }
	  inline vec3F(float s) { m_s[0] = s; m_s[1] = s; m_s[2] = s; }
	  inline vec3F(float x, float y, float z) { m_s[0] = x; m_s[1] = y; m_s[2] = z; }

	  inline float operator[] (uint i) const { RG_ETC1_ASSERT(i < 3); return m_s[i]; }

	  inline vec3F& operator += (const vec3F& other) { for (uint i = 0; i < 3; i++) m_s[i] += other.m_s[i]; return *this; }

	  inline vec3F& operator *= (float s) { for (uint i = 0; i < 3; i++) m_s[i] *= s; return *this; }
   };

   enum etc_constants
   {
	  cETC1BytesPerBlock = 8U,

	  cETC1SelectorBits = 2U,
	  cETC1SelectorValues = 1U << cETC1SelectorBits,
	  cETC1SelectorMask = cETC1SelectorValues - 1U,

	  cETC1BlockShift = 2U,
	  cETC1BlockSize = 1U << cETC1BlockShift,

	  cETC1LSBSelectorIndicesBitOffset = 0,
	  cETC1MSBSelectorIndicesBitOffset = 16,

	  cETC1FlipBitOffset = 32,
	  cETC1DiffBitOffset = 33,

	  cETC1IntenModifierNumBits = 3,
	  cETC1IntenModifierValues = 1 << cETC1IntenModifierNumBits,
	  cETC1RightIntenModifierTableBitOffset = 34,
	  cETC1LeftIntenModifierTableBitOffset = 37,

	  // Base+Delta encoding (5 bit bases, 3 bit delta)
	  cETC1BaseColorCompNumBits = 5,
	  cETC1BaseColorCompMax = 1 << cETC1BaseColorCompNumBits,

	  cETC1DeltaColorCompNumBits = 3,
	  cETC1DeltaColorComp = 1 << cETC1DeltaColorCompNumBits,
	  cETC1DeltaColorCompMax = 1 << cETC1DeltaColorCompNumBits,

	  cETC1BaseColor5RBitOffset = 59,
	  cETC1BaseColor5GBitOffset = 51,
	  cETC1BaseColor5BBitOffset = 43,

	  cETC1DeltaColor3RBitOffset = 56,
	  cETC1DeltaColor3GBitOffset = 48,
	  cETC1DeltaColor3BBitOffset = 40,

	  // Absolute (non-delta) encoding (two 4-bit per component bases)
	  cETC1AbsColorCompNumBits = 4,
	  cETC1AbsColorCompMax = 1 << cETC1AbsColorCompNumBits,

	  cETC1AbsColor4R1BitOffset = 60,
	  cETC1AbsColor4G1BitOffset = 52,
	  cETC1AbsColor4B1BitOffset = 44,

	  cETC1AbsColor4R2BitOffset = 56,
	  cETC1AbsColor4G2BitOffset = 48,
	  cETC1AbsColor4B2BitOffset = 40,

	  cETC1ColorDeltaMin = -4,
	  cETC1ColorDeltaMax = 3,

	  // Delta3:
	  // 0   1   2   3   4   5   6   7
	  // 000 001 010 011 100 101 110 111
	  // 0   1   2   3   -4  -3  -2  -1
   };

   static uint8 g_quant5_tab[256+16];

   static const int g_etc1_inten_tables[cETC1IntenModifierValues][cETC1SelectorValues] =
   {
	  { -8,  -2,   2,   8 }, { -17,  -5,  5,  17 }, { -29,  -9,   9,  29 }, {  -42, -13, 13,  42 },
	  { -60, -18, 18,  60 }, { -80, -24, 24,  80 }, { -106, -33, 33, 106 }, { -183, -47, 47, 183 }
   };

   static const uint8 g_etc1_to_selector_index[cETC1SelectorValues] = { 2, 3, 1, 0 };
   static const uint8 g_selector_index_to_etc1[cETC1SelectorValues] = { 3, 2, 0, 1 };

   // Given an ETC1 diff/inten_table/selector, and an 8-bit desired color, this table encodes the best packed_color in the low byte, and the abs error in the high byte.
   static uint16 g_etc1_inverse_lookup[2*8*4][256];      // [diff/inten_table/selector][desired_color]

   // g_color8_to_etc_block_config[color][table_index] = Supplies for each 8-bit color value a list of packed ETC1 diff/intensity table/selectors/packed_colors that map to that color.
   // To pack: diff | (inten << 1) | (selector << 4) | (packed_c << 8)
   static const uint16 g_color8_to_etc_block_config_0_255[2][33] =
   {
	  { 0x0000,  0x0010,  0x0002,  0x0012,  0x0004,  0x0014,  0x0006,  0x0016,  0x0008,  0x0018,  0x000A,  0x001A,  0x000C,  0x001C,  0x000E,  0x001E,
		0x0001,  0x0011,  0x0003,  0x0013,  0x0005,  0x0015,  0x0007,  0x0017,  0x0009,  0x0019,  0x000B,  0x001B,  0x000D,  0x001D,  0x000F,  0x001F, 0xFFFF },
	  { 0x0F20,  0x0F30,  0x0E32,  0x0F22,  0x0E34,  0x0F24,  0x0D36,  0x0F26,  0x0C38,  0x0E28,  0x0B3A,  0x0E2A,  0x093C,  0x0E2C,  0x053E,  0x0D2E,
		0x1E31,  0x1F21,  0x1D33,  0x1F23,  0x1C35,  0x1E25,  0x1A37,  0x1E27,  0x1839,  0x1D29,  0x163B,  0x1C2B,  0x133D,  0x1B2D,  0x093F,  0x1A2F, 0xFFFF },
   };

   // Really only [254][11].
   static const uint16 g_color8_to_etc_block_config_1_to_254[254][12] =
   {
	  { 0x021C, 0x0D0D, 0xFFFF }, { 0x0020, 0x0021, 0x0A0B, 0x061F, 0xFFFF }, { 0x0113, 0x0217, 0xFFFF }, { 0x0116, 0x031E,
	  0x0B0E, 0x0405, 0xFFFF }, { 0x0022, 0x0204, 0x050A, 0x0023, 0xFFFF }, { 0x0111, 0x0319, 0x0809, 0x170F, 0xFFFF }, {
	  0x0303, 0x0215, 0x0607, 0xFFFF }, { 0x0030, 0x0114, 0x0408, 0x0031, 0x0201, 0x051D, 0xFFFF }, { 0x0100, 0x0024, 0x0306,
	  0x0025, 0x041B, 0x0E0D, 0xFFFF }, { 0x021A, 0x0121, 0x0B0B, 0x071F, 0xFFFF }, { 0x0213, 0x0317, 0xFFFF }, { 0x0112,
	  0x0505, 0xFFFF }, { 0x0026, 0x070C, 0x0123, 0x0027, 0xFFFF }, { 0x0211, 0x0909, 0xFFFF }, { 0x0110, 0x0315, 0x0707,
	  0x0419, 0x180F, 0xFFFF }, { 0x0218, 0x0131, 0x0301, 0x0403, 0x061D, 0xFFFF }, { 0x0032, 0x0202, 0x0033, 0x0125, 0x051B,
	  0x0F0D, 0xFFFF }, { 0x0028, 0x031C, 0x0221, 0x0029, 0xFFFF }, { 0x0120, 0x0313, 0x0C0B, 0x081F, 0xFFFF }, { 0x0605,
	  0x0417, 0xFFFF }, { 0x0216, 0x041E, 0x0C0E, 0x0223, 0x0127, 0xFFFF }, { 0x0122, 0x0304, 0x060A, 0x0311, 0x0A09, 0xFFFF
	  }, { 0x0519, 0x190F, 0xFFFF }, { 0x002A, 0x0231, 0x0503, 0x0415, 0x0807, 0x002B, 0x071D, 0xFFFF }, { 0x0130, 0x0214,
	  0x0508, 0x0401, 0x0133, 0x0225, 0x061B, 0xFFFF }, { 0x0200, 0x0124, 0x0406, 0x0321, 0x0129, 0x100D, 0xFFFF }, { 0x031A,
	  0x0D0B, 0x091F, 0xFFFF }, { 0x0413, 0x0705, 0x0517, 0xFFFF }, { 0x0212, 0x0034, 0x0323, 0x0035, 0x0227, 0xFFFF }, {
	  0x0126, 0x080C, 0x0B09, 0xFFFF }, { 0x0411, 0x0619, 0x1A0F, 0xFFFF }, { 0x0210, 0x0331, 0x0603, 0x0515, 0x0907, 0x012B,
	  0xFFFF }, { 0x0318, 0x002C, 0x0501, 0x0233, 0x0325, 0x071B, 0x002D, 0x081D, 0xFFFF }, { 0x0132, 0x0302, 0x0229, 0x110D,
	  0xFFFF }, { 0x0128, 0x041C, 0x0421, 0x0E0B, 0x0A1F, 0xFFFF }, { 0x0220, 0x0513, 0x0617, 0xFFFF }, { 0x0135, 0x0805,
	  0x0327, 0xFFFF }, { 0x0316, 0x051E, 0x0D0E, 0x0423, 0xFFFF }, { 0x0222, 0x0404, 0x070A, 0x0511, 0x0719, 0x0C09, 0x1B0F,
	  0xFFFF }, { 0x0703, 0x0615, 0x0A07, 0x022B, 0xFFFF }, { 0x012A, 0x0431, 0x0601, 0x0333, 0x012D, 0x091D, 0xFFFF }, {
	  0x0230, 0x0314, 0x0036, 0x0608, 0x0425, 0x0037, 0x0329, 0x081B, 0x120D, 0xFFFF }, { 0x0300, 0x0224, 0x0506, 0x0521,
	  0x0F0B, 0x0B1F, 0xFFFF }, { 0x041A, 0x0613, 0x0717, 0xFFFF }, { 0x0235, 0x0905, 0xFFFF }, { 0x0312, 0x0134, 0x0523,
	  0x0427, 0xFFFF }, { 0x0226, 0x090C, 0x002E, 0x0611, 0x0D09, 0x002F, 0xFFFF }, { 0x0715, 0x0B07, 0x0819, 0x032B, 0x1C0F,
	  0xFFFF }, { 0x0310, 0x0531, 0x0701, 0x0803, 0x022D, 0x0A1D, 0xFFFF }, { 0x0418, 0x012C, 0x0433, 0x0525, 0x0137, 0x091B,
	  0x130D, 0xFFFF }, { 0x0232, 0x0402, 0x0621, 0x0429, 0xFFFF }, { 0x0228, 0x051C, 0x0713, 0x100B, 0x0C1F, 0xFFFF }, {
	  0x0320, 0x0335, 0x0A05, 0x0817, 0xFFFF }, { 0x0623, 0x0527, 0xFFFF }, { 0x0416, 0x061E, 0x0E0E, 0x0711, 0x0E09, 0x012F,
	  0xFFFF }, { 0x0322, 0x0504, 0x080A, 0x0919, 0x1D0F, 0xFFFF }, { 0x0631, 0x0903, 0x0815, 0x0C07, 0x042B, 0x032D, 0x0B1D,
	  0xFFFF }, { 0x022A, 0x0801, 0x0533, 0x0625, 0x0237, 0x0A1B, 0xFFFF }, { 0x0330, 0x0414, 0x0136, 0x0708, 0x0721, 0x0529,
	  0x140D, 0xFFFF }, { 0x0400, 0x0324, 0x0606, 0x0038, 0x0039, 0x110B, 0x0D1F, 0xFFFF }, { 0x051A, 0x0813, 0x0B05, 0x0917,
	  0xFFFF }, { 0x0723, 0x0435, 0x0627, 0xFFFF }, { 0x0412, 0x0234, 0x0F09, 0x022F, 0xFFFF }, { 0x0326, 0x0A0C, 0x012E,
	  0x0811, 0x0A19, 0x1E0F, 0xFFFF }, { 0x0731, 0x0A03, 0x0915, 0x0D07, 0x052B, 0xFFFF }, { 0x0410, 0x0901, 0x0633, 0x0725,
	  0x0337, 0x0B1B, 0x042D, 0x0C1D, 0xFFFF }, { 0x0518, 0x022C, 0x0629, 0x150D, 0xFFFF }, { 0x0332, 0x0502, 0x0821, 0x0139,
	  0x120B, 0x0E1F, 0xFFFF }, { 0x0328, 0x061C, 0x0913, 0x0A17, 0xFFFF }, { 0x0420, 0x0535, 0x0C05, 0x0727, 0xFFFF }, {
	  0x0823, 0x032F, 0xFFFF }, { 0x0516, 0x071E, 0x0F0E, 0x0911, 0x0B19, 0x1009, 0x1F0F, 0xFFFF }, { 0x0422, 0x0604, 0x090A,
	  0x0B03, 0x0A15, 0x0E07, 0x062B, 0xFFFF }, { 0x0831, 0x0A01, 0x0733, 0x052D, 0x0D1D, 0xFFFF }, { 0x032A, 0x0825, 0x0437,
	  0x0729, 0x0C1B, 0x160D, 0xFFFF }, { 0x0430, 0x0514, 0x0236, 0x0808, 0x0921, 0x0239, 0x130B, 0x0F1F, 0xFFFF }, { 0x0500,
	  0x0424, 0x0706, 0x0138, 0x0A13, 0x0B17, 0xFFFF }, { 0x061A, 0x0635, 0x0D05, 0xFFFF }, { 0x0923, 0x0827, 0xFFFF }, {
	  0x0512, 0x0334, 0x003A, 0x0A11, 0x1109, 0x003B, 0x042F, 0xFFFF }, { 0x0426, 0x0B0C, 0x022E, 0x0B15, 0x0F07, 0x0C19,
	  0x072B, 0xFFFF }, { 0x0931, 0x0B01, 0x0C03, 0x062D, 0x0E1D, 0xFFFF }, { 0x0510, 0x0833, 0x0925, 0x0537, 0x0D1B, 0x170D,
	  0xFFFF }, { 0x0618, 0x032C, 0x0A21, 0x0339, 0x0829, 0xFFFF }, { 0x0432, 0x0602, 0x0B13, 0x140B, 0x101F, 0xFFFF }, {
	  0x0428, 0x071C, 0x0735, 0x0E05, 0x0C17, 0xFFFF }, { 0x0520, 0x0A23, 0x0927, 0xFFFF }, { 0x0B11, 0x1209, 0x013B, 0x052F,
	  0xFFFF }, { 0x0616, 0x081E, 0x0D19, 0xFFFF }, { 0x0522, 0x0704, 0x0A0A, 0x0A31, 0x0D03, 0x0C15, 0x1007, 0x082B, 0x072D,
	  0x0F1D, 0xFFFF }, { 0x0C01, 0x0933, 0x0A25, 0x0637, 0x0E1B, 0xFFFF }, { 0x042A, 0x0B21, 0x0929, 0x180D, 0xFFFF }, {
	  0x0530, 0x0614, 0x0336, 0x0908, 0x0439, 0x150B, 0x111F, 0xFFFF }, { 0x0600, 0x0524, 0x0806, 0x0238, 0x0C13, 0x0F05,
	  0x0D17, 0xFFFF }, { 0x071A, 0x0B23, 0x0835, 0x0A27, 0xFFFF }, { 0x1309, 0x023B, 0x062F, 0xFFFF }, { 0x0612, 0x0434,
	  0x013A, 0x0C11, 0x0E19, 0xFFFF }, { 0x0526, 0x0C0C, 0x032E, 0x0B31, 0x0E03, 0x0D15, 0x1107, 0x092B, 0xFFFF }, { 0x0D01,
	  0x0A33, 0x0B25, 0x0737, 0x0F1B, 0x082D, 0x101D, 0xFFFF }, { 0x0610, 0x0A29, 0x190D, 0xFFFF }, { 0x0718, 0x042C, 0x0C21,
	  0x0539, 0x160B, 0x121F, 0xFFFF }, { 0x0532, 0x0702, 0x0D13, 0x0E17, 0xFFFF }, { 0x0528, 0x081C, 0x0935, 0x1005, 0x0B27,
	  0xFFFF }, { 0x0620, 0x0C23, 0x033B, 0x072F, 0xFFFF }, { 0x0D11, 0x0F19, 0x1409, 0xFFFF }, { 0x0716, 0x003C, 0x091E,
	  0x0F03, 0x0E15, 0x1207, 0x0A2B, 0x003D, 0xFFFF }, { 0x0622, 0x0804, 0x0B0A, 0x0C31, 0x0E01, 0x0B33, 0x092D, 0x111D,
	  0xFFFF }, { 0x0C25, 0x0837, 0x0B29, 0x101B, 0x1A0D, 0xFFFF }, { 0x052A, 0x0D21, 0x0639, 0x170B, 0x131F, 0xFFFF }, {
	  0x0630, 0x0714, 0x0436, 0x0A08, 0x0E13, 0x0F17, 0xFFFF }, { 0x0700, 0x0624, 0x0906, 0x0338, 0x0A35, 0x1105, 0xFFFF }, {
	  0x081A, 0x0D23, 0x0C27, 0xFFFF }, { 0x0E11, 0x1509, 0x043B, 0x082F, 0xFFFF }, { 0x0712, 0x0534, 0x023A, 0x0F15, 0x1307,
	  0x1019, 0x0B2B, 0x013D, 0xFFFF }, { 0x0626, 0x0D0C, 0x042E, 0x0D31, 0x0F01, 0x1003, 0x0A2D, 0x121D, 0xFFFF }, { 0x0C33,
	  0x0D25, 0x0937, 0x111B, 0x1B0D, 0xFFFF }, { 0x0710, 0x0E21, 0x0739, 0x0C29, 0xFFFF }, { 0x0818, 0x052C, 0x0F13, 0x180B,
	  0x141F, 0xFFFF }, { 0x0632, 0x0802, 0x0B35, 0x1205, 0x1017, 0xFFFF }, { 0x0628, 0x091C, 0x0E23, 0x0D27, 0xFFFF }, {
	  0x0720, 0x0F11, 0x1609, 0x053B, 0x092F, 0xFFFF }, { 0x1119, 0x023D, 0xFFFF }, { 0x0816, 0x013C, 0x0A1E, 0x0E31, 0x1103,
	  0x1015, 0x1407, 0x0C2B, 0x0B2D, 0x131D, 0xFFFF }, { 0x0722, 0x0904, 0x0C0A, 0x1001, 0x0D33, 0x0E25, 0x0A37, 0x121B,
	  0xFFFF }, { 0x0F21, 0x0D29, 0x1C0D, 0xFFFF }, { 0x062A, 0x0839, 0x190B, 0x151F, 0xFFFF }, { 0x0730, 0x0814, 0x0536,
	  0x0B08, 0x1013, 0x1305, 0x1117, 0xFFFF }, { 0x0800, 0x0724, 0x0A06, 0x0438, 0x0F23, 0x0C35, 0x0E27, 0xFFFF }, { 0x091A,
	  0x1709, 0x063B, 0x0A2F, 0xFFFF }, { 0x1011, 0x1219, 0x033D, 0xFFFF }, { 0x0812, 0x0634, 0x033A, 0x0F31, 0x1203, 0x1115,
	  0x1507, 0x0D2B, 0xFFFF }, { 0x0726, 0x0E0C, 0x052E, 0x1101, 0x0E33, 0x0F25, 0x0B37, 0x131B, 0x0C2D, 0x141D, 0xFFFF }, {
	  0x0E29, 0x1D0D, 0xFFFF }, { 0x0810, 0x1021, 0x0939, 0x1A0B, 0x161F, 0xFFFF }, { 0x0918, 0x062C, 0x1113, 0x1217, 0xFFFF
	  }, { 0x0732, 0x0902, 0x0D35, 0x1405, 0x0F27, 0xFFFF }, { 0x0728, 0x0A1C, 0x1023, 0x073B, 0x0B2F, 0xFFFF }, { 0x0820,
	  0x1111, 0x1319, 0x1809, 0xFFFF }, { 0x1303, 0x1215, 0x1607, 0x0E2B, 0x043D, 0xFFFF }, { 0x0916, 0x023C, 0x0B1E, 0x1031,
	  0x1201, 0x0F33, 0x0D2D, 0x151D, 0xFFFF }, { 0x0822, 0x0A04, 0x0D0A, 0x1025, 0x0C37, 0x0F29, 0x141B, 0x1E0D, 0xFFFF }, {
	  0x1121, 0x0A39, 0x1B0B, 0x171F, 0xFFFF }, { 0x072A, 0x1213, 0x1317, 0xFFFF }, { 0x0830, 0x0914, 0x0636, 0x0C08, 0x0E35,
	  0x1505, 0xFFFF }, { 0x0900, 0x0824, 0x0B06, 0x0538, 0x1123, 0x1027, 0xFFFF }, { 0x0A1A, 0x1211, 0x1909, 0x083B, 0x0C2F,
	  0xFFFF }, { 0x1315, 0x1707, 0x1419, 0x0F2B, 0x053D, 0xFFFF }, { 0x0912, 0x0734, 0x043A, 0x1131, 0x1301, 0x1403, 0x0E2D,
	  0x161D, 0xFFFF }, { 0x0826, 0x0F0C, 0x062E, 0x1033, 0x1125, 0x0D37, 0x151B, 0x1F0D, 0xFFFF }, { 0x1221, 0x0B39, 0x1029,
	  0xFFFF }, { 0x0910, 0x1313, 0x1C0B, 0x181F, 0xFFFF }, { 0x0A18, 0x072C, 0x0F35, 0x1605, 0x1417, 0xFFFF }, { 0x0832,
	  0x0A02, 0x1223, 0x1127, 0xFFFF }, { 0x0828, 0x0B1C, 0x1311, 0x1A09, 0x093B, 0x0D2F, 0xFFFF }, { 0x0920, 0x1519, 0x063D,
	  0xFFFF }, { 0x1231, 0x1503, 0x1415, 0x1807, 0x102B, 0x0F2D, 0x171D, 0xFFFF }, { 0x0A16, 0x033C, 0x0C1E, 0x1401, 0x1133,
	  0x1225, 0x0E37, 0x161B, 0xFFFF }, { 0x0922, 0x0B04, 0x0E0A, 0x1321, 0x1129, 0xFFFF }, { 0x0C39, 0x1D0B, 0x191F, 0xFFFF
	  }, { 0x082A, 0x1413, 0x1705, 0x1517, 0xFFFF }, { 0x0930, 0x0A14, 0x0736, 0x0D08, 0x1323, 0x1035, 0x1227, 0xFFFF }, {
	  0x0A00, 0x0924, 0x0C06, 0x0638, 0x1B09, 0x0A3B, 0x0E2F, 0xFFFF }, { 0x0B1A, 0x1411, 0x1619, 0x073D, 0xFFFF }, { 0x1331,
	  0x1603, 0x1515, 0x1907, 0x112B, 0xFFFF }, { 0x0A12, 0x0834, 0x053A, 0x1501, 0x1233, 0x1325, 0x0F37, 0x171B, 0x102D,
	  0x181D, 0xFFFF }, { 0x0926, 0x072E, 0x1229, 0xFFFF }, { 0x1421, 0x0D39, 0x1E0B, 0x1A1F, 0xFFFF }, { 0x0A10, 0x1513,
	  0x1617, 0xFFFF }, { 0x0B18, 0x082C, 0x1135, 0x1805, 0x1327, 0xFFFF }, { 0x0932, 0x0B02, 0x1423, 0x0B3B, 0x0F2F, 0xFFFF
	  }, { 0x0928, 0x0C1C, 0x1511, 0x1719, 0x1C09, 0xFFFF }, { 0x0A20, 0x1703, 0x1615, 0x1A07, 0x122B, 0x083D, 0xFFFF }, {
	  0x1431, 0x1601, 0x1333, 0x112D, 0x191D, 0xFFFF }, { 0x0B16, 0x043C, 0x0D1E, 0x1425, 0x1037, 0x1329, 0x181B, 0xFFFF }, {
	  0x0A22, 0x0C04, 0x0F0A, 0x1521, 0x0E39, 0x1F0B, 0x1B1F, 0xFFFF }, { 0x1613, 0x1717, 0xFFFF }, { 0x092A, 0x1235, 0x1905,
	  0xFFFF }, { 0x0A30, 0x0B14, 0x0836, 0x0E08, 0x1523, 0x1427, 0xFFFF }, { 0x0B00, 0x0A24, 0x0D06, 0x0738, 0x1611, 0x1D09,
	  0x0C3B, 0x102F, 0xFFFF }, { 0x0C1A, 0x1715, 0x1B07, 0x1819, 0x132B, 0x093D, 0xFFFF }, { 0x1531, 0x1701, 0x1803, 0x122D,
	  0x1A1D, 0xFFFF }, { 0x0B12, 0x0934, 0x063A, 0x1433, 0x1525, 0x1137, 0x191B, 0xFFFF }, { 0x0A26, 0x003E, 0x082E, 0x1621,
	  0x0F39, 0x1429, 0x003F, 0xFFFF }, { 0x1713, 0x1C1F, 0xFFFF }, { 0x0B10, 0x1335, 0x1A05, 0x1817, 0xFFFF }, { 0x0C18,
	  0x092C, 0x1623, 0x1527, 0xFFFF }, { 0x0A32, 0x0C02, 0x1711, 0x1E09, 0x0D3B, 0x112F, 0xFFFF }, { 0x0A28, 0x0D1C, 0x1919,
	  0x0A3D, 0xFFFF }, { 0x0B20, 0x1631, 0x1903, 0x1815, 0x1C07, 0x142B, 0x132D, 0x1B1D, 0xFFFF }, { 0x1801, 0x1533, 0x1625,
	  0x1237, 0x1A1B, 0xFFFF }, { 0x0C16, 0x053C, 0x0E1E, 0x1721, 0x1529, 0x013F, 0xFFFF }, { 0x0B22, 0x0D04, 0x1039, 0x1D1F,
	  0xFFFF }, { 0x1813, 0x1B05, 0x1917, 0xFFFF }, { 0x0A2A, 0x1723, 0x1435, 0x1627, 0xFFFF }, { 0x0B30, 0x0C14, 0x0936,
	  0x0F08, 0x1F09, 0x0E3B, 0x122F, 0xFFFF }, { 0x0C00, 0x0B24, 0x0E06, 0x0838, 0x1811, 0x1A19, 0x0B3D, 0xFFFF }, { 0x0D1A,
	  0x1731, 0x1A03, 0x1915, 0x1D07, 0x152B, 0xFFFF }, { 0x1901, 0x1633, 0x1725, 0x1337, 0x1B1B, 0x142D, 0x1C1D, 0xFFFF }, {
	  0x0C12, 0x0A34, 0x073A, 0x1629, 0x023F, 0xFFFF }, { 0x0B26, 0x013E, 0x092E, 0x1821, 0x1139, 0x1E1F, 0xFFFF }, { 0x1913,
	  0x1A17, 0xFFFF }, { 0x0C10, 0x1535, 0x1C05, 0x1727, 0xFFFF }, { 0x0D18, 0x0A2C, 0x1823, 0x0F3B, 0x132F, 0xFFFF }, {
	  0x0B32, 0x0D02, 0x1911, 0x1B19, 0xFFFF }, { 0x0B28, 0x0E1C, 0x1B03, 0x1A15, 0x1E07, 0x162B, 0x0C3D, 0xFFFF }, { 0x0C20,
	  0x1831, 0x1A01, 0x1733, 0x152D, 0x1D1D, 0xFFFF }, { 0x1825, 0x1437, 0x1729, 0x1C1B, 0x033F, 0xFFFF }, { 0x0D16, 0x063C,
	  0x0F1E, 0x1921, 0x1239, 0x1F1F, 0xFFFF }, { 0x0C22, 0x0E04, 0x1A13, 0x1B17, 0xFFFF }, { 0x1635, 0x1D05, 0xFFFF }, {
	  0x0B2A, 0x1923, 0x1827, 0xFFFF }, { 0x0C30, 0x0D14, 0x0A36, 0x1A11, 0x103B, 0x142F, 0xFFFF }, { 0x0D00, 0x0C24, 0x0F06,
	  0x0938, 0x1B15, 0x1F07, 0x1C19, 0x172B, 0x0D3D, 0xFFFF }, { 0x0E1A, 0x1931, 0x1B01, 0x1C03, 0x162D, 0x1E1D, 0xFFFF }, {
	  0x1833, 0x1925, 0x1537, 0x1D1B, 0xFFFF }, { 0x0D12, 0x0B34, 0x083A, 0x1A21, 0x1339, 0x1829, 0x043F, 0xFFFF }, { 0x0C26,
	  0x023E, 0x0A2E, 0x1B13, 0xFFFF }, { 0x1735, 0x1E05, 0x1C17, 0xFFFF }, { 0x0D10, 0x1A23, 0x1927, 0xFFFF }, { 0x0E18,
	  0x0B2C, 0x1B11, 0x113B, 0x152F, 0xFFFF }, { 0x0C32, 0x0E02, 0x1D19, 0x0E3D, 0xFFFF }, { 0x0C28, 0x0F1C, 0x1A31, 0x1D03,
	  0x1C15, 0x182B, 0x172D, 0x1F1D, 0xFFFF }, { 0x0D20, 0x1C01, 0x1933, 0x1A25, 0x1637, 0x1E1B, 0xFFFF }, { 0x1B21, 0x1929,
	  0x053F, 0xFFFF }, { 0x0E16, 0x073C, 0x1439, 0xFFFF }, { 0x0D22, 0x0F04, 0x1C13, 0x1F05, 0x1D17, 0xFFFF }, { 0x1B23,
	  0x1835, 0x1A27, 0xFFFF }, { 0x0C2A, 0x123B, 0x162F, 0xFFFF }, { 0x0D30, 0x0E14, 0x0B36, 0x1C11, 0x1E19, 0x0F3D, 0xFFFF
	  }, { 0x0E00, 0x0D24, 0x0A38, 0x1B31, 0x1E03, 0x1D15, 0x192B, 0xFFFF }, { 0x0F1A, 0x1D01, 0x1A33, 0x1B25, 0x1737, 0x1F1B,
	  0x182D, 0xFFFF }, { 0x1A29, 0x063F, 0xFFFF }, { 0x0E12, 0x0C34, 0x093A, 0x1C21, 0x1539, 0xFFFF }, { 0x0D26, 0x033E,
	  0x0B2E, 0x1D13, 0x1E17, 0xFFFF }, { 0x1935, 0x1B27, 0xFFFF }, { 0x0E10, 0x1C23, 0x133B, 0x172F, 0xFFFF }, { 0x0F18,
	  0x0C2C, 0x1D11, 0x1F19, 0xFFFF }, { 0x0D32, 0x0F02, 0x1F03, 0x1E15, 0x1A2B, 0x103D, 0xFFFF }, { 0x0D28, 0x1C31, 0x1E01,
	  0x1B33, 0x192D, 0xFFFF }, { 0x0E20, 0x1C25, 0x1837, 0x1B29, 0x073F, 0xFFFF }, { 0x1D21, 0x1639, 0xFFFF }, { 0x0F16,
	  0x083C, 0x1E13, 0x1F17, 0xFFFF }, { 0x0E22, 0x1A35, 0xFFFF }, { 0x1D23, 0x1C27, 0xFFFF }, { 0x0D2A, 0x1E11, 0x143B,
	  0x182F, 0xFFFF }, { 0x0E30, 0x0F14, 0x0C36, 0x1F15, 0x1B2B, 0x113D, 0xFFFF }, { 0x0F00, 0x0E24, 0x0B38, 0x1D31, 0x1F01,
	  0x1A2D, 0xFFFF }, { 0x1C33, 0x1D25, 0x1937, 0xFFFF }, { 0x1E21, 0x1739, 0x1C29, 0x083F, 0xFFFF }, { 0x0F12, 0x0D34,
	  0x0A3A, 0x1F13, 0xFFFF }, { 0x0E26, 0x043E, 0x0C2E, 0x1B35, 0xFFFF }, { 0x1E23, 0x1D27, 0xFFFF }, { 0x0F10, 0x1F11,
	  0x153B, 0x192F, 0xFFFF }, { 0x0D2C, 0x123D, 0xFFFF },
   };

   struct etc1_block
   {
	  // big endian uint64:
	  // bit ofs:  56  48  40  32  24  16   8   0
	  // byte ofs: b0, b1, b2, b3, b4, b5, b6, b7
	  union
	  {
		 uint64 m_uint64;
		 uint8 m_bytes[8];
	  };

	  uint8 m_low_color[2];
	  uint8 m_high_color[2];

	  enum { cNumSelectorBytes = 4 };
	  uint8 m_selectors[cNumSelectorBytes];

	  inline void clear()
	  {
		 zero_this(this);
	  }

	  inline uint get_byte_bits(uint ofs, uint num) const
	  {
		 RG_ETC1_ASSERT((ofs + num) <= 64U);
		 RG_ETC1_ASSERT(num && (num <= 8U));
		 RG_ETC1_ASSERT((ofs >> 3) == ((ofs + num - 1) >> 3));
		 const uint byte_ofs = 7 - (ofs >> 3);
		 const uint byte_bit_ofs = ofs & 7;
		 return (m_bytes[byte_ofs] >> byte_bit_ofs) & ((1 << num) - 1);
	  }

	  inline void set_byte_bits(uint ofs, uint num, uint bits)
	  {
		 RG_ETC1_ASSERT((ofs + num) <= 64U);
		 RG_ETC1_ASSERT(num && (num < 32U));
		 RG_ETC1_ASSERT((ofs >> 3) == ((ofs + num - 1) >> 3));
		 RG_ETC1_ASSERT(bits < (1U << num));
		 const uint byte_ofs = 7 - (ofs >> 3);
		 const uint byte_bit_ofs = ofs & 7;
		 const uint mask = (1 << num) - 1;
		 m_bytes[byte_ofs] &= ~(mask << byte_bit_ofs);
		 m_bytes[byte_ofs] |= (bits << byte_bit_ofs);
	  }

	  // false = left/right subblocks
	  // true = upper/lower subblocks
	  inline bool get_flip_bit() const
	  {
		 return (m_bytes[3] & 1) != 0;
	  }

	  inline void set_flip_bit(bool flip)
	  {
		 m_bytes[3] &= ~1;
		 m_bytes[3] |= static_cast<uint8>(flip);
	  }

	  inline bool get_diff_bit() const
	  {
		 return (m_bytes[3] & 2) != 0;
	  }

	  inline void set_diff_bit(bool diff)
	  {
		 m_bytes[3] &= ~2;
		 m_bytes[3] |= (static_cast<uint>(diff) << 1);
	  }

	  // Returns intensity modifier table (0-7) used by subblock subblock_id.
	  // subblock_id=0 left/top (CW 1), 1=right/bottom (CW 2)
	  inline uint get_inten_table(uint subblock_id) const
	  {
		 RG_ETC1_ASSERT(subblock_id < 2);
		 const uint ofs = subblock_id ? 2 : 5;
		 return (m_bytes[3] >> ofs) & 7;
	  }

	  // Sets intensity modifier table (0-7) used by subblock subblock_id (0 or 1)
	  inline void set_inten_table(uint subblock_id, uint t)
	  {
		 RG_ETC1_ASSERT(subblock_id < 2);
		 RG_ETC1_ASSERT(t < 8);
		 const uint ofs = subblock_id ? 2 : 5;
		 m_bytes[3] &= ~(7 << ofs);
		 m_bytes[3] |= (t << ofs);
	  }

	  // Returned selector value ranges from 0-3 and is a direct index into g_etc1_inten_tables.
	  inline uint get_selector(uint x, uint y) const
	  {
		 RG_ETC1_ASSERT((x | y) < 4);

		 const uint bit_index = x * 4 + y;
		 const uint byte_bit_ofs = bit_index & 7;
		 const uint8 *p = &m_bytes[7 - (bit_index >> 3)];
		 const uint lsb = (p[0] >> byte_bit_ofs) & 1;
		 const uint msb = (p[-2] >> byte_bit_ofs) & 1;
		 const uint val = lsb | (msb << 1);

		 return g_etc1_to_selector_index[val];
	  }

	  // Selector "val" ranges from 0-3 and is a direct index into g_etc1_inten_tables.
	  inline void set_selector(uint x, uint y, uint val)
	  {
		 RG_ETC1_ASSERT((x | y | val) < 4);
		 const uint bit_index = x * 4 + y;

		 uint8 *p = &m_bytes[7 - (bit_index >> 3)];

		 const uint byte_bit_ofs = bit_index & 7;
		 const uint mask = 1 << byte_bit_ofs;

		 const uint etc1_val = g_selector_index_to_etc1[val];

		 const uint lsb = etc1_val & 1;
		 const uint msb = etc1_val >> 1;

		 p[0] &= ~mask;
		 p[0] |= (lsb << byte_bit_ofs);

		 p[-2] &= ~mask;
		 p[-2] |= (msb << byte_bit_ofs);
	  }

	  inline void set_base4_color(uint idx, uint16 c)
	  {
		 if (idx)
		 {
			set_byte_bits(cETC1AbsColor4R2BitOffset, 4, (c >> 8) & 15);
			set_byte_bits(cETC1AbsColor4G2BitOffset, 4, (c >> 4) & 15);
			set_byte_bits(cETC1AbsColor4B2BitOffset, 4, c & 15);
		 }
		 else
		 {
			set_byte_bits(cETC1AbsColor4R1BitOffset, 4, (c >> 8) & 15);
			set_byte_bits(cETC1AbsColor4G1BitOffset, 4, (c >> 4) & 15);
			set_byte_bits(cETC1AbsColor4B1BitOffset, 4, c & 15);
		 }
	  }

	  inline uint16 get_base4_color(uint idx) const
	  {
		 uint r, g, b;
		 if (idx)
		 {
			r = get_byte_bits(cETC1AbsColor4R2BitOffset, 4);
			g = get_byte_bits(cETC1AbsColor4G2BitOffset, 4);
			b = get_byte_bits(cETC1AbsColor4B2BitOffset, 4);
		 }
		 else
		 {
			r = get_byte_bits(cETC1AbsColor4R1BitOffset, 4);
			g = get_byte_bits(cETC1AbsColor4G1BitOffset, 4);
			b = get_byte_bits(cETC1AbsColor4B1BitOffset, 4);
		 }
		 return static_cast<uint16>(b | (g << 4U) | (r << 8U));
	  }

	  inline void set_base5_color(uint16 c)
	  {
		 set_byte_bits(cETC1BaseColor5RBitOffset, 5, (c >> 10) & 31);
		 set_byte_bits(cETC1BaseColor5GBitOffset, 5, (c >> 5) & 31);
		 set_byte_bits(cETC1BaseColor5BBitOffset, 5, c & 31);
	  }

	  inline uint16 get_base5_color() const
	  {
		 const uint r = get_byte_bits(cETC1BaseColor5RBitOffset, 5);
		 const uint g = get_byte_bits(cETC1BaseColor5GBitOffset, 5);
		 const uint b = get_byte_bits(cETC1BaseColor5BBitOffset, 5);
		 return static_cast<uint16>(b | (g << 5U) | (r << 10U));
	  }

	  void set_delta3_color(uint16 c)
	  {
		 set_byte_bits(cETC1DeltaColor3RBitOffset, 3, (c >> 6) & 7);
		 set_byte_bits(cETC1DeltaColor3GBitOffset, 3, (c >> 3) & 7);
		 set_byte_bits(cETC1DeltaColor3BBitOffset, 3, c & 7);
	  }

	  inline uint16 get_delta3_color() const
	  {
		 const uint r = get_byte_bits(cETC1DeltaColor3RBitOffset, 3);
		 const uint g = get_byte_bits(cETC1DeltaColor3GBitOffset, 3);
		 const uint b = get_byte_bits(cETC1DeltaColor3BBitOffset, 3);
		 return static_cast<uint16>(b | (g << 3U) | (r << 6U));
	  }

	  // Base color 5
	  static uint16 pack_color5(const color_quad_u8& color, bool scaled, uint bias = 127U);
	  static uint16 pack_color5(uint r, uint g, uint b, bool scaled, uint bias = 127U);

	  static color_quad_u8 unpack_color5(uint16 packed_color5, bool scaled, uint alpha = 255U);
	  static void unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color, bool scaled);

	  static bool unpack_color5(color_quad_u8& result, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha = 255U);
	  static bool unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha = 255U);

	  // Delta color 3
	  // Inputs range from -4 to 3 (cETC1ColorDeltaMin to cETC1ColorDeltaMax)
	  static uint16 pack_delta3(int r, int g, int b);

	  // Results range from -4 to 3 (cETC1ColorDeltaMin to cETC1ColorDeltaMax)
	  static void unpack_delta3(int& r, int& g, int& b, uint16 packed_delta3);

	  // Abs color 4
	  static uint16 pack_color4(const color_quad_u8& color, bool scaled, uint bias = 127U);
	  static uint16 pack_color4(uint r, uint g, uint b, bool scaled, uint bias = 127U);

	  static color_quad_u8 unpack_color4(uint16 packed_color4, bool scaled, uint alpha = 255U);
	  static void unpack_color4(uint& r, uint& g, uint& b, uint16 packed_color4, bool scaled);

	  // subblock colors
	  static void get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint table_idx);
	  static bool get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint16 packed_delta3, uint table_idx);
	  static void get_abs_subblock_colors(color_quad_u8* pDst, uint16 packed_color4, uint table_idx);

	  static inline void unscaled_to_scaled_color(color_quad_u8& dst, const color_quad_u8& src, bool color4)
	  {
		 if (color4)
		 {
			dst.r = src.r | (src.r << 4);
			dst.g = src.g | (src.g << 4);
			dst.b = src.b | (src.b << 4);
		 }
		 else
		 {
			dst.r = (src.r >> 2) | (src.r << 3);
			dst.g = (src.g >> 2) | (src.g << 3);
			dst.b = (src.b >> 2) | (src.b << 3);
		 }
		 dst.a = src.a;
	  }
   };

   // Returns pointer to sorted array.
   template<typename T, typename Q>
   T* indirect_radix_sort(uint num_indices, T* pIndices0, T* pIndices1, const Q* pKeys, uint key_ofs, uint key_size, bool init_indices)
   {
	  RG_ETC1_ASSERT((key_ofs >= 0) && (key_ofs < sizeof(T)));
	  RG_ETC1_ASSERT((key_size >= 1) && (key_size <= 4));

	  if (init_indices)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + (num_indices >> 1) * 2;
		 uint i;
		 for (i = 0; p != q; p += 2, i += 2)
		 {
			p[0] = static_cast<T>(i);
			p[1] = static_cast<T>(i + 1);
		 }

		 if (num_indices & 1)
			*p = static_cast<T>(i);
	  }

	  uint hist[256 * 4];

	  memset(hist, 0, sizeof(hist[0]) * 256 * key_size);

#define RG_ETC1_GET_KEY(p) (*(const uint*)((const uint8*)(pKeys + *(p)) + key_ofs))
#define RG_ETC1_GET_KEY_FROM_INDEX(i) (*(const uint*)((const uint8*)(pKeys + (i)) + key_ofs))

	  if (key_size == 4)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + num_indices;
		 for ( ; p != q; p++)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[        key        & 0xFF]++;
			hist[256 + ((key >>  8) & 0xFF)]++;
			hist[512 + ((key >> 16) & 0xFF)]++;
			hist[768 + ((key >> 24) & 0xFF)]++;
		 }
	  }
	  else if (key_size == 3)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + num_indices;
		 for ( ; p != q; p++)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[        key        & 0xFF]++;
			hist[256 + ((key >>  8) & 0xFF)]++;
			hist[512 + ((key >> 16) & 0xFF)]++;
		 }
	  }
	  else if (key_size == 2)
	  {
		 T* p = pIndices0;
		 T* q = pIndices0 + (num_indices >> 1) * 2;

		 for ( ; p != q; p += 2)
		 {
			const uint key0 = RG_ETC1_GET_KEY(p);
			const uint key1 = RG_ETC1_GET_KEY(p+1);

			hist[        key0         & 0xFF]++;
			hist[256 + ((key0 >>  8) & 0xFF)]++;

			hist[        key1        & 0xFF]++;
			hist[256 + ((key1 >>  8) & 0xFF)]++;
		 }

		 if (num_indices & 1)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[        key        & 0xFF]++;
			hist[256 + ((key >>  8) & 0xFF)]++;
		 }
	  }
	  else
	  {
		 RG_ETC1_ASSERT(key_size == 1);
		 if (key_size != 1)
			return NULL;

		 T* p = pIndices0;
		 T* q = pIndices0 + (num_indices >> 1) * 2;

		 for ( ; p != q; p += 2)
		 {
			const uint key0 = RG_ETC1_GET_KEY(p);
			const uint key1 = RG_ETC1_GET_KEY(p+1);

			hist[key0 & 0xFF]++;
			hist[key1 & 0xFF]++;
		 }

		 if (num_indices & 1)
		 {
			const uint key = RG_ETC1_GET_KEY(p);

			hist[key & 0xFF]++;
		 }
	  }

	  T* pCur = pIndices0;
	  T* pNew = pIndices1;

	  for (uint pass = 0; pass < key_size; pass++)
	  {
		 const uint* pHist = &hist[pass << 8];

		 uint offsets[256];

		 uint cur_ofs = 0;
		 for (uint i = 0; i < 256; i += 2)
		 {
			offsets[i] = cur_ofs;
			cur_ofs += pHist[i];

			offsets[i+1] = cur_ofs;
			cur_ofs += pHist[i+1];
		 }

		 const uint pass_shift = pass << 3;

		 T* p = pCur;
		 T* q = pCur + (num_indices >> 1) * 2;

		 for ( ; p != q; p += 2)
		 {
			uint index0 = p[0];
			uint index1 = p[1];

			uint c0 = (RG_ETC1_GET_KEY_FROM_INDEX(index0) >> pass_shift) & 0xFF;
			uint c1 = (RG_ETC1_GET_KEY_FROM_INDEX(index1) >> pass_shift) & 0xFF;

			if (c0 == c1)
			{
			   uint dst_offset0 = offsets[c0];

			   offsets[c0] = dst_offset0 + 2;

			   pNew[dst_offset0] = static_cast<T>(index0);
			   pNew[dst_offset0 + 1] = static_cast<T>(index1);
			}
			else
			{
			   uint dst_offset0 = offsets[c0]++;
			   uint dst_offset1 = offsets[c1]++;

			   pNew[dst_offset0] = static_cast<T>(index0);
			   pNew[dst_offset1] = static_cast<T>(index1);
			}
		 }

		 if (num_indices & 1)
		 {
			uint index = *p;
			uint c = (RG_ETC1_GET_KEY_FROM_INDEX(index) >> pass_shift) & 0xFF;

			uint dst_offset = offsets[c];
			offsets[c] = dst_offset + 1;

			pNew[dst_offset] = static_cast<T>(index);
		 }

		 T* t = pCur;
		 pCur = pNew;
		 pNew = t;
	  }

	  return pCur;
   }

#undef RG_ETC1_GET_KEY
#undef RG_ETC1_GET_KEY_FROM_INDEX

   uint16 etc1_block::pack_color5(const color_quad_u8& color, bool scaled, uint bias)
   {
	  return pack_color5(color.r, color.g, color.b, scaled, bias);
   }

   uint16 etc1_block::pack_color5(uint r, uint g, uint b, bool scaled, uint bias)
   {
	  if (scaled)
	  {
		 r = (r * 31U + bias) / 255U;
		 g = (g * 31U + bias) / 255U;
		 b = (b * 31U + bias) / 255U;
	  }

	  r = rg_etc1::minimum(r, 31U);
	  g = rg_etc1::minimum(g, 31U);
	  b = rg_etc1::minimum(b, 31U);

	  return static_cast<uint16>(b | (g << 5U) | (r << 10U));
   }

   color_quad_u8 etc1_block::unpack_color5(uint16 packed_color5, bool scaled, uint alpha)
   {
	  uint b = packed_color5 & 31U;
	  uint g = (packed_color5 >> 5U) & 31U;
	  uint r = (packed_color5 >> 10U) & 31U;

	  if (scaled)
	  {
		 b = (b << 3U) | (b >> 2U);
		 g = (g << 3U) | (g >> 2U);
		 r = (r << 3U) | (r >> 2U);
	  }

	  return color_quad_u8(cNoClamp, r, g, b, rg_etc1::minimum(alpha, 255U));
   }

   void etc1_block::unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color5, bool scaled)
   {
	  color_quad_u8 c(unpack_color5(packed_color5, scaled, 0));
	  r = c.r;
	  g = c.g;
	  b = c.b;
   }

   bool etc1_block::unpack_color5(color_quad_u8& result, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha)
   {
	  int dc_r, dc_g, dc_b;
	  unpack_delta3(dc_r, dc_g, dc_b, packed_delta3);

	  int b = (packed_color5 & 31U) + dc_b;
	  int g = ((packed_color5 >> 5U) & 31U) + dc_g;
	  int r = ((packed_color5 >> 10U) & 31U) + dc_r;

	  bool success = true;
	  if (static_cast<uint>(r | g | b) > 31U)
	  {
		 success = false;
		 r = rg_etc1::clamp<int>(r, 0, 31);
		 g = rg_etc1::clamp<int>(g, 0, 31);
		 b = rg_etc1::clamp<int>(b, 0, 31);
	  }

	  if (scaled)
	  {
		 b = (b << 3U) | (b >> 2U);
		 g = (g << 3U) | (g >> 2U);
		 r = (r << 3U) | (r >> 2U);
	  }

	  result.set_noclamp_rgba(r, g, b, rg_etc1::minimum(alpha, 255U));
	  return success;
   }

   bool etc1_block::unpack_color5(uint& r, uint& g, uint& b, uint16 packed_color5, uint16 packed_delta3, bool scaled, uint alpha)
   {
	  color_quad_u8 result;
	  const bool success = unpack_color5(result, packed_color5, packed_delta3, scaled, alpha);
	  r = result.r;
	  g = result.g;
	  b = result.b;
	  return success;
   }

   uint16 etc1_block::pack_delta3(int r, int g, int b)
   {
	  RG_ETC1_ASSERT((r >= cETC1ColorDeltaMin) && (r <= cETC1ColorDeltaMax));
	  RG_ETC1_ASSERT((g >= cETC1ColorDeltaMin) && (g <= cETC1ColorDeltaMax));
	  RG_ETC1_ASSERT((b >= cETC1ColorDeltaMin) && (b <= cETC1ColorDeltaMax));
	  if (r < 0) r += 8;
	  if (g < 0) g += 8;
	  if (b < 0) b += 8;
	  return static_cast<uint16>(b | (g << 3) | (r << 6));
   }

   void etc1_block::unpack_delta3(int& r, int& g, int& b, uint16 packed_delta3)
   {
	  r = (packed_delta3 >> 6) & 7;
	  g = (packed_delta3 >> 3) & 7;
	  b = packed_delta3 & 7;
	  if (r >= 4) r -= 8;
	  if (g >= 4) g -= 8;
	  if (b >= 4) b -= 8;
   }

   uint16 etc1_block::pack_color4(const color_quad_u8& color, bool scaled, uint bias)
   {
	  return pack_color4(color.r, color.g, color.b, scaled, bias);
   }

   uint16 etc1_block::pack_color4(uint r, uint g, uint b, bool scaled, uint bias)
   {
	  if (scaled)
	  {
		 r = (r * 15U + bias) / 255U;
		 g = (g * 15U + bias) / 255U;
		 b = (b * 15U + bias) / 255U;
	  }

	  r = rg_etc1::minimum(r, 15U);
	  g = rg_etc1::minimum(g, 15U);
	  b = rg_etc1::minimum(b, 15U);

	  return static_cast<uint16>(b | (g << 4U) | (r << 8U));
   }

   color_quad_u8 etc1_block::unpack_color4(uint16 packed_color4, bool scaled, uint alpha)
   {
	  uint b = packed_color4 & 15U;
	  uint g = (packed_color4 >> 4U) & 15U;
	  uint r = (packed_color4 >> 8U) & 15U;

	  if (scaled)
	  {
		 b = (b << 4U) | b;
		 g = (g << 4U) | g;
		 r = (r << 4U) | r;
	  }

	  return color_quad_u8(cNoClamp, r, g, b, rg_etc1::minimum(alpha, 255U));
   }

   void etc1_block::unpack_color4(uint& r, uint& g, uint& b, uint16 packed_color4, bool scaled)
   {
	  color_quad_u8 c(unpack_color4(packed_color4, scaled, 0));
	  r = c.r;
	  g = c.g;
	  b = c.b;
   }

   void etc1_block::get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint table_idx)
   {
	  RG_ETC1_ASSERT(table_idx < cETC1IntenModifierValues);
	  const int *pInten_modifer_table = &g_etc1_inten_tables[table_idx][0];

	  uint r, g, b;
	  unpack_color5(r, g, b, packed_color5, true);

	  const int ir = static_cast<int>(r), ig = static_cast<int>(g), ib = static_cast<int>(b);

	  const int y0 = pInten_modifer_table[0];
	  pDst[0].set(ir + y0, ig + y0, ib + y0);

	  const int y1 = pInten_modifer_table[1];
	  pDst[1].set(ir + y1, ig + y1, ib + y1);

	  const int y2 = pInten_modifer_table[2];
	  pDst[2].set(ir + y2, ig + y2, ib + y2);

	  const int y3 = pInten_modifer_table[3];
	  pDst[3].set(ir + y3, ig + y3, ib + y3);
   }

   bool etc1_block::get_diff_subblock_colors(color_quad_u8* pDst, uint16 packed_color5, uint16 packed_delta3, uint table_idx)
   {
	  RG_ETC1_ASSERT(table_idx < cETC1IntenModifierValues);
	  const int *pInten_modifer_table = &g_etc1_inten_tables[table_idx][0];

	  uint r, g, b;
	  bool success = unpack_color5(r, g, b, packed_color5, packed_delta3, true);

	  const int ir = static_cast<int>(r), ig = static_cast<int>(g), ib = static_cast<int>(b);

	  const int y0 = pInten_modifer_table[0];
	  pDst[0].set(ir + y0, ig + y0, ib + y0);

	  const int y1 = pInten_modifer_table[1];
	  pDst[1].set(ir + y1, ig + y1, ib + y1);

	  const int y2 = pInten_modifer_table[2];
	  pDst[2].set(ir + y2, ig + y2, ib + y2);

	  const int y3 = pInten_modifer_table[3];
	  pDst[3].set(ir + y3, ig + y3, ib + y3);

	  return success;
   }

   void etc1_block::get_abs_subblock_colors(color_quad_u8* pDst, uint16 packed_color4, uint table_idx)
   {
	  RG_ETC1_ASSERT(table_idx < cETC1IntenModifierValues);
	  const int *pInten_modifer_table = &g_etc1_inten_tables[table_idx][0];

	  uint r, g, b;
	  unpack_color4(r, g, b, packed_color4, true);

	  const int ir = static_cast<int>(r), ig = static_cast<int>(g), ib = static_cast<int>(b);

	  const int y0 = pInten_modifer_table[0];
	  pDst[0].set(ir + y0, ig + y0, ib + y0);

	  const int y1 = pInten_modifer_table[1];
	  pDst[1].set(ir + y1, ig + y1, ib + y1);

	  const int y2 = pInten_modifer_table[2];
	  pDst[2].set(ir + y2, ig + y2, ib + y2);

	  const int y3 = pInten_modifer_table[3];
	  pDst[3].set(ir + y3, ig + y3, ib + y3);
   }

   bool unpack_etc1_block(const void* pETC1_block, unsigned int* pDst_pixels_rgba, bool preserve_alpha)
   {
	  color_quad_u8* pDst = reinterpret_cast<color_quad_u8*>(pDst_pixels_rgba);
	  const etc1_block& block = *static_cast<const etc1_block*>(pETC1_block);

	  const bool diff_flag = block.get_diff_bit();
	  const bool flip_flag = block.get_flip_bit();
	  const uint table_index0 = block.get_inten_table(0);
	  const uint table_index1 = block.get_inten_table(1);

	  color_quad_u8 subblock_colors0[4];
	  color_quad_u8 subblock_colors1[4];
	  bool success = true;

	  if (diff_flag)
	  {
		 const uint16 base_color5 = block.get_base5_color();
		 const uint16 delta_color3 = block.get_delta3_color();
		 etc1_block::get_diff_subblock_colors(subblock_colors0, base_color5, table_index0);

		 if (!etc1_block::get_diff_subblock_colors(subblock_colors1, base_color5, delta_color3, table_index1))
			success = false;
	  }
	  else
	  {
		 const uint16 base_color4_0 = block.get_base4_color(0);
		 etc1_block::get_abs_subblock_colors(subblock_colors0, base_color4_0, table_index0);

		 const uint16 base_color4_1 = block.get_base4_color(1);
		 etc1_block::get_abs_subblock_colors(subblock_colors1, base_color4_1, table_index1);
	  }

	  if (preserve_alpha)
	  {
		 if (flip_flag)
		 {
			for (uint y = 0; y < 2; y++)
			{
			   pDst[0].set_rgb(subblock_colors0[block.get_selector(0, y)]);
			   pDst[1].set_rgb(subblock_colors0[block.get_selector(1, y)]);
			   pDst[2].set_rgb(subblock_colors0[block.get_selector(2, y)]);
			   pDst[3].set_rgb(subblock_colors0[block.get_selector(3, y)]);
			   pDst += 4;
			}

			for (uint y = 2; y < 4; y++)
			{
			   pDst[0].set_rgb(subblock_colors1[block.get_selector(0, y)]);
			   pDst[1].set_rgb(subblock_colors1[block.get_selector(1, y)]);
			   pDst[2].set_rgb(subblock_colors1[block.get_selector(2, y)]);
			   pDst[3].set_rgb(subblock_colors1[block.get_selector(3, y)]);
			   pDst += 4;
			}
		 }
		 else
		 {
			for (uint y = 0; y < 4; y++)
			{
			   pDst[0].set_rgb(subblock_colors0[block.get_selector(0, y)]);
			   pDst[1].set_rgb(subblock_colors0[block.get_selector(1, y)]);
			   pDst[2].set_rgb(subblock_colors1[block.get_selector(2, y)]);
			   pDst[3].set_rgb(subblock_colors1[block.get_selector(3, y)]);
			   pDst += 4;
			}
		 }
	  }
	  else
	  {
		 if (flip_flag)
		 {
			// 0000
			// 0000
			// 1111
			// 1111
			for (uint y = 0; y < 2; y++)
			{
			   pDst[0] = subblock_colors0[block.get_selector(0, y)];
			   pDst[1] = subblock_colors0[block.get_selector(1, y)];
			   pDst[2] = subblock_colors0[block.get_selector(2, y)];
			   pDst[3] = subblock_colors0[block.get_selector(3, y)];
			   pDst += 4;
			}

			for (uint y = 2; y < 4; y++)
			{
			   pDst[0] = subblock_colors1[block.get_selector(0, y)];
			   pDst[1] = subblock_colors1[block.get_selector(1, y)];
			   pDst[2] = subblock_colors1[block.get_selector(2, y)];
			   pDst[3] = subblock_colors1[block.get_selector(3, y)];
			   pDst += 4;
			}
		 }
		 else
		 {
			// 0011
			// 0011
			// 0011
			// 0011
			for (uint y = 0; y < 4; y++)
			{
			   pDst[0] = subblock_colors0[block.get_selector(0, y)];
			   pDst[1] = subblock_colors0[block.get_selector(1, y)];
			   pDst[2] = subblock_colors1[block.get_selector(2, y)];
			   pDst[3] = subblock_colors1[block.get_selector(3, y)];
			   pDst += 4;
			}
		 }
	  }

	  return success;
   }

   struct etc1_solution_coordinates
   {
	  inline etc1_solution_coordinates() :
	  m_unscaled_color(0, 0, 0, 0),
		 m_inten_table(0),
		 m_color4(false)
	  {
	  }

	  inline etc1_solution_coordinates(uint r, uint g, uint b, uint inten_table, bool color4) :
	  m_unscaled_color(r, g, b, 255),
		 m_inten_table(inten_table),
		 m_color4(color4)
	  {
	  }

	  inline etc1_solution_coordinates(const color_quad_u8& c, uint inten_table, bool color4) :
	  m_unscaled_color(c),
		 m_inten_table(inten_table),
		 m_color4(color4)
	  {
	  }

	  inline etc1_solution_coordinates(const etc1_solution_coordinates& other)
	  {
		 *this = other;
	  }

	  inline etc1_solution_coordinates& operator= (const etc1_solution_coordinates& rhs)
	  {
		 m_unscaled_color = rhs.m_unscaled_color;
		 m_inten_table = rhs.m_inten_table;
		 m_color4 = rhs.m_color4;
		 return *this;
	  }

	  inline void clear()
	  {
		 m_unscaled_color.clear();
		 m_inten_table = 0;
		 m_color4 = false;
	  }

	  inline color_quad_u8 get_scaled_color() const
	  {
		 int br, bg, bb;
		 if (m_color4)
		 {
			br = m_unscaled_color.r | (m_unscaled_color.r << 4);
			bg = m_unscaled_color.g | (m_unscaled_color.g << 4);
			bb = m_unscaled_color.b | (m_unscaled_color.b << 4);
		 }
		 else
		 {
			br = (m_unscaled_color.r >> 2) | (m_unscaled_color.r << 3);
			bg = (m_unscaled_color.g >> 2) | (m_unscaled_color.g << 3);
			bb = (m_unscaled_color.b >> 2) | (m_unscaled_color.b << 3);
		 }
		 return color_quad_u8(br, bg, bb);
	  }

	  inline void get_block_colors(color_quad_u8* pBlock_colors)
	  {
		 int br, bg, bb;
		 if (m_color4)
		 {
			br = m_unscaled_color.r | (m_unscaled_color.r << 4);
			bg = m_unscaled_color.g | (m_unscaled_color.g << 4);
			bb = m_unscaled_color.b | (m_unscaled_color.b << 4);
		 }
		 else
		 {
			br = (m_unscaled_color.r >> 2) | (m_unscaled_color.r << 3);
			bg = (m_unscaled_color.g >> 2) | (m_unscaled_color.g << 3);
			bb = (m_unscaled_color.b >> 2) | (m_unscaled_color.b << 3);
		 }
		 const int* pInten_table = g_etc1_inten_tables[m_inten_table];
		 pBlock_colors[0].set(br + pInten_table[0], bg + pInten_table[0], bb + pInten_table[0]);
		 pBlock_colors[1].set(br + pInten_table[1], bg + pInten_table[1], bb + pInten_table[1]);
		 pBlock_colors[2].set(br + pInten_table[2], bg + pInten_table[2], bb + pInten_table[2]);
		 pBlock_colors[3].set(br + pInten_table[3], bg + pInten_table[3], bb + pInten_table[3]);
	  }

	  color_quad_u8 m_unscaled_color;
	  uint m_inten_table;
	  bool m_color4;
   };

   class etc1_optimizer
   {
	  etc1_optimizer(const etc1_optimizer&);
	  etc1_optimizer& operator= (const etc1_optimizer&);

   public:
	  etc1_optimizer()
	  {
		 clear();
	  }

	  void clear()
	  {
		 m_pParams = NULL;
		 m_pResult = NULL;
		 m_pSorted_luma = NULL;
		 m_pSorted_luma_indices = NULL;
	  }

	  struct params : etc1_pack_params
	  {
		 params()
		 {
			clear();
		 }

		 params(const etc1_pack_params& base_params) :
		 etc1_pack_params(base_params)
		 {
			clear_optimizer_params();
		 }

		 void clear()
		 {
			etc1_pack_params::clear();
			clear_optimizer_params();
		 }

		 void clear_optimizer_params()
		 {
			m_num_src_pixels = 0;
			m_pSrc_pixels = 0;

			m_use_color4 = false;
			static const int s_default_scan_delta[] = { 0 };
			m_pScan_deltas = s_default_scan_delta;
			m_scan_delta_size = 1;

			m_base_color5.clear();
			m_constrain_against_base_color5 = false;
		 }

		 uint m_num_src_pixels;
		 const color_quad_u8* m_pSrc_pixels;

		 bool m_use_color4;
		 const int* m_pScan_deltas;
		 uint m_scan_delta_size;

		 color_quad_u8 m_base_color5;
		 bool m_constrain_against_base_color5;
	  };

	  struct results
	  {
		 uint64 m_error;
		 color_quad_u8 m_block_color_unscaled;
		 uint m_block_inten_table;
		 uint m_n;
		 uint8* m_pSelectors;
		 bool m_block_color4;

		 inline results& operator= (const results& rhs)
		 {
			m_block_color_unscaled = rhs.m_block_color_unscaled;
			m_block_color4 = rhs.m_block_color4;
			m_block_inten_table = rhs.m_block_inten_table;
			m_error = rhs.m_error;
			RG_ETC1_ASSERT(m_n == rhs.m_n);
			memcpy(m_pSelectors, rhs.m_pSelectors, rhs.m_n);
			return *this;
		 }
	  };

	  void init(const params& params, results& result);
	  bool compute();

   private:
	  struct potential_solution
	  {
		 potential_solution() : m_coords(), m_error(cUINT64_MAX), m_valid(false)
		 {
		 }

		 etc1_solution_coordinates  m_coords;
		 uint8                      m_selectors[8];
		 uint64                     m_error;
		 bool                       m_valid;

		 void clear()
		 {
			m_coords.clear();
			m_error = cUINT64_MAX;
			m_valid = false;
		 }
	  };

	  const params* m_pParams;
	  results* m_pResult;

	  int m_limit;

	  vec3F m_avg_color;
	  int m_br, m_bg, m_bb;
	  uint16 m_luma[8];
	  uint32 m_sorted_luma[2][8];
	  const uint32* m_pSorted_luma_indices;
	  uint32* m_pSorted_luma;

	  uint8 m_selectors[8];
	  uint8 m_best_selectors[8];

	  potential_solution m_best_solution;
	  potential_solution m_trial_solution;
	  uint8 m_temp_selectors[8];

	  bool evaluate_solution(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution);
	  bool evaluate_solution_fast(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution);
   };

   bool etc1_optimizer::compute()
   {
	  const uint n = m_pParams->m_num_src_pixels;
	  const int scan_delta_size = m_pParams->m_scan_delta_size;

	  // Scan through a subset of the 3D lattice centered around the avg block color trying each 3D (555 or 444) lattice point as a potential block color.
	  // Each time a better solution is found try to refine the current solution's block color based of the current selectors and intensity table index.
	  for (int zdi = 0; zdi < scan_delta_size; zdi++)
	  {
		 const int zd = m_pParams->m_pScan_deltas[zdi];
		 const int mbb = m_bb + zd;
		 if (mbb < 0) continue; else if (mbb > m_limit) break;

		 for (int ydi = 0; ydi < scan_delta_size; ydi++)
		 {
			const int yd = m_pParams->m_pScan_deltas[ydi];
			const int mbg = m_bg + yd;
			if (mbg < 0) continue; else if (mbg > m_limit) break;

			for (int xdi = 0; xdi < scan_delta_size; xdi++)
			{
			   const int xd = m_pParams->m_pScan_deltas[xdi];
			   const int mbr = m_br + xd;
			   if (mbr < 0) continue; else if (mbr > m_limit) break;

			   etc1_solution_coordinates coords(mbr, mbg, mbb, 0, m_pParams->m_use_color4);
			   if (m_pParams->m_quality == cHighQuality)
			   {
				  if (!evaluate_solution(coords, m_trial_solution, &m_best_solution))
					 continue;
			   }
			   else
			   {
				  if (!evaluate_solution_fast(coords, m_trial_solution, &m_best_solution))
					 continue;
			   }

			   // Now we have the input block, the avg. color of the input pixels, a set of trial selector indices, and the block color+intensity index.
			   // Now, for each component, attempt to refine the current solution by solving a simple linear equation. For example, for 4 colors:
			   // The goal is:
			   // pixel0 - (block_color+inten_table[selector0]) + pixel1 - (block_color+inten_table[selector1]) + pixel2 - (block_color+inten_table[selector2]) + pixel3 - (block_color+inten_table[selector3]) = 0
			   // Rearranging this:
			   // (pixel0 + pixel1 + pixel2 + pixel3) - (block_color+inten_table[selector0]) - (block_color+inten_table[selector1]) - (block_color+inten_table[selector2]) - (block_color+inten_table[selector3]) = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3) - block_color - inten_table[selector0] - block_color-inten_table[selector1] - block_color-inten_table[selector2] - block_color-inten_table[selector3] = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3) - 4*block_color - inten_table[selector0] - inten_table[selector1] - inten_table[selector2] - inten_table[selector3] = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3) - 4*block_color - (inten_table[selector0] + inten_table[selector1] + inten_table[selector2] + inten_table[selector3]) = 0
			   // (pixel0 + pixel1 + pixel2 + pixel3)/4 - block_color - (inten_table[selector0] + inten_table[selector1] + inten_table[selector2] + inten_table[selector3])/4 = 0
			   // block_color = (pixel0 + pixel1 + pixel2 + pixel3)/4 - (inten_table[selector0] + inten_table[selector1] + inten_table[selector2] + inten_table[selector3])/4
			   // So what this means:
			   // optimal_block_color = avg_input - avg_inten_delta
			   // So the optimal block color can be computed by taking the average block color and subtracting the current average of the intensity delta.
			   // Unfortunately, optimal_block_color must then be quantized to 555 or 444 so it's not always possible to improve matters using this formula.
			   // Also, the above formula is for unclamped intensity deltas. The actual implementation takes into account clamping.

			   const uint max_refinement_trials = (m_pParams->m_quality == cLowQuality) ? 2 : (((xd | yd | zd) == 0) ? 4 : 2);
			   for (uint refinement_trial = 0; refinement_trial < max_refinement_trials; refinement_trial++)
			   {
				  const uint8* pSelectors = m_best_solution.m_selectors;
				  const int* pInten_table = g_etc1_inten_tables[m_best_solution.m_coords.m_inten_table];

				  int delta_sum_r = 0, delta_sum_g = 0, delta_sum_b = 0;
				  const color_quad_u8 base_color(m_best_solution.m_coords.get_scaled_color());
				  for (uint r = 0; r < n; r++)
				  {
					 const uint s = *pSelectors++;
					 const int yd = pInten_table[s];
					 // Compute actual delta being applied to each pixel, taking into account clamping.
					 delta_sum_r += rg_etc1::clamp<int>(base_color.r + yd, 0, 255) - base_color.r;
					 delta_sum_g += rg_etc1::clamp<int>(base_color.g + yd, 0, 255) - base_color.g;
					 delta_sum_b += rg_etc1::clamp<int>(base_color.b + yd, 0, 255) - base_color.b;
				  }
				  if ((!delta_sum_r) && (!delta_sum_g) && (!delta_sum_b))
					 break;
				  const float avg_delta_r_f = static_cast<float>(delta_sum_r) / n;
				  const float avg_delta_g_f = static_cast<float>(delta_sum_g) / n;
				  const float avg_delta_b_f = static_cast<float>(delta_sum_b) / n;
				  const int br1 = rg_etc1::clamp<int>(static_cast<uint>((m_avg_color[0] - avg_delta_r_f) * m_limit / 255.0f + .5f), 0, m_limit);
				  const int bg1 = rg_etc1::clamp<int>(static_cast<uint>((m_avg_color[1] - avg_delta_g_f) * m_limit / 255.0f + .5f), 0, m_limit);
				  const int bb1 = rg_etc1::clamp<int>(static_cast<uint>((m_avg_color[2] - avg_delta_b_f) * m_limit / 255.0f + .5f), 0, m_limit);

				  bool skip = false;

				  if ((mbr == br1) && (mbg == bg1) && (mbb == bb1))
					 skip = true;
				  else if ((br1 == m_best_solution.m_coords.m_unscaled_color.r) && (bg1 == m_best_solution.m_coords.m_unscaled_color.g) && (bb1 == m_best_solution.m_coords.m_unscaled_color.b))
					 skip = true;
				  else if ((m_br == br1) && (m_bg == bg1) && (m_bb == bb1))
					 skip = true;

				  if (skip)
					 break;

				  etc1_solution_coordinates coords1(br1, bg1, bb1, 0, m_pParams->m_use_color4);
				  if (m_pParams->m_quality == cHighQuality)
				  {
					 if (!evaluate_solution(coords1, m_trial_solution, &m_best_solution))
						break;
				  }
				  else
				  {
					 if (!evaluate_solution_fast(coords1, m_trial_solution, &m_best_solution))
						break;
				  }

			   }  // refinement_trial

			} // xdi
		 } // ydi
	  } // zdi

	  if (!m_best_solution.m_valid)
	  {
		 m_pResult->m_error = cUINT32_MAX;
		 return false;
	  }

	  const uint8* pSelectors = m_best_solution.m_selectors;

#ifdef RG_ETC1_BUILD_DEBUG
	  {
		 color_quad_u8 block_colors[4];
		 m_best_solution.m_coords.get_block_colors(block_colors);

		 const color_quad_u8* pSrc_pixels = m_pParams->m_pSrc_pixels;
		 uint64 actual_error = 0;
		 for (uint i = 0; i < n; i++)
			actual_error += pSrc_pixels[i].squared_distance_rgb(block_colors[pSelectors[i]]);

		 RG_ETC1_ASSERT(actual_error == m_best_solution.m_error);
	  }
#endif

	  m_pResult->m_error = m_best_solution.m_error;

	  m_pResult->m_block_color_unscaled = m_best_solution.m_coords.m_unscaled_color;
	  m_pResult->m_block_color4 = m_best_solution.m_coords.m_color4;

	  m_pResult->m_block_inten_table = m_best_solution.m_coords.m_inten_table;
	  memcpy(m_pResult->m_pSelectors, pSelectors, n);
	  m_pResult->m_n = n;

	  return true;
   }

   void etc1_optimizer::init(const params& p, results& r)
   {
	  // This version is hardcoded for 8 pixel subblocks.
	  RG_ETC1_ASSERT(p.m_num_src_pixels == 8);

	  m_pParams = &p;
	  m_pResult = &r;

	  const uint n = 8;

	  m_limit = m_pParams->m_use_color4 ? 15 : 31;

	  vec3F avg_color(0.0f);

	  for (uint i = 0; i < n; i++)
	  {
		 const color_quad_u8& c = m_pParams->m_pSrc_pixels[i];
		 const vec3F fc(c.r, c.g, c.b);

		 avg_color += fc;

		 m_luma[i] = static_cast<uint16>(c.r + c.g + c.b);
		 m_sorted_luma[0][i] = i;
	  }
	  avg_color *= (1.0f / static_cast<float>(n));
	  m_avg_color = avg_color;

	  m_br = rg_etc1::clamp<int>(static_cast<uint>(m_avg_color[0] * m_limit / 255.0f + .5f), 0, m_limit);
	  m_bg = rg_etc1::clamp<int>(static_cast<uint>(m_avg_color[1] * m_limit / 255.0f + .5f), 0, m_limit);
	  m_bb = rg_etc1::clamp<int>(static_cast<uint>(m_avg_color[2] * m_limit / 255.0f + .5f), 0, m_limit);

	  if (m_pParams->m_quality <= cMediumQuality)
	  {
		 m_pSorted_luma_indices = indirect_radix_sort(n, m_sorted_luma[0], m_sorted_luma[1], m_luma, 0, sizeof(m_luma[0]), false);
		 m_pSorted_luma = m_sorted_luma[0];
		 if (m_pSorted_luma_indices == m_sorted_luma[0])
			m_pSorted_luma = m_sorted_luma[1];

		 for (uint i = 0; i < n; i++)
			m_pSorted_luma[i] = m_luma[m_pSorted_luma_indices[i]];
	  }

	  m_best_solution.m_coords.clear();
	  m_best_solution.m_valid = false;
	  m_best_solution.m_error = cUINT64_MAX;
   }

   bool etc1_optimizer::evaluate_solution(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution)
   {
	  trial_solution.m_valid = false;

	  if (m_pParams->m_constrain_against_base_color5)
	  {
		 const int dr = coords.m_unscaled_color.r - m_pParams->m_base_color5.r;
		 const int dg = coords.m_unscaled_color.g - m_pParams->m_base_color5.g;
		 const int db = coords.m_unscaled_color.b - m_pParams->m_base_color5.b;

		 if ((rg_etc1::minimum(dr, dg, db) < cETC1ColorDeltaMin) || (rg_etc1::maximum(dr, dg, db) > cETC1ColorDeltaMax))
			return false;
	  }

	  const color_quad_u8 base_color(coords.get_scaled_color());

	  const uint n = 8;

	  trial_solution.m_error = cUINT64_MAX;

	  for (uint inten_table = 0; inten_table < cETC1IntenModifierValues; inten_table++)
	  {
		 const int* pInten_table = g_etc1_inten_tables[inten_table];

		 color_quad_u8 block_colors[4];
		 for (uint s = 0; s < 4; s++)
		 {
			const int yd = pInten_table[s];
			block_colors[s].set(base_color.r + yd, base_color.g + yd, base_color.b + yd, 0);
		 }

		 uint64 total_error = 0;

		 const color_quad_u8* pSrc_pixels = m_pParams->m_pSrc_pixels;
		 for (uint c = 0; c < n; c++)
		 {
			const color_quad_u8& src_pixel = *pSrc_pixels++;

			uint best_selector_index = 0;
			uint best_error = rg_etc1::square(src_pixel.r - block_colors[0].r) + rg_etc1::square(src_pixel.g - block_colors[0].g) + rg_etc1::square(src_pixel.b - block_colors[0].b);

			uint trial_error = rg_etc1::square(src_pixel.r - block_colors[1].r) + rg_etc1::square(src_pixel.g - block_colors[1].g) + rg_etc1::square(src_pixel.b - block_colors[1].b);
			if (trial_error < best_error)
			{
			   best_error = trial_error;
			   best_selector_index = 1;
			}

			trial_error = rg_etc1::square(src_pixel.r - block_colors[2].r) + rg_etc1::square(src_pixel.g - block_colors[2].g) + rg_etc1::square(src_pixel.b - block_colors[2].b);
			if (trial_error < best_error)
			{
			   best_error = trial_error;
			   best_selector_index = 2;
			}

			trial_error = rg_etc1::square(src_pixel.r - block_colors[3].r) + rg_etc1::square(src_pixel.g - block_colors[3].g) + rg_etc1::square(src_pixel.b - block_colors[3].b);
			if (trial_error < best_error)
			{
			   best_error = trial_error;
			   best_selector_index = 3;
			}

			m_temp_selectors[c] = static_cast<uint8>(best_selector_index);

			total_error += best_error;
			if (total_error >= trial_solution.m_error)
			   break;
		 }

		 if (total_error < trial_solution.m_error)
		 {
			trial_solution.m_error = total_error;
			trial_solution.m_coords.m_inten_table = inten_table;
			memcpy(trial_solution.m_selectors, m_temp_selectors, 8);
			trial_solution.m_valid = true;
		 }
	  }
	  trial_solution.m_coords.m_unscaled_color = coords.m_unscaled_color;
	  trial_solution.m_coords.m_color4 = m_pParams->m_use_color4;

	  bool success = false;
	  if (pBest_solution)
	  {
		 if (trial_solution.m_error < pBest_solution->m_error)
		 {
			*pBest_solution = trial_solution;
			success = true;
		 }
	  }

	  return success;
   }

   bool etc1_optimizer::evaluate_solution_fast(const etc1_solution_coordinates& coords, potential_solution& trial_solution, potential_solution* pBest_solution)
   {
	  if (m_pParams->m_constrain_against_base_color5)
	  {
		 const int dr = coords.m_unscaled_color.r - m_pParams->m_base_color5.r;
		 const int dg = coords.m_unscaled_color.g - m_pParams->m_base_color5.g;
		 const int db = coords.m_unscaled_color.b - m_pParams->m_base_color5.b;

		 if ((rg_etc1::minimum(dr, dg, db) < cETC1ColorDeltaMin) || (rg_etc1::maximum(dr, dg, db) > cETC1ColorDeltaMax))
		 {
			trial_solution.m_valid = false;
			return false;
		 }
	  }

	  const color_quad_u8 base_color(coords.get_scaled_color());

	  const uint n = 8;

	  trial_solution.m_error = cUINT64_MAX;

	  for (int inten_table = cETC1IntenModifierValues - 1; inten_table >= 0; --inten_table)
	  {
		 const int* pInten_table = g_etc1_inten_tables[inten_table];

		 uint block_inten[4];
		 color_quad_u8 block_colors[4];
		 for (uint s = 0; s < 4; s++)
		 {
			const int yd = pInten_table[s];
			color_quad_u8 block_color(base_color.r + yd, base_color.g + yd, base_color.b + yd, 0);
			block_colors[s] = block_color;
			block_inten[s] = block_color.r + block_color.g + block_color.b;
		 }

		 // evaluate_solution_fast() enforces/assumesd a total ordering of the input colors along the intensity (1,1,1) axis to more quickly classify the inputs to selectors.
		 // The inputs colors have been presorted along the projection onto this axis, and ETC1 block colors are always ordered along the intensity axis, so this classification is fast.
		 // 0   1   2   3
		 //   01  12  23
		 const uint block_inten_midpoints[3] = { block_inten[0] + block_inten[1], block_inten[1] + block_inten[2], block_inten[2] + block_inten[3] };

		 uint64 total_error = 0;
		 const color_quad_u8* pSrc_pixels = m_pParams->m_pSrc_pixels;
		 if ((m_pSorted_luma[n - 1] * 2) < block_inten_midpoints[0])
		 {
			if (block_inten[0] > m_pSorted_luma[n - 1])
			{
			   const uint min_error = labs(block_inten[0] - m_pSorted_luma[n - 1]);
			   if (min_error >= trial_solution.m_error)
				  continue;
			}

			memset(&m_temp_selectors[0], 0, n);

			for (uint c = 0; c < n; c++)
			   total_error += block_colors[0].squared_distance_rgb(pSrc_pixels[c]);
		 }
		 else if ((m_pSorted_luma[0] * 2) >= block_inten_midpoints[2])
		 {
			if (m_pSorted_luma[0] > block_inten[3])
			{
			   const uint min_error = labs(m_pSorted_luma[0] - block_inten[3]);
			   if (min_error >= trial_solution.m_error)
				  continue;
			}

			memset(&m_temp_selectors[0], 3, n);

			for (uint c = 0; c < n; c++)
			   total_error += block_colors[3].squared_distance_rgb(pSrc_pixels[c]);
		 }
		 else
		 {
			uint cur_selector = 0, c;
			for (c = 0; c < n; c++)
			{
			   const uint y = m_pSorted_luma[c];
			   while ((y * 2) >= block_inten_midpoints[cur_selector])
				  if (++cur_selector > 2)
					 goto done;
			   const uint sorted_pixel_index = m_pSorted_luma_indices[c];
			   m_temp_selectors[sorted_pixel_index] = static_cast<uint8>(cur_selector);
			   total_error += block_colors[cur_selector].squared_distance_rgb(pSrc_pixels[sorted_pixel_index]);
			}
done:
			while (c < n)
			{
			   const uint sorted_pixel_index = m_pSorted_luma_indices[c];
			   m_temp_selectors[sorted_pixel_index] = 3;
			   total_error += block_colors[3].squared_distance_rgb(pSrc_pixels[sorted_pixel_index]);
			   ++c;
			}
		 }

		 if (total_error < trial_solution.m_error)
		 {
			trial_solution.m_error = total_error;
			trial_solution.m_coords.m_inten_table = inten_table;
			memcpy(trial_solution.m_selectors, m_temp_selectors, n);
			trial_solution.m_valid = true;
			if (!total_error)
			   break;
		 }
	  }
	  trial_solution.m_coords.m_unscaled_color = coords.m_unscaled_color;
	  trial_solution.m_coords.m_color4 = m_pParams->m_use_color4;

	  bool success = false;
	  if (pBest_solution)
	  {
		 if (trial_solution.m_error < pBest_solution->m_error)
		 {
			*pBest_solution = trial_solution;
			success = true;
		 }
	  }

	  return success;
   }

   static uint etc1_decode_value(uint diff, uint inten, uint selector, uint packed_c)
   {
	  const uint limit = diff ? 32 : 16; limit;
	  RG_ETC1_ASSERT((diff < 2) && (inten < 8) && (selector < 4) && (packed_c < limit));
	  int c;
	  if (diff)
		 c = (packed_c >> 2) | (packed_c << 3);
	  else
		 c = packed_c | (packed_c << 4);
	  c += g_etc1_inten_tables[inten][selector];
	  c = rg_etc1::clamp<int>(c, 0, 255);
	  return c;
   }

   static inline int mul_8bit(int a, int b) { int t = a*b + 128; return (t + (t >> 8)) >> 8; }

   void pack_etc1_block_init()
   {
	  for (uint diff = 0; diff < 2; diff++)
	  {
		 const uint limit = diff ? 32 : 16;

		 for (uint inten = 0; inten < 8; inten++)
		 {
			for (uint selector = 0; selector < 4; selector++)
			{
			   const uint inverse_table_index = diff + (inten << 1) + (selector << 4);
			   for (uint color = 0; color < 256; color++)
			   {
				  uint best_error = cUINT32_MAX, best_packed_c = 0;
				  for (uint packed_c = 0; packed_c < limit; packed_c++)
				  {
					 int v = etc1_decode_value(diff, inten, selector, packed_c);
					 uint err = labs(v - static_cast<int>(color));
					 if (err < best_error)
					 {
						best_error = err;
						best_packed_c = packed_c;
						if (!best_error)
						   break;
					 }
				  }
				  RG_ETC1_ASSERT(best_error <= 255);
				  g_etc1_inverse_lookup[inverse_table_index][color] = static_cast<uint16>(best_packed_c | (best_error << 8));
			   }
			}
		 }
	  }

	  uint expand5[32];
	  for(int i = 0; i < 32; i++)
		 expand5[i] = (i << 3) | (i >> 2);

	  for(int i = 0; i < 256 + 16; i++)
	  {
		 int v = clamp<int>(i - 8, 0, 255);
		 g_quant5_tab[i] = static_cast<uint8>(expand5[mul_8bit(v,31)]);
	  }
   }

   // Packs solid color blocks efficiently using a set of small precomputed tables.
   // For random 888 inputs, MSE results are better than Erricson's ETC1 packer in "slow" mode ~9.5% of the time, is slightly worse only ~.01% of the time, and is equal the rest of the time.
   static uint64 pack_etc1_block_solid_color(etc1_block& block, const uint8* pColor, etc1_pack_params& pack_params)
   {
	  pack_params;
	  RG_ETC1_ASSERT(g_etc1_inverse_lookup[0][255]);

	  static uint s_next_comp[4] = { 1, 2, 0, 1 };

	  uint best_error = cUINT32_MAX, best_i = 0;
	  int best_x = 0, best_packed_c1 = 0, best_packed_c2 = 0;

	  // For each possible 8-bit value, there is a precomputed list of diff/inten/selector configurations that allow that 8-bit value to be encoded with no error.
	  for (uint i = 0; i < 3; i++)
	  {
		 const uint c1 = pColor[s_next_comp[i]], c2 = pColor[s_next_comp[i + 1]];

		 const int delta_range = 1;
		 for (int delta = -delta_range; delta <= delta_range; delta++)
		 {
			const int c_plus_delta = rg_etc1::clamp<int>(pColor[i] + delta, 0, 255);

			const uint16* pTable;
			if (!c_plus_delta)
			   pTable = g_color8_to_etc_block_config_0_255[0];
			else if (c_plus_delta == 255)
			   pTable = g_color8_to_etc_block_config_0_255[1];
			else
			   pTable = g_color8_to_etc_block_config_1_to_254[c_plus_delta - 1];

			do
			{
			   const uint x = *pTable++;

#ifdef RG_ETC1_BUILD_DEBUG
			   const uint diff = x & 1;
			   const uint inten = (x >> 1) & 7;
			   const uint selector = (x >> 4) & 3;
			   const uint p0 = (x >> 8) & 255;
			   RG_ETC1_ASSERT(etc1_decode_value(diff, inten, selector, p0) == (uint)c_plus_delta);
#endif

			   const uint16* pInverse_table = g_etc1_inverse_lookup[x & 0xFF];
			   uint16 p1 = pInverse_table[c1];
			   uint16 p2 = pInverse_table[c2];
			   const uint trial_error = rg_etc1::square(c_plus_delta - pColor[i]) + rg_etc1::square(p1 >> 8) + rg_etc1::square(p2 >> 8);
			   if (trial_error < best_error)
			   {
				  best_error = trial_error;
				  best_x = x;
				  best_packed_c1 = p1 & 0xFF;
				  best_packed_c2 = p2 & 0xFF;
				  best_i = i;
				  if (!best_error)
					 goto found_perfect_match;
			   }
			} while (*pTable != 0xFFFF);
		 }
	  }
found_perfect_match:

	  const uint diff = best_x & 1;
	  const uint inten = (best_x >> 1) & 7;

	  block.m_bytes[3] = static_cast<uint8>(((inten | (inten << 3)) << 2) | (diff << 1));

	  const uint etc1_selector = g_selector_index_to_etc1[(best_x >> 4) & 3];
	  *reinterpret_cast<uint16*>(&block.m_bytes[4]) = (etc1_selector & 2) ? 0xFFFF : 0;
	  *reinterpret_cast<uint16*>(&block.m_bytes[6]) = (etc1_selector & 1) ? 0xFFFF : 0;

	  const uint best_packed_c0 = (best_x >> 8) & 255;
	  if (diff)
	  {
		 block.m_bytes[best_i] = static_cast<uint8>(best_packed_c0 << 3);
		 block.m_bytes[s_next_comp[best_i]] = static_cast<uint8>(best_packed_c1 << 3);
		 block.m_bytes[s_next_comp[best_i+1]] = static_cast<uint8>(best_packed_c2 << 3);
	  }
	  else
	  {
		 block.m_bytes[best_i] = static_cast<uint8>(best_packed_c0 | (best_packed_c0 << 4));
		 block.m_bytes[s_next_comp[best_i]] = static_cast<uint8>(best_packed_c1 | (best_packed_c1 << 4));
		 block.m_bytes[s_next_comp[best_i+1]] = static_cast<uint8>(best_packed_c2 | (best_packed_c2 << 4));
	  }

	  return best_error;
   }

   static uint pack_etc1_block_solid_color_constrained(
	  etc1_optimizer::results& results,
	  uint num_colors, const uint8* pColor,
	  etc1_pack_params& pack_params,
	  bool use_diff,
	  const color_quad_u8* pBase_color5_unscaled)
   {
	  RG_ETC1_ASSERT(g_etc1_inverse_lookup[0][255]);

	  pack_params;
	  static uint s_next_comp[4] = { 1, 2, 0, 1 };

	  uint best_error = cUINT32_MAX, best_i = 0;
	  int best_x = 0, best_packed_c1 = 0, best_packed_c2 = 0;

	  // For each possible 8-bit value, there is a precomputed list of diff/inten/selector configurations that allow that 8-bit value to be encoded with no error.
	  for (uint i = 0; i < 3; i++)
	  {
		 const uint c1 = pColor[s_next_comp[i]], c2 = pColor[s_next_comp[i + 1]];

		 const int delta_range = 1;
		 for (int delta = -delta_range; delta <= delta_range; delta++)
		 {
			const int c_plus_delta = rg_etc1::clamp<int>(pColor[i] + delta, 0, 255);

			const uint16* pTable;
			if (!c_plus_delta)
			   pTable = g_color8_to_etc_block_config_0_255[0];
			else if (c_plus_delta == 255)
			   pTable = g_color8_to_etc_block_config_0_255[1];
			else
			   pTable = g_color8_to_etc_block_config_1_to_254[c_plus_delta - 1];

			do
			{
			   const uint x = *pTable++;
			   const uint diff = x & 1;
			   if (static_cast<uint>(use_diff) != diff)
			   {
				  if (*pTable == 0xFFFF)
					 break;
				  continue;
			   }

			   if ((diff) && (pBase_color5_unscaled))
			   {
				  const int p0 = (x >> 8) & 255;
				  int delta = p0 - static_cast<int>(pBase_color5_unscaled->c[i]);
				  if ((delta < cETC1ColorDeltaMin) || (delta > cETC1ColorDeltaMax))
				  {
					 if (*pTable == 0xFFFF)
						break;
					 continue;
				  }
			   }

#ifdef RG_ETC1_BUILD_DEBUG
			   {
				  const uint inten = (x >> 1) & 7;
				  const uint selector = (x >> 4) & 3;
				  const uint p0 = (x >> 8) & 255;
				  RG_ETC1_ASSERT(etc1_decode_value(diff, inten, selector, p0) == (uint)c_plus_delta);
			   }
#endif

			   const uint16* pInverse_table = g_etc1_inverse_lookup[x & 0xFF];
			   uint16 p1 = pInverse_table[c1];
			   uint16 p2 = pInverse_table[c2];

			   if ((diff) && (pBase_color5_unscaled))
			   {
				  int delta1 = (p1 & 0xFF) - static_cast<int>(pBase_color5_unscaled->c[s_next_comp[i]]);
				  int delta2 = (p2 & 0xFF) - static_cast<int>(pBase_color5_unscaled->c[s_next_comp[i + 1]]);
				  if ((delta1 < cETC1ColorDeltaMin) || (delta1 > cETC1ColorDeltaMax) || (delta2 < cETC1ColorDeltaMin) || (delta2 > cETC1ColorDeltaMax))
				  {
					 if (*pTable == 0xFFFF)
						break;
					 continue;
				  }
			   }

			   const uint trial_error = rg_etc1::square(c_plus_delta - pColor[i]) + rg_etc1::square(p1 >> 8) + rg_etc1::square(p2 >> 8);
			   if (trial_error < best_error)
			   {
				  best_error = trial_error;
				  best_x = x;
				  best_packed_c1 = p1 & 0xFF;
				  best_packed_c2 = p2 & 0xFF;
				  best_i = i;
				  if (!best_error)
					 goto found_perfect_match;
			   }
			} while (*pTable != 0xFFFF);
		 }
	  }
found_perfect_match:

	  if (best_error == cUINT32_MAX)
		 return best_error;

	  best_error *= num_colors;

	  results.m_n = num_colors;
	  results.m_block_color4 = !(best_x & 1);
	  results.m_block_inten_table = (best_x >> 1) & 7;
	  memset(results.m_pSelectors, (best_x >> 4) & 3, num_colors);

	  const uint best_packed_c0 = (best_x >> 8) & 255;
	  results.m_block_color_unscaled[best_i] = static_cast<uint8>(best_packed_c0);
	  results.m_block_color_unscaled[s_next_comp[best_i]] = static_cast<uint8>(best_packed_c1);
	  results.m_block_color_unscaled[s_next_comp[best_i + 1]] = static_cast<uint8>(best_packed_c2);
	  results.m_error = best_error;

	  return best_error;
   }

   // Function originally from RYG's public domain real-time DXT1 compressor, modified for 555.
   static void dither_block_555(color_quad_u8* dest, const color_quad_u8* block)
   {
	  int err[8],*ep1 = err,*ep2 = err+4;
	  uint8 *quant = g_quant5_tab+8;

	  memset(dest, 0xFF, sizeof(color_quad_u8)*16);

	  // process channels seperately
	  for(int ch=0;ch<3;ch++)
	  {
		 uint8* bp = (uint8*)block;
		 uint8* dp = (uint8*)dest;

		 bp += ch; dp += ch;

		 memset(err,0, sizeof(err));
		 for(int y = 0; y < 4; y++)
		 {
			// pixel 0
			dp[ 0] = quant[bp[ 0] + ((3*ep2[1] + 5*ep2[0]) >> 4)];
			ep1[0] = bp[ 0] - dp[ 0];

			// pixel 1
			dp[ 4] = quant[bp[ 4] + ((7*ep1[0] + 3*ep2[2] + 5*ep2[1] + ep2[0]) >> 4)];
			ep1[1] = bp[ 4] - dp[ 4];

			// pixel 2
			dp[ 8] = quant[bp[ 8] + ((7*ep1[1] + 3*ep2[3] + 5*ep2[2] + ep2[1]) >> 4)];
			ep1[2] = bp[ 8] - dp[ 8];

			// pixel 3
			dp[12] = quant[bp[12] + ((7*ep1[2] + 5*ep2[3] + ep2[2]) >> 4)];
			ep1[3] = bp[12] - dp[12];

			// advance to next line
			int* tmp = ep1; ep1 = ep2; ep2 = tmp;
			bp += 16;
			dp += 16;
		 }
	  }
   }

   unsigned int pack_etc1_block(void* pETC1_block, const unsigned int* pSrc_pixels_rgba, etc1_pack_params& pack_params)
   {
	  const color_quad_u8* pSrc_pixels = reinterpret_cast<const color_quad_u8*>(pSrc_pixels_rgba);
	  etc1_block& dst_block = *static_cast<etc1_block*>(pETC1_block);

#ifdef RG_ETC1_BUILD_DEBUG
	  // Ensure all alpha values are 0xFF.
	  for (uint i = 0; i < 16; i++)
	  {
		 RG_ETC1_ASSERT(pSrc_pixels[i].a == 255);
	  }
#endif

	  color_quad_u8 src_pixel0(pSrc_pixels[0]);

	  // Check for solid block.
	  const uint32 first_pixel_u32 = pSrc_pixels->m_u32;
	  int r;
	  for (r = 15; r >= 1; --r)
		 if (pSrc_pixels[r].m_u32 != first_pixel_u32)
			break;
	  if (!r)
		 return static_cast<unsigned int>(16 * pack_etc1_block_solid_color(dst_block, &pSrc_pixels[0].r, pack_params));

	  color_quad_u8 dithered_pixels[16];
	  if (pack_params.m_dithering)
	  {
		 dither_block_555(dithered_pixels, pSrc_pixels);
		 pSrc_pixels = dithered_pixels;
	  }

	  etc1_optimizer optimizer;

	  uint64 best_error = cUINT64_MAX;
	  uint best_flip = false, best_use_color4 = false;

	  uint8 best_selectors[2][8];
	  etc1_optimizer::results best_results[2];
	  for (uint i = 0; i < 2; i++)
	  {
		 best_results[i].m_n = 8;
		 best_results[i].m_pSelectors = best_selectors[i];
	  }

	  uint8 selectors[3][8];
	  etc1_optimizer::results results[3];

	  for (uint i = 0; i < 3; i++)
	  {
		 results[i].m_n = 8;
		 results[i].m_pSelectors = selectors[i];
	  }

	  color_quad_u8 subblock_pixels[8];

	  etc1_optimizer::params params(pack_params);
	  params.m_num_src_pixels = 8;
	  params.m_pSrc_pixels = subblock_pixels;

	  for (uint flip = 0; flip < 2; flip++)
	  {
		 for (uint use_color4 = 0; use_color4 < 2; use_color4++)
		 {
			uint64 trial_error = 0;

			uint subblock;
			for (subblock = 0; subblock < 2; subblock++)
			{
			   if (flip)
				  memcpy(subblock_pixels, pSrc_pixels + subblock * 8, sizeof(color_quad_u8) * 8);
			   else
			   {
				  const color_quad_u8* pSrc_col = pSrc_pixels + subblock * 2;
				  subblock_pixels[0] = pSrc_col[0]; subblock_pixels[1] = pSrc_col[4]; subblock_pixels[2] = pSrc_col[8]; subblock_pixels[3] = pSrc_col[12];
				  subblock_pixels[4] = pSrc_col[1]; subblock_pixels[5] = pSrc_col[5]; subblock_pixels[6] = pSrc_col[9]; subblock_pixels[7] = pSrc_col[13];
			   }

			   results[2].m_error = cUINT64_MAX;
			   if ((params.m_quality >= cMediumQuality) && ((subblock) || (use_color4)))
			   {
				  const uint32 subblock_pixel0_u32 = subblock_pixels[0].m_u32;
				  for (r = 7; r >= 1; --r)
					 if (subblock_pixels[r].m_u32 != subblock_pixel0_u32)
						break;
				  if (!r)
				  {
					 pack_etc1_block_solid_color_constrained(results[2], 8, &subblock_pixels[0].r, pack_params, !use_color4, (subblock && !use_color4) ? &results[0].m_block_color_unscaled : NULL);
				  }
			   }

			   params.m_use_color4 = (use_color4 != 0);
			   params.m_constrain_against_base_color5 = false;

			   if ((!use_color4) && (subblock))
			   {
				  params.m_constrain_against_base_color5 = true;
				  params.m_base_color5 = results[0].m_block_color_unscaled;
			   }

			   if (params.m_quality == cHighQuality)
			   {
				  static const int s_scan_delta_0_to_4[] = { -4, -3, -2, -1, 0, 1, 2, 3, 4 };
				  params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_0_to_4);
				  params.m_pScan_deltas = s_scan_delta_0_to_4;
			   }
			   else if (params.m_quality == cMediumQuality)
			   {
				  static const int s_scan_delta_0_to_1[] = { -1, 0, 1 };
				  params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_0_to_1);
				  params.m_pScan_deltas = s_scan_delta_0_to_1;
			   }
			   else
			   {
				  static const int s_scan_delta_0[] = { 0 };
				  params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_0);
				  params.m_pScan_deltas = s_scan_delta_0;
			   }

			   optimizer.init(params, results[subblock]);
			   if (!optimizer.compute())
				  break;

			   if (params.m_quality >= cMediumQuality)
			   {
				  // TODO: Fix fairly arbitrary/unrefined thresholds that control how far away to scan for potentially better solutions.
				  const uint refinement_error_thresh0 = 3000;
				  const uint refinement_error_thresh1 = 6000;
				  if (results[subblock].m_error > refinement_error_thresh0)
				  {
					 if (params.m_quality == cMediumQuality)
					 {
						static const int s_scan_delta_2_to_3[] = { -3, -2, 2, 3 };
						params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_2_to_3);
						params.m_pScan_deltas = s_scan_delta_2_to_3;
					 }
					 else
					 {
						static const int s_scan_delta_5_to_5[] = { -5, 5 };
						static const int s_scan_delta_5_to_8[] = { -8, -7, -6, -5, 5, 6, 7, 8 };
						if (results[subblock].m_error > refinement_error_thresh1)
						{
						   params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_5_to_8);
						   params.m_pScan_deltas = s_scan_delta_5_to_8;
						}
						else
						{
						   params.m_scan_delta_size = RG_ETC1_ARRAY_SIZE(s_scan_delta_5_to_5);
						   params.m_pScan_deltas = s_scan_delta_5_to_5;
						}
					 }

					 if (!optimizer.compute())
						break;
				  }

				  if (results[2].m_error < results[subblock].m_error)
					 results[subblock] = results[2];
			   }

			   trial_error += results[subblock].m_error;
			   if (trial_error >= best_error)
				  break;
			}

			if (subblock < 2)
			   continue;

			best_error = trial_error;
			best_results[0] = results[0];
			best_results[1] = results[1];
			best_flip = flip;
			best_use_color4 = use_color4;

		 } // use_color4

	  } // flip

	  int dr = best_results[1].m_block_color_unscaled.r - best_results[0].m_block_color_unscaled.r;
	  int dg = best_results[1].m_block_color_unscaled.g - best_results[0].m_block_color_unscaled.g;
	  int db = best_results[1].m_block_color_unscaled.b - best_results[0].m_block_color_unscaled.b;
	  RG_ETC1_ASSERT(best_use_color4 || (rg_etc1::minimum(dr, dg, db) >= cETC1ColorDeltaMin) && (rg_etc1::maximum(dr, dg, db) <= cETC1ColorDeltaMax));

	  if (best_use_color4)
	  {
		 dst_block.m_bytes[0] = static_cast<uint8>(best_results[1].m_block_color_unscaled.r | (best_results[0].m_block_color_unscaled.r << 4));
		 dst_block.m_bytes[1] = static_cast<uint8>(best_results[1].m_block_color_unscaled.g | (best_results[0].m_block_color_unscaled.g << 4));
		 dst_block.m_bytes[2] = static_cast<uint8>(best_results[1].m_block_color_unscaled.b | (best_results[0].m_block_color_unscaled.b << 4));
	  }
	  else
	  {
		 if (dr < 0) dr += 8; dst_block.m_bytes[0] = static_cast<uint8>((best_results[0].m_block_color_unscaled.r << 3) | dr);
		 if (dg < 0) dg += 8; dst_block.m_bytes[1] = static_cast<uint8>((best_results[0].m_block_color_unscaled.g << 3) | dg);
		 if (db < 0) db += 8; dst_block.m_bytes[2] = static_cast<uint8>((best_results[0].m_block_color_unscaled.b << 3) | db);
	  }

	  dst_block.m_bytes[3] = static_cast<uint8>( (best_results[1].m_block_inten_table << 2) | (best_results[0].m_block_inten_table << 5) | ((~best_use_color4 & 1) << 1) | best_flip );

	  uint selector0 = 0, selector1 = 0;
	  if (best_flip)
	  {
		 // flipped:
		 // { 0, 0 }, { 1, 0 }, { 2, 0 }, { 3, 0 },
		 // { 0, 1 }, { 1, 1 }, { 2, 1 }, { 3, 1 }
		 //
		 // { 0, 2 }, { 1, 2 }, { 2, 2 }, { 3, 2 },
		 // { 0, 3 }, { 1, 3 }, { 2, 3 }, { 3, 3 }
		 const uint8* pSelectors0 = best_results[0].m_pSelectors;
		 const uint8* pSelectors1 = best_results[1].m_pSelectors;
		 for (int x = 3; x >= 0; --x)
		 {
			uint b;
			b = g_selector_index_to_etc1[pSelectors1[4 + x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			b = g_selector_index_to_etc1[pSelectors1[x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			b = g_selector_index_to_etc1[pSelectors0[4 + x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			b = g_selector_index_to_etc1[pSelectors0[x]];
			selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);
		 }
	  }
	  else
	  {
		 // non-flipped:
		 // { 0, 0 }, { 0, 1 }, { 0, 2 }, { 0, 3 },
		 // { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 }
		 //
		 // { 2, 0 }, { 2, 1 }, { 2, 2 }, { 2, 3 },
		 // { 3, 0 }, { 3, 1 }, { 3, 2 }, { 3, 3 }
		 for (int subblock = 1; subblock >= 0; --subblock)
		 {
			const uint8* pSelectors = best_results[subblock].m_pSelectors + 4;
			for (uint i = 0; i < 2; i++)
			{
			   uint b;
			   b = g_selector_index_to_etc1[pSelectors[3]];
			   selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			   b = g_selector_index_to_etc1[pSelectors[2]];
			   selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			   b = g_selector_index_to_etc1[pSelectors[1]];
			   selector0 = (selector0 << 1) | (b & 1); selector1 = (selector1 << 1) | (b >> 1);

			   b = g_selector_index_to_etc1[pSelectors[0]];
			   selector0 = (selector0 << 1) | (b & 1);selector1 = (selector1 << 1) | (b >> 1);

			   pSelectors -= 4;
			}
		 }
	  }

	  dst_block.m_bytes[4] = static_cast<uint8>(selector1 >> 8); dst_block.m_bytes[5] = static_cast<uint8>(selector1 & 0xFF);
	  dst_block.m_bytes[6] = static_cast<uint8>(selector0 >> 8); dst_block.m_bytes[7] = static_cast<uint8>(selector0 & 0xFF);

	  return static_cast<unsigned int>(best_error);
   }

} // namespace rg_etc1

#undef  clamp


//#line 1 "jpge.h"
// jpge.h - C++ class for JPEG compression.
// Public domain, Rich Geldreich <richgel99@gmail.com>
// Alex Evans: Added RGBA support, linear memory allocator.
#ifndef JPEG_ENCODER_H
#define JPEG_ENCODER_H

namespace jpge
{
  typedef unsigned char  uint8;
  typedef signed short   int16;
  typedef signed int     int32;
  typedef unsigned short uint16;
  typedef unsigned int   uint32;
  typedef unsigned int   uint;

  // JPEG chroma subsampling factors. Y_ONLY (grayscale images) and H2V2 (color images) are the most common.
  enum subsampling_t { Y_ONLY = 0, H1V1 = 1, H2V1 = 2, H2V2 = 3 };

  // JPEG compression parameters structure.
  struct params
  {
	inline params() : m_quality(85), m_subsampling(H2V2), m_no_chroma_discrim_flag(false), m_two_pass_flag(false) { }

	inline bool check() const
	{
	  if ((m_quality < 1) || (m_quality > 100)) return false;
	  if ((uint)m_subsampling > (uint)H2V2) return false;
	  return true;
	}

	// Quality: 1-100, higher is better. Typical values are around 50-95.
	int m_quality;

	// m_subsampling:
	// 0 = Y (grayscale) only
	// 1 = YCbCr, no subsampling (H1V1, YCbCr 1x1x1, 3 blocks per MCU)
	// 2 = YCbCr, H2V1 subsampling (YCbCr 2x1x1, 4 blocks per MCU)
	// 3 = YCbCr, H2V2 subsampling (YCbCr 4x1x1, 6 blocks per MCU-- very common)
	subsampling_t m_subsampling;

	// Disables CbCr discrimination - only intended for testing.
	// If true, the Y quantization table is also used for the CbCr channels.
	bool m_no_chroma_discrim_flag;

	bool m_two_pass_flag;
  };

  // Writes JPEG image to a file.
  // num_channels must be 1 (Y) or 3 (RGB), image pitch must be width*num_channels.
  bool compress_image_to_jpeg_file(const char *pFilename, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params = params());

  // Writes JPEG image to memory buffer.
  // On entry, buf_size is the size of the output buffer pointed at by pBuf, which should be at least ~1024 bytes.
  // If return value is true, buf_size will be set to the size of the compressed data.
  bool compress_image_to_jpeg_file_in_memory(void *pBuf, int &buf_size, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params = params());

  // Output stream abstract class - used by the jpeg_encoder class to write to the output stream.
  // put_buf() is generally called with len==JPGE_OUT_BUF_SIZE bytes, but for headers it'll be called with smaller amounts.
  class output_stream
  {
  public:
	virtual ~output_stream() { };
	virtual bool put_buf(const void* Pbuf, int len) = 0;
	template<class T> inline bool put_obj(const T& obj) { return put_buf(&obj, sizeof(T)); }
  };

  // Lower level jpeg_encoder class - useful if more control is needed than the above helper functions.
  class jpeg_encoder
  {
  public:
	jpeg_encoder();
	~jpeg_encoder();

	// Initializes the compressor.
	// pStream: The stream object to use for writing compressed data.
	// params - Compression parameters structure, defined above.
	// width, height  - Image dimensions.
	// channels - May be 1, or 3. 1 indicates grayscale, 3 indicates RGB source data.
	// Returns false on out of memory or if a stream write fails.
	bool init(output_stream *pStream, int width, int height, int src_channels, const params &comp_params = params());

	const params &get_params() const { return m_params; }

	// Deinitializes the compressor, freeing any allocated memory. May be called at any time.
	void deinit();

	uint get_total_passes() const { return m_params.m_two_pass_flag ? 2 : 1; }
	inline uint get_cur_pass() { return m_pass_num; }

	// Call this method with each source scanline.
	// width * src_channels bytes per scanline is expected (RGB or Y format).
	// You must call with NULL after all scanlines are processed to finish compression.
	// Returns false on out of memory or if a stream write fails.
	bool process_scanline(const void* pScanline);

  private:
	jpeg_encoder(const jpeg_encoder &);
	jpeg_encoder &operator =(const jpeg_encoder &);

	typedef int32 sample_array_t;

	output_stream *m_pStream;
	params m_params;
	uint8 m_num_components;
	uint8 m_comp_h_samp[3], m_comp_v_samp[3];
	int m_image_x, m_image_y, m_image_bpp, m_image_bpl;
	int m_image_x_mcu, m_image_y_mcu;
	int m_image_bpl_xlt, m_image_bpl_mcu;
	int m_mcus_per_row;
	int m_mcu_x, m_mcu_y;
	uint8 *m_mcu_lines[16];
	uint8 m_mcu_y_ofs;
	sample_array_t m_sample_array[64];
	int16 m_coefficient_array[64];
	int32 m_quantization_tables[2][64];
	uint m_huff_codes[4][256];
	uint8 m_huff_code_sizes[4][256];
	uint8 m_huff_bits[4][17];
	uint8 m_huff_val[4][256];
	uint32 m_huff_count[4][256];
	int m_last_dc_val[3];
	enum { JPGE_OUT_BUF_SIZE = 2048 };
	uint8 m_out_buf[JPGE_OUT_BUF_SIZE];
	uint8 *m_pOut_buf;
	uint m_out_buf_left;
	uint32 m_bit_buffer;
	uint m_bits_in;
	uint8 m_pass_num;
	bool m_all_stream_writes_succeeded;

	void optimize_huffman_table(int table_num, int table_len);
	void emit_byte(uint8 i);
	void emit_word(uint i);
	void emit_marker(int marker);
	void emit_jfif_app0();
	void emit_dqt();
	void emit_sof();
	void emit_dht(uint8 *bits, uint8 *val, int index, bool ac_flag);
	void emit_dhts();
	void emit_sos();
	void emit_markers();
	void compute_huffman_table(uint *codes, uint8 *code_sizes, uint8 *bits, uint8 *val);
	void compute_quant_table(int32 *dst, int16 *src);
	void adjust_quant_table(int32 *dst, int32 *src);
	void first_pass_init();
	bool second_pass_init();
	bool jpg_open(int p_x_res, int p_y_res, int src_channels);
	void load_block_8_8_grey(int x);
	void load_block_8_8(int x, int y, int c);
	void load_block_16_8(int x, int c);
	void load_block_16_8_8(int x, int c);
	void load_quantized_coefficients(int component_num);
	void flush_output_buffer();
	void put_bits(uint bits, uint len);
	void code_coefficients_pass_one(int component_num);
	void code_coefficients_pass_two(int component_num);
	void code_block(int component_num);
	void process_mcu_row();
	bool terminate_pass_one();
	bool terminate_pass_two();
	bool process_end_of_image();
	void load_mcu(const void* src);
	void clear();
	void init();
  };

} // namespace jpge

#endif // JPEG_ENCODER


//#line 1 "jpge.cpp"
// jpge.cpp - C++ class for JPEG compression.
// Public domain, Rich Geldreich <richgel99@gmail.com>
// v1.01, Dec. 18, 2010 - Initial release
// v1.02, Apr. 6, 2011 - Removed 2x2 ordered dither in H2V1 chroma subsampling method load_block_16_8_8(). (The rounding factor was 2, when it should have been 1. Either way, it wasn't helping.)
// v1.03, Apr. 16, 2011 - Added support for optimized Huffman code tables, optimized dynamic memory allocation down to only 1 alloc.
//                        Also from Alex Evans: Added RGBA support, linear memory allocator (no longer needed in v1.03).
// v1.04, May. 19, 2012: Forgot to set m_pFile ptr to NULL in cfile_stream::close(). Thanks to Owen Kaluza for reporting this bug.
//                       Code tweaks to fix VS2008 static code analysis warnings (all looked harmless).
//                       Code review revealed method load_block_16_8_8() (used for the non-default H2V1 sampling mode to downsample chroma) somehow didn't get the rounding factor fix from v1.02.

#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#define JPGE_MAX(a,b) (((a)>(b))?(a):(b))
#define JPGE_MIN(a,b) (((a)<(b))?(a):(b))

namespace jpge {

static inline void *jpge_malloc(size_t nSize) { return malloc(nSize); }
static inline void jpge_free(void *p) { free(p); }

// Various JPEG enums and tables.
enum { M_SOF0 = 0xC0, M_DHT = 0xC4, M_SOI = 0xD8, M_EOI = 0xD9, M_SOS = 0xDA, M_DQT = 0xDB, M_APP0 = 0xE0 };
enum { DC_LUM_CODES = 12, AC_LUM_CODES = 256, DC_CHROMA_CODES = 12, AC_CHROMA_CODES = 256, MAX_HUFF_SYMBOLS = 257, MAX_HUFF_CODESIZE = 32 };

static uint8 s_zag[64] = { 0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63 };
static int16 s_std_lum_quant[64] = { 16,11,12,14,12,10,16,14,13,14,18,17,16,19,24,40,26,24,22,22,24,49,35,37,29,40,58,51,61,60,57,51,56,55,64,72,92,78,64,68,87,69,55,56,80,109,81,87,95,98,103,104,103,62,77,113,121,112,100,120,92,101,103,99 };
static int16 s_std_croma_quant[64] = { 17,18,18,24,21,24,47,26,26,47,99,66,56,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99 };
static uint8 s_dc_lum_bits[17] = { 0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0 };
static uint8 s_dc_lum_val[DC_LUM_CODES] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
static uint8 s_ac_lum_bits[17] = { 0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d };
static uint8 s_ac_lum_val[AC_LUM_CODES]  =
{
  0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
  0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
  0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
  0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
  0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
  0xf9,0xfa
};
static uint8 s_dc_chroma_bits[17] = { 0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0 };
static uint8 s_dc_chroma_val[DC_CHROMA_CODES]  = { 0,1,2,3,4,5,6,7,8,9,10,11 };
static uint8 s_ac_chroma_bits[17] = { 0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77 };
static uint8 s_ac_chroma_val[AC_CHROMA_CODES] =
{
  0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
  0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
  0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
  0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
  0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
  0xf9,0xfa
};

// Low-level helper functions.
template <class T> inline void clear_obj(T &obj) { memset(&obj, 0, sizeof(obj)); }

const int YR = 19595, YG = 38470, YB = 7471, CB_R = -11059, CB_G = -21709, CB_B = 32768, CR_R = 32768, CR_G = -27439, CR_B = -5329;
static inline uint8 clamp(int i) { if (static_cast<uint>(i) > 255U) { if (i < 0) i = 0; else if (i > 255) i = 255; } return static_cast<uint8>(i); }

static void RGB_to_YCC(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst += 3, pSrc += 3, num_pixels--)
  {
	const int r = pSrc[0], g = pSrc[1], b = pSrc[2];
	pDst[0] = static_cast<uint8>((r * YR + g * YG + b * YB + 32768) >> 16);
	pDst[1] = clamp(128 + ((r * CB_R + g * CB_G + b * CB_B + 32768) >> 16));
	pDst[2] = clamp(128 + ((r * CR_R + g * CR_G + b * CR_B + 32768) >> 16));
  }
}

static void RGB_to_Y(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst++, pSrc += 3, num_pixels--)
	pDst[0] = static_cast<uint8>((pSrc[0] * YR + pSrc[1] * YG + pSrc[2] * YB + 32768) >> 16);
}

static void RGBA_to_YCC(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst += 3, pSrc += 4, num_pixels--)
  {
	const int r = pSrc[0], g = pSrc[1], b = pSrc[2];
	pDst[0] = static_cast<uint8>((r * YR + g * YG + b * YB + 32768) >> 16);
	pDst[1] = clamp(128 + ((r * CB_R + g * CB_G + b * CB_B + 32768) >> 16));
	pDst[2] = clamp(128 + ((r * CR_R + g * CR_G + b * CR_B + 32768) >> 16));
  }
}

static void RGBA_to_Y(uint8* pDst, const uint8 *pSrc, int num_pixels)
{
  for ( ; num_pixels; pDst++, pSrc += 4, num_pixels--)
	pDst[0] = static_cast<uint8>((pSrc[0] * YR + pSrc[1] * YG + pSrc[2] * YB + 32768) >> 16);
}

static void Y_to_YCC(uint8* pDst, const uint8* pSrc, int num_pixels)
{
  for( ; num_pixels; pDst += 3, pSrc++, num_pixels--) { pDst[0] = pSrc[0]; pDst[1] = 128; pDst[2] = 128; }
}

// Forward DCT - DCT derived from jfdctint.
enum { CONST_BITS = 13, ROW_BITS = 2 };
#define DCT_DESCALE(x, n) (((x) + (((int32)1) << ((n) - 1))) >> (n))
#define DCT_MUL(var, c) (static_cast<int16>(var) * static_cast<int32>(c))
#define DCT1D(s0, s1, s2, s3, s4, s5, s6, s7) \
  int32 t0 = s0 + s7, t7 = s0 - s7, t1 = s1 + s6, t6 = s1 - s6, t2 = s2 + s5, t5 = s2 - s5, t3 = s3 + s4, t4 = s3 - s4; \
  int32 t10 = t0 + t3, t13 = t0 - t3, t11 = t1 + t2, t12 = t1 - t2; \
  int32 u1 = DCT_MUL(t12 + t13, 4433); \
  s2 = u1 + DCT_MUL(t13, 6270); \
  s6 = u1 + DCT_MUL(t12, -15137); \
  u1 = t4 + t7; \
  int32 u2 = t5 + t6, u3 = t4 + t6, u4 = t5 + t7; \
  int32 z5 = DCT_MUL(u3 + u4, 9633); \
  t4 = DCT_MUL(t4, 2446); t5 = DCT_MUL(t5, 16819); \
  t6 = DCT_MUL(t6, 25172); t7 = DCT_MUL(t7, 12299); \
  u1 = DCT_MUL(u1, -7373); u2 = DCT_MUL(u2, -20995); \
  u3 = DCT_MUL(u3, -16069); u4 = DCT_MUL(u4, -3196); \
  u3 += z5; u4 += z5; \
  s0 = t10 + t11; s1 = t7 + u1 + u4; s3 = t6 + u2 + u3; s4 = t10 - t11; s5 = t5 + u2 + u4; s7 = t4 + u1 + u3;

static void DCT2D(int32 *p)
{
  int32 c, *q = p;
  for (c = 7; c >= 0; c--, q += 8)
  {
	int32 s0 = q[0], s1 = q[1], s2 = q[2], s3 = q[3], s4 = q[4], s5 = q[5], s6 = q[6], s7 = q[7];
	DCT1D(s0, s1, s2, s3, s4, s5, s6, s7);
	q[0] = s0 << ROW_BITS; q[1] = DCT_DESCALE(s1, CONST_BITS-ROW_BITS); q[2] = DCT_DESCALE(s2, CONST_BITS-ROW_BITS); q[3] = DCT_DESCALE(s3, CONST_BITS-ROW_BITS);
	q[4] = s4 << ROW_BITS; q[5] = DCT_DESCALE(s5, CONST_BITS-ROW_BITS); q[6] = DCT_DESCALE(s6, CONST_BITS-ROW_BITS); q[7] = DCT_DESCALE(s7, CONST_BITS-ROW_BITS);
  }
  for (q = p, c = 7; c >= 0; c--, q++)
  {
	int32 s0 = q[0*8], s1 = q[1*8], s2 = q[2*8], s3 = q[3*8], s4 = q[4*8], s5 = q[5*8], s6 = q[6*8], s7 = q[7*8];
	DCT1D(s0, s1, s2, s3, s4, s5, s6, s7);
	q[0*8] = DCT_DESCALE(s0, ROW_BITS+3); q[1*8] = DCT_DESCALE(s1, CONST_BITS+ROW_BITS+3); q[2*8] = DCT_DESCALE(s2, CONST_BITS+ROW_BITS+3); q[3*8] = DCT_DESCALE(s3, CONST_BITS+ROW_BITS+3);
	q[4*8] = DCT_DESCALE(s4, ROW_BITS+3); q[5*8] = DCT_DESCALE(s5, CONST_BITS+ROW_BITS+3); q[6*8] = DCT_DESCALE(s6, CONST_BITS+ROW_BITS+3); q[7*8] = DCT_DESCALE(s7, CONST_BITS+ROW_BITS+3);
  }
}

struct sym_freq { uint m_key, m_sym_index; };

// Radix sorts sym_freq[] array by 32-bit key m_key. Returns ptr to sorted values.
static inline sym_freq* radix_sort_syms(uint num_syms, sym_freq* pSyms0, sym_freq* pSyms1)
{
  const uint cMaxPasses = 4;
  uint32 hist[256 * cMaxPasses]; clear_obj(hist);
  for (uint i = 0; i < num_syms; i++) { uint freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; hist[256*2 + ((freq >> 16) & 0xFF)]++; hist[256*3 + ((freq >> 24) & 0xFF)]++; }
  sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1;
  uint total_passes = cMaxPasses; while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;
  for (uint pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)
  {
	const uint32* pHist = &hist[pass << 8];
	uint offsets[256], cur_ofs = 0;
	for (uint i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }
	for (uint i = 0; i < num_syms; i++)
	  pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];
	sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t;
  }
  return pCur_syms;
}

// calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
static void calculate_minimum_redundancy(sym_freq *A, int n)
{
  int root, leaf, next, avbl, used, dpth;
  if (n==0) return; else if (n==1) { A[0].m_key = 1; return; }
  A[0].m_key += A[1].m_key; root = 0; leaf = 2;
  for (next=1; next < n-1; next++)
  {
	if (leaf>=n || A[root].m_key<A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = next; } else A[next].m_key = A[leaf++].m_key;
	if (leaf>=n || (root<next && A[root].m_key<A[leaf].m_key)) { A[next].m_key += A[root].m_key; A[root++].m_key = next; } else A[next].m_key += A[leaf++].m_key;
  }
  A[n-2].m_key = 0;
  for (next=n-3; next>=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;
  avbl = 1; used = dpth = 0; root = n-2; next = n-1;
  while (avbl>0)
  {
	while (root>=0 && (int)A[root].m_key==dpth) { used++; root--; }
	while (avbl>used) { A[next--].m_key = dpth; avbl--; }
	avbl = 2*used; dpth++; used = 0;
  }
}

// Limits canonical Huffman code table's max code size to max_code_size.
static void huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)
{
  if (code_list_len <= 1) return;

  for (int i = max_code_size + 1; i <= MAX_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];

  uint32 total = 0;
  for (int i = max_code_size; i > 0; i--)
	total += (((uint32)pNum_codes[i]) << (max_code_size - i));

  while (total != (1UL << max_code_size))
  {
	pNum_codes[max_code_size]--;
	for (int i = max_code_size - 1; i > 0; i--)
	{
	  if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }
	}
	total--;
  }
}

// Generates an optimized offman table.
void jpeg_encoder::optimize_huffman_table(int table_num, int table_len)
{
  sym_freq syms0[MAX_HUFF_SYMBOLS], syms1[MAX_HUFF_SYMBOLS];
  syms0[0].m_key = 1; syms0[0].m_sym_index = 0;  // dummy symbol, assures that no valid code contains all 1's
  int num_used_syms = 1;
  const uint32 *pSym_count = &m_huff_count[table_num][0];
  for (int i = 0; i < table_len; i++)
	if (pSym_count[i]) { syms0[num_used_syms].m_key = pSym_count[i]; syms0[num_used_syms++].m_sym_index = i + 1; }
  sym_freq* pSyms = radix_sort_syms(num_used_syms, syms0, syms1);
  calculate_minimum_redundancy(pSyms, num_used_syms);

  // Count the # of symbols of each code size.
  int num_codes[1 + MAX_HUFF_CODESIZE]; clear_obj(num_codes);
  for (int i = 0; i < num_used_syms; i++)
	num_codes[pSyms[i].m_key]++;

  const uint JPGE_CODE_SIZE_LIMIT = 16; // the maximum possible size of a JPEG Huffman code (valid range is [9,16] - 9 vs. 8 because of the dummy symbol)
  huffman_enforce_max_code_size(num_codes, num_used_syms, JPGE_CODE_SIZE_LIMIT);

  // Compute m_huff_bits array, which contains the # of symbols per code size.
  clear_obj(m_huff_bits[table_num]);
  for (int i = 1; i <= (int)JPGE_CODE_SIZE_LIMIT; i++)
	m_huff_bits[table_num][i] = static_cast<uint8>(num_codes[i]);

  // Remove the dummy symbol added above, which must be in largest bucket.
  for (int i = JPGE_CODE_SIZE_LIMIT; i >= 1; i--)
  {
	if (m_huff_bits[table_num][i]) { m_huff_bits[table_num][i]--; break; }
  }

  // Compute the m_huff_val array, which contains the symbol indices sorted by code size (smallest to largest).
  for (int i = num_used_syms - 1; i >= 1; i--)
	m_huff_val[table_num][num_used_syms - 1 - i] = static_cast<uint8>(pSyms[i].m_sym_index - 1);
}

// JPEG marker generation.
void jpeg_encoder::emit_byte(uint8 i)
{
  m_all_stream_writes_succeeded = m_all_stream_writes_succeeded && m_pStream->put_obj(i);
}

void jpeg_encoder::emit_word(uint i)
{
  emit_byte(uint8(i >> 8)); emit_byte(uint8(i & 0xFF));
}

void jpeg_encoder::emit_marker(int marker)
{
  emit_byte(uint8(0xFF)); emit_byte(uint8(marker));
}

// Emit JFIF marker
void jpeg_encoder::emit_jfif_app0()
{
  emit_marker(M_APP0);
  emit_word(2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);
  emit_byte(0x4A); emit_byte(0x46); emit_byte(0x49); emit_byte(0x46); /* Identifier: ASCII "JFIF" */
  emit_byte(0);
  emit_byte(1);      /* Major version */
  emit_byte(1);      /* Minor version */
  emit_byte(0);      /* Density unit */
  emit_word(1);
  emit_word(1);
  emit_byte(0);      /* No thumbnail image */
  emit_byte(0);
}

// Emit quantization tables
void jpeg_encoder::emit_dqt()
{
  for (int i = 0; i < ((m_num_components == 3) ? 2 : 1); i++)
  {
	emit_marker(M_DQT);
	emit_word(64 + 1 + 2);
	emit_byte(static_cast<uint8>(i));
	for (int j = 0; j < 64; j++)
	  emit_byte(static_cast<uint8>(m_quantization_tables[i][j]));
  }
}

// Emit start of frame marker
void jpeg_encoder::emit_sof()
{
  emit_marker(M_SOF0);                           /* baseline */
  emit_word(3 * m_num_components + 2 + 5 + 1);
  emit_byte(8);                                  /* precision */
  emit_word(m_image_y);
  emit_word(m_image_x);
  emit_byte(m_num_components);
  for (int i = 0; i < m_num_components; i++)
  {
	emit_byte(static_cast<uint8>(i + 1));                                   /* component ID     */
	emit_byte((m_comp_h_samp[i] << 4) + m_comp_v_samp[i]);  /* h and v sampling */
	emit_byte(i > 0);                                   /* quant. table num */
  }
}

// Emit Huffman table.
void jpeg_encoder::emit_dht(uint8 *bits, uint8 *val, int index, bool ac_flag)
{
  emit_marker(M_DHT);

  int length = 0;
  for (int i = 1; i <= 16; i++)
	length += bits[i];

  emit_word(length + 2 + 1 + 16);
  emit_byte(static_cast<uint8>(index + (ac_flag << 4)));

  for (int i = 1; i <= 16; i++)
	emit_byte(bits[i]);

  for (int i = 0; i < length; i++)
	emit_byte(val[i]);
}

// Emit all Huffman tables.
void jpeg_encoder::emit_dhts()
{
  emit_dht(m_huff_bits[0+0], m_huff_val[0+0], 0, false);
  emit_dht(m_huff_bits[2+0], m_huff_val[2+0], 0, true);
  if (m_num_components == 3)
  {
	emit_dht(m_huff_bits[0+1], m_huff_val[0+1], 1, false);
	emit_dht(m_huff_bits[2+1], m_huff_val[2+1], 1, true);
  }
}

// emit start of scan
void jpeg_encoder::emit_sos()
{
  emit_marker(M_SOS);
  emit_word(2 * m_num_components + 2 + 1 + 3);
  emit_byte(m_num_components);
  for (int i = 0; i < m_num_components; i++)
  {
	emit_byte(static_cast<uint8>(i + 1));
	if (i == 0)
	  emit_byte((0 << 4) + 0);
	else
	  emit_byte((1 << 4) + 1);
  }
  emit_byte(0);     /* spectral selection */
  emit_byte(63);
  emit_byte(0);
}

// Emit all markers at beginning of image file.
void jpeg_encoder::emit_markers()
{
  emit_marker(M_SOI);
  emit_jfif_app0();
  emit_dqt();
  emit_sof();
  emit_dhts();
  emit_sos();
}

// Compute the actual canonical Huffman codes/code sizes given the JPEG huff bits and val arrays.
void jpeg_encoder::compute_huffman_table(uint *codes, uint8 *code_sizes, uint8 *bits, uint8 *val)
{
  int i, l, last_p, si;
  uint8 huff_size[257];
  uint huff_code[257];
  uint code;

  int p = 0;
  for (l = 1; l <= 16; l++)
	for (i = 1; i <= bits[l]; i++)
	  huff_size[p++] = (char)l;

  huff_size[p] = 0; last_p = p; // write sentinel

  code = 0; si = huff_size[0]; p = 0;

  while (huff_size[p])
  {
	while (huff_size[p] == si)
	  huff_code[p++] = code++;
	code <<= 1;
	si++;
  }

  memset(codes, 0, sizeof(codes[0])*256);
  memset(code_sizes, 0, sizeof(code_sizes[0])*256);
  for (p = 0; p < last_p; p++)
  {
	codes[val[p]]      = huff_code[p];
	code_sizes[val[p]] = huff_size[p];
  }
}

// Quantization table generation.
void jpeg_encoder::compute_quant_table(int32 *pDst, int16 *pSrc)
{
  int32 q;
  if (m_params.m_quality < 50)
	q = 5000 / m_params.m_quality;
  else
	q = 200 - m_params.m_quality * 2;
  for (int i = 0; i < 64; i++)
  {
	int32 j = *pSrc++; j = (j * q + 50L) / 100L;
	*pDst++ = JPGE_MIN(JPGE_MAX(j, 1), 255);
  }
}

// Higher-level methods.
void jpeg_encoder::first_pass_init()
{
  m_bit_buffer = 0; m_bits_in = 0;
  memset(m_last_dc_val, 0, 3 * sizeof(m_last_dc_val[0]));
  m_mcu_y_ofs = 0;
  m_pass_num = 1;
}

bool jpeg_encoder::second_pass_init()
{
  compute_huffman_table(&m_huff_codes[0+0][0], &m_huff_code_sizes[0+0][0], m_huff_bits[0+0], m_huff_val[0+0]);
  compute_huffman_table(&m_huff_codes[2+0][0], &m_huff_code_sizes[2+0][0], m_huff_bits[2+0], m_huff_val[2+0]);
  if (m_num_components > 1)
  {
	compute_huffman_table(&m_huff_codes[0+1][0], &m_huff_code_sizes[0+1][0], m_huff_bits[0+1], m_huff_val[0+1]);
	compute_huffman_table(&m_huff_codes[2+1][0], &m_huff_code_sizes[2+1][0], m_huff_bits[2+1], m_huff_val[2+1]);
  }
  first_pass_init();
  emit_markers();
  m_pass_num = 2;
  return true;
}

bool jpeg_encoder::jpg_open(int p_x_res, int p_y_res, int src_channels)
{
  m_num_components = 3;
  switch (m_params.m_subsampling)
  {
	case Y_ONLY:
	{
	  m_num_components = 1;
	  m_comp_h_samp[0] = 1; m_comp_v_samp[0] = 1;
	  m_mcu_x          = 8; m_mcu_y          = 8;
	  break;
	}
	case H1V1:
	{
	  m_comp_h_samp[0] = 1; m_comp_v_samp[0] = 1;
	  m_comp_h_samp[1] = 1; m_comp_v_samp[1] = 1;
	  m_comp_h_samp[2] = 1; m_comp_v_samp[2] = 1;
	  m_mcu_x          = 8; m_mcu_y          = 8;
	  break;
	}
	case H2V1:
	{
	  m_comp_h_samp[0] = 2; m_comp_v_samp[0] = 1;
	  m_comp_h_samp[1] = 1; m_comp_v_samp[1] = 1;
	  m_comp_h_samp[2] = 1; m_comp_v_samp[2] = 1;
	  m_mcu_x          = 16; m_mcu_y         = 8;
	  break;
	}
	case H2V2:
	{
	  m_comp_h_samp[0] = 2; m_comp_v_samp[0] = 2;
	  m_comp_h_samp[1] = 1; m_comp_v_samp[1] = 1;
	  m_comp_h_samp[2] = 1; m_comp_v_samp[2] = 1;
	  m_mcu_x          = 16; m_mcu_y         = 16;
	}
  }

  m_image_x        = p_x_res; m_image_y = p_y_res;
  m_image_bpp      = src_channels;
  m_image_bpl      = m_image_x * src_channels;
  m_image_x_mcu    = (m_image_x + m_mcu_x - 1) & (~(m_mcu_x - 1));
  m_image_y_mcu    = (m_image_y + m_mcu_y - 1) & (~(m_mcu_y - 1));
  m_image_bpl_xlt  = m_image_x * m_num_components;
  m_image_bpl_mcu  = m_image_x_mcu * m_num_components;
  m_mcus_per_row   = m_image_x_mcu / m_mcu_x;

  if ((m_mcu_lines[0] = static_cast<uint8*>(jpge_malloc(m_image_bpl_mcu * m_mcu_y))) == NULL) return false;
  for (int i = 1; i < m_mcu_y; i++)
	m_mcu_lines[i] = m_mcu_lines[i-1] + m_image_bpl_mcu;

  compute_quant_table(m_quantization_tables[0], s_std_lum_quant);
  compute_quant_table(m_quantization_tables[1], m_params.m_no_chroma_discrim_flag ? s_std_lum_quant : s_std_croma_quant);

  m_out_buf_left = JPGE_OUT_BUF_SIZE;
  m_pOut_buf = m_out_buf;

  if (m_params.m_two_pass_flag)
  {
	clear_obj(m_huff_count);
	first_pass_init();
  }
  else
  {
	memcpy(m_huff_bits[0+0], s_dc_lum_bits, 17);    memcpy(m_huff_val [0+0], s_dc_lum_val, DC_LUM_CODES);
	memcpy(m_huff_bits[2+0], s_ac_lum_bits, 17);    memcpy(m_huff_val [2+0], s_ac_lum_val, AC_LUM_CODES);
	memcpy(m_huff_bits[0+1], s_dc_chroma_bits, 17); memcpy(m_huff_val [0+1], s_dc_chroma_val, DC_CHROMA_CODES);
	memcpy(m_huff_bits[2+1], s_ac_chroma_bits, 17); memcpy(m_huff_val [2+1], s_ac_chroma_val, AC_CHROMA_CODES);
	if (!second_pass_init()) return false;   // in effect, skip over the first pass
  }
  return m_all_stream_writes_succeeded;
}

void jpeg_encoder::load_block_8_8_grey(int x)
{
  uint8 *pSrc;
  sample_array_t *pDst = m_sample_array;
  x <<= 3;
  for (int i = 0; i < 8; i++, pDst += 8)
  {
	pSrc = m_mcu_lines[i] + x;
	pDst[0] = pSrc[0] - 128; pDst[1] = pSrc[1] - 128; pDst[2] = pSrc[2] - 128; pDst[3] = pSrc[3] - 128;
	pDst[4] = pSrc[4] - 128; pDst[5] = pSrc[5] - 128; pDst[6] = pSrc[6] - 128; pDst[7] = pSrc[7] - 128;
  }
}

void jpeg_encoder::load_block_8_8(int x, int y, int c)
{
  uint8 *pSrc;
  sample_array_t *pDst = m_sample_array;
  x = (x * (8 * 3)) + c;
  y <<= 3;
  for (int i = 0; i < 8; i++, pDst += 8)
  {
	pSrc = m_mcu_lines[y + i] + x;
	pDst[0] = pSrc[0 * 3] - 128; pDst[1] = pSrc[1 * 3] - 128; pDst[2] = pSrc[2 * 3] - 128; pDst[3] = pSrc[3 * 3] - 128;
	pDst[4] = pSrc[4 * 3] - 128; pDst[5] = pSrc[5 * 3] - 128; pDst[6] = pSrc[6 * 3] - 128; pDst[7] = pSrc[7 * 3] - 128;
  }
}

void jpeg_encoder::load_block_16_8(int x, int c)
{
  uint8 *pSrc1, *pSrc2;
  sample_array_t *pDst = m_sample_array;
  x = (x * (16 * 3)) + c;
  int a = 0, b = 2;
  for (int i = 0; i < 16; i += 2, pDst += 8)
  {
	pSrc1 = m_mcu_lines[i + 0] + x;
	pSrc2 = m_mcu_lines[i + 1] + x;
	pDst[0] = ((pSrc1[ 0 * 3] + pSrc1[ 1 * 3] + pSrc2[ 0 * 3] + pSrc2[ 1 * 3] + a) >> 2) - 128; pDst[1] = ((pSrc1[ 2 * 3] + pSrc1[ 3 * 3] + pSrc2[ 2 * 3] + pSrc2[ 3 * 3] + b) >> 2) - 128;
	pDst[2] = ((pSrc1[ 4 * 3] + pSrc1[ 5 * 3] + pSrc2[ 4 * 3] + pSrc2[ 5 * 3] + a) >> 2) - 128; pDst[3] = ((pSrc1[ 6 * 3] + pSrc1[ 7 * 3] + pSrc2[ 6 * 3] + pSrc2[ 7 * 3] + b) >> 2) - 128;
	pDst[4] = ((pSrc1[ 8 * 3] + pSrc1[ 9 * 3] + pSrc2[ 8 * 3] + pSrc2[ 9 * 3] + a) >> 2) - 128; pDst[5] = ((pSrc1[10 * 3] + pSrc1[11 * 3] + pSrc2[10 * 3] + pSrc2[11 * 3] + b) >> 2) - 128;
	pDst[6] = ((pSrc1[12 * 3] + pSrc1[13 * 3] + pSrc2[12 * 3] + pSrc2[13 * 3] + a) >> 2) - 128; pDst[7] = ((pSrc1[14 * 3] + pSrc1[15 * 3] + pSrc2[14 * 3] + pSrc2[15 * 3] + b) >> 2) - 128;
	int temp = a; a = b; b = temp;
  }
}

void jpeg_encoder::load_block_16_8_8(int x, int c)
{
  uint8 *pSrc1;
  sample_array_t *pDst = m_sample_array;
  x = (x * (16 * 3)) + c;
  for (int i = 0; i < 8; i++, pDst += 8)
  {
	pSrc1 = m_mcu_lines[i + 0] + x;
	pDst[0] = ((pSrc1[ 0 * 3] + pSrc1[ 1 * 3]) >> 1) - 128; pDst[1] = ((pSrc1[ 2 * 3] + pSrc1[ 3 * 3]) >> 1) - 128;
	pDst[2] = ((pSrc1[ 4 * 3] + pSrc1[ 5 * 3]) >> 1) - 128; pDst[3] = ((pSrc1[ 6 * 3] + pSrc1[ 7 * 3]) >> 1) - 128;
	pDst[4] = ((pSrc1[ 8 * 3] + pSrc1[ 9 * 3]) >> 1) - 128; pDst[5] = ((pSrc1[10 * 3] + pSrc1[11 * 3]) >> 1) - 128;
	pDst[6] = ((pSrc1[12 * 3] + pSrc1[13 * 3]) >> 1) - 128; pDst[7] = ((pSrc1[14 * 3] + pSrc1[15 * 3]) >> 1) - 128;
  }
}

void jpeg_encoder::load_quantized_coefficients(int component_num)
{
  int32 *q = m_quantization_tables[component_num > 0];
  int16 *pDst = m_coefficient_array;
  for (int i = 0; i < 64; i++)
  {
	sample_array_t j = m_sample_array[s_zag[i]];
	if (j < 0)
	{
	  if ((j = -j + (*q >> 1)) < *q)
		*pDst++ = 0;
	  else
		*pDst++ = static_cast<int16>(-(j / *q));
	}
	else
	{
	  if ((j = j + (*q >> 1)) < *q)
		*pDst++ = 0;
	  else
		*pDst++ = static_cast<int16>((j / *q));
	}
	q++;
  }
}

void jpeg_encoder::flush_output_buffer()
{
  if (m_out_buf_left != JPGE_OUT_BUF_SIZE)
	m_all_stream_writes_succeeded = m_all_stream_writes_succeeded && m_pStream->put_buf(m_out_buf, JPGE_OUT_BUF_SIZE - m_out_buf_left);
  m_pOut_buf = m_out_buf;
  m_out_buf_left = JPGE_OUT_BUF_SIZE;
}

void jpeg_encoder::put_bits(uint bits, uint len)
{
  m_bit_buffer |= ((uint32)bits << (24 - (m_bits_in += len)));
  while (m_bits_in >= 8)
  {
	uint8 c;
	#define JPGE_PUT_BYTE(c) { *m_pOut_buf++ = (c); if (--m_out_buf_left == 0) flush_output_buffer(); }
	JPGE_PUT_BYTE(c = (uint8)((m_bit_buffer >> 16) & 0xFF));
	if (c == 0xFF) JPGE_PUT_BYTE(0);
	m_bit_buffer <<= 8;
	m_bits_in -= 8;
  }
}

void jpeg_encoder::code_coefficients_pass_one(int component_num)
{
  if (component_num >= 3) return; // just to shut up static analysis
  int i, run_len, nbits, temp1;
  int16 *src = m_coefficient_array;
  uint32 *dc_count = component_num ? m_huff_count[0 + 1] : m_huff_count[0 + 0], *ac_count = component_num ? m_huff_count[2 + 1] : m_huff_count[2 + 0];

  temp1 = src[0] - m_last_dc_val[component_num];
  m_last_dc_val[component_num] = src[0];
  if (temp1 < 0) temp1 = -temp1;

  nbits = 0;
  while (temp1)
  {
	nbits++; temp1 >>= 1;
  }

  dc_count[nbits]++;
  for (run_len = 0, i = 1; i < 64; i++)
  {
	if ((temp1 = m_coefficient_array[i]) == 0)
	  run_len++;
	else
	{
	  while (run_len >= 16)
	  {
		ac_count[0xF0]++;
		run_len -= 16;
	  }
	  if (temp1 < 0) temp1 = -temp1;
	  nbits = 1;
	  while (temp1 >>= 1) nbits++;
	  ac_count[(run_len << 4) + nbits]++;
	  run_len = 0;
	}
  }
  if (run_len) ac_count[0]++;
}

void jpeg_encoder::code_coefficients_pass_two(int component_num)
{
  int i, j, run_len, nbits, temp1, temp2;
  int16 *pSrc = m_coefficient_array;
  uint *codes[2];
  uint8 *code_sizes[2];

  if (component_num == 0)
  {
	codes[0] = m_huff_codes[0 + 0]; codes[1] = m_huff_codes[2 + 0];
	code_sizes[0] = m_huff_code_sizes[0 + 0]; code_sizes[1] = m_huff_code_sizes[2 + 0];
  }
  else
  {
	codes[0] = m_huff_codes[0 + 1]; codes[1] = m_huff_codes[2 + 1];
	code_sizes[0] = m_huff_code_sizes[0 + 1]; code_sizes[1] = m_huff_code_sizes[2 + 1];
  }

  temp1 = temp2 = pSrc[0] - m_last_dc_val[component_num];
  m_last_dc_val[component_num] = pSrc[0];

  if (temp1 < 0)
  {
	temp1 = -temp1; temp2--;
  }

  nbits = 0;
  while (temp1)
  {
	nbits++; temp1 >>= 1;
  }

  put_bits(codes[0][nbits], code_sizes[0][nbits]);
  if (nbits) put_bits(temp2 & ((1 << nbits) - 1), nbits);

  for (run_len = 0, i = 1; i < 64; i++)
  {
	if ((temp1 = m_coefficient_array[i]) == 0)
	  run_len++;
	else
	{
	  while (run_len >= 16)
	  {
		put_bits(codes[1][0xF0], code_sizes[1][0xF0]);
		run_len -= 16;
	  }
	  if ((temp2 = temp1) < 0)
	  {
		temp1 = -temp1;
		temp2--;
	  }
	  nbits = 1;
	  while (temp1 >>= 1)
		nbits++;
	  j = (run_len << 4) + nbits;
	  put_bits(codes[1][j], code_sizes[1][j]);
	  put_bits(temp2 & ((1 << nbits) - 1), nbits);
	  run_len = 0;
	}
  }
  if (run_len)
	put_bits(codes[1][0], code_sizes[1][0]);
}

void jpeg_encoder::code_block(int component_num)
{
  DCT2D(m_sample_array);
  load_quantized_coefficients(component_num);
  if (m_pass_num == 1)
	code_coefficients_pass_one(component_num);
  else
	code_coefficients_pass_two(component_num);
}

void jpeg_encoder::process_mcu_row()
{
  if (m_num_components == 1)
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8_grey(i); code_block(0);
	}
  }
  else if ((m_comp_h_samp[0] == 1) && (m_comp_v_samp[0] == 1))
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8(i, 0, 0); code_block(0); load_block_8_8(i, 0, 1); code_block(1); load_block_8_8(i, 0, 2); code_block(2);
	}
  }
  else if ((m_comp_h_samp[0] == 2) && (m_comp_v_samp[0] == 1))
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8(i * 2 + 0, 0, 0); code_block(0); load_block_8_8(i * 2 + 1, 0, 0); code_block(0);
	  load_block_16_8_8(i, 1); code_block(1); load_block_16_8_8(i, 2); code_block(2);
	}
  }
  else if ((m_comp_h_samp[0] == 2) && (m_comp_v_samp[0] == 2))
  {
	for (int i = 0; i < m_mcus_per_row; i++)
	{
	  load_block_8_8(i * 2 + 0, 0, 0); code_block(0); load_block_8_8(i * 2 + 1, 0, 0); code_block(0);
	  load_block_8_8(i * 2 + 0, 1, 0); code_block(0); load_block_8_8(i * 2 + 1, 1, 0); code_block(0);
	  load_block_16_8(i, 1); code_block(1); load_block_16_8(i, 2); code_block(2);
	}
  }
}

bool jpeg_encoder::terminate_pass_one()
{
  optimize_huffman_table(0+0, DC_LUM_CODES); optimize_huffman_table(2+0, AC_LUM_CODES);
  if (m_num_components > 1)
  {
	optimize_huffman_table(0+1, DC_CHROMA_CODES); optimize_huffman_table(2+1, AC_CHROMA_CODES);
  }
  return second_pass_init();
}

bool jpeg_encoder::terminate_pass_two()
{
  put_bits(0x7F, 7);
  flush_output_buffer();
  emit_marker(M_EOI);
  m_pass_num++; // purposely bump up m_pass_num, for debugging
  return true;
}

bool jpeg_encoder::process_end_of_image()
{
  if (m_mcu_y_ofs)
  {
	if (m_mcu_y_ofs < 16) // check here just to shut up static analysis
	{
	  for (int i = m_mcu_y_ofs; i < m_mcu_y; i++)
		memcpy(m_mcu_lines[i], m_mcu_lines[m_mcu_y_ofs - 1], m_image_bpl_mcu);
	}

	process_mcu_row();
  }

  if (m_pass_num == 1)
	return terminate_pass_one();
  else
	return terminate_pass_two();
}

void jpeg_encoder::load_mcu(const void *pSrc)
{
  const uint8* Psrc = reinterpret_cast<const uint8*>(pSrc);

  uint8* pDst = m_mcu_lines[m_mcu_y_ofs]; // OK to write up to m_image_bpl_xlt bytes to pDst

  if (m_num_components == 1)
  {
	if (m_image_bpp == 4)
	  RGBA_to_Y(pDst, Psrc, m_image_x);
	else if (m_image_bpp == 3)
	  RGB_to_Y(pDst, Psrc, m_image_x);
	else
	  memcpy(pDst, Psrc, m_image_x);
  }
  else
  {
	if (m_image_bpp == 4)
	  RGBA_to_YCC(pDst, Psrc, m_image_x);
	else if (m_image_bpp == 3)
	  RGB_to_YCC(pDst, Psrc, m_image_x);
	else
	  Y_to_YCC(pDst, Psrc, m_image_x);
  }

  // Possibly duplicate pixels at end of scanline if not a multiple of 8 or 16
  if (m_num_components == 1)
	memset(m_mcu_lines[m_mcu_y_ofs] + m_image_bpl_xlt, pDst[m_image_bpl_xlt - 1], m_image_x_mcu - m_image_x);
  else
  {
	const uint8 y = pDst[m_image_bpl_xlt - 3 + 0], cb = pDst[m_image_bpl_xlt - 3 + 1], cr = pDst[m_image_bpl_xlt - 3 + 2];
	uint8 *q = m_mcu_lines[m_mcu_y_ofs] + m_image_bpl_xlt;
	for (int i = m_image_x; i < m_image_x_mcu; i++)
	{
	  *q++ = y; *q++ = cb; *q++ = cr;
	}
  }

  if (++m_mcu_y_ofs == m_mcu_y)
  {
	process_mcu_row();
	m_mcu_y_ofs = 0;
  }
}

void jpeg_encoder::clear()
{
  m_mcu_lines[0] = NULL;
  m_pass_num = 0;
  m_all_stream_writes_succeeded = true;
}

jpeg_encoder::jpeg_encoder()
{
  clear();
}

jpeg_encoder::~jpeg_encoder()
{
  deinit();
}

bool jpeg_encoder::init(output_stream *pStream, int width, int height, int src_channels, const params &comp_params)
{
  deinit();
  if (((!pStream) || (width < 1) || (height < 1)) || ((src_channels != 1) && (src_channels != 3) && (src_channels != 4)) || (!comp_params.check())) return false;
  m_pStream = pStream;
  m_params = comp_params;
  return jpg_open(width, height, src_channels);
}

void jpeg_encoder::deinit()
{
  jpge_free(m_mcu_lines[0]);
  clear();
}

bool jpeg_encoder::process_scanline(const void* pScanline)
{
  if ((m_pass_num < 1) || (m_pass_num > 2)) return false;
  if (m_all_stream_writes_succeeded)
  {
	if (!pScanline)
	{
	  if (!process_end_of_image()) return false;
	}
	else
	{
	  load_mcu(pScanline);
	}
  }
  return m_all_stream_writes_succeeded;
}

// Higher level wrappers/examples (optional).
#include <stdio.h>

class cfile_stream : public output_stream
{
   cfile_stream(const cfile_stream &);
   cfile_stream &operator= (const cfile_stream &);

   FILE* m_pFile;
   bool m_bStatus;

public:
   cfile_stream() : m_pFile(NULL), m_bStatus(false) { }

   virtual ~cfile_stream()
   {
	  close();
   }

   bool open(const char *pFilename)
   {
	  close();
	  m_pFile = fopen(pFilename, "wb");
	  m_bStatus = (m_pFile != NULL);
	  return m_bStatus;
   }

   bool close()
   {
	  if (m_pFile)
	  {
		 if (fclose(m_pFile) == EOF)
		 {
			m_bStatus = false;
		 }
		 m_pFile = NULL;
	  }
	  return m_bStatus;
   }

   virtual bool put_buf(const void* pBuf, int len)
   {
	  m_bStatus = m_bStatus && (fwrite(pBuf, len, 1, m_pFile) == 1);
	  return m_bStatus;
   }

   uint get_size() const
   {
	  return m_pFile ? ftell(m_pFile) : 0;
   }
};

// Writes JPEG image to file.
bool compress_image_to_jpeg_file(const char *pFilename, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params)
{
  cfile_stream dst_stream;
  if (!dst_stream.open(pFilename))
	return false;

  jpge::jpeg_encoder dst_image;
  if (!dst_image.init(&dst_stream, width, height, num_channels, comp_params))
	return false;

  for (uint pass_index = 0; pass_index < dst_image.get_total_passes(); pass_index++)
  {
	for (int i = 0; i < height; i++)
	{
	   const uint8* pBuf = pImage_data + i * width * num_channels;
	   if (!dst_image.process_scanline(pBuf))
		  return false;
	}
	if (!dst_image.process_scanline(NULL))
	   return false;
  }

  dst_image.deinit();

  return dst_stream.close();
}

class memory_stream : public output_stream
{
   memory_stream(const memory_stream &);
   memory_stream &operator= (const memory_stream &);

   uint8 *m_pBuf;
   uint m_buf_size, m_buf_ofs;

public:
   memory_stream(void *pBuf, uint buf_size) : m_pBuf(static_cast<uint8*>(pBuf)), m_buf_size(buf_size), m_buf_ofs(0) { }

   virtual ~memory_stream() { }

   virtual bool put_buf(const void* pBuf, int len)
   {
	  uint buf_remaining = m_buf_size - m_buf_ofs;
	  if ((uint)len > buf_remaining)
		 return false;
	  memcpy(m_pBuf + m_buf_ofs, pBuf, len);
	  m_buf_ofs += len;
	  return true;
   }

   uint get_size() const
   {
	  return m_buf_ofs;
   }
};

bool compress_image_to_jpeg_file_in_memory(void *pDstBuf, int &buf_size, int width, int height, int num_channels, const uint8 *pImage_data, const params &comp_params)
{
   if ((!pDstBuf) || (!buf_size))
	  return false;

   memory_stream dst_stream(pDstBuf, buf_size);

   buf_size = 0;

   jpge::jpeg_encoder dst_image;
   if (!dst_image.init(&dst_stream, width, height, num_channels, comp_params))
	  return false;

   for (uint pass_index = 0; pass_index < dst_image.get_total_passes(); pass_index++)
   {
	 for (int i = 0; i < height; i++)
	 {
		const uint8* pScanline = pImage_data + i * width * num_channels;
		if (!dst_image.process_scanline(pScanline))
		   return false;
	 }
	 if (!dst_image.process_scanline(NULL))
		return false;
   }

   dst_image.deinit();

   buf_size = dst_stream.get_size();
   return true;
}

} // namespace jpge


//#line 1 "lodepng.h"
#ifndef LODEPNG_H
#define LODEPNG_H

#include <string.h> /*for size_t*/

#ifdef __cplusplus
#include <vector>
#include <string>
#endif /*__cplusplus*/

#define LODEPNG_VERSION_STRING "20141130"

/*
The following #defines are used to create code sections. They can be disabled
to disable code sections, which can give faster compile time and smaller binary.
The "NO_COMPILE" defines are designed to be used to pass as defines to the
compiler command to disable them without modifying this header, e.g.
-DLODEPNG_NO_COMPILE_ZLIB for gcc.
*/
/*deflate & zlib. If disabled, you must specify alternative zlib functions in
the custom_zlib field of the compress and decompress settings*/
#ifndef LODEPNG_NO_COMPILE_ZLIB
#define LODEPNG_COMPILE_ZLIB
#endif
/*png encoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_PNG
#define LODEPNG_COMPILE_PNG
#endif
/*deflate&zlib decoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_DECODER
#define LODEPNG_COMPILE_DECODER
#endif
/*deflate&zlib encoder and png encoder*/
#ifndef LODEPNG_NO_COMPILE_ENCODER
#define LODEPNG_COMPILE_ENCODER
#endif
/*the optional built in harddisk file loading and saving functions*/
#ifndef LODEPNG_NO_COMPILE_DISK
#define LODEPNG_COMPILE_DISK
#endif
/*support for chunks other than IHDR, IDAT, PLTE, tRNS, IEND: ancillary and unknown chunks*/
#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS
#define LODEPNG_COMPILE_ANCILLARY_CHUNKS
#endif
/*ability to convert error numerical codes to English text string*/
#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT
#define LODEPNG_COMPILE_ERROR_TEXT
#endif
/*Compile the default allocators (C's free, malloc and realloc). If you disable this,
you can define the functions lodepng_free, lodepng_malloc and lodepng_realloc in your
source files with custom allocators.*/
#ifndef LODEPNG_NO_COMPILE_ALLOCATORS
#define LODEPNG_COMPILE_ALLOCATORS
#endif
/*compile the C++ version (you can disable the C++ wrapper here even when compiling for C++)*/
#ifdef __cplusplus
#ifndef LODEPNG_NO_COMPILE_CPP
#define LODEPNG_COMPILE_CPP
#endif
#endif

#ifdef LODEPNG_COMPILE_PNG
/*The PNG color types (also used for raw).*/
typedef enum LodePNGColorType
{
  LCT_GREY = 0, /*greyscale: 1,2,4,8,16 bit*/
  LCT_RGB = 2, /*RGB: 8,16 bit*/
  LCT_PALETTE = 3, /*palette: 1,2,4,8 bit*/
  LCT_GREY_ALPHA = 4, /*greyscale with alpha: 8,16 bit*/
  LCT_RGBA = 6 /*RGB with alpha: 8,16 bit*/
} LodePNGColorType;

#ifdef LODEPNG_COMPILE_DECODER
/*
Converts PNG data in memory to raw pixel data.
out: Output parameter. Pointer to buffer that will contain the raw pixel data.
	 After decoding, its size is w * h * (bytes per pixel) bytes larger than
	 initially. Bytes per pixel depends on colortype and bitdepth.
	 Must be freed after usage with free(*out).
	 Note: for 16-bit per channel colors, uses big endian format like PNG does.
w: Output parameter. Pointer to width of pixel data.
h: Output parameter. Pointer to height of pixel data.
in: Memory buffer with the PNG file.
insize: size of the in buffer.
colortype: the desired color type for the raw output image. See explanation on PNG color types.
bitdepth: the desired bit depth for the raw output image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h,
							   const unsigned char* in, size_t insize,
							   LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_memory, but always decodes to 32-bit RGBA raw image*/
unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h,
						  const unsigned char* in, size_t insize);

/*Same as lodepng_decode_memory, but always decodes to 24-bit RGB raw image*/
unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h,
						  const unsigned char* in, size_t insize);

#ifdef LODEPNG_COMPILE_DISK
/*
Load PNG from disk, from file with given name.
Same as the other decode functions, but instead takes a filename as input.
*/
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h,
							 const char* filename,
							 LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_file, but always decodes to 32-bit RGBA raw image.*/
unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h,
							   const char* filename);

/*Same as lodepng_decode_file, but always decodes to 24-bit RGB raw image.*/
unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h,
							   const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Converts raw pixel data into a PNG image in memory. The colortype and bitdepth
  of the output PNG image cannot be chosen, they are automatically determined
  by the colortype, bitdepth and content of the input pixel data.
  Note: for 16-bit per channel colors, needs big endian format like PNG does.
out: Output parameter. Pointer to buffer that will contain the PNG image data.
	 Must be freed after usage with free(*out).
outsize: Output parameter. Pointer to the size in bytes of the out buffer.
image: The raw pixel data to encode. The size of this buffer should be
	   w * h * (bytes per pixel), bytes per pixel depends on colortype and bitdepth.
w: width of the raw pixel data in pixels.
h: height of the raw pixel data in pixels.
colortype: the color type of the raw input image. See explanation on PNG color types.
bitdepth: the bit depth of the raw input image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize,
							   const unsigned char* image, unsigned w, unsigned h,
							   LodePNGColorType colortype, unsigned bitdepth);

/* @r-lyeh { */
unsigned lodepng_encode_memory_std(unsigned char** out, size_t* outsize,
							   const unsigned char* image, unsigned w, unsigned h,
							   unsigned colortype, unsigned bitdepth);
/* } */

/*Same as lodepng_encode_memory, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32(unsigned char** out, size_t* outsize,
						  const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_memory, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24(unsigned char** out, size_t* outsize,
						  const unsigned char* image, unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DISK
/*
Converts raw pixel data into a PNG file on disk.
Same as the other encode functions, but instead takes a filename as output.
NOTE: This overwrites existing files without warning!
*/
unsigned lodepng_encode_file(const char* filename,
							 const unsigned char* image, unsigned w, unsigned h,
							 LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_encode_file, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32_file(const char* filename,
							   const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_file, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24_file(const char* filename,
							   const unsigned char* image, unsigned w, unsigned h);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_CPP
namespace lodepng
{
#ifdef LODEPNG_COMPILE_DECODER
/*Same as lodepng_decode_memory, but decodes to an std::vector. The colortype
is the format to output the pixels to. Default is RGBA 8-bit per channel.*/
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const unsigned char* in, size_t insize,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const std::vector<unsigned char>& in,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
/*
Converts PNG file from disk to raw pixel data in memory.
Same as the other decode functions, but instead takes a filename as input.
*/
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const std::string& filename,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_DECODER

#ifdef LODEPNG_COMPILE_ENCODER
/*Same as lodepng_encode_memory, but encodes to an std::vector. colortype
is that of the raw input data. The output PNG color type will be auto chosen.*/
unsigned encode(std::vector<unsigned char>& out,
				const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#ifdef LODEPNG_COMPILE_DISK
/*
Converts 32-bit RGBA raw pixel data into a PNG file on disk.
Same as the other encode functions, but instead takes a filename as output.
NOTE: This overwrites existing files without warning!
*/
unsigned encode(const std::string& filename,
				const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
unsigned encode(const std::string& filename,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype = LCT_RGBA, unsigned bitdepth = 8);
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_ENCODER
} //namespace lodepng
#endif /*LODEPNG_COMPILE_CPP*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*Returns an English description of the numerical error code.*/
const char* lodepng_error_text(unsigned code);
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/

#ifdef LODEPNG_COMPILE_DECODER
/*Settings for zlib decompression*/
typedef struct LodePNGDecompressSettings LodePNGDecompressSettings;
struct LodePNGDecompressSettings
{
  unsigned ignore_adler32; /*if 1, continue and don't give an error message if the Adler32 checksum is corrupted*/

  /*use custom zlib decoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
						  const unsigned char*, size_t,
						  const LodePNGDecompressSettings*);
  /*use custom deflate decoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_inflate)(unsigned char**, size_t*,
							 const unsigned char*, size_t,
							 const LodePNGDecompressSettings*);

  const void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGDecompressSettings lodepng_default_decompress_settings;
void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Settings for zlib compression. Tweaking these settings tweaks the balance
between speed and compression ratio.
*/
typedef struct LodePNGCompressSettings LodePNGCompressSettings;
struct LodePNGCompressSettings /*deflate = compress*/
{
  /*LZ77 related settings*/
  unsigned btype; /*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*/
  unsigned use_lz77; /*whether or not to use LZ77. Should be 1 for proper compression.*/
  unsigned windowsize; /*must be a power of two <= 32768. higher compresses more but is slower. Default value: 2048.*/
  unsigned minmatch; /*mininum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*/
  unsigned nicematch; /*stop searching if >= this length found. Set to 258 for best compression. Default: 128*/
  unsigned lazymatching; /*use lazy matching: better compression but a bit slower. Default: true*/

  /*use custom zlib encoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
						  const unsigned char*, size_t,
						  const LodePNGCompressSettings*);
  /*use custom deflate encoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_deflate)(unsigned char**, size_t*,
							 const unsigned char*, size_t,
							 const LodePNGCompressSettings*);

  const void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGCompressSettings lodepng_default_compress_settings;
void lodepng_compress_settings_init(LodePNGCompressSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_PNG
/*
Color mode of an image. Contains all information required to decode the pixel
bits to RGBA colors. This information is the same as used in the PNG file
format, and is used both for PNG and raw image data in LodePNG.
*/
typedef struct LodePNGColorMode
{
  /*header (IHDR)*/
  LodePNGColorType colortype; /*color type, see PNG standard or documentation further in this header file*/
  unsigned bitdepth;  /*bits per sample, see PNG standard or documentation further in this header file*/

  /*
  palette (PLTE and tRNS)

  Dynamically allocated with the colors of the palette, including alpha.
  When encoding a PNG, to store your colors in the palette of the LodePNGColorMode, first use
  lodepng_palette_clear, then for each color use lodepng_palette_add.
  If you encode an image without alpha with palette, don't forget to put value 255 in each A byte of the palette.

  When decoding, by default you can ignore this palette, since LodePNG already
  fills the palette colors in the pixels of the raw RGBA output.

  The palette is only supported for color type 3.
  */
  unsigned char* palette; /*palette in RGBARGBA... order. When allocated, must be either 0, or have size 1024*/
  size_t palettesize; /*palette size in number of colors (amount of bytes is 4 * palettesize)*/

  /*
  transparent color key (tRNS)

  This color uses the same bit depth as the bitdepth value in this struct, which can be 1-bit to 16-bit.
  For greyscale PNGs, r, g and b will all 3 be set to the same.

  When decoding, by default you can ignore this information, since LodePNG sets
  pixels with this key to transparent already in the raw RGBA output.

  The color key is only supported for color types 0 and 2.
  */
  unsigned key_defined; /*is a transparent color key given? 0 = false, 1 = true*/
  unsigned key_r;       /*red/greyscale component of color key*/
  unsigned key_g;       /*green component of color key*/
  unsigned key_b;       /*blue component of color key*/
} LodePNGColorMode;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_color_mode_init(LodePNGColorMode* info);
void lodepng_color_mode_cleanup(LodePNGColorMode* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source);

void lodepng_palette_clear(LodePNGColorMode* info);
/*add 1 color to the palette*/
unsigned lodepng_palette_add(LodePNGColorMode* info,
							 unsigned char r, unsigned char g, unsigned char b, unsigned char a);

/*get the total amount of bits per pixel, based on colortype and bitdepth in the struct*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info);
/*get the amount of color channels used, based on colortype in the struct.
If a palette is used, it counts as 1 channel.*/
unsigned lodepng_get_channels(const LodePNGColorMode* info);
/*is it a greyscale type? (only colortype 0 or 4)*/
unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info);
/*has it got an alpha channel? (only colortype 2 or 6)*/
unsigned lodepng_is_alpha_type(const LodePNGColorMode* info);
/*has it got a palette? (only colortype 3)*/
unsigned lodepng_is_palette_type(const LodePNGColorMode* info);
/*only returns true if there is a palette and there is a value in the palette with alpha < 255.
Loops through the palette to check this.*/
unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info);
/*
Check if the given color info indicates the possibility of having non-opaque pixels in the PNG image.
Returns true if the image can have translucent or invisible pixels (it still be opaque if it doesn't use such pixels).
Returns false if the image can only have opaque pixels.
In detail, it returns true only if it's a color type with alpha, or has a palette with non-opaque values,
or if "key_defined" is true.
*/
unsigned lodepng_can_have_alpha(const LodePNGColorMode* info);
/*Returns the byte size of a raw image buffer with given width, height and color mode*/
size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*The information of a Time chunk in PNG.*/
typedef struct LodePNGTime
{
  unsigned year;    /*2 bytes used (0-65535)*/
  unsigned month;   /*1-12*/
  unsigned day;     /*1-31*/
  unsigned hour;    /*0-23*/
  unsigned minute;  /*0-59*/
  unsigned second;  /*0-60 (to allow for leap seconds)*/
} LodePNGTime;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*Information about the PNG image, except pixels, width and height.*/
typedef struct LodePNGInfo
{
  /*header (IHDR), palette (PLTE) and transparency (tRNS) chunks*/
  unsigned compression_method;/*compression method of the original file. Always 0.*/
  unsigned filter_method;     /*filter method of the original file*/
  unsigned interlace_method;  /*interlace method of the original file*/
  LodePNGColorMode color;     /*color type and bits, palette and transparency of the PNG file*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*
  suggested background color chunk (bKGD)
  This color uses the same color mode as the PNG (except alpha channel), which can be 1-bit to 16-bit.

  For greyscale PNGs, r, g and b will all 3 be set to the same. When encoding
  the encoder writes the red one. For palette PNGs: When decoding, the RGB value
  will be stored, not a palette index. But when encoding, specify the index of
  the palette in background_r, the other two are then ignored.

  The decoder does not use this background color to edit the color of pixels.
  */
  unsigned background_defined; /*is a suggested background color given?*/
  unsigned background_r;       /*red component of suggested background color*/
  unsigned background_g;       /*green component of suggested background color*/
  unsigned background_b;       /*blue component of suggested background color*/

  /*
  non-international text chunks (tEXt and zTXt)

  The char** arrays each contain num strings. The actual messages are in
  text_strings, while text_keys are keywords that give a short description what
  the actual text represents, e.g. Title, Author, Description, or anything else.

  A keyword is minimum 1 character and maximum 79 characters long. It's
  discouraged to use a single line length longer than 79 characters for texts.

  Don't allocate these text buffers yourself. Use the init/cleanup functions
  correctly and use lodepng_add_text and lodepng_clear_text.
  */
  size_t text_num; /*the amount of texts in these char** buffers (there may be more texts in itext)*/
  char** text_keys; /*the keyword of a text chunk (e.g. "Comment")*/
  char** text_strings; /*the actual text*/

  /*
  international text chunks (iTXt)
  Similar to the non-international text chunks, but with additional strings
  "langtags" and "transkeys".
  */
  size_t itext_num; /*the amount of international texts in this PNG*/
  char** itext_keys; /*the English keyword of the text chunk (e.g. "Comment")*/
  char** itext_langtags; /*language tag for this text's language, ISO/IEC 646 string, e.g. ISO 639 language tag*/
  char** itext_transkeys; /*keyword translated to the international language - UTF-8 string*/
  char** itext_strings; /*the actual international text - UTF-8 string*/

  /*time chunk (tIME)*/
  unsigned time_defined; /*set to 1 to make the encoder generate a tIME chunk*/
  LodePNGTime time;

  /*phys chunk (pHYs)*/
  unsigned phys_defined; /*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/
  unsigned phys_x; /*pixels per unit in x direction*/
  unsigned phys_y; /*pixels per unit in y direction*/
  unsigned phys_unit; /*may be 0 (unknown unit) or 1 (metre)*/

  /*
  unknown chunks
  There are 3 buffers, one for each position in the PNG where unknown chunks can appear
  each buffer contains all unknown chunks for that position consecutively
  The 3 buffers are the unknown chunks between certain critical chunks:
  0: IHDR-PLTE, 1: PLTE-IDAT, 2: IDAT-IEND
  Do not allocate or traverse this data yourself. Use the chunk traversing functions declared
  later, such as lodepng_chunk_next and lodepng_chunk_append, to read/write this struct.
  */
  unsigned char* unknown_chunks_data[3];
  size_t unknown_chunks_size[3]; /*size in bytes of the unknown chunks, given for protection*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGInfo;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_info_init(LodePNGInfo* info);
void lodepng_info_cleanup(LodePNGInfo* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
void lodepng_clear_text(LodePNGInfo* info); /*use this to clear the texts again after you filled them in*/
unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str); /*push back both texts at once*/

void lodepng_clear_itext(LodePNGInfo* info); /*use this to clear the itexts again after you filled them in*/
unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
						   const char* transkey, const char* str); /*push back the 4 texts of 1 chunk at once*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*
Converts raw buffer from one color type to another color type, based on
LodePNGColorMode structs to describe the input and output color type.
See the reference manual at the end of this header file to see which color conversions are supported.
return value = LodePNG error code (0 if all went ok, an error if the conversion isn't supported)
The out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel
of the output color type (lodepng_get_bpp).
For < 8 bpp images, there should not be padding bits at the end of scanlines.
For 16-bit per channel colors, uses big endian format like PNG does.
Return value is LodePNG error code
*/
unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
						 LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
						 unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DECODER
/*
Settings for the decoder. This contains settings for the PNG and the Zlib
decoder, but not the Info settings from the Info structs.
*/
typedef struct LodePNGDecoderSettings
{
  LodePNGDecompressSettings zlibsettings; /*in here is the setting to ignore Adler32 checksums*/

  unsigned ignore_crc; /*ignore CRC checksums*/

  unsigned color_convert; /*whether to convert the PNG to the color type you want. Default: yes*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned read_text_chunks; /*if false but remember_unknown_chunks is true, they're stored in the unknown chunks*/
  /*store all bytes from unknown chunks in the LodePNGInfo (off by default, useful for a png editor)*/
  unsigned remember_unknown_chunks;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGDecoderSettings;

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*automatically use color type with less bits per pixel if losslessly possible. Default: AUTO*/
typedef enum LodePNGFilterStrategy
{
  /*every filter at zero*/
  LFS_ZERO,
  /*Use filter that gives minumum sum, as described in the official PNG filter heuristic.*/
  LFS_MINSUM,
  /*Use the filter type that gives smallest Shannon entropy for this scanline. Depending
  on the image, this is better or worse than minsum.*/
  LFS_ENTROPY,
  /*
  Brute-force-search PNG filters by compressing each filter for each scanline.
  Experimental, very slow, and only rarely gives better compression than MINSUM.
  */
  LFS_BRUTE_FORCE,
  /*use predefined_filters buffer: you specify the filter type for each scanline*/
  LFS_PREDEFINED
} LodePNGFilterStrategy;

/*Gives characteristics about the colors of the image, which helps decide which color model to use for encoding.
Used internally by default if "auto_convert" is enabled. Public because it's useful for custom algorithms.*/
typedef struct LodePNGColorProfile
{
  unsigned colored; /*not greyscale*/
  unsigned key; /*if true, image is not opaque. Only if true and alpha is false, color key is possible.*/
  unsigned short key_r; /*these values are always in 16-bit bitdepth in the profile*/
  unsigned short key_g;
  unsigned short key_b;
  unsigned alpha; /*alpha channel or alpha palette required*/
  unsigned numcolors; /*amount of colors, up to 257. Not valid if bits == 16.*/
  unsigned char palette[1024]; /*Remembers up to the first 256 RGBA colors, in no particular order*/
  unsigned bits; /*bits per channel (not for palette). 1,2 or 4 for greyscale only. 16 if 16-bit per channel required.*/
} LodePNGColorProfile;

void lodepng_color_profile_init(LodePNGColorProfile* profile);

/*Get a LodePNGColorProfile of the image.*/
unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,
								   const unsigned char* image, unsigned w, unsigned h,
								   const LodePNGColorMode* mode_in);
/*The function LodePNG uses internally to decide the PNG color with auto_convert.
Chooses an optimal color model, e.g. grey if only grey pixels, palette if < 256 colors, ...*/
unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,
								   const unsigned char* image, unsigned w, unsigned h,
								   const LodePNGColorMode* mode_in);

/*Settings for the encoder.*/
typedef struct LodePNGEncoderSettings
{
  LodePNGCompressSettings zlibsettings; /*settings for the zlib encoder, such as window size, ...*/

  unsigned auto_convert; /*automatically choose output PNG color type. Default: true*/

  /*If true, follows the official PNG heuristic: if the PNG uses a palette or lower than
  8 bit depth, set all filters to zero. Otherwise use the filter_strategy. Note that to
  completely follow the official PNG heuristic, filter_palette_zero must be true and
  filter_strategy must be LFS_MINSUM*/
  unsigned filter_palette_zero;
  /*Which filter strategy to use when not using zeroes due to filter_palette_zero.
  Set filter_palette_zero to 0 to ensure always using your chosen strategy. Default: LFS_MINSUM*/
  LodePNGFilterStrategy filter_strategy;
  /*used if filter_strategy is LFS_PREDEFINED. In that case, this must point to a buffer with
  the same length as the amount of scanlines in the image, and each value must <= 5. You
  have to cleanup this buffer, LodePNG will never free it. Don't forget that filter_palette_zero
  must be set to 0 to ensure this is also used on palette or low bitdepth images.*/
  const unsigned char* predefined_filters;

  /*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette).
  If colortype is 3, PLTE is _always_ created.*/
  unsigned force_palette;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*add LodePNG identifier and version as a text chunk, for debugging*/
  unsigned add_id;
  /*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/
  unsigned text_compression;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGEncoderSettings;

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)
/*The settings, state and information for extended encoding and decoding.*/
typedef struct LodePNGState
{
#ifdef LODEPNG_COMPILE_DECODER
  LodePNGDecoderSettings decoder; /*the decoding settings*/
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  LodePNGEncoderSettings encoder; /*the encoding settings*/
#endif /*LODEPNG_COMPILE_ENCODER*/
  LodePNGColorMode info_raw; /*specifies the format in which you would like to get the raw pixel buffer*/
  LodePNGInfo info_png; /*info of the PNG image obtained after decoding*/
  unsigned error;
#ifdef LODEPNG_COMPILE_CPP
  //For the lodepng::State subclass.
  virtual ~LodePNGState(){}
#endif
} LodePNGState;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_state_init(LodePNGState* state);
void lodepng_state_cleanup(LodePNGState* state);
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source);
#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_DECODER
/*
Same as lodepng_decode_memory, but uses a LodePNGState to allow custom settings and
getting much more information about the PNG image and color mode.
*/
unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
						LodePNGState* state,
						const unsigned char* in, size_t insize);

/*
Read the PNG header, but not the actual data. This returns only the information
that is in the header chunk of the PNG, such as width, height and color type. The
information is placed in the info_png field of the LodePNGState.
*/
unsigned lodepng_inspect(unsigned* w, unsigned* h,
						 LodePNGState* state,
						 const unsigned char* in, size_t insize);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/
unsigned lodepng_encode(unsigned char** out, size_t* outsize,
						const unsigned char* image, unsigned w, unsigned h,
						LodePNGState* state);
#endif /*LODEPNG_COMPILE_ENCODER*/

/*
The lodepng_chunk functions are normally not needed, except to traverse the
unknown chunks stored in the LodePNGInfo struct, or add new ones to it.
It also allows traversing the chunks of an encoded PNG file yourself.

PNG standard chunk naming conventions:
First byte: uppercase = critical, lowercase = ancillary
Second byte: uppercase = public, lowercase = private
Third byte: must be uppercase
Fourth byte: uppercase = unsafe to copy, lowercase = safe to copy
*/

/*
Gets the length of the data of the chunk. Total chunk length has 12 bytes more.
There must be at least 4 bytes to read from. If the result value is too large,
it may be corrupt data.
*/
unsigned lodepng_chunk_length(const unsigned char* chunk);

/*puts the 4-byte type in null terminated string*/
void lodepng_chunk_type(char type[5], const unsigned char* chunk);

/*check if the type is the given type*/
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type);

/*0: it's one of the critical chunk types, 1: it's an ancillary chunk (see PNG standard)*/
unsigned char lodepng_chunk_ancillary(const unsigned char* chunk);

/*0: public, 1: private (see PNG standard)*/
unsigned char lodepng_chunk_private(const unsigned char* chunk);

/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy (see PNG standard)*/
unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk);

/*get pointer to the data of the chunk, where the input points to the header of the chunk*/
unsigned char* lodepng_chunk_data(unsigned char* chunk);
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk);

/*returns 0 if the crc is correct, 1 if it's incorrect (0 for OK as usual!)*/
unsigned lodepng_chunk_check_crc(const unsigned char* chunk);

/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/
void lodepng_chunk_generate_crc(unsigned char* chunk);

/*iterate to next chunks. don't use on IEND chunk, as there is no next chunk then*/
unsigned char* lodepng_chunk_next(unsigned char* chunk);
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk);

/*
Appends chunk to the data in out. The given chunk should already have its chunk header.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returns error code (0 if it went ok)
*/
unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk);

/*
Appends new chunk to out. The chunk to append is given by giving its length, type
and data separately. The type is a 4-letter string.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returne error code (0 if it went ok)
*/
unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
							  const char* type, const unsigned char* data);

/*Calculate CRC32 of buffer*/
unsigned lodepng_crc32(const unsigned char* buf, size_t len);
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ZLIB
/*
This zlib part can be used independently to zlib compress and decompress a
buffer. It cannot be used to create gzip files however, and it only supports the
part of zlib that is required for PNG, it does not support dictionaries.
*/

#ifdef LODEPNG_COMPILE_DECODER
/*Inflate a buffer. Inflate is the decompression step of deflate. Out buffer must be freed after use.*/
unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGDecompressSettings* settings);

/*
Decompresses Zlib data. Reallocates the out buffer and appends the data. The
data must be according to the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize,
								 const unsigned char* in, size_t insize,
								 const LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Compresses data with Zlib. Reallocates the out buffer and appends the data.
Zlib adds a small header and trailer around the deflate data.
The data is output in the format of the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize,
							   const unsigned char* in, size_t insize,
							   const LodePNGCompressSettings* settings);

/*
Find length-limited Huffman code for given frequencies. This function is in the
public interface only for tests, it's used internally by lodepng_deflate.
*/
unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
									  size_t numcodes, unsigned maxbitlen);

/*Compress a buffer with deflate. See RFC 1951. Out buffer must be freed after use.*/
unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGCompressSettings* settings);

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DISK
/*
Load a file from disk into buffer. The function allocates the out buffer, and
after usage you should free it.
out: output parameter, contains pointer to loaded buffer.
outsize: output parameter, size of the allocated out buffer
filename: the path to the file to load
return value: error code (0 means ok)
*/
unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename);

/*
Save a file from buffer to disk. Warning, if it exists, this function overwrites
the file without warning!
buffer: the buffer to write
buffersize: size of the buffer to write
filename: the path to the file to save to
return value: error code (0 means ok)
*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/

#ifdef LODEPNG_COMPILE_CPP
//The LodePNG C++ wrapper uses std::vectors instead of manually allocated memory buffers.
namespace lodepng
{
#ifdef LODEPNG_COMPILE_PNG
class State : public LodePNGState
{
  public:
	State();
	State(const State& other);
	virtual ~State();
	State& operator=(const State& other);
};

#ifdef LODEPNG_COMPILE_DECODER
//Same as other lodepng::decode, but using a State for more settings and information.
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const unsigned char* in, size_t insize);
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const std::vector<unsigned char>& in);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
//Same as other lodepng::encode, but using a State for more settings and information.
unsigned encode(std::vector<unsigned char>& out,
				const unsigned char* in, unsigned w, unsigned h,
				State& state);
unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				State& state);
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DISK
/*
Load a file from disk into an std::vector. If the vector is empty, then either
the file doesn't exist or is an empty file.
*/
void load_file(std::vector<unsigned char>& buffer, const std::string& filename);

/*
Save the binary data in an std::vector to a file on disk. The file is overwritten
without warning.
*/
void save_file(const std::vector<unsigned char>& buffer, const std::string& filename);
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_PNG

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_DECODER
//Zlib-decompress an unsigned char buffer
unsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
					const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);

//Zlib-decompress an std::vector
unsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
					const LodePNGDecompressSettings& settings = lodepng_default_decompress_settings);
#endif //LODEPNG_COMPILE_DECODER

#ifdef LODEPNG_COMPILE_ENCODER
//Zlib-compress an unsigned char buffer
unsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
				  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);

//Zlib-compress an std::vector
unsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
				  const LodePNGCompressSettings& settings = lodepng_default_compress_settings);
#endif //LODEPNG_COMPILE_ENCODER
#endif //LODEPNG_COMPILE_ZLIB
} //namespace lodepng
#endif /*LODEPNG_COMPILE_CPP*/

/*
TODO:
[.] test if there are no memory leaks or security exploits - done a lot but needs to be checked often
[.] check compatibility with vareous compilers  - done but needs to be redone for every newer version
[X] converting color to 16-bit per channel types
[ ] read all public PNG chunk types (but never let the color profile and gamma ones touch RGB values)
[ ] make sure encoder generates no chunks with size > (2^31)-1
[ ] partial decoding (stream processing)
[X] let the "isFullyOpaque" function check color keys and transparent palettes too
[X] better name for the variables "codes", "codesD", "codelengthcodes", "clcl" and "lldl"
[ ] don't stop decoding on errors like 69, 57, 58 (make warnings)
[ ] let the C++ wrapper catch exceptions coming from the standard library and return LodePNG error codes
[ ] allow user to provide custom color conversion functions, e.g. for premultiplied alpha, padding bits or not, ...
*/

#endif /*LODEPNG_H inclusion guard*/

/*
LodePNG Documentation
---------------------

0. table of contents
--------------------

  1. about
   1.1. supported features
   1.2. features not supported
  2. C and C++ version
  3. security
  4. decoding
  5. encoding
  6. color conversions
	6.1. PNG color types
	6.2. color conversions
	6.3. padding bits
	6.4. A note about 16-bits per channel and endianness
  7. error values
  8. chunks and PNG editing
  9. compiler support
  10. examples
   10.1. decoder C++ example
   10.2. decoder C example
  11. changes
  12. contact information

1. about
--------

PNG is a file format to store raster images losslessly with good compression,
supporting different color types and alpha channel.

LodePNG is a PNG codec according to the Portable Network Graphics (PNG)
Specification (Second Edition) - W3C Recommendation 10 November 2003.

The specifications used are:

*) Portable Network Graphics (PNG) Specification (Second Edition):
	 http://www.w3.org/TR/2003/REC-PNG-20031110
*) RFC 1950 ZLIB Compressed Data Format version 3.3:
	 http://www.gzip.org/zlib/rfc-zlib.html
*) RFC 1951 DEFLATE Compressed Data Format Specification ver 1.3:
	 http://www.gzip.org/zlib/rfc-deflate.html

The most recent version of LodePNG can currently be found at
http://lodev.org/lodepng/

LodePNG works both in C (ISO C90) and C++, with a C++ wrapper that adds
extra functionality.

LodePNG exists out of two files:
-lodepng.h: the header file for both C and C++
-lodepng.c(pp): give it the name lodepng.c or lodepng.cpp (or .cc) depending on your usage

If you want to start using LodePNG right away without reading this doc, get the
examples from the LodePNG website to see how to use it in code, or check the
smaller examples in chapter 13 here.

LodePNG is simple but only supports the basic requirements. To achieve
simplicity, the following design choices were made: There are no dependencies
on any external library. There are functions to decode and encode a PNG with
a single function call, and extended versions of these functions taking a
LodePNGState struct allowing to specify or get more information. By default
the colors of the raw image are always RGB or RGBA, no matter what color type
the PNG file uses. To read and write files, there are simple functions to
convert the files to/from buffers in memory.

This all makes LodePNG suitable for loading textures in games, demos and small
programs, ... It's less suitable for full fledged image editors, loading PNGs
over network (it requires all the image data to be available before decoding can
begin), life-critical systems, ...

1.1. supported features
-----------------------

The following features are supported by the decoder:

*) decoding of PNGs with any color type, bit depth and interlace mode, to a 24- or 32-bit color raw image,
   or the same color type as the PNG
*) encoding of PNGs, from any raw image to 24- or 32-bit color, or the same color type as the raw image
*) Adam7 interlace and deinterlace for any color type
*) loading the image from harddisk or decoding it from a buffer from other sources than harddisk
*) support for alpha channels, including RGBA color model, translucent palettes and color keying
*) zlib decompression (inflate)
*) zlib compression (deflate)
*) CRC32 and ADLER32 checksums
*) handling of unknown chunks, allowing making a PNG editor that stores custom and unknown chunks.
*) the following chunks are supported (generated/interpreted) by both encoder and decoder:
	IHDR: header information
	PLTE: color palette
	IDAT: pixel data
	IEND: the final chunk
	tRNS: transparency for palettized images
	tEXt: textual information
	zTXt: compressed textual information
	iTXt: international textual information
	bKGD: suggested background color
	pHYs: physical dimensions
	tIME: modification time

1.2. features not supported
---------------------------

The following features are _not_ supported:

*) some features needed to make a conformant PNG-Editor might be still missing.
*) partial loading/stream processing. All data must be available and is processed in one call.
*) The following public chunks are not supported but treated as unknown chunks by LodePNG
	cHRM, gAMA, iCCP, sRGB, sBIT, hIST, sPLT
   Some of these are not supported on purpose: LodePNG wants to provide the RGB values
   stored in the pixels, not values modified by system dependent gamma or color models.

2. C and C++ version
--------------------

The C version uses buffers allocated with alloc that you need to free()
yourself. You need to use init and cleanup functions for each struct whenever
using a struct from the C version to avoid exploits and memory leaks.

The C++ version has extra functions with std::vectors in the interface and the
lodepng::State class which is a LodePNGState with constructor and destructor.

These files work without modification for both C and C++ compilers because all
the additional C++ code is in "#ifdef __cplusplus" blocks that make C-compilers
ignore it, and the C code is made to compile both with strict ISO C90 and C++.

To use the C++ version, you need to rename the source file to lodepng.cpp
(instead of lodepng.c), and compile it with a C++ compiler.

To use the C version, you need to rename the source file to lodepng.c (instead
of lodepng.cpp), and compile it with a C compiler.

3. Security
-----------

Even if carefully designed, it's always possible that LodePNG contains possible
exploits. If you discover one, please let me know, and it will be fixed.

When using LodePNG, care has to be taken with the C version of LodePNG, as well
as the C-style structs when working with C++. The following conventions are used
for all C-style structs:

-if a struct has a corresponding init function, always call the init function when making a new one
-if a struct has a corresponding cleanup function, call it before the struct disappears to avoid memory leaks
-if a struct has a corresponding copy function, use the copy function instead of "=".
 The destination must also be inited already.

4. Decoding
-----------

Decoding converts a PNG compressed image to a raw pixel buffer.

Most documentation on using the decoder is at its declarations in the header
above. For C, simple decoding can be done with functions such as
lodepng_decode32, and more advanced decoding can be done with the struct
LodePNGState and lodepng_decode. For C++, all decoding can be done with the
various lodepng::decode functions, and lodepng::State can be used for advanced
features.

When using the LodePNGState, it uses the following fields for decoding:
*) LodePNGInfo info_png: it stores extra information about the PNG (the input) in here
*) LodePNGColorMode info_raw: here you can say what color mode of the raw image (the output) you want to get
*) LodePNGDecoderSettings decoder: you can specify a few extra settings for the decoder to use

LodePNGInfo info_png
--------------------

After decoding, this contains extra information of the PNG image, except the actual
pixels, width and height because these are already gotten directly from the decoder
functions.

It contains for example the original color type of the PNG image, text comments,
suggested background color, etc... More details about the LodePNGInfo struct are
at its declaration documentation.

LodePNGColorMode info_raw
-------------------------

When decoding, here you can specify which color type you want
the resulting raw image to be. If this is different from the colortype of the
PNG, then the decoder will automatically convert the result. This conversion
always works, except if you want it to convert a color PNG to greyscale or to
a palette with missing colors.

By default, 32-bit color is used for the result.

LodePNGDecoderSettings decoder
------------------------------

The settings can be used to ignore the errors created by invalid CRC and Adler32
chunks, and to disable the decoding of tEXt chunks.

There's also a setting color_convert, true by default. If false, no conversion
is done, the resulting data will be as it was in the PNG (after decompression)
and you'll have to puzzle the colors of the pixels together yourself using the
color type information in the LodePNGInfo.

5. Encoding
-----------

Encoding converts a raw pixel buffer to a PNG compressed image.

Most documentation on using the encoder is at its declarations in the header
above. For C, simple encoding can be done with functions such as
lodepng_encode32, and more advanced decoding can be done with the struct
LodePNGState and lodepng_encode. For C++, all encoding can be done with the
various lodepng::encode functions, and lodepng::State can be used for advanced
features.

Like the decoder, the encoder can also give errors. However it gives less errors
since the encoder input is trusted, the decoder input (a PNG image that could
be forged by anyone) is not trusted.

When using the LodePNGState, it uses the following fields for encoding:
*) LodePNGInfo info_png: here you specify how you want the PNG (the output) to be.
*) LodePNGColorMode info_raw: here you say what color type of the raw image (the input) has
*) LodePNGEncoderSettings encoder: you can specify a few settings for the encoder to use

LodePNGInfo info_png
--------------------

When encoding, you use this the opposite way as when decoding: for encoding,
you fill in the values you want the PNG to have before encoding. By default it's
not needed to specify a color type for the PNG since it's automatically chosen,
but it's possible to choose it yourself given the right settings.

The encoder will not always exactly match the LodePNGInfo struct you give,
it tries as close as possible. Some things are ignored by the encoder. The
encoder uses, for example, the following settings from it when applicable:
colortype and bitdepth, text chunks, time chunk, the color key, the palette, the
background color, the interlace method, unknown chunks, ...

When encoding to a PNG with colortype 3, the encoder will generate a PLTE chunk.
If the palette contains any colors for which the alpha channel is not 255 (so
there are translucent colors in the palette), it'll add a tRNS chunk.

LodePNGColorMode info_raw
-------------------------

You specify the color type of the raw image that you give to the input here,
including a possible transparent color key and palette you happen to be using in
your raw image data.

By default, 32-bit color is assumed, meaning your input has to be in RGBA
format with 4 bytes (unsigned chars) per pixel.

LodePNGEncoderSettings encoder
------------------------------

The following settings are supported (some are in sub-structs):
*) auto_convert: when this option is enabled, the encoder will
automatically choose the smallest possible color mode (including color key) that
can encode the colors of all pixels without information loss.
*) btype: the block type for LZ77. 0 = uncompressed, 1 = fixed huffman tree,
   2 = dynamic huffman tree (best compression). Should be 2 for proper
   compression.
*) use_lz77: whether or not to use LZ77 for compressed block types. Should be
   true for proper compression.
*) windowsize: the window size used by the LZ77 encoder (1 - 32768). Has value
   2048 by default, but can be set to 32768 for better, but slow, compression.
*) force_palette: if colortype is 2 or 6, you can make the encoder write a PLTE
   chunk if force_palette is true. This can used as suggested palette to convert
   to by viewers that don't support more than 256 colors (if those still exist)
*) add_id: add text chunk "Encoder: LodePNG <version>" to the image.
*) text_compression: default 1. If 1, it'll store texts as zTXt instead of tEXt chunks.
  zTXt chunks use zlib compression on the text. This gives a smaller result on
  large texts but a larger result on small texts (such as a single program name).
  It's all tEXt or all zTXt though, there's no separate setting per text yet.

6. color conversions
--------------------

An important thing to note about LodePNG, is that the color type of the PNG, and
the color type of the raw image, are completely independent. By default, when
you decode a PNG, you get the result as a raw image in the color type you want,
no matter whether the PNG was encoded with a palette, greyscale or RGBA color.
And if you encode an image, by default LodePNG will automatically choose the PNG
color type that gives good compression based on the values of colors and amount
of colors in the image. It can be configured to let you control it instead as
well, though.

To be able to do this, LodePNG does conversions from one color mode to another.
It can convert from almost any color type to any other color type, except the
following conversions: RGB to greyscale is not supported, and converting to a
palette when the palette doesn't have a required color is not supported. This is
not supported on purpose: this is information loss which requires a color
reduction algorithm that is beyong the scope of a PNG encoder (yes, RGB to grey
is easy, but there are multiple ways if you want to give some channels more
weight).

By default, when decoding, you get the raw image in 32-bit RGBA or 24-bit RGB
color, no matter what color type the PNG has. And by default when encoding,
LodePNG automatically picks the best color model for the output PNG, and expects
the input image to be 32-bit RGBA or 24-bit RGB. So, unless you want to control
the color format of the images yourself, you can skip this chapter.

6.1. PNG color types
--------------------

A PNG image can have many color types, ranging from 1-bit color to 64-bit color,
as well as palettized color modes. After the zlib decompression and unfiltering
in the PNG image is done, the raw pixel data will have that color type and thus
a certain amount of bits per pixel. If you want the output raw image after
decoding to have another color type, a conversion is done by LodePNG.

The PNG specification gives the following color types:

0: greyscale, bit depths 1, 2, 4, 8, 16
2: RGB, bit depths 8 and 16
3: palette, bit depths 1, 2, 4 and 8
4: greyscale with alpha, bit depths 8 and 16
6: RGBA, bit depths 8 and 16

Bit depth is the amount of bits per pixel per color channel. So the total amount
of bits per pixel is: amount of channels * bitdepth.

6.2. color conversions
----------------------

As explained in the sections about the encoder and decoder, you can specify
color types and bit depths in info_png and info_raw to change the default
behaviour.

If, when decoding, you want the raw image to be something else than the default,
you need to set the color type and bit depth you want in the LodePNGColorMode,
or the parameters colortype and bitdepth of the simple decoding function.

If, when encoding, you use another color type than the default in the raw input
image, you need to specify its color type and bit depth in the LodePNGColorMode
of the raw image, or use the parameters colortype and bitdepth of the simple
encoding function.

If, when encoding, you don't want LodePNG to choose the output PNG color type
but control it yourself, you need to set auto_convert in the encoder settings
to false, and specify the color type you want in the LodePNGInfo of the
encoder (including palette: it can generate a palette if auto_convert is true,
otherwise not).

If the input and output color type differ (whether user chosen or auto chosen),
LodePNG will do a color conversion, which follows the rules below, and may
sometimes result in an error.

To avoid some confusion:
-the decoder converts from PNG to raw image
-the encoder converts from raw image to PNG
-the colortype and bitdepth in LodePNGColorMode info_raw, are those of the raw image
-the colortype and bitdepth in the color field of LodePNGInfo info_png, are those of the PNG
-when encoding, the color type in LodePNGInfo is ignored if auto_convert
 is enabled, it is automatically generated instead
-when decoding, the color type in LodePNGInfo is set by the decoder to that of the original
 PNG image, but it can be ignored since the raw image has the color type you requested instead
-if the color type of the LodePNGColorMode and PNG image aren't the same, a conversion
 between the color types is done if the color types are supported. If it is not
 supported, an error is returned. If the types are the same, no conversion is done.
-even though some conversions aren't supported, LodePNG supports loading PNGs from any
 colortype and saving PNGs to any colortype, sometimes it just requires preparing
 the raw image correctly before encoding.
-both encoder and decoder use the same color converter.

Non supported color conversions:
-color to greyscale: no error is thrown, but the result will look ugly because
only the red channel is taken
-anything to palette when that palette does not have that color in it: in this
case an error is thrown

Supported color conversions:
-anything to 8-bit RGB, 8-bit RGBA, 16-bit RGB, 16-bit RGBA
-any grey or grey+alpha, to grey or grey+alpha
-anything to a palette, as long as the palette has the requested colors in it
-removing alpha channel
-higher to smaller bitdepth, and vice versa

If you want no color conversion to be done (e.g. for speed or control):
-In the encoder, you can make it save a PNG with any color type by giving the
raw color mode and LodePNGInfo the same color mode, and setting auto_convert to
false.
-In the decoder, you can make it store the pixel data in the same color type
as the PNG has, by setting the color_convert setting to false. Settings in
info_raw are then ignored.

The function lodepng_convert does the color conversion. It is available in the
interface but normally isn't needed since the encoder and decoder already call
it.

6.3. padding bits
-----------------

In the PNG file format, if a less than 8-bit per pixel color type is used and the scanlines
have a bit amount that isn't a multiple of 8, then padding bits are used so that each
scanline starts at a fresh byte. But that is NOT true for the LodePNG raw input and output.
The raw input image you give to the encoder, and the raw output image you get from the decoder
will NOT have these padding bits, e.g. in the case of a 1-bit image with a width
of 7 pixels, the first pixel of the second scanline will the the 8th bit of the first byte,
not the first bit of a new byte.

6.4. A note about 16-bits per channel and endianness
----------------------------------------------------

LodePNG uses unsigned char arrays for 16-bit per channel colors too, just like
for any other color format. The 16-bit values are stored in big endian (most
significant byte first) in these arrays. This is the opposite order of the
little endian used by x86 CPU's.

LodePNG always uses big endian because the PNG file format does so internally.
Conversions to other formats than PNG uses internally are not supported by
LodePNG on purpose, there are myriads of formats, including endianness of 16-bit
colors, the order in which you store R, G, B and A, and so on. Supporting and
converting to/from all that is outside the scope of LodePNG.

This may mean that, depending on your use case, you may want to convert the big
endian output of LodePNG to little endian with a for loop. This is certainly not
always needed, many applications and libraries support big endian 16-bit colors
anyway, but it means you cannot simply cast the unsigned char* buffer to an
unsigned short* buffer on x86 CPUs.

7. error values
---------------

All functions in LodePNG that return an error code, return 0 if everything went
OK, or a non-zero code if there was an error.

The meaning of the LodePNG error values can be retrieved with the function
lodepng_error_text: given the numerical error code, it returns a description
of the error in English as a string.

Check the implementation of lodepng_error_text to see the meaning of each code.

8. chunks and PNG editing
-------------------------

If you want to add extra chunks to a PNG you encode, or use LodePNG for a PNG
editor that should follow the rules about handling of unknown chunks, or if your
program is able to read other types of chunks than the ones handled by LodePNG,
then that's possible with the chunk functions of LodePNG.

A PNG chunk has the following layout:

4 bytes length
4 bytes type name
length bytes data
4 bytes CRC

8.1. iterating through chunks
-----------------------------

If you have a buffer containing the PNG image data, then the first chunk (the
IHDR chunk) starts at byte number 8 of that buffer. The first 8 bytes are the
signature of the PNG and are not part of a chunk. But if you start at byte 8
then you have a chunk, and can check the following things of it.

NOTE: none of these functions check for memory buffer boundaries. To avoid
exploits, always make sure the buffer contains all the data of the chunks.
When using lodepng_chunk_next, make sure the returned value is within the
allocated memory.

unsigned lodepng_chunk_length(const unsigned char* chunk):

Get the length of the chunk's data. The total chunk length is this length + 12.

void lodepng_chunk_type(char type[5], const unsigned char* chunk):
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type):

Get the type of the chunk or compare if it's a certain type

unsigned char lodepng_chunk_critical(const unsigned char* chunk):
unsigned char lodepng_chunk_private(const unsigned char* chunk):
unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk):

Check if the chunk is critical in the PNG standard (only IHDR, PLTE, IDAT and IEND are).
Check if the chunk is private (public chunks are part of the standard, private ones not).
Check if the chunk is safe to copy. If it's not, then, when modifying data in a critical
chunk, unsafe to copy chunks of the old image may NOT be saved in the new one if your
program doesn't handle that type of unknown chunk.

unsigned char* lodepng_chunk_data(unsigned char* chunk):
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk):

Get a pointer to the start of the data of the chunk.

unsigned lodepng_chunk_check_crc(const unsigned char* chunk):
void lodepng_chunk_generate_crc(unsigned char* chunk):

Check if the crc is correct or generate a correct one.

unsigned char* lodepng_chunk_next(unsigned char* chunk):
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk):

Iterate to the next chunk. This works if you have a buffer with consecutive chunks. Note that these
functions do no boundary checking of the allocated data whatsoever, so make sure there is enough
data available in the buffer to be able to go to the next chunk.

unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk):
unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
							  const char* type, const unsigned char* data):

These functions are used to create new chunks that are appended to the data in *out that has
length *outlength. The append function appends an existing chunk to the new data. The create
function creates a new chunk with the given parameters and appends it. Type is the 4-letter
name of the chunk.

8.2. chunks in info_png
-----------------------

The LodePNGInfo struct contains fields with the unknown chunk in it. It has 3
buffers (each with size) to contain 3 types of unknown chunks:
the ones that come before the PLTE chunk, the ones that come between the PLTE
and the IDAT chunks, and the ones that come after the IDAT chunks.
It's necessary to make the distionction between these 3 cases because the PNG
standard forces to keep the ordering of unknown chunks compared to the critical
chunks, but does not force any other ordering rules.

info_png.unknown_chunks_data[0] is the chunks before PLTE
info_png.unknown_chunks_data[1] is the chunks after PLTE, before IDAT
info_png.unknown_chunks_data[2] is the chunks after IDAT

The chunks in these 3 buffers can be iterated through and read by using the same
way described in the previous subchapter.

When using the decoder to decode a PNG, you can make it store all unknown chunks
if you set the option settings.remember_unknown_chunks to 1. By default, this
option is off (0).

The encoder will always encode unknown chunks that are stored in the info_png.
If you need it to add a particular chunk that isn't known by LodePNG, you can
use lodepng_chunk_append or lodepng_chunk_create to the chunk data in
info_png.unknown_chunks_data[x].

Chunks that are known by LodePNG should not be added in that way. E.g. to make
LodePNG add a bKGD chunk, set background_defined to true and add the correct
parameters there instead.

9. compiler support
-------------------

No libraries other than the current standard C library are needed to compile
LodePNG. For the C++ version, only the standard C++ library is needed on top.
Add the files lodepng.c(pp) and lodepng.h to your project, include
lodepng.h where needed, and your program can read/write PNG files.

It is compatible with C90 and up, and C++03 and up.

If performance is important, use optimization when compiling! For both the
encoder and decoder, this makes a large difference.

Make sure that LodePNG is compiled with the same compiler of the same version
and with the same settings as the rest of the program, or the interfaces with
std::vectors and std::strings in C++ can be incompatible.

CHAR_BITS must be 8 or higher, because LodePNG uses unsigned chars for octets.

*) gcc and g++

LodePNG is developed in gcc so this compiler is natively supported. It gives no
warnings with compiler options "-Wall -Wextra -pedantic -ansi", with gcc and g++
version 4.7.1 on Linux, 32-bit and 64-bit.

*) Clang

Fully supported and warning-free.

*) Mingw

The Mingw compiler (a port of gcc for Windows) should be fully supported by
LodePNG.

*) Visual Studio and Visual C++ Express Edition

LodePNG should be warning-free with warning level W4. Two warnings were disabled
with pragmas though: warning 4244 about implicit conversions, and warning 4996
where it wants to use a non-standard function fopen_s instead of the standard C
fopen.

Visual Studio may want "stdafx.h" files to be included in each source file and
give an error "unexpected end of file while looking for precompiled header".
This is not standard C++ and will not be added to the stock LodePNG. You can
disable it for lodepng.cpp only by right clicking it, Properties, C/C++,
Precompiled Headers, and set it to Not Using Precompiled Headers there.

NOTE: Modern versions of VS should be fully supported, but old versions, e.g.
VS6, are not guaranteed to work.

*) Compilers on Macintosh

LodePNG has been reported to work both with gcc and LLVM for Macintosh, both for
C and C++.

*) Other Compilers

If you encounter problems on any compilers, feel free to let me know and I may
try to fix it if the compiler is modern and standards complient.

10. examples
------------

This decoder example shows the most basic usage of LodePNG. More complex
examples can be found on the LodePNG website.

10.1. decoder C++ example
-------------------------

#include <iostream>

int main(int argc, char *argv[])
{
  const char* filename = argc > 1 ? argv[1] : "test.png";

  //load and decode
  std::vector<unsigned char> image;
  unsigned width, height;
  unsigned error = lodepng::decode(image, width, height, filename);

  //if there's an error, display it
  if(error) std::cout << "decoder error " << error << ": " << lodepng_error_text(error) << std::endl;

  //the pixels are now in the vector "image", 4 bytes per pixel, ordered RGBARGBA..., use it as texture, draw it, ...
}

10.2. decoder C example
-----------------------

int main(int argc, char *argv[])
{
  unsigned error;
  unsigned char* image;
  size_t width, height;
  const char* filename = argc > 1 ? argv[1] : "test.png";

  error = lodepng_decode32_file(&image, &width, &height, filename);

  if(error) printf("decoder error %u: %s\n", error, lodepng_error_text(error));

  / * use image here * /

  free(image);
  return 0;
}

11. changes
-----------

The version number of LodePNG is the date of the change given in the format
yyyymmdd.

Some changes aren't backwards compatible. Those are indicated with a (!)
symbol.

*) 23 aug 2014: Reduced needless memory usage of decoder.
*) 28 jun 2014: Removed fix_png setting, always support palette OOB for
	simplicity. Made ColorProfile public.
*) 09 jun 2014: Faster encoder by fixing hash bug and more zeros optimization.
*) 22 dec 2013: Power of two windowsize required for optimization.
*) 15 apr 2013: Fixed bug with LAC_ALPHA and color key.
*) 25 mar 2013: Added an optional feature to ignore some PNG errors (fix_png).
*) 11 mar 2013 (!): Bugfix with custom free. Changed from "my" to "lodepng_"
	prefix for the custom allocators and made it possible with a new #define to
	use custom ones in your project without needing to change lodepng's code.
*) 28 jan 2013: Bugfix with color key.
*) 27 okt 2012: Tweaks in text chunk keyword length error handling.
*) 8 okt 2012 (!): Added new filter strategy (entropy) and new auto color mode.
	(no palette). Better deflate tree encoding. New compression tweak settings.
	Faster color conversions while decoding. Some internal cleanups.
*) 23 sep 2012: Reduced warnings in Visual Studio a little bit.
*) 1 sep 2012 (!): Removed #define's for giving custom (de)compression functions
	and made it work with function pointers instead.
*) 23 jun 2012: Added more filter strategies. Made it easier to use custom alloc
	and free functions and toggle #defines from compiler flags. Small fixes.
*) 6 may 2012 (!): Made plugging in custom zlib/deflate functions more flexible.
*) 22 apr 2012 (!): Made interface more consistent, renaming a lot. Removed
	redundant C++ codec classes. Reduced amount of structs. Everything changed,
	but it is cleaner now imho and functionality remains the same. Also fixed
	several bugs and shrinked the implementation code. Made new samples.
*) 6 nov 2011 (!): By default, the encoder now automatically chooses the best
	PNG color model and bit depth, based on the amount and type of colors of the
	raw image. For this, autoLeaveOutAlphaChannel replaced by auto_choose_color.
*) 9 okt 2011: simpler hash chain implementation for the encoder.
*) 8 sep 2011: lz77 encoder lazy matching instead of greedy matching.
*) 23 aug 2011: tweaked the zlib compression parameters after benchmarking.
	A bug with the PNG filtertype heuristic was fixed, so that it chooses much
	better ones (it's quite significant). A setting to do an experimental, slow,
	brute force search for PNG filter types is added.
*) 17 aug 2011 (!): changed some C zlib related function names.
*) 16 aug 2011: made the code less wide (max 120 characters per line).
*) 17 apr 2011: code cleanup. Bugfixes. Convert low to 16-bit per sample colors.
*) 21 feb 2011: fixed compiling for C90. Fixed compiling with sections disabled.
*) 11 dec 2010: encoding is made faster, based on suggestion by Peter Eastman
	to optimize long sequences of zeros.
*) 13 nov 2010: added LodePNG_InfoColor_hasPaletteAlpha and
	LodePNG_InfoColor_canHaveAlpha functions for convenience.
*) 7 nov 2010: added LodePNG_error_text function to get error code description.
*) 30 okt 2010: made decoding slightly faster
*) 26 okt 2010: (!) changed some C function and struct names (more consistent).
	 Reorganized the documentation and the declaration order in the header.
*) 08 aug 2010: only changed some comments and external samples.
*) 05 jul 2010: fixed bug thanks to warnings in the new gcc version.
*) 14 mar 2010: fixed bug where too much memory was allocated for char buffers.
*) 02 sep 2008: fixed bug where it could create empty tree that linux apps could
	read by ignoring the problem but windows apps couldn't.
*) 06 jun 2008: added more error checks for out of memory cases.
*) 26 apr 2008: added a few more checks here and there to ensure more safety.
*) 06 mar 2008: crash with encoding of strings fixed
*) 02 feb 2008: support for international text chunks added (iTXt)
*) 23 jan 2008: small cleanups, and #defines to divide code in sections
*) 20 jan 2008: support for unknown chunks allowing using LodePNG for an editor.
*) 18 jan 2008: support for tIME and pHYs chunks added to encoder and decoder.
*) 17 jan 2008: ability to encode and decode compressed zTXt chunks added
	Also vareous fixes, such as in the deflate and the padding bits code.
*) 13 jan 2008: Added ability to encode Adam7-interlaced images. Improved
	filtering code of encoder.
*) 07 jan 2008: (!) changed LodePNG to use ISO C90 instead of C++. A
	C++ wrapper around this provides an interface almost identical to before.
	Having LodePNG be pure ISO C90 makes it more portable. The C and C++ code
	are together in these files but it works both for C and C++ compilers.
*) 29 dec 2007: (!) changed most integer types to unsigned int + other tweaks
*) 30 aug 2007: bug fixed which makes this Borland C++ compatible
*) 09 aug 2007: some VS2005 warnings removed again
*) 21 jul 2007: deflate code placed in new namespace separate from zlib code
*) 08 jun 2007: fixed bug with 2- and 4-bit color, and small interlaced images
*) 04 jun 2007: improved support for Visual Studio 2005: crash with accessing
	invalid std::vector element [0] fixed, and level 3 and 4 warnings removed
*) 02 jun 2007: made the encoder add a tag with version by default
*) 27 may 2007: zlib and png code separated (but still in the same file),
	simple encoder/decoder functions added for more simple usage cases
*) 19 may 2007: minor fixes, some code cleaning, new error added (error 69),
	moved some examples from here to lodepng_examples.cpp
*) 12 may 2007: palette decoding bug fixed
*) 24 apr 2007: changed the license from BSD to the zlib license
*) 11 mar 2007: very simple addition: ability to encode bKGD chunks.
*) 04 mar 2007: (!) tEXt chunk related fixes, and support for encoding
	palettized PNG images. Plus little interface change with palette and texts.
*) 03 mar 2007: Made it encode dynamic Huffman shorter with repeat codes.
	Fixed a bug where the end code of a block had length 0 in the Huffman tree.
*) 26 feb 2007: Huffman compression with dynamic trees (BTYPE 2) now implemented
	and supported by the encoder, resulting in smaller PNGs at the output.
*) 27 jan 2007: Made the Adler-32 test faster so that a timewaste is gone.
*) 24 jan 2007: gave encoder an error interface. Added color conversion from any
	greyscale type to 8-bit greyscale with or without alpha.
*) 21 jan 2007: (!) Totally changed the interface. It allows more color types
	to convert to and is more uniform. See the manual for how it works now.
*) 07 jan 2007: Some cleanup & fixes, and a few changes over the last days:
	encode/decode custom tEXt chunks, separate classes for zlib & deflate, and
	at last made the decoder give errors for incorrect Adler32 or Crc.
*) 01 jan 2007: Fixed bug with encoding PNGs with less than 8 bits per channel.
*) 29 dec 2006: Added support for encoding images without alpha channel, and
	cleaned out code as well as making certain parts faster.
*) 28 dec 2006: Added "Settings" to the encoder.
*) 26 dec 2006: The encoder now does LZ77 encoding and produces much smaller files now.
	Removed some code duplication in the decoder. Fixed little bug in an example.
*) 09 dec 2006: (!) Placed output parameters of public functions as first parameter.
	Fixed a bug of the decoder with 16-bit per color.
*) 15 okt 2006: Changed documentation structure
*) 09 okt 2006: Encoder class added. It encodes a valid PNG image from the
	given image buffer, however for now it's not compressed.
*) 08 sep 2006: (!) Changed to interface with a Decoder class
*) 30 jul 2006: (!) LodePNG_InfoPng , width and height are now retrieved in different
	way. Renamed decodePNG to decodePNGGeneric.
*) 29 jul 2006: (!) Changed the interface: image info is now returned as a
	struct of type LodePNG::LodePNG_Info, instead of a vector, which was a bit clumsy.
*) 28 jul 2006: Cleaned the code and added new error checks.
	Corrected terminology "deflate" into "inflate".
*) 23 jun 2006: Added SDL example in the documentation in the header, this
	example allows easy debugging by displaying the PNG and its transparency.
*) 22 jun 2006: (!) Changed way to obtain error value. Added
	loadFile function for convenience. Made decodePNG32 faster.
*) 21 jun 2006: (!) Changed type of info vector to unsigned.
	Changed position of palette in info vector. Fixed an important bug that
	happened on PNGs with an uncompressed block.
*) 16 jun 2006: Internally changed unsigned into unsigned where
	needed, and performed some optimizations.
*) 07 jun 2006: (!) Renamed functions to decodePNG and placed them
	in LodePNG namespace. Changed the order of the parameters. Rewrote the
	documentation in the header. Renamed files to lodepng.cpp and lodepng.h
*) 22 apr 2006: Optimized and improved some code
*) 07 sep 2005: (!) Changed to std::vector interface
*) 12 aug 2005: Initial release (C++, decoder only)

12. contact information
-----------------------

Feel free to contact me with suggestions, problems, comments, ... concerning
LodePNG. If you encounter a PNG image that doesn't work properly with this
decoder, feel free to send it and I'll use it to find and fix the problem.

My email address is (puzzle the account and domain together with an @ symbol):
Domain: gmail dot com.
Account: lode dot vandevenne.

Copyright (c) 2005-2014 Lode Vandevenne
*/


//#line 1 "lodepng.cpp"
/*
The manual and changelog are in the header file "lodepng.h"
Rename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.
*/

#include <stdio.h>
#include <stdlib.h>

#ifdef LODEPNG_COMPILE_CPP
#include <fstream>
#endif /*LODEPNG_COMPILE_CPP*/

#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/
#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/
#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/
#endif /*_MSC_VER */

/*
This source file is built up in the following large parts. The code sections
with the "LODEPNG_COMPILE_" #defines divide this up further in an intermixed way.
-Tools for C and common code for PNG and Zlib
-C Code for Zlib (huffman, deflate, ...)
-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)
-The C++ wrapper around all of the above
*/

/*The malloc, realloc and free functions defined here with "lodepng_" in front
of the name, so that you can easily change them to others related to your
platform if needed. Everything else in the code calls these. Pass
-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out
#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size)
{
  return malloc(size);
}

static void* lodepng_realloc(void* ptr, size_t new_size)
{
  return realloc(ptr, new_size);
}

static void lodepng_free(void* ptr)
{
  free(ptr);
}
#else /*LODEPNG_COMPILE_ALLOCATORS*/
void* lodepng_malloc(size_t size);
void* lodepng_realloc(void* ptr, size_t new_size);
void lodepng_free(void* ptr);
#endif /*LODEPNG_COMPILE_ALLOCATORS*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // Tools for C, and common code for PNG and Zlib.                       // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

/*
Often in case of an error a value is assigned to a variable and then it breaks
out of a loop (to go to the cleanup phase of a function). This macro does that.
It makes the error handling code shorter and more readable.

Example: if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83);
*/
#define CERROR_BREAK(errorvar, code)\
{\
  errorvar = code;\
  break;\
}

/*version of CERROR_BREAK that assumes the common case where the error variable is named "error"*/
#define ERROR_BREAK(code) CERROR_BREAK(error, code)

/*Set error var to the error code, and return it.*/
#define CERROR_RETURN_ERROR(errorvar, code)\
{\
  errorvar = code;\
  return code;\
}

/*Try the code, if it returns error, also return the error.*/
#define CERROR_TRY_RETURN(call)\
{\
  unsigned error = call;\
  if(error) return error;\
}

/*Set error var to the error code, and return from the void function.*/
#define CERROR_RETURN(errorvar, code)\
{\
  errorvar = code;\
  return;\
}

/*
About uivector, ucvector and string:
-All of them wrap dynamic arrays or text strings in a similar way.
-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.
-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.
-They're not used in the interface, only internally in this file as static functions.
-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.
*/

#ifdef LODEPNG_COMPILE_ZLIB
/*dynamic vector of unsigned ints*/
typedef struct uivector
{
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p)
{
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
  lodepng_free(((uivector*)p)->data);
  ((uivector*)p)->data = NULL;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_reserve(uivector* p, size_t allocsize)
{
  if(allocsize > p->allocsize)
  {
	size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);
	void* data = lodepng_realloc(p->data, newsize);
	if(data)
	{
	  p->allocsize = newsize;
	  p->data = (unsigned*)data;
	}
	else return 0; /*error: not enough memory*/
  }
  return 1;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size)
{
  if(!uivector_reserve(p, size * sizeof(unsigned))) return 0;
  p->size = size;
  return 1; /*success*/
}

/*resize and give all new elements the value*/
static unsigned uivector_resizev(uivector* p, size_t size, unsigned value)
{
  size_t oldsize = p->size, i;
  if(!uivector_resize(p, size)) return 0;
  for(i = oldsize; i < size; ++i) p->data[i] = value;
  return 1;
}

static void uivector_init(uivector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}

#ifdef LODEPNG_COMPILE_ENCODER
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c)
{
  if(!uivector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}

/*copy q to p, returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_copy(uivector* p, const uivector* q)
{
  size_t i;
  if(!uivector_resize(p, q->size)) return 0;
  for(i = 0; i != q->size; ++i) p->data[i] = q->data[i];
  return 1;
}
#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

/* /////////////////////////////////////////////////////////////////////////// */

/*dynamic vector of unsigned chars*/
typedef struct ucvector
{
  unsigned char* data;
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_reserve(ucvector* p, size_t allocsize)
{
  if(allocsize > p->allocsize)
  {
	size_t newsize = (allocsize > p->allocsize * 2) ? allocsize : (allocsize * 3 / 2);
	void* data = lodepng_realloc(p->data, newsize);
	if(data)
	{
	  p->allocsize = newsize;
	  p->data = (unsigned char*)data;
	}
	else return 0; /*error: not enough memory*/
  }
  return 1;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size)
{
  if(!ucvector_reserve(p, size * sizeof(unsigned char))) return 0;
  p->size = size;
  return 1; /*success*/
}

#ifdef LODEPNG_COMPILE_PNG

static void ucvector_cleanup(void* p)
{
  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
  lodepng_free(((ucvector*)p)->data);
  ((ucvector*)p)->data = NULL;
}

static void ucvector_init(ucvector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}

#ifdef LODEPNG_COMPILE_DECODER
/*resize and give all new elements the value*/
static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value)
{
  size_t oldsize = p->size, i;
  if(!ucvector_resize(p, size)) return 0;
  for(i = oldsize; i < size; ++i) p->data[i] = value;
  return 1;
}
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ZLIB
/*you can both convert from vector to buffer&size and vica versa. If you use
init_buffer to take over a buffer and size, it is not needed to use cleanup*/
static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
{
  p->data = buffer;
  p->allocsize = p->size = size;
}
#endif /*LODEPNG_COMPILE_ZLIB*/

#if (defined(LODEPNG_COMPILE_PNG) && defined(LODEPNG_COMPILE_ANCILLARY_CHUNKS)) || defined(LODEPNG_COMPILE_ENCODER)
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_push_back(ucvector* p, unsigned char c)
{
  if(!ucvector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/

/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned string_resize(char** out, size_t size)
{
  char* data = (char*)lodepng_realloc(*out, size + 1);
  if(data)
  {
	data[size] = 0; /*null termination char*/
	*out = data;
  }
  return data != 0;
}

/*init a {char*, size_t} pair for use as string*/
static void string_init(char** out)
{
  *out = NULL;
  string_resize(out, 0);
}

/*free the above pair again*/
static void string_cleanup(char** out)
{
  lodepng_free(*out);
  *out = NULL;
}

static void string_set(char** out, const char* in)
{
  size_t insize = strlen(in), i;
  if(string_resize(out, insize))
  {
	for(i = 0; i != insize; ++i)
	{
	  (*out)[i] = in[i];
	}
  }
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_read32bitInt(const unsigned char* buffer)
{
  return (unsigned)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
}

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value)
{
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
  buffer[3] = (unsigned char)((value      ) & 0xff);
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/

#ifdef LODEPNG_COMPILE_ENCODER
static void lodepng_add32bitInt(ucvector* buffer, unsigned value)
{
  ucvector_resize(buffer, buffer->size + 4); /*todo: give error if resize failed*/
  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / File IO                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename)
{
  FILE* file;
  long size;

  /*provide some proper output values if error will happen*/
  *out = 0;
  *outsize = 0;

  file = fopen(filename, "rb");
  if(!file) return 78;

  /*get filesize:*/
  fseek(file , 0 , SEEK_END);
  size = ftell(file);
  rewind(file);

  /*read contents of the file into the vector*/
  *outsize = 0;
  *out = (unsigned char*)lodepng_malloc((size_t)size);
  if(size && (*out)) (*outsize) = fread(*out, 1, (size_t)size, file);

  fclose(file);
  if(!(*out) && size) return 83; /*the above malloc failed*/
  return 0;
}

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)
{
  FILE* file;
  file = fopen(filename, "wb" );
  if(!file) return 79;
  fwrite((char*)buffer , 1 , buffersize, file);
  fclose(file);
  return 0;
}

#endif /*LODEPNG_COMPILE_DISK*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of common code and tools. Begin of Zlib related code.            // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_ENCODER
/*TODO: this ignores potential out of memory errors*/
#define addBitToStream(/*size_t**/ bitpointer, /*ucvector**/ bitstream, /*unsigned char*/ bit)\
{\
  /*add a new byte at the end*/\
  if(((*bitpointer) & 7) == 0) ucvector_push_back(bitstream, (unsigned char)0);\
  /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/\
  (bitstream->data[bitstream->size - 1]) |= (bit << ((*bitpointer) & 0x7));\
  ++(*bitpointer);\
}

static void addBitsToStream(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> i) & 1));
}

static void addBitsToStreamReversed(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i != nbits; ++i) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> (nbits - 1 - i)) & 1));
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

#define READBIT(bitpointer, bitstream) ((bitstream[bitpointer >> 3] >> (bitpointer & 0x7)) & (unsigned char)1)

static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)(READBIT(*bitpointer, bitstream));
  ++(*bitpointer);
  return result;
}

static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0, i;
  for(i = 0; i != nbits; ++i)
  {
	result += ((unsigned)READBIT(*bitpointer, bitstream)) << i;
	++(*bitpointer);
  }
  return result;
}
#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflate - Huffman                                                      / */
/* ////////////////////////////////////////////////////////////////////////// */

#define FIRST_LENGTH_CODE_INDEX 257
#define LAST_LENGTH_CODE_INDEX 285
/*256 literals, the end code, some length codes, and 2 unused codes*/
#define NUM_DEFLATE_CODE_SYMBOLS 288
/*the distance codes have their own symbols, 30 used, 2 unused*/
#define NUM_DISTANCE_SYMBOLS 32
/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/
#define NUM_CODE_LENGTH_CODES 19

/*the base lengths represented by codes 257-285*/
static const unsigned LENGTHBASE[29]
  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
	 67, 83, 99, 115, 131, 163, 195, 227, 258};

/*the extra bits used by codes 257-285 (added to base length)*/
static const unsigned LENGTHEXTRA[29]
  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
	  4,  4,  4,   4,   5,   5,   5,   5,   0};

/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/
static const unsigned DISTANCEBASE[30]
  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
	 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};

/*the extra bits of backwards distances (added to base)*/
static const unsigned DISTANCEEXTRA[30]
  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,
	   8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};

/*the order in which "code length alphabet code lengths" are stored, out of this
the huffman tree of the dynamic huffman tree lengths is generated*/
static const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]
  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/* ////////////////////////////////////////////////////////////////////////// */

/*
Huffman tree struct, containing multiple representations of the tree
*/
typedef struct HuffmanTree
{
  unsigned* tree2d;
  unsigned* tree1d;
  unsigned* lengths; /*the lengths of the codes of the 1d-tree*/
  unsigned maxbitlen; /*maximum number of bits a single code can get*/
  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/
} HuffmanTree;

/*function used for debug purposes to draw the tree in ascii art with C++*/
/*
static void HuffmanTree_draw(HuffmanTree* tree)
{
  std::cout << "tree. length: " << tree->numcodes << " maxbitlen: " << tree->maxbitlen << std::endl;
  for(size_t i = 0; i != tree->tree1d.size; ++i)
  {
	if(tree->lengths.data[i])
	  std::cout << i << " " << tree->tree1d.data[i] << " " << tree->lengths.data[i] << std::endl;
  }
  std::cout << std::endl;
}*/

static void HuffmanTree_init(HuffmanTree* tree)
{
  tree->tree2d = 0;
  tree->tree1d = 0;
  tree->lengths = 0;
}

static void HuffmanTree_cleanup(HuffmanTree* tree)
{
  lodepng_free(tree->tree2d);
  lodepng_free(tree->tree1d);
  lodepng_free(tree->lengths);
}

/*the tree representation used by the decoder. return value is error*/
static unsigned HuffmanTree_make2DTree(HuffmanTree* tree)
{
  unsigned nodefilled = 0; /*up to which node it is filled*/
  unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/
  unsigned n, i;

  tree->tree2d = (unsigned*)lodepng_malloc(tree->numcodes * 2 * sizeof(unsigned));
  if(!tree->tree2d) return 83; /*alloc fail*/

  /*
  convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means
  uninited, a value >= numcodes is an address to another bit, a value < numcodes
  is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as
  many columns as codes - 1.
  A good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
  Here, the internal nodes are stored (what their 0 and 1 option point to).
  There is only memory for such good tree currently, if there are more nodes
  (due to too long length codes), error 55 will happen
  */
  for(n = 0; n < tree->numcodes * 2; ++n)
  {
	tree->tree2d[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
  }

  for(n = 0; n < tree->numcodes; ++n) /*the codes*/
  {
	for(i = 0; i != tree->lengths[n]; ++i) /*the bits for this code*/
	{
	  unsigned char bit = (unsigned char)((tree->tree1d[n] >> (tree->lengths[n] - i - 1)) & 1);
	  /*oversubscribed, see comment in lodepng_error_text*/
	  if(treepos > 2147483647 || treepos + 2 > tree->numcodes) return 55;
	  if(tree->tree2d[2 * treepos + bit] == 32767) /*not yet filled in*/
	  {
		if(i + 1 == tree->lengths[n]) /*last bit*/
		{
		  tree->tree2d[2 * treepos + bit] = n; /*put the current code in it*/
		  treepos = 0;
		}
		else
		{
		  /*put address of the next step in here, first that address has to be found of course
		  (it's just nodefilled + 1)...*/
		  ++nodefilled;
		  /*addresses encoded with numcodes added to it*/
		  tree->tree2d[2 * treepos + bit] = nodefilled + tree->numcodes;
		  treepos = nodefilled;
		}
	  }
	  else treepos = tree->tree2d[2 * treepos + bit] - tree->numcodes;
	}
  }

  for(n = 0; n < tree->numcodes * 2; ++n)
  {
	if(tree->tree2d[n] == 32767) tree->tree2d[n] = 0; /*remove possible remaining 32767's*/
  }

  return 0;
}

/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree)
{
  uivector blcount;
  uivector nextcode;
  unsigned error = 0;
  unsigned bits, n;

  uivector_init(&blcount);
  uivector_init(&nextcode);

  tree->tree1d = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
  if(!tree->tree1d) error = 83; /*alloc fail*/

  if(!uivector_resizev(&blcount, tree->maxbitlen + 1, 0)
  || !uivector_resizev(&nextcode, tree->maxbitlen + 1, 0))
	error = 83; /*alloc fail*/

  if(!error)
  {
	/*step 1: count number of instances of each code length*/
	for(bits = 0; bits != tree->numcodes; ++bits) ++blcount.data[tree->lengths[bits]];
	/*step 2: generate the nextcode values*/
	for(bits = 1; bits <= tree->maxbitlen; ++bits)
	{
	  nextcode.data[bits] = (nextcode.data[bits - 1] + blcount.data[bits - 1]) << 1;
	}
	/*step 3: generate all the codes*/
	for(n = 0; n != tree->numcodes; ++n)
	{
	  if(tree->lengths[n] != 0) tree->tree1d[n] = nextcode.data[tree->lengths[n]]++;
	}
  }

  uivector_cleanup(&blcount);
  uivector_cleanup(&nextcode);

  if(!error) return HuffmanTree_make2DTree(tree);
  else return error;
}

/*
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
											size_t numcodes, unsigned maxbitlen)
{
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  for(i = 0; i != numcodes; ++i) tree->lengths[i] = bitlen[i];
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->maxbitlen = maxbitlen;
  return HuffmanTree_makeFromLengths2(tree);
}

#ifdef LODEPNG_COMPILE_ENCODER

/*
A coin, this is the terminology used for the package-merge algorithm and the
coin collector's problem. This is used to generate the huffman tree.
A coin can be multiple coins (when they're merged)
*/
typedef struct Coin
{
  uivector symbols;
  float weight; /*the sum of all weights in this coin*/
} Coin;

static void coin_init(Coin* c)
{
  uivector_init(&c->symbols);
}

/*argument c is void* so that this dtor can be given as function pointer to the vector resize function*/
static void coin_cleanup(void* c)
{
  uivector_cleanup(&((Coin*)c)->symbols);
}

static void coin_copy(Coin* c1, const Coin* c2)
{
  c1->weight = c2->weight;
  uivector_copy(&c1->symbols, &c2->symbols);
}

static void add_coins(Coin* c1, const Coin* c2)
{
  size_t i;
  for(i = 0; i != c2->symbols.size; ++i) uivector_push_back(&c1->symbols, c2->symbols.data[i]);
  c1->weight += c2->weight;
}

static void init_coins(Coin* coins, size_t num)
{
  size_t i;
  for(i = 0; i != num; ++i) coin_init(&coins[i]);
}

static void cleanup_coins(Coin* coins, size_t num)
{
  size_t i;
  for(i = 0; i != num; ++i) coin_cleanup(&coins[i]);
}

static int coin_compare(const void* a, const void* b) {
  float wa = ((const Coin*)a)->weight;
  float wb = ((const Coin*)b)->weight;
  return wa > wb ? 1 : wa < wb ? -1 : 0;
}

static unsigned append_symbol_coins(Coin* coins, const unsigned* frequencies, unsigned numcodes, size_t sum)
{
  unsigned i;
  unsigned j = 0; /*index of present symbols*/
  for(i = 0; i != numcodes; ++i)
  {
	if(frequencies[i] != 0) /*only include symbols that are present*/
	{
	  coins[j].weight = frequencies[i] / (float)sum;
	  uivector_push_back(&coins[j].symbols, i);
	  ++j;
	}
  }
  return 0;
}

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
									  size_t numcodes, unsigned maxbitlen)
{
  unsigned i, j;
  size_t sum = 0, numpresent = 0;
  unsigned error = 0;
  Coin* coins; /*the coins of the currently calculated row*/
  Coin* prev_row; /*the previous row of coins*/
  size_t numcoins;
  size_t coinmem;

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/

  for(i = 0; i != numcodes; ++i)
  {
	if(frequencies[i] > 0)
	{
	  ++numpresent;
	  sum += frequencies[i];
	}
  }

  for(i = 0; i != numcodes; ++i) lengths[i] = 0;

  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. To decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoritical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0)
  {
	lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
  }
  else if(numpresent == 1)
  {
	for(i = 0; i != numcodes; ++i)
	{
	  if(frequencies[i])
	  {
		lengths[i] = 1;
		lengths[i == 0 ? 1 : 0] = 1;
		break;
	  }
	}
  }
  else
  {
	/*Package-Merge algorithm represented by coin collector's problem
	For every symbol, maxbitlen coins will be created*/

	coinmem = numpresent * 2; /*max amount of coins needed with the current algo*/
	coins = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);
	prev_row = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);
	if(!coins || !prev_row)
	{
	  lodepng_free(coins);
	  lodepng_free(prev_row);
	  return 83; /*alloc fail*/
	}
	init_coins(coins, coinmem);
	init_coins(prev_row, coinmem);

	/*first row, lowest denominator*/
	error = append_symbol_coins(coins, frequencies, numcodes, sum);
	numcoins = numpresent;
	qsort(coins, numcoins, sizeof(Coin), coin_compare);
	if(!error)
	{
	  unsigned numprev = 0;
	  for(j = 1; j <= maxbitlen && !error; ++j) /*each of the remaining rows*/
	  {
		unsigned tempnum;
		Coin* tempcoins;
		/*swap prev_row and coins, and their amounts*/
		tempcoins = prev_row; prev_row = coins; coins = tempcoins;
		tempnum = numprev; numprev = numcoins; numcoins = tempnum;

		cleanup_coins(coins, numcoins);
		init_coins(coins, numcoins);

		numcoins = 0;

		/*fill in the merged coins of the previous row*/
		for(i = 0; i + 1 < numprev; i += 2)
		{
		  /*merge prev_row[i] and prev_row[i + 1] into new coin*/
		  Coin* coin = &coins[numcoins++];
		  coin_copy(coin, &prev_row[i]);
		  add_coins(coin, &prev_row[i + 1]);
		}
		/*fill in all the original symbols again*/
		if(j < maxbitlen)
		{
		  error = append_symbol_coins(coins + numcoins, frequencies, numcodes, sum);
		  numcoins += numpresent;
		}
		qsort(coins, numcoins, sizeof(Coin), coin_compare);
	  }
	}

	if(!error)
	{
	  /*calculate the lengths of each symbol, as the amount of times a coin of each symbol is used*/
	  for(i = 0; i + 1 < numpresent; ++i)
	  {
		Coin* coin = &coins[i];
		for(j = 0; j < coin->symbols.size; ++j) ++lengths[coin->symbols.data[j]];
	  }
	}

	cleanup_coins(coins, coinmem);
	lodepng_free(coins);
	cleanup_coins(prev_row, coinmem);
	lodepng_free(prev_row);
  }

  return error;
}

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
												size_t mincodes, size_t numcodes, unsigned maxbitlen)
{
  unsigned error = 0;
  while(!frequencies[numcodes - 1] && numcodes > mincodes) --numcodes; /*trim zeroes*/
  tree->maxbitlen = maxbitlen;
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->lengths = (unsigned*)lodepng_realloc(tree->lengths, numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  /*initialize all lengths to 0*/
  memset(tree->lengths, 0, numcodes * sizeof(unsigned));

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
  return error;
}

static unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)
{
  return tree->tree1d[index];
}

static unsigned HuffmanTree_getLength(const HuffmanTree* tree, unsigned index)
{
  return tree->lengths[index];
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; ++i) bitlen[i] = 8;
  for(i = 144; i <= 255; ++i) bitlen[i] = 9;
  for(i = 256; i <= 279; ++i) bitlen[i] = 7;
  for(i = 280; i <= 287; ++i) bitlen[i] = 8;

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen[i] = 5;
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code, or (unsigned)(-1) if error happened
inbitlength is the length of the complete buffer, in bits (so its byte length times 8)
*/
static unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,
									const HuffmanTree* codetree, size_t inbitlength)
{
  unsigned treepos = 0, ct;
  for(;;)
  {
	if(*bp >= inbitlength) return (unsigned)(-1); /*error: end of input memory reached without endcode*/
	/*
	decode the symbol from the tree. The "readBitFromStream" code is inlined in
	the expression below because this is the biggest bottleneck while decoding
	*/
	ct = codetree->tree2d[(treepos << 1) + READBIT(*bp, in)];
	++(*bp);
	if(ct < codetree->numcodes) return ct; /*the symbol is decoded, return it*/
	else treepos = ct - codetree->numcodes; /*symbol not yet decoded, instead move tree position*/

	if(treepos >= codetree->numcodes) return (unsigned)(-1); /*error: it appeared outside the codetree*/
  }
}
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/
static void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)
{
  /*TODO: check for out of memory errors*/
  generateFixedLitLenTree(tree_ll);
  generateFixedDistanceTree(tree_d);
}

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
									  const unsigned char* in, size_t* bp, size_t inlength)
{
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
  unsigned n, HLIT, HDIST, HCLEN, i;
  size_t inbitlength = inlength * 8;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
  unsigned* bitlen_d = 0; /*dist code lengths*/
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if((*bp) + 14 > (inlength << 3)) return 49; /*error: the bit pointer is or will go past the memory*/

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBitsFromStream(bp, in, 5) + 257;
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBitsFromStream(bp, in, 5) + 1;
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBitsFromStream(bp, in, 4) + 4;

  if((*bp) + HCLEN * 3 > (inlength << 3)) return 50; /*error: the bit pointer is or will go past the memory*/

  HuffmanTree_init(&tree_cl);

  while(!error)
  {
	/*read the code length codes out of 3 * (amount of code length codes) bits*/

	bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
	if(!bitlen_cl) ERROR_BREAK(83 /*alloc fail*/);

	for(i = 0; i != NUM_CODE_LENGTH_CODES; ++i)
	{
	  if(i < HCLEN) bitlen_cl[CLCL_ORDER[i]] = readBitsFromStream(bp, in, 3);
	  else bitlen_cl[CLCL_ORDER[i]] = 0; /*if not, it must stay 0*/
	}

	error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
	if(error) break;

	/*now we can use this tree to read the lengths for the tree that this function will return*/
	bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
	bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
	if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
	for(i = 0; i != NUM_DEFLATE_CODE_SYMBOLS; ++i) bitlen_ll[i] = 0;
	for(i = 0; i != NUM_DISTANCE_SYMBOLS; ++i) bitlen_d[i] = 0;

	/*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
	i = 0;
	while(i < HLIT + HDIST)
	{
	  unsigned code = huffmanDecodeSymbol(in, bp, &tree_cl, inbitlength);
	  if(code <= 15) /*a length code*/
	  {
		if(i < HLIT) bitlen_ll[i] = code;
		else bitlen_d[i - HLIT] = code;
		++i;
	  }
	  else if(code == 16) /*repeat previous*/
	  {
		unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
		unsigned value; /*set value to the previous code*/

		if (i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/

		if((*bp + 2) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
		replength += readBitsFromStream(bp, in, 2);

		if(i < HLIT + 1) value = bitlen_ll[i - 1];
		else value = bitlen_d[i - HLIT - 1];
		/*repeat this value in the next lengths*/
		for(n = 0; n < replength; ++n)
		{
		  if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
		  if(i < HLIT) bitlen_ll[i] = value;
		  else bitlen_d[i - HLIT] = value;
		  ++i;
		}
	  }
	  else if(code == 17) /*repeat "0" 3-10 times*/
	  {
		unsigned replength = 3; /*read in the bits that indicate repeat length*/
		if((*bp + 3) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
		replength += readBitsFromStream(bp, in, 3);

		/*repeat this value in the next lengths*/
		for(n = 0; n < replength; ++n)
		{
		  if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/

		  if(i < HLIT) bitlen_ll[i] = 0;
		  else bitlen_d[i - HLIT] = 0;
		  ++i;
		}
	  }
	  else if(code == 18) /*repeat "0" 11-138 times*/
	  {
		unsigned replength = 11; /*read in the bits that indicate repeat length*/
		if((*bp + 7) > inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
		replength += readBitsFromStream(bp, in, 7);

		/*repeat this value in the next lengths*/
		for(n = 0; n < replength; ++n)
		{
		  if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/

		  if(i < HLIT) bitlen_ll[i] = 0;
		  else bitlen_d[i - HLIT] = 0;
		  ++i;
		}
	  }
	  else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
	  {
		if(code == (unsigned)(-1))
		{
		  /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
		  (10=no endcode, 11=wrong jump outside of tree)*/
		  error = (*bp) > inbitlength ? 10 : 11;
		}
		else error = 16; /*unexisting code, this can never happen*/
		break;
	  }
	}
	if(error) break;

	if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

	/*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
	error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
	if(error) break;
	error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

	break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
  lodepng_free(bitlen_ll);
  lodepng_free(bitlen_d);
  HuffmanTree_cleanup(&tree_cl);

  return error;
}

/*inflate a block with dynamic of fixed Huffman tree*/
static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,
									size_t* pos, size_t inlength, unsigned btype)
{
  unsigned error = 0;
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/
  size_t inbitlength = inlength * 8;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  if(btype == 1) getTreeInflateFixed(&tree_ll, &tree_d);
  else if(btype == 2) error = getTreeInflateDynamic(&tree_ll, &tree_d, in, bp, inlength);

  while(!error) /*decode all symbols until end reached, breaks at end code*/
  {
	/*code_ll is literal, length or end code*/
	unsigned code_ll = huffmanDecodeSymbol(in, bp, &tree_ll, inbitlength);
	if(code_ll <= 255) /*literal symbol*/
	{
	  /*ucvector_push_back would do the same, but for some reason the two lines below run 10% faster*/
	  if(!ucvector_resize(out, (*pos) + 1)) ERROR_BREAK(83 /*alloc fail*/);
	  out->data[*pos] = (unsigned char)code_ll;
	  ++(*pos);
	}
	else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/
	{
	  unsigned code_d, distance;
	  unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
	  size_t start, forward, backward, length;

	  /*part 1: get length base*/
	  length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];

	  /*part 2: get extra bits and add the value of that to length*/
	  numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
	  if((*bp + numextrabits_l) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/
	  length += readBitsFromStream(bp, in, numextrabits_l);

	  /*part 3: get distance code*/
	  code_d = huffmanDecodeSymbol(in, bp, &tree_d, inbitlength);
	  if(code_d > 29)
	  {
		if(code_ll == (unsigned)(-1)) /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
		{
		  /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
		  (10=no endcode, 11=wrong jump outside of tree)*/
		  error = (*bp) > inlength * 8 ? 10 : 11;
		}
		else error = 18; /*error: invalid distance code (30-31 are never used)*/
		break;
	  }
	  distance = DISTANCEBASE[code_d];

	  /*part 4: get extra bits from distance*/
	  numextrabits_d = DISTANCEEXTRA[code_d];
	  if((*bp + numextrabits_d) > inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/
	  distance += readBitsFromStream(bp, in, numextrabits_d);

	  /*part 5: fill in all the out[n] values based on the length and dist*/
	  start = (*pos);
	  if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
	  backward = start - distance;

	  if(!ucvector_resize(out, (*pos) + length)) ERROR_BREAK(83 /*alloc fail*/);
	  for(forward = 0; forward < length; ++forward)
	  {
		out->data[(*pos)] = out->data[backward];
		++(*pos);
		++backward;
		if(backward >= start) backward = start - distance;
	  }
	}
	else if(code_ll == 256)
	{
	  break; /*end code, break the loop*/
	}
	else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
	{
	  /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
	  (10=no endcode, 11=wrong jump outside of tree)*/
	  error = ((*bp) > inlength * 8) ? 10 : 11;
	  break;
	}
  }

  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)
{
  size_t p;
  unsigned LEN, NLEN, n, error = 0;

  /*go to first boundary of byte*/
  while(((*bp) & 0x7) != 0) ++(*bp);
  p = (*bp) / 8; /*byte position*/

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(p + 4 >= inlength) return 52; /*error, bit pointer will jump past memory*/
  LEN = in[p] + 256u * in[p + 1]; p += 2;
  NLEN = in[p] + 256u * in[p + 1]; p += 2;

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/

  if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/
  for(n = 0; n < LEN; ++n) out->data[(*pos)++] = in[p++];

  (*bp) = p * 8;

  return error;
}

static unsigned lodepng_inflatev(ucvector* out,
								 const unsigned char* in, size_t insize,
								 const LodePNGDecompressSettings* settings)
{
  /*bit pointer in the "in" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/
  size_t bp = 0;
  unsigned BFINAL = 0;
  size_t pos = 0; /*byte position in the out buffer*/
  unsigned error = 0;

  (void)settings;

  while(!BFINAL)
  {
	unsigned BTYPE;
	if(bp + 2 >= insize * 8) return 52; /*error, bit pointer will jump past memory*/
	BFINAL = readBitFromStream(&bp, in);
	BTYPE = 1u * readBitFromStream(&bp, in);
	BTYPE += 2u * readBitFromStream(&bp, in);

	if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
	else if(BTYPE == 0) error = inflateNoCompression(out, in, &bp, &pos, insize); /*no compression*/
	else error = inflateHuffmanBlock(out, in, &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/

	if(error) return error;
  }

  return error;
}

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGDecompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_inflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned inflate(unsigned char** out, size_t* outsize,
						const unsigned char* in, size_t insize,
						const LodePNGDecompressSettings* settings)
{
  if(settings->custom_inflate)
  {
	return settings->custom_inflate(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_inflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflator (Compressor)                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*bitlen is the size in bits of the code*/
static void addHuffmanSymbol(size_t* bp, ucvector* compressed, unsigned code, unsigned bitlen)
{
  addBitsToStreamReversed(bp, compressed, code, bitlen);
}

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value)
{
  /*linear search implementation*/
  /*for(size_t i = 1; i < array_size; ++i) if(array[i] > value) return i - 1;
  return array_size - 1;*/

  /*binary search implementation (not that much faster) (precondition: array_size > 0)*/
  size_t left  = 1;
  size_t right = array_size - 1;
  while(left <= right)
  {
	size_t mid = (left + right) / 2;
	if(array[mid] <= value) left = mid + 1; /*the value to find is more to the right*/
	else if(array[mid - 1] > value) right = mid - 1; /*the value to find is more to the left*/
	else return mid - 1;
  }
  return array_size - 1;
}

static void addLengthDistance(uivector* values, size_t length, size_t distance)
{
  /*values in encoded vector are those used by deflate:
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);

  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);
  uivector_push_back(values, extra_length);
  uivector_push_back(values, dist_code);
  uivector_push_back(values, extra_distance);
}

/*3 bytes of data get encoded into two bytes. The hash cannot use more than 3
bytes as input because 3 is the minimum match length for deflate*/
static const unsigned HASH_NUM_VALUES = 65536;
static const unsigned HASH_BIT_MASK = 65535; /*HASH_NUM_VALUES - 1, but C90 does not like that as initializer*/

typedef struct Hash
{
  int* head; /*hash value to head circular pos - can be outdated if went around window*/
  /*circular pos to prev circular pos*/
  unsigned short* chain;
  int* val; /*circular pos to hash value*/

  /*TODO: do this not only for zeros but for any repeated byte. However for PNG
  it's always going to be the zeros that dominate, so not important for PNG*/
  int* headz; /*similar to head, but for chainz*/
  unsigned short* chainz; /*those with same amount of zeros*/
  unsigned short* zeros; /*length of zeros streak, used as a second hash chain*/
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize)
{
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);

  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  hash->headz = (int*)lodepng_malloc(sizeof(int) * (MAX_SUPPORTED_DEFLATE_LENGTH + 1));
  hash->chainz = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);

  if(!hash->head || !hash->chain || !hash->val  || !hash->headz|| !hash->chainz || !hash->zeros)
  {
	return 83; /*alloc fail*/
  }

  /*initialize hash table*/
  for(i = 0; i != HASH_NUM_VALUES; ++i) hash->head[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->val[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->chain[i] = i; /*same value as index indicates uninitialized*/

  for(i = 0; i <= MAX_SUPPORTED_DEFLATE_LENGTH; ++i) hash->headz[i] = -1;
  for(i = 0; i != windowsize; ++i) hash->chainz[i] = i; /*same value as index indicates uninitialized*/

  return 0;
}

static void hash_cleanup(Hash* hash)
{
  lodepng_free(hash->head);
  lodepng_free(hash->val);
  lodepng_free(hash->chain);

  lodepng_free(hash->zeros);
  lodepng_free(hash->headz);
  lodepng_free(hash->chainz);
}

static unsigned getHash(const unsigned char* data, size_t size, size_t pos)
{
  unsigned result = 0;
  if (pos + 2 < size)
  {
	/*A simple shift and xor hash is used. Since the data of PNGs is dominated
	by zeroes due to the filters, a better hash does not have a significant
	effect on speed in traversing the chain, and causes more time spend on
	calculating the hash.*/
	result ^= (unsigned)(data[pos + 0] << 0u);
	result ^= (unsigned)(data[pos + 1] << 4u);
	result ^= (unsigned)(data[pos + 2] << 8u);
  } else {
	size_t amount, i;
	if(pos >= size) return 0;
	amount = size - pos;
	for(i = 0; i != amount; ++i) result ^= (unsigned)(data[pos + i] << (i * 8u));
  }
  return result & HASH_BIT_MASK;
}

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos)
{
  const unsigned char* start = data + pos;
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
  if(end > data + size) end = data + size;
  data = start;
  while (data != end && *data == 0) ++data;
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
}

/*wpos = pos & (windowsize - 1)*/
static void updateHashChain(Hash* hash, size_t wpos, unsigned hashval, unsigned short numzeros)
{
  hash->val[wpos] = (int)hashval;
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
  hash->head[hashval] = wpos;

  hash->zeros[wpos] = numzeros;
  if(hash->headz[numzeros] != -1) hash->chainz[wpos] = hash->headz[numzeros];
  hash->headz[numzeros] = wpos;
}

/*
LZ77-encode the data. Return value is error code. The input are raw bytes, the output
is in the form of unsigned integers with codes representing for example literal bytes, or
length/distance pairs.
It uses a hash table technique to let it encode faster. When doing LZ77 encoding, a
sliding window (of windowsize) is used, and all past bytes in that window can be used as
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
						   const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
						   unsigned minmatch, unsigned nicematch, unsigned lazymatching)
{
  size_t pos;
  unsigned i, error = 0;
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8;
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;

  unsigned usezeros = 1; /*not sure if setting it to false for windowsize < 8192 is better or worse*/
  unsigned numzeros = 0;

  unsigned offset; /*the offset represents the distance in LZ77 terminology*/
  unsigned length;
  unsigned lazy = 0;
  unsigned lazylength = 0, lazyoffset = 0;
  unsigned hashval;
  unsigned current_offset, current_length;
  unsigned prev_offset;
  const unsigned char *lastptr, *foreptr, *backptr;
  unsigned hashpos;

  if(windowsize == 0 || windowsize > 32768) return 60; /*error: windowsize smaller/larger than allowed*/
  if((windowsize & (windowsize - 1)) != 0) return 90; /*error: must be power of two*/

  if(nicematch > MAX_SUPPORTED_DEFLATE_LENGTH) nicematch = MAX_SUPPORTED_DEFLATE_LENGTH;

  for(pos = inpos; pos < insize; ++pos)
  {
	size_t wpos = pos & (windowsize - 1); /*position for in 'circular' hash buffers*/
	unsigned chainlength = 0;

	hashval = getHash(in, insize, pos);

	if(usezeros && hashval == 0)
	{
	  if (numzeros == 0) numzeros = countZeros(in, insize, pos);
	  else if (pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
	}
	else
	{
	  numzeros = 0;
	}

	updateHashChain(hash, wpos, hashval, numzeros);

	/*the length and offset found for the current position*/
	length = 0;
	offset = 0;

	hashpos = hash->chain[wpos];

	lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

	/*search for the longest string*/
	prev_offset = 0;
	for(;;)
	{
	  if(chainlength++ >= maxchainlength) break;
	  current_offset = hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize;

	  if(current_offset < prev_offset) break; /*stop when went completely around the circular buffer*/
	  prev_offset = current_offset;
	  if(current_offset > 0)
	  {
		/*test the next characters*/
		foreptr = &in[pos];
		backptr = &in[pos - current_offset];

		/*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
		if(numzeros >= 3)
		{
		  unsigned skip = hash->zeros[hashpos];
		  if(skip > numzeros) skip = numzeros;
		  backptr += skip;
		  foreptr += skip;
		}

		while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/
		{
		  ++backptr;
		  ++foreptr;
		}
		current_length = (unsigned)(foreptr - &in[pos]);

		if(current_length > length)
		{
		  length = current_length; /*the longest length*/
		  offset = current_offset; /*the offset that is related to this longest length*/
		  /*jump out once a length of max length is found (speed gain). This also jumps
		  out if length is MAX_SUPPORTED_DEFLATE_LENGTH*/
		  if(current_length >= nicematch) break;
		}
	  }

	  if(hashpos == hash->chain[hashpos]) break;

	  if(numzeros >= 3 && length > numzeros) {
		hashpos = hash->chainz[hashpos];
		if(hash->zeros[hashpos] != numzeros) break;
	  } else {
		hashpos = hash->chain[hashpos];
		/*outdated hash value, happens if particular value was not encountered in whole last window*/
		if(hash->val[hashpos] != (int)hashval) break;
	  }
	}

	if(lazymatching)
	{
	  if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH)
	  {
		lazy = 1;
		lazylength = length;
		lazyoffset = offset;
		continue; /*try the next byte*/
	  }
	  if(lazy)
	  {
		lazy = 0;
		if(pos == 0) ERROR_BREAK(81);
		if(length > lazylength + 1)
		{
		  /*push the previous character as literal*/
		  if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
		}
		else
		{
		  length = lazylength;
		  offset = lazyoffset;
		  hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
		  hash->headz[numzeros] = -1; /*idem*/
		  --pos;
		}
	  }
	}
	if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);

	/*encode it as length/distance pair or literal value*/
	if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/
	{
	  if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
	}
	else if(length < minmatch || (length == 3 && offset > 4096))
	{
	  /*compensate for the fact that longer offsets have more extra bits, a
	  length of only 3 may be not worth it then*/
	  if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
	}
	else
	{
	  addLengthDistance(out, length, offset);
	  for(i = 1; i < length; ++i)
	  {
		++pos;
		wpos = pos & (windowsize - 1);
		hashval = getHash(in, insize, pos);
		if(usezeros && hashval == 0)
		{
		  if (numzeros == 0) numzeros = countZeros(in, insize, pos);
		  else if (pos + numzeros > insize || in[pos + numzeros - 1] != 0) --numzeros;
		}
		else
		{
		  numzeros = 0;
		}
		updateHashChain(hash, wpos, hashval, numzeros);
	  }
	}
  } /*end of the loop through each character of input*/

  return error;
}

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)
{
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, j, numdeflateblocks = (datasize + 65534) / 65535;
  unsigned datapos = 0;
  for(i = 0; i != numdeflateblocks; ++i)
  {
	unsigned BFINAL, BTYPE, LEN, NLEN;
	unsigned char firstbyte;

	BFINAL = (i == numdeflateblocks - 1);
	BTYPE = 0;

	firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1) << 1) + ((BTYPE & 2) << 1));
	ucvector_push_back(out, firstbyte);

	LEN = 65535;
	if(datasize - datapos < 65535) LEN = (unsigned)datasize - datapos;
	NLEN = 65535 - LEN;

	ucvector_push_back(out, (unsigned char)(LEN % 256));
	ucvector_push_back(out, (unsigned char)(LEN / 256));
	ucvector_push_back(out, (unsigned char)(NLEN % 256));
	ucvector_push_back(out, (unsigned char)(NLEN / 256));

	/*Decompressed data*/
	for(j = 0; j < 65535 && datapos < datasize; ++j)
	{
	  ucvector_push_back(out, data[datapos++]);
	}
  }

  return 0;
}

/*
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(size_t* bp, ucvector* out, const uivector* lz77_encoded,
						  const HuffmanTree* tree_ll, const HuffmanTree* tree_d)
{
  size_t i = 0;
  for(i = 0; i != lz77_encoded->size; ++i)
  {
	unsigned val = lz77_encoded->data[i];
	addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_ll, val), HuffmanTree_getLength(tree_ll, val));
	if(val > 256) /*for a length code, 3 more things have to be added*/
	{
	  unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
	  unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
	  unsigned length_extra_bits = lz77_encoded->data[++i];

	  unsigned distance_code = lz77_encoded->data[++i];

	  unsigned distance_index = distance_code;
	  unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
	  unsigned distance_extra_bits = lz77_encoded->data[++i];

	  addBitsToStream(bp, out, length_extra_bits, n_length_extra_bits);
	  addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_d, distance_code),
					   HuffmanTree_getLength(tree_d, distance_code));
	  addBitsToStream(bp, out, distance_extra_bits, n_distance_extra_bits);
	}
  }
}

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(ucvector* out, size_t* bp, Hash* hash,
							   const unsigned char* data, size_t datapos, size_t dataend,
							   const LodePNGCompressSettings* settings, unsigned final)
{
  unsigned error = 0;

  /*
  A block is compressed as follows: The PNG data is lz77 encoded, resulting in
  literal bytes and length/distance pairs. This is then huffman compressed with
  two huffman trees. One huffman tree is used for the lit and len values ("ll"),
  another huffman tree is used for the dist values ("d"). These two trees are
  stored using their code lengths, and to compress even more these code lengths
  are also run-length encoded and huffman compressed. This gives a huffman tree
  of code lengths "cl". The code lenghts used to describe this third tree are
  the code length code lengths ("clcl").
  */

  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  uivector frequencies_ll; /*frequency of lit,len codes*/
  uivector frequencies_d; /*frequency of dist codes*/
  uivector frequencies_cl; /*frequency of code length codes*/
  uivector bitlen_lld; /*lit,len,dist code lenghts (int bits), literally (without repeat codes).*/
  uivector bitlen_lld_e; /*bitlen_lld encoded with repeat codes (this is a rudemtary run length compression)*/
  /*bitlen_cl is the code length code lengths ("clcl"). The bit lengths of codes to represent tree_cl
  (these are written as is in the file, it would be crazy to compress these using yet another huffman
  tree that needs to be represented by yet another set of code lengths)*/
  uivector bitlen_cl;
  size_t datasize = dataend - datapos;

  /*
  Due to the huffman compression of huffman tree representations ("two levels"), there are some anologies:
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
  size_t numcodes_ll, numcodes_d, i;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);
  HuffmanTree_init(&tree_cl);
  uivector_init(&frequencies_ll);
  uivector_init(&frequencies_d);
  uivector_init(&frequencies_cl);
  uivector_init(&bitlen_lld);
  uivector_init(&bitlen_lld_e);
  uivector_init(&bitlen_cl);

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error)
  {
	if(settings->use_lz77)
	{
	  error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
						 settings->minmatch, settings->nicematch, settings->lazymatching);
	  if(error) break;
	}
	else
	{
	  if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
	  for(i = datapos; i < dataend; ++i) lz77_encoded.data[i] = data[i]; /*no LZ77, but still will be Huffman compressed*/
	}

	if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83 /*alloc fail*/);
	if(!uivector_resizev(&frequencies_d, 30, 0)) ERROR_BREAK(83 /*alloc fail*/);

	/*Count the frequencies of lit, len and dist codes*/
	for(i = 0; i != lz77_encoded.size; ++i)
	{
	  unsigned symbol = lz77_encoded.data[i];
	  ++frequencies_ll.data[symbol];
	  if(symbol > 256)
	  {
		unsigned dist = lz77_encoded.data[i + 2];
		++frequencies_d.data[dist];
		i += 3;
	  }
	}
	frequencies_ll.data[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

	/*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
	error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll.data, 257, frequencies_ll.size, 15);
	if(error) break;
	/*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
	error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d.data, 2, frequencies_d.size, 15);
	if(error) break;

	numcodes_ll = tree_ll.numcodes; if(numcodes_ll > 286) numcodes_ll = 286;
	numcodes_d = tree_d.numcodes; if(numcodes_d > 30) numcodes_d = 30;
	/*store the code lengths of both generated trees in bitlen_lld*/
	for(i = 0; i != numcodes_ll; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_ll, (unsigned)i));
	for(i = 0; i != numcodes_d; ++i) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_d, (unsigned)i));

	/*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
	17 (3-10 zeroes), 18 (11-138 zeroes)*/
	for(i = 0; i != (unsigned)bitlen_lld.size; ++i)
	{
	  unsigned j = 0; /*amount of repititions*/
	  while(i + j + 1 < (unsigned)bitlen_lld.size && bitlen_lld.data[i + j + 1] == bitlen_lld.data[i]) ++j;

	  if(bitlen_lld.data[i] == 0 && j >= 2) /*repeat code for zeroes*/
	  {
		++j; /*include the first zero*/
		if(j <= 10) /*repeat code 17 supports max 10 zeroes*/
		{
		  uivector_push_back(&bitlen_lld_e, 17);
		  uivector_push_back(&bitlen_lld_e, j - 3);
		}
		else /*repeat code 18 supports max 138 zeroes*/
		{
		  if(j > 138) j = 138;
		  uivector_push_back(&bitlen_lld_e, 18);
		  uivector_push_back(&bitlen_lld_e, j - 11);
		}
		i += (j - 1);
	  }
	  else if(j >= 3) /*repeat code for value other than zero*/
	  {
		size_t k;
		unsigned num = j / 6, rest = j % 6;
		uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
		for(k = 0; k < num; ++k)
		{
		  uivector_push_back(&bitlen_lld_e, 16);
		  uivector_push_back(&bitlen_lld_e, 6 - 3);
		}
		if(rest >= 3)
		{
		  uivector_push_back(&bitlen_lld_e, 16);
		  uivector_push_back(&bitlen_lld_e, rest - 3);
		}
		else j -= rest;
		i += j;
	  }
	  else /*too short to benefit from repeat code*/
	  {
		uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
	  }
	}

	/*generate tree_cl, the huffmantree of huffmantrees*/

	if(!uivector_resizev(&frequencies_cl, NUM_CODE_LENGTH_CODES, 0)) ERROR_BREAK(83 /*alloc fail*/);
	for(i = 0; i != bitlen_lld_e.size; ++i)
	{
	  ++frequencies_cl.data[bitlen_lld_e.data[i]];
	  /*after a repeat code come the bits that specify the number of repetitions,
	  those don't need to be in the frequencies_cl calculation*/
	  if(bitlen_lld_e.data[i] >= 16) ++i;
	}

	error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl.data,
											frequencies_cl.size, frequencies_cl.size, 7);
	if(error) break;

	if(!uivector_resize(&bitlen_cl, tree_cl.numcodes)) ERROR_BREAK(83 /*alloc fail*/);
	for(i = 0; i != tree_cl.numcodes; ++i)
	{
	  /*lenghts of code length tree is in the order as specified by deflate*/
	  bitlen_cl.data[i] = HuffmanTree_getLength(&tree_cl, CLCL_ORDER[i]);
	}
	while(bitlen_cl.data[bitlen_cl.size - 1] == 0 && bitlen_cl.size > 4)
	{
	  /*remove zeros at the end, but minimum size must be 4*/
	  if(!uivector_resize(&bitlen_cl, bitlen_cl.size - 1)) ERROR_BREAK(83 /*alloc fail*/);
	}
	if(error) break;

	/*
	Write everything into the output

	After the BFINAL and BTYPE, the dynamic block consists out of the following:
	- 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN
	- (HCLEN+4)*3 bits code lengths of code length alphabet
	- HLIT + 257 code lenghts of lit/length alphabet (encoded using the code length
	  alphabet, + possible repetition codes 16, 17, 18)
	- HDIST + 1 code lengths of distance alphabet (encoded using the code length
	  alphabet, + possible repetition codes 16, 17, 18)
	- compressed data
	- 256 (end code)
	*/

	/*Write block type*/
	addBitToStream(bp, out, BFINAL);
	addBitToStream(bp, out, 0); /*first bit of BTYPE "dynamic"*/
	addBitToStream(bp, out, 1); /*second bit of BTYPE "dynamic"*/

	/*write the HLIT, HDIST and HCLEN values*/
	HLIT = (unsigned)(numcodes_ll - 257);
	HDIST = (unsigned)(numcodes_d - 1);
	HCLEN = (unsigned)bitlen_cl.size - 4;
	/*trim zeroes for HCLEN. HLIT and HDIST were already trimmed at tree creation*/
	while(!bitlen_cl.data[HCLEN + 4 - 1] && HCLEN > 0) --HCLEN;
	addBitsToStream(bp, out, HLIT, 5);
	addBitsToStream(bp, out, HDIST, 5);
	addBitsToStream(bp, out, HCLEN, 4);

	/*write the code lenghts of the code length alphabet*/
	for(i = 0; i != HCLEN + 4; ++i) addBitsToStream(bp, out, bitlen_cl.data[i], 3);

	/*write the lenghts of the lit/len AND the dist alphabet*/
	for(i = 0; i != bitlen_lld_e.size; ++i)
	{
	  addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_cl, bitlen_lld_e.data[i]),
					   HuffmanTree_getLength(&tree_cl, bitlen_lld_e.data[i]));
	  /*extra bits of repeat codes*/
	  if(bitlen_lld_e.data[i] == 16) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 2);
	  else if(bitlen_lld_e.data[i] == 17) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 3);
	  else if(bitlen_lld_e.data[i] == 18) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 7);
	}

	/*write the compressed data symbols*/
	writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
	/*error: the length of the end code 256 must be larger than 0*/
	if(HuffmanTree_getLength(&tree_ll, 256) == 0) ERROR_BREAK(64);

	/*write the end code*/
	addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

	break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);
  HuffmanTree_cleanup(&tree_cl);
  uivector_cleanup(&frequencies_ll);
  uivector_cleanup(&frequencies_d);
  uivector_cleanup(&frequencies_cl);
  uivector_cleanup(&bitlen_lld_e);
  uivector_cleanup(&bitlen_lld);
  uivector_cleanup(&bitlen_cl);

  return error;
}

static unsigned deflateFixed(ucvector* out, size_t* bp, Hash* hash,
							 const unsigned char* data,
							 size_t datapos, size_t dataend,
							 const LodePNGCompressSettings* settings, unsigned final)
{
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
  unsigned error = 0;
  size_t i;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  generateFixedLitLenTree(&tree_ll);
  generateFixedDistanceTree(&tree_d);

  addBitToStream(bp, out, BFINAL);
  addBitToStream(bp, out, 1); /*first bit of BTYPE*/
  addBitToStream(bp, out, 0); /*second bit of BTYPE*/

  if(settings->use_lz77) /*LZ77 encoded*/
  {
	uivector lz77_encoded;
	uivector_init(&lz77_encoded);
	error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
					   settings->minmatch, settings->nicematch, settings->lazymatching);
	if(!error) writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
	uivector_cleanup(&lz77_encoded);
  }
  else /*no LZ77, but still will be Huffman compressed*/
  {
	for(i = datapos; i < dataend; ++i)
	{
	  addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, data[i]), HuffmanTree_getLength(&tree_ll, data[i]));
	}
  }
  /*add END code*/
  if(!error) addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
								 const LodePNGCompressSettings* settings)
{
  unsigned error = 0;
  size_t i, blocksize, numdeflateblocks;
  size_t bp = 0; /*the bit pointer*/
  Hash hash;

  if(settings->btype > 2) return 61;
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
  else if(settings->btype == 1) blocksize = insize;
  else /*if(settings->btype == 2)*/
  {
	blocksize = insize / 8 + 8;
	if(blocksize < 65535) blocksize = 65535;
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);
  if(error) return error;

  for(i = 0; i != numdeflateblocks && !error; ++i)
  {
	unsigned final = (i == numdeflateblocks - 1);
	size_t start = i * blocksize;
	size_t end = start + blocksize;
	if(end > insize) end = insize;

	if(settings->btype == 1) error = deflateFixed(out, &bp, &hash, in, start, end, settings, final);
	else if(settings->btype == 2) error = deflateDynamic(out, &bp, &hash, in, start, end, settings, final);
  }

  hash_cleanup(&hash);

  return error;
}

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
						 const unsigned char* in, size_t insize,
						 const LodePNGCompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_deflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned deflate(unsigned char** out, size_t* outsize,
						const unsigned char* in, size_t insize,
						const LodePNGCompressSettings* settings)
{
  if(settings->custom_deflate)
  {
	return settings->custom_deflate(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_deflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                  */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
	/*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
	unsigned amount = len > 5550 ? 5550 : len;
	len -= amount;
	while(amount > 0)
	{
	  s1 += (*data++);
	  s2 += s1;
	  --amount;
	}
	s1 %= 65521;
	s2 %= 65521;
  }

  return (s2 << 16) | s1;
}

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len)
{
  return update_adler32(1L, data, len);
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Zlib                                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DECODER

unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
								 size_t insize, const LodePNGDecompressSettings* settings)
{
  unsigned error = 0;
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0)
  {
	/*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
	return 24;
  }

  CM = in[0] & 15;
  CINFO = (in[0] >> 4) & 15;
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7)
  {
	/*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
	return 25;
  }
  if(FDICT != 0)
  {
	/*error: the specification of PNG says about the zlib stream:
	  "The additional flags shall not specify a preset dictionary."*/
	return 26;
  }

  error = inflate(out, outsize, in + 2, insize - 2, settings);
  if(error) return error;

  if(!settings->ignore_adler32)
  {
	unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
	unsigned checksum = adler32(*out, (unsigned)(*outsize));
	if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
  }

  return 0; /*no error*/
}

static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
								size_t insize, const LodePNGDecompressSettings* settings)
{
  if(settings->custom_zlib)
  {
	return settings->custom_zlib(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_zlib_decompress(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
							   size_t insize, const LodePNGCompressSettings* settings)
{
  /*initially, *out must be NULL and outsize 0, if you just give some random *out
  that's pointing to a non allocated buffer, this'll crash*/
  ucvector outv;
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
  size_t deflatesize = 0;

  /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
  unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
  unsigned FLEVEL = 0;
  unsigned FDICT = 0;
  unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
  unsigned FCHECK = 31 - CMFFLG % 31;
  CMFFLG += FCHECK;

  /*ucvector-controlled version of the output buffer, for dynamic array*/
  ucvector_init_buffer(&outv, *out, *outsize);

  ucvector_push_back(&outv, (unsigned char)(CMFFLG / 256));
  ucvector_push_back(&outv, (unsigned char)(CMFFLG % 256));

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);

  if(!error)
  {
	unsigned ADLER32 = adler32(in, (unsigned)insize);
	for(i = 0; i != deflatesize; ++i) ucvector_push_back(&outv, deflatedata[i]);
	lodepng_free(deflatedata);
	lodepng_add32bitInt(&outv, ADLER32);
  }

  *out = outv.data;
  *outsize = outv.size;

  return error;
}

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
							  size_t insize, const LodePNGCompressSettings* settings)
{
  if(settings->custom_zlib)
  {
	return settings->custom_zlib(out, outsize, in, insize, settings);
  }
  else
  {
	return lodepng_zlib_compress(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_ENCODER*/

#else /*no LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DECODER
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
								size_t insize, const LodePNGDecompressSettings* settings)
{
  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
							  size_t insize, const LodePNGCompressSettings* settings)
{
  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#endif /*LODEPNG_COMPILE_ZLIB*/

/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings)
{
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
  settings->use_lz77 = 1;
  settings->windowsize = DEFAULT_WINDOWSIZE;
  settings->minmatch = 3;
  settings->nicematch = 128;
  settings->lazymatching = 1;

  settings->custom_zlib = 0;
  settings->custom_deflate = 0;
  settings->custom_context = 0;
}

const LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};

#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings)
{
  settings->ignore_adler32 = 0;

  settings->custom_zlib = 0;
  settings->custom_inflate = 0;
  settings->custom_context = 0;
}

const LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0};

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of Zlib related code. Begin of PNG related code.                 // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG

/* ////////////////////////////////////////////////////////////////////////// */
/* / CRC32                                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */

/* CRC polynomial: 0xedb88320 */
static unsigned lodepng_crc32_table[256] = {
		   0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u, 3915621685u, 2657392035u,
   249268274u, 2044508324u, 3772115230u, 2547177864u,  162941995u, 2125561021u, 3887607047u, 2428444049u,
   498536548u, 1789927666u, 4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,
   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u, 4195302755u, 2366115317u,
   997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u,
   901097722u, 1119000684u, 3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,
   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u, 3485111705u, 3099436303u,
   671266974u, 1594198024u, 3322730930u, 2970347812u,  795835527u, 1483230225u, 3244367275u, 3060149565u,
  1994146192u,   31158534u, 2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,
  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u, 2439277719u, 3865271297u,
  1802195444u,  476864866u, 2238001368u, 4066508878u, 1812370925u,  453092731u, 2181625025u, 4111451223u,
  1706088902u,  314042704u, 2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,
  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u,
  1131014506u,  879679996u, 2909243462u, 3663771856u, 1141124467u,  855842277u, 2852801631u, 3708648649u,
  1342533948u,  654459306u, 3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,
  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u, 3082640443u, 3233442989u,
  3988292384u, 2596254646u,   62317068u, 1957810842u, 3939845945u, 2647816111u,   81470997u, 1943803523u,
  3814918930u, 2489596804u,  225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,
  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,  426522225u, 1852507879u,
  4275313526u, 2312317920u,  282753626u, 1742555852u, 4189708143u, 2394877945u,  397917763u, 1622183637u,
  3604390888u, 2714866558u,  953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,
  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,  829329135u, 1181335161u,
  3412177804u, 3160834842u,  628085408u, 1382605366u, 3423369109u, 3138078467u,  570562233u, 1426400815u,
  3317316542u, 2998733608u,  733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,
  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u, 1913087877u,   83908371u,
  2512341634u, 3803740692u, 2075208622u,  213261112u, 2463272603u, 3855990285u, 2094854071u,  198958881u,
  2262029012u, 4057260610u, 1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,
  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u, 1634467795u,  376229701u,
  2685067896u, 3608007406u, 1308918612u,  956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u,
  2932959818u, 3654703836u, 1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* buf, size_t len)
{
  unsigned c = 0xffffffffL;
  size_t n;

  for(n = 0; n < len; ++n)
  {
	c = lodepng_crc32_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
  }
  return c ^ 0xffffffffL;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
  ++(*bitpointer);
  return result;
}

static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0;
  size_t i;
  for(i = nbits - 1; i < nbits; --i)
  {
	result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
  }
  return result;
}

#ifdef LODEPNG_COMPILE_DECODER
static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream must be 0 for this to work*/
  if(bit)
  {
	/*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
	bitstream[(*bitpointer) >> 3] |= (bit << (7 - ((*bitpointer) & 0x7)));
  }
  ++(*bitpointer);
}
#endif /*LODEPNG_COMPILE_DECODER*/

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
  ++(*bitpointer);
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk)
{
  return lodepng_read32bitInt(&chunk[0]);
}

void lodepng_chunk_type(char type[5], const unsigned char* chunk)
{
  unsigned i;
  for(i = 0; i != 4; ++i) type[i] = (char)chunk[4 + i];
  type[4] = 0; /*null termination char*/
}

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type)
{
  if(strlen(type) != 4) return 0;
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
}

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk)
{
  return((chunk[4] & 32) != 0);
}

unsigned char lodepng_chunk_private(const unsigned char* chunk)
{
  return((chunk[6] & 32) != 0);
}

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)
{
  return((chunk[7] & 32) != 0);
}

unsigned char* lodepng_chunk_data(unsigned char* chunk)
{
  return &chunk[8];
}

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk)
{
  return &chunk[8];
}

unsigned lodepng_chunk_check_crc(const unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
  if(CRC != checksum) return 1;
  else return 0;
}

void lodepng_chunk_generate_crc(unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
  lodepng_set32bitInt(chunk + 8 + length, CRC);
}

unsigned char* lodepng_chunk_next(unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk)
{
  unsigned i;
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  unsigned char *chunk_start, *new_buffer;
  size_t new_length = (*outlength) + total_chunk_length;
  if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk_start = &(*out)[new_length - total_chunk_length];

  for(i = 0; i != total_chunk_length; ++i) chunk_start[i] = chunk[i];

  return 0;
}

unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
							  const char* type, const unsigned char* data)
{
  unsigned i;
  unsigned char *chunk, *new_buffer;
  size_t new_length = (*outlength) + length + 12;
  if(new_length < length + 12 || new_length < (*outlength)) return 77; /*integer overflow happened*/
  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk = &(*out)[(*outlength) - length - 12];

  /*1: length*/
  lodepng_set32bitInt(chunk, (unsigned)length);

  /*2: chunk name (4 letters)*/
  chunk[4] = (unsigned char)type[0];
  chunk[5] = (unsigned char)type[1];
  chunk[6] = (unsigned char)type[2];
  chunk[7] = (unsigned char)type[3];

  /*3: the data*/
  for(i = 0; i != length; ++i) chunk[8 + i] = data[i];

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);

  return 0;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Color types and such                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

/*return type is a LodePNG error code*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) /*bd = bitdepth*/
{
  switch(colortype)
  {
	case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/
	case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/
	case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/
	case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/
	case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/
	default: return 31;
  }
  return 0; /*allowed color type / bits combination*/
}

static unsigned getNumColorChannels(LodePNGColorType colortype)
{
  switch(colortype)
  {
	case 0: return 1; /*grey*/
	case 2: return 3; /*RGB*/
	case 3: return 1; /*palette*/
	case 4: return 2; /*grey + alpha*/
	case 6: return 4; /*RGBA*/
  }
  return 0; /*unexisting color type*/
}

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)
{
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
}

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info)
{
  info->key_defined = 0;
  info->key_r = info->key_g = info->key_b = 0;
  info->colortype = LCT_RGBA;
  info->bitdepth = 8;
  info->palette = 0;
  info->palettesize = 0;
}

void lodepng_color_mode_cleanup(LodePNGColorMode* info)
{
  lodepng_palette_clear(info);
}

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source)
{
  size_t i;
  lodepng_color_mode_cleanup(dest);
  *dest = *source;
  if(source->palette)
  {
	dest->palette = (unsigned char*)lodepng_malloc(1024);
	if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
	for(i = 0; i != source->palettesize * 4; ++i) dest->palette[i] = source->palette[i];
  }
  return 0;
}

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b)
{
  size_t i;
  if(a->colortype != b->colortype) return 0;
  if(a->bitdepth != b->bitdepth) return 0;
  if(a->key_defined != b->key_defined) return 0;
  if(a->key_defined)
  {
	if(a->key_r != b->key_r) return 0;
	if(a->key_g != b->key_g) return 0;
	if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i != a->palettesize * 4; ++i)
  {
	if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
}

void lodepng_palette_clear(LodePNGColorMode* info)
{
  if(info->palette) lodepng_free(info->palette);
  info->palette = 0;
  info->palettesize = 0;
}

unsigned lodepng_palette_add(LodePNGColorMode* info,
							 unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  unsigned char* data;
  /*the same resize technique as C++ std::vectors is used, and here it's made so that for a palette with
  the max of 256 colors, it'll have the exact alloc size*/
  if(!info->palette) /*allocate palette if empty*/
  {
	/*room for 256 colors with 4 bytes each*/
	data = (unsigned char*)lodepng_realloc(info->palette, 1024);
	if(!data) return 83; /*alloc fail*/
	else info->palette = data;
  }
  info->palette[4 * info->palettesize + 0] = r;
  info->palette[4 * info->palettesize + 1] = g;
  info->palette[4 * info->palettesize + 2] = b;
  info->palette[4 * info->palettesize + 3] = a;
  ++info->palettesize;
  return 0;
}

unsigned lodepng_get_bpp(const LodePNGColorMode* info)
{
  /*calculate bits per pixel out of colortype and bitdepth*/
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
}

unsigned lodepng_get_channels(const LodePNGColorMode* info)
{
  return getNumColorChannels(info->colortype);
}

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
}

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info)
{
  return (info->colortype & 4) != 0; /*4 or 6*/
}

unsigned lodepng_is_palette_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info)
{
  size_t i;
  for(i = 0; i != info->palettesize; ++i)
  {
	if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info)
{
  return info->key_defined
	  || lodepng_is_alpha_type(info)
	  || lodepng_has_palette_alpha(info);
}

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return (w * h * lodepng_get_bpp(color) + 7) / 8;
}

size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  return (w * h * lodepng_get_bpp_lct(colortype, bitdepth) + 7) / 8;
}

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_DECODER
/*in an idat chunk, each scanline is a multiple of 8 bits, unlike the lodepng output buffer*/
static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i != 3; ++i) info->unknown_chunks_data[i] = 0;
  for(i = 0; i != 3; ++i) info->unknown_chunks_size[i] = 0;
}

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i != 3; ++i) lodepng_free(info->unknown_chunks_data[i]);
}

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src)
{
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i != 3; ++i)
  {
	size_t j;
	dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
	dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
	if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
	for(j = 0; j < src->unknown_chunks_size[i]; ++j)
	{
	  dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
	}
  }

  return 0;
}

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info)
{
  info->text_num = 0;
  info->text_keys = NULL;
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i != info->text_num; ++i)
  {
	string_cleanup(&info->text_keys[i]);
	string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
  lodepng_free(info->text_strings);
}

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->text_keys = 0;
  dest->text_strings = 0;
  dest->text_num = 0;
  for(i = 0; i != source->text_num; ++i)
  {
	CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
}

void lodepng_clear_text(LodePNGInfo* info)
{
  LodePNGText_cleanup(info);
}

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
  if(!new_keys || !new_strings)
  {
	lodepng_free(new_keys);
	lodepng_free(new_strings);
	return 83; /*alloc fail*/
  }

  ++info->text_num;
  info->text_keys = new_keys;
  info->text_strings = new_strings;

  string_init(&info->text_keys[info->text_num - 1]);
  string_set(&info->text_keys[info->text_num - 1], key);

  string_init(&info->text_strings[info->text_num - 1]);
  string_set(&info->text_strings[info->text_num - 1], str);

  return 0;
}

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info)
{
  info->itext_num = 0;
  info->itext_keys = NULL;
  info->itext_langtags = NULL;
  info->itext_transkeys = NULL;
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i != info->itext_num; ++i)
  {
	string_cleanup(&info->itext_keys[i]);
	string_cleanup(&info->itext_langtags[i]);
	string_cleanup(&info->itext_transkeys[i]);
	string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
  lodepng_free(info->itext_langtags);
  lodepng_free(info->itext_transkeys);
  lodepng_free(info->itext_strings);
}

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->itext_keys = 0;
  dest->itext_langtags = 0;
  dest->itext_transkeys = 0;
  dest->itext_strings = 0;
  dest->itext_num = 0;
  for(i = 0; i != source->itext_num; ++i)
  {
	CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
										source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
}

void lodepng_clear_itext(LodePNGInfo* info)
{
  LodePNGIText_cleanup(info);
}

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
						   const char* transkey, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
  if(!new_keys || !new_langtags || !new_transkeys || !new_strings)
  {
	lodepng_free(new_keys);
	lodepng_free(new_langtags);
	lodepng_free(new_transkeys);
	lodepng_free(new_strings);
	return 83; /*alloc fail*/
  }

  ++info->itext_num;
  info->itext_keys = new_keys;
  info->itext_langtags = new_langtags;
  info->itext_transkeys = new_transkeys;
  info->itext_strings = new_strings;

  string_init(&info->itext_keys[info->itext_num - 1]);
  string_set(&info->itext_keys[info->itext_num - 1], key);

  string_init(&info->itext_langtags[info->itext_num - 1]);
  string_set(&info->itext_langtags[info->itext_num - 1], langtag);

  string_init(&info->itext_transkeys[info->itext_num - 1]);
  string_set(&info->itext_transkeys[info->itext_num - 1], transkey);

  string_init(&info->itext_strings[info->itext_num - 1]);
  string_set(&info->itext_strings[info->itext_num - 1], str);

  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info)
{
  lodepng_color_mode_init(&info->color);
  info->interlace_method = 0;
  info->compression_method = 0;
  info->filter_method = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
  info->background_r = info->background_g = info->background_b = 0;

  LodePNGText_init(info);
  LodePNGIText_init(info);

  info->time_defined = 0;
  info->phys_defined = 0;

  LodePNGUnknownChunks_init(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

void lodepng_info_cleanup(LodePNGInfo* info)
{
  lodepng_color_mode_cleanup(&info->color);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
  LodePNGIText_cleanup(info);

  LodePNGUnknownChunks_cleanup(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  lodepng_info_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->color);
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));

  LodePNGUnknownChunks_init(dest);
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
}

void lodepng_info_swap(LodePNGInfo* a, LodePNGInfo* b)
{
  LodePNGInfo temp = *a;
  *a = *b;
  *b = temp;
}

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4), in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)
{
  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; /*8 / bits - 1*/
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index & m;
  in &= (1u << bits) - 1u; /*filter out any other bits of the input value*/
  in = in << (bits * (m - p));
  if(p == 0) out[index * bits / 8] = in;
  else out[index * bits / 8] |= in;
}

typedef struct ColorTree ColorTree;

/*
One node of a color tree
This is the data structure used to count the number of unique colors and to get a palette
index for a color. It's like an octree, but because the alpha channel is used too, each
node has 16 instead of 8 children.
*/
struct ColorTree
{
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree)
{
  int i;
  for(i = 0; i != 16; ++i) tree->children[i] = 0;
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree)
{
  int i;
  for(i = 0; i != 16; ++i)
  {
	if(tree->children[i])
	{
	  color_tree_cleanup(tree->children[i]);
	  lodepng_free(tree->children[i]);
	}
  }
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  int bit = 0;
  for(bit = 0; bit < 8; ++bit)
  {
	int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
	if(!tree->children[i]) return -1;
	else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
}

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  return color_tree_get(tree, r, g, b, a) >= 0;
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")*/
static void color_tree_add(ColorTree* tree,
						   unsigned char r, unsigned char g, unsigned char b, unsigned char a, unsigned index)
{
  int bit;
  for(bit = 0; bit < 8; ++bit)
  {
	int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
	if(!tree->children[i])
	{
	  tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
	  color_tree_init(tree->children[i]);
	}
	tree = tree->children[i];
  }
  tree->index = (int)index;
}

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
							 const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
							 unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  if(mode->colortype == LCT_GREY)
  {
	unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
	if(mode->bitdepth == 8) out[i] = grey;
	else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = grey;
	else
	{
	  /*take the most significant bits of grey*/
	  grey = (grey >> (8 - mode->bitdepth)) & ((1 << mode->bitdepth) - 1);
	  addColorBits(out, i, mode->bitdepth, grey);
	}
  }
  else if(mode->colortype == LCT_RGB)
  {
	if(mode->bitdepth == 8)
	{
	  out[i * 3 + 0] = r;
	  out[i * 3 + 1] = g;
	  out[i * 3 + 2] = b;
	}
	else
	{
	  out[i * 6 + 0] = out[i * 6 + 1] = r;
	  out[i * 6 + 2] = out[i * 6 + 3] = g;
	  out[i * 6 + 4] = out[i * 6 + 5] = b;
	}
  }
  else if(mode->colortype == LCT_PALETTE)
  {
	int index = color_tree_get(tree, r, g, b, a);
	if(index < 0) return 82; /*color not in palette*/
	if(mode->bitdepth == 8) out[i] = index;
	else addColorBits(out, i, mode->bitdepth, (unsigned)index);
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
	if(mode->bitdepth == 8)
	{
	  out[i * 2 + 0] = grey;
	  out[i * 2 + 1] = a;
	}
	else if(mode->bitdepth == 16)
	{
	  out[i * 4 + 0] = out[i * 4 + 1] = grey;
	  out[i * 4 + 2] = out[i * 4 + 3] = a;
	}
  }
  else if(mode->colortype == LCT_RGBA)
  {
	if(mode->bitdepth == 8)
	{
	  out[i * 4 + 0] = r;
	  out[i * 4 + 1] = g;
	  out[i * 4 + 2] = b;
	  out[i * 4 + 3] = a;
	}
	else
	{
	  out[i * 8 + 0] = out[i * 8 + 1] = r;
	  out[i * 8 + 2] = out[i * 8 + 3] = g;
	  out[i * 8 + 4] = out[i * 8 + 5] = b;
	  out[i * 8 + 6] = out[i * 8 + 7] = a;
	}
  }

  return 0; /*no error*/
}

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static void rgba16ToPixel(unsigned char* out, size_t i,
						 const LodePNGColorMode* mode,
						 unsigned short r, unsigned short g, unsigned short b, unsigned short a)
{
  if(mode->colortype == LCT_GREY)
  {
	unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
	out[i * 2 + 0] = (grey >> 8) & 255;
	out[i * 2 + 1] = grey & 255;
  }
  else if(mode->colortype == LCT_RGB)
  {
	out[i * 6 + 0] = (r >> 8) & 255;
	out[i * 6 + 1] = r & 255;
	out[i * 6 + 2] = (g >> 8) & 255;
	out[i * 6 + 3] = g & 255;
	out[i * 6 + 4] = (b >> 8) & 255;
	out[i * 6 + 5] = b & 255;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
	out[i * 4 + 0] = (grey >> 8) & 255;
	out[i * 4 + 1] = grey & 255;
	out[i * 4 + 2] = (a >> 8) & 255;
	out[i * 4 + 3] = a & 255;
  }
  else if(mode->colortype == LCT_RGBA)
  {
	out[i * 8 + 0] = (r >> 8) & 255;
	out[i * 8 + 1] = r & 255;
	out[i * 8 + 2] = (g >> 8) & 255;
	out[i * 8 + 3] = g & 255;
	out[i * 8 + 4] = (b >> 8) & 255;
	out[i * 8 + 5] = b & 255;
	out[i * 8 + 6] = (a >> 8) & 255;
	out[i * 8 + 7] = a & 255;
  }
}

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static void getPixelColorRGBA8(unsigned char* r, unsigned char* g,
							   unsigned char* b, unsigned char* a,
							   const unsigned char* in, size_t i,
							   const LodePNGColorMode* mode)
{
  if(mode->colortype == LCT_GREY)
  {
	if(mode->bitdepth == 8)
	{
	  *r = *g = *b = in[i];
	  if(mode->key_defined && *r == mode->key_r) *a = 0;
	  else *a = 255;
	}
	else if(mode->bitdepth == 16)
	{
	  *r = *g = *b = in[i * 2 + 0];
	  if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
	  else *a = 255;
	}
	else
	{
	  unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
	  size_t j = i * mode->bitdepth;
	  unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
	  *r = *g = *b = (value * 255) / highest;
	  if(mode->key_defined && value == mode->key_r) *a = 0;
	  else *a = 255;
	}
  }
  else if(mode->colortype == LCT_RGB)
  {
	if(mode->bitdepth == 8)
	{
	  *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
	  if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
	  else *a = 255;
	}
	else
	{
	  *r = in[i * 6 + 0];
	  *g = in[i * 6 + 2];
	  *b = in[i * 6 + 4];
	  if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
		 && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
		 && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
	  else *a = 255;
	}
  }
  else if(mode->colortype == LCT_PALETTE)
  {
	unsigned index;
	if(mode->bitdepth == 8) index = in[i];
	else
	{
	  size_t j = i * mode->bitdepth;
	  index = readBitsFromReversedStream(&j, in, mode->bitdepth);
	}

	if(index >= mode->palettesize)
	{
	  /*This is an error according to the PNG spec, but common PNG decoders make it black instead.
	  Done here too, slightly faster due to no error handling needed.*/
	  *r = *g = *b = 0;
	  *a = 255;
	}
	else
	{
	  *r = mode->palette[index * 4 + 0];
	  *g = mode->palette[index * 4 + 1];
	  *b = mode->palette[index * 4 + 2];
	  *a = mode->palette[index * 4 + 3];
	}
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	if(mode->bitdepth == 8)
	{
	  *r = *g = *b = in[i * 2 + 0];
	  *a = in[i * 2 + 1];
	}
	else
	{
	  *r = *g = *b = in[i * 4 + 0];
	  *a = in[i * 4 + 2];
	}
  }
  else if(mode->colortype == LCT_RGBA)
  {
	if(mode->bitdepth == 8)
	{
	  *r = in[i * 4 + 0];
	  *g = in[i * 4 + 1];
	  *b = in[i * 4 + 2];
	  *a = in[i * 4 + 3];
	}
	else
	{
	  *r = in[i * 8 + 0];
	  *g = in[i * 8 + 2];
	  *b = in[i * 8 + 4];
	  *a = in[i * 8 + 6];
	}
  }
}

/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color
mode test cases, optimized to convert the colors much faster, when converting
to RGBA or RGB with 8 bit per cannel. buffer must be RGBA or RGB output with
enough memory, if has_alpha is true the output is RGBA. mode has the color mode
of the input buffer.*/
static void getPixelColorsRGBA8(unsigned char* buffer, size_t numpixels,
								unsigned has_alpha, const unsigned char* in,
								const LodePNGColorMode* mode)
{
  unsigned num_channels = has_alpha ? 4 : 3;
  size_t i;
  if(mode->colortype == LCT_GREY)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i];
		if(has_alpha) buffer[3] = mode->key_defined && in[i] == mode->key_r ? 0 : 255;
	  }
	}
	else if(mode->bitdepth == 16)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i * 2];
		if(has_alpha) buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
	  }
	}
	else
	{
	  unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
	  size_t j = 0;
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
		buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
		if(has_alpha) buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
	  }
	}
  }
  else if(mode->colortype == LCT_RGB)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 3 + 0];
		buffer[1] = in[i * 3 + 1];
		buffer[2] = in[i * 3 + 2];
		if(has_alpha) buffer[3] = mode->key_defined && buffer[0] == mode->key_r
		   && buffer[1]== mode->key_g && buffer[2] == mode->key_b ? 0 : 255;
	  }
	}
	else
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 6 + 0];
		buffer[1] = in[i * 6 + 2];
		buffer[2] = in[i * 6 + 4];
		if(has_alpha) buffer[3] = mode->key_defined
		   && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
		   && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
		   && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
	  }
	}
  }
  else if(mode->colortype == LCT_PALETTE)
  {
	unsigned index;
	size_t j = 0;
	for(i = 0; i != numpixels; ++i, buffer += num_channels)
	{
	  if(mode->bitdepth == 8) index = in[i];
	  else index = readBitsFromReversedStream(&j, in, mode->bitdepth);

	  if(index >= mode->palettesize)
	  {
		/*This is an error according to the PNG spec, but most PNG decoders make it black instead.
		Done here too, slightly faster due to no error handling needed.*/
		buffer[0] = buffer[1] = buffer[2] = 0;
		if(has_alpha) buffer[3] = 255;
	  }
	  else
	  {
		buffer[0] = mode->palette[index * 4 + 0];
		buffer[1] = mode->palette[index * 4 + 1];
		buffer[2] = mode->palette[index * 4 + 2];
		if(has_alpha) buffer[3] = mode->palette[index * 4 + 3];
	  }
	}
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
		if(has_alpha) buffer[3] = in[i * 2 + 1];
	  }
	}
	else
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
		if(has_alpha) buffer[3] = in[i * 4 + 2];
	  }
	}
  }
  else if(mode->colortype == LCT_RGBA)
  {
	if(mode->bitdepth == 8)
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 4 + 0];
		buffer[1] = in[i * 4 + 1];
		buffer[2] = in[i * 4 + 2];
		if(has_alpha) buffer[3] = in[i * 4 + 3];
	  }
	}
	else
	{
	  for(i = 0; i != numpixels; ++i, buffer += num_channels)
	  {
		buffer[0] = in[i * 8 + 0];
		buffer[1] = in[i * 8 + 2];
		buffer[2] = in[i * 8 + 4];
		if(has_alpha) buffer[3] = in[i * 8 + 6];
	  }
	}
  }
}

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static void getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
								const unsigned char* in, size_t i, const LodePNGColorMode* mode)
{
  if(mode->colortype == LCT_GREY)
  {
	*r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
	if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
	else *a = 65535;
  }
  else if(mode->colortype == LCT_RGB)
  {
	*r = 256 * in[i * 6 + 0] + in[i * 6 + 1];
	*g = 256 * in[i * 6 + 2] + in[i * 6 + 3];
	*b = 256 * in[i * 6 + 4] + in[i * 6 + 5];
	if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
	   && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
	   && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
	else *a = 65535;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
	*r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];
	*a = 256 * in[i * 4 + 2] + in[i * 4 + 3];
  }
  else if(mode->colortype == LCT_RGBA)
  {
	*r = 256 * in[i * 8 + 0] + in[i * 8 + 1];
	*g = 256 * in[i * 8 + 2] + in[i * 8 + 3];
	*b = 256 * in[i * 8 + 4] + in[i * 8 + 5];
	*a = 256 * in[i * 8 + 6] + in[i * 8 + 7];
  }
}

unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
						 LodePNGColorMode* mode_out, const LodePNGColorMode* mode_in,
						 unsigned w, unsigned h)
{
  size_t i;
  ColorTree tree;
  size_t numpixels = w * h;

  if(lodepng_color_mode_equal(mode_out, mode_in))
  {
	size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
	for(i = 0; i != numbytes; ++i) out[i] = in[i];
	return 0;
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
	size_t palsize = 1u << mode_out->bitdepth;
	if(mode_out->palettesize < palsize) palsize = mode_out->palettesize;
	color_tree_init(&tree);
	for(i = 0; i != palsize; ++i)
	{
	  unsigned char* p = &mode_out->palette[i * 4];
	  color_tree_add(&tree, p[0], p[1], p[2], p[3], i);
	}
  }

  if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16)
  {
	for(i = 0; i != numpixels; ++i)
	{
	  unsigned short r = 0, g = 0, b = 0, a = 0;
	  getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
	  rgba16ToPixel(out, i, mode_out, r, g, b, a);
	}
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA)
  {
	getPixelColorsRGBA8(out, numpixels, 1, in, mode_in);
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB)
  {
	getPixelColorsRGBA8(out, numpixels, 0, in, mode_in);
  }
  else
  {
	unsigned char r = 0, g = 0, b = 0, a = 0;
	for(i = 0; i != numpixels; ++i)
	{
	  getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in);
	  rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
	}
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
	color_tree_cleanup(&tree);
  }

  return 0; /*no error (this function currently never has one, but maybe OOM detection added later.)*/
}

#ifdef LODEPNG_COMPILE_ENCODER

void lodepng_color_profile_init(LodePNGColorProfile* profile)
{
  profile->colored = 0;
  profile->key = 0;
  profile->alpha = 0;
  profile->key_r = profile->key_g = profile->key_b = 0;
  profile->numcolors = 0;
  profile->bits = 1;
}

/*function used for debug purposes with C++*/
/*void printColorProfile(LodePNGColorProfile* p)
{
  std::cout << "colored: " << (int)p->colored << ", ";
  std::cout << "key: " << (int)p->key << ", ";
  std::cout << "key_r: " << (int)p->key_r << ", ";
  std::cout << "key_g: " << (int)p->key_g << ", ";
  std::cout << "key_b: " << (int)p->key_b << ", ";
  std::cout << "alpha: " << (int)p->alpha << ", ";
  std::cout << "numcolors: " << (int)p->numcolors << ", ";
  std::cout << "bits: " << (int)p->bits << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
static unsigned getValueRequiredBits(unsigned char value)
{
  if(value == 0 || value == 255) return 1;
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
  return 8;
}

/*profile must already have been inited with mode.
It's ok to set some parameters of profile to done already.*/
unsigned lodepng_get_color_profile(LodePNGColorProfile* profile,
								   const unsigned char* in, unsigned w, unsigned h,
								   const LodePNGColorMode* mode)
{
  unsigned error = 0;
  size_t i;
  ColorTree tree;
  size_t numpixels = w * h;

  unsigned colored_done = lodepng_is_greyscale_type(mode) ? 1 : 0;
  unsigned alpha_done = lodepng_can_have_alpha(mode) ? 0 : 1;
  unsigned numcolors_done = 0;
  unsigned bpp = lodepng_get_bpp(mode);
  unsigned bits_done = bpp == 1 ? 1 : 0;
  unsigned maxnumcolors = 257;
  unsigned sixteen = 0;
  if(bpp <= 8) maxnumcolors = bpp == 1 ? 2 : (bpp == 2 ? 4 : (bpp == 4 ? 16 : 256));

  color_tree_init(&tree);

  /*Check if the 16-bit input is truly 16-bit*/
  if(mode->bitdepth == 16)
  {
	unsigned short r, g, b, a;
	for(i = 0; i != numpixels; ++i)
	{
	  getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);
	  if((r & 255u) != ((r >> 8) & 255u) || (g & 255u) != ((g >> 8) & 255u) ||
		 (b & 255u) != ((b >> 8) & 255u) || (a & 255u) != ((a >> 8) & 255u)) /*first and second byte differ*/
	  {
		sixteen = 1;
		break;
	  }
	}
  }

  if(sixteen)
  {
	unsigned short r = 0, g = 0, b = 0, a = 0;
	profile->bits = 16;
	bits_done = numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/

	for(i = 0; i != numpixels; ++i)
	{
	  getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);

	  if(!colored_done && (r != g || r != b))
	  {
		profile->colored = 1;
		colored_done = 1;
	  }

	  if(!alpha_done)
	  {
		unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);
		if(a != 65535 && (a != 0 || (profile->key && !matchkey)))
		{
		  profile->alpha = 1;
		  alpha_done = 1;
		  if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
		}
		else if(a == 0 && !profile->alpha && !profile->key)
		{
		  profile->key = 1;
		  profile->key_r = r;
		  profile->key_g = g;
		  profile->key_b = b;
		}
		else if(a == 65535 && profile->key && matchkey)
		{
		  /* Color key cannot be used if an opaque pixel also has that RGB color. */
		  profile->alpha = 1;
		  alpha_done = 1;
		}
	  }

	  if(alpha_done && numcolors_done && colored_done && bits_done) break;
	}
  }
  else /* < 16-bit */
  {
	for(i = 0; i != numpixels; ++i)
	{
	  unsigned char r = 0, g = 0, b = 0, a = 0;
	  getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode);

	  if(!bits_done && profile->bits < 8)
	  {
		/*only r is checked, < 8 bits is only relevant for greyscale*/
		unsigned bits = getValueRequiredBits(r);
		if(bits > profile->bits) profile->bits = bits;
	  }
	  bits_done = (profile->bits >= bpp);

	  if(!colored_done && (r != g || r != b))
	  {
		profile->colored = 1;
		colored_done = 1;
		if(profile->bits < 8) profile->bits = 8; /*PNG has no colored modes with less than 8-bit per channel*/
	  }

	  if(!alpha_done)
	  {
		unsigned matchkey = (r == profile->key_r && g == profile->key_g && b == profile->key_b);
		if(a != 255 && (a != 0 || (profile->key && !matchkey)))
		{
		  profile->alpha = 1;
		  alpha_done = 1;
		  if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
		}
		else if(a == 0 && !profile->alpha && !profile->key)
		{
		  profile->key = 1;
		  profile->key_r = r;
		  profile->key_g = g;
		  profile->key_b = b;
		}
		else if(a == 255 && profile->key && matchkey)
		{
		  /* Color key cannot be used if an opaque pixel also has that RGB color. */
		  profile->alpha = 1;
		  alpha_done = 1;
		  if(profile->bits < 8) profile->bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
		}
	  }

	  if(!numcolors_done)
	  {
		if(!color_tree_has(&tree, r, g, b, a))
		{
		  color_tree_add(&tree, r, g, b, a, profile->numcolors);
		  if(profile->numcolors < 256)
		  {
			unsigned char* p = profile->palette;
			unsigned n = profile->numcolors;
			p[n * 4 + 0] = r;
			p[n * 4 + 1] = g;
			p[n * 4 + 2] = b;
			p[n * 4 + 3] = a;
		  }
		  ++profile->numcolors;
		  numcolors_done = profile->numcolors >= maxnumcolors;
		}
	  }

	  if(alpha_done && numcolors_done && colored_done && bits_done) break;
	}

	/*make the profile's key always 16-bit for consistency - repeat each byte twice*/
	profile->key_r += (profile->key_r << 8);
	profile->key_g += (profile->key_g << 8);
	profile->key_b += (profile->key_b << 8);
  }

  color_tree_cleanup(&tree);
  return error;
}

/*Automatically chooses color type that gives smallest amount of bits in the
output image, e.g. grey if there are only greyscale pixels, palette if there
are less than 256 colors, ...
Updates values of mode with a potentially smaller color model. mode_out should
contain the user chosen color model, but will be overwritten with the new chosen one.*/
unsigned lodepng_auto_choose_color(LodePNGColorMode* mode_out,
								   const unsigned char* image, unsigned w, unsigned h,
								   const LodePNGColorMode* mode_in)
{
  LodePNGColorProfile prof;
  unsigned error = 0;
  unsigned i, n, palettebits, grey_ok, palette_ok;

  lodepng_color_profile_init(&prof);
  error = lodepng_get_color_profile(&prof, image, w, h, mode_in);
  if(error) return error;
  mode_out->key_defined = 0;

  if(prof.key && w * h <= 16) {
	prof.alpha = 1; /*too few pixels to justify tRNS chunk overhead*/
	if(prof.bits < 8) prof.bits = 8; /*PNG has no alphachannel modes with less than 8-bit per channel*/
  }
  grey_ok = !prof.colored && !prof.alpha; /*grey without alpha, with potentially low bits*/
  n = prof.numcolors;
  palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
  palette_ok = n <= 256 && (n * 2 < w * h) && prof.bits <= 8;
  if(w * h < n * 2) palette_ok = 0; /*don't add palette overhead if image has only a few pixels*/
  if(grey_ok && prof.bits <= palettebits) palette_ok = 0; /*grey is less overhead*/

  if(palette_ok)
  {
	unsigned char* p = prof.palette;
	lodepng_palette_clear(mode_out); /*remove potential earlier palette*/
	for(i = 0; i != prof.numcolors; ++i)
	{
	  error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
	  if(error) break;
	}

	mode_out->colortype = LCT_PALETTE;
	mode_out->bitdepth = palettebits;

	if(mode_in->colortype == LCT_PALETTE && mode_in->palettesize >= mode_out->palettesize
		&& mode_in->bitdepth == mode_out->bitdepth)
	{
	  /*If input should have same palette colors, keep original to preserve its order and prevent conversion*/
	  lodepng_color_mode_cleanup(mode_out);
	  lodepng_color_mode_copy(mode_out, mode_in);
	}
  }
  else /*8-bit or 16-bit per channel*/
  {
	mode_out->bitdepth = prof.bits;
	mode_out->colortype = prof.alpha ? (prof.colored ? LCT_RGBA : LCT_GREY_ALPHA)
									 : (prof.colored ? LCT_RGB : LCT_GREY);

	if(prof.key && !prof.alpha)
	{
	  unsigned mask = (1u << mode_out->bitdepth) - 1u; /*profile always uses 16-bit, mask converts it*/
	  mode_out->key_r = prof.key_r & mask;
	  mode_out->key_g = prof.key_g & mask;
	  mode_out->key_b = prof.key_b & mask;
	  mode_out->key_defined = 1;
	}
  }

  return error;
}

#endif /* #ifdef LODEPNG_COMPILE_ENCODER */

/*
Paeth predicter, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c)
{
  short pa = abs(b - c);
  short pb = abs(a - c);
  short pc = abs(a + b - c - c);

  if(pc < pa && pc < pb) return (unsigned char)c;
  else if(pb < pa) return (unsigned char)b;
  else return (unsigned char)a;
}

/*shared values used by multiple Adam7 related functions*/

static const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/
static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/

/*
Outputs various dimensions and positions in the image related to the Adam7 reduced images.
passw: output containing the width of the 7 passes
passh: output containing the height of the 7 passes
filter_passstart: output containing the index of the start and end of each
 reduced image with filter bytes
padded_passstart output containing the index of the start and end of each
 reduced image when without filter bytes but with padded scanlines
passstart: output containing the index of the start and end of each reduced
 image without padding between scanlines, but still padding between the images
w, h: width and height of non-interlaced image
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
								size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
{
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i != 7; ++i)
  {
	passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
	passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
	if(passw[i] == 0) passh[i] = 0;
	if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i != 7; ++i)
  {
	/*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
	filter_passstart[i + 1] = filter_passstart[i]
							+ ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0);
	/*bits padded if needed to fill full byte at end of each scanline*/
	padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8);
	/*only padded at end of reduced image*/
	passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8;
  }
}

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
						 const unsigned char* in, size_t insize)
{
  LodePNGInfo* info = &state->info_png;
  if(insize == 0 || in == 0)
  {
	CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
  }
  if(insize < 33)
  {
	CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  lodepng_info_cleanup(info);
  lodepng_info_init(info);

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
	 || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10)
  {
	CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
  }
  if(in[12] != 'I' || in[13] != 'H' || in[14] != 'D' || in[15] != 'R')
  {
	CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
  }

  /*read the values given in the header*/
  *w = lodepng_read32bitInt(&in[16]);
  *h = lodepng_read32bitInt(&in[20]);
  info->color.bitdepth = in[24];
  info->color.colortype = (LodePNGColorType)in[25];
  info->compression_method = in[26];
  info->filter_method = in[27];
  info->interlace_method = in[28];

  if(*w == 0 || *h == 0)
  {
	CERROR_RETURN_ERROR(state->error, 93);
  }

  if(!state->decoder.ignore_crc)
  {
	unsigned CRC = lodepng_read32bitInt(&in[29]);
	unsigned checksum = lodepng_crc32(&in[12], 17);
	if(CRC != checksum)
	{
	  CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
	}
  }

  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);

  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
  return state->error;
}

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
								 size_t bytewidth, unsigned char filterType, size_t length)
{
  /*
  For PNG filter method 0
  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,
  the filter works byte per byte (bytewidth = 1)
  precon is the previous unfiltered scanline, recon the result, scanline the current one
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType)
  {
	case 0:
	  for(i = 0; i != length; ++i) recon[i] = scanline[i];
	  break;
	case 1:
	  for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
	  for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth];
	  break;
	case 2:
	  if(precon)
	  {
		for(i = 0; i != length; ++i) recon[i] = scanline[i] + precon[i];
	  }
	  else
	  {
		for(i = 0; i != length; ++i) recon[i] = scanline[i];
	  }
	  break;
	case 3:
	  if(precon)
	  {
		for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i] + precon[i] / 2;
		for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i) recon[i] = scanline[i];
		for(i = bytewidth; i < length; ++i) recon[i] = scanline[i] + recon[i - bytewidth] / 2;
	  }
	  break;
	case 4:
	  if(precon)
	  {
		for(i = 0; i != bytewidth; ++i)
		{
		  recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
		}
		for(i = bytewidth; i < length; ++i)
		{
		  recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
		}
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i)
		{
		  recon[i] = scanline[i];
		}
		for(i = bytewidth; i < length; ++i)
		{
		  /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
		  recon[i] = (scanline[i] + recon[i - bytewidth]);
		}
	  }
	  break;
	default: return 36; /*error: unexisting filter type given*/
  }
  return 0;
}

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  /*
  For PNG filter method 0
  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)
  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  size_t linebytes = (w * bpp + 7) / 8;

  for(y = 0; y < h; ++y)
  {
	size_t outindex = linebytes * y;
	size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
	unsigned char filterType = in[inindex];

	CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

	prevline = &out[outindex];
  }

  return 0;
}

/*
in: Adam7 interlaced image, with no padding bits between scanlines, but between
 reduced images so that each reduced image starts at a byte.
out: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h
bpp: bits per pixel
out has the following size in bits: w * h * bpp.
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  size_t bytewidth = bpp / 8;
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
		size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
		for(b = 0; b < bytewidth; ++b)
		{
		  out[pixeloutstart + b] = in[pixelinstart + b];
		}
	  }
	}
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  unsigned ilinebits = bpp * passw[i];
	  unsigned olinebits = bpp * w;
	  size_t obp, ibp; /*bit pointers (for out and in buffer)*/
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
		obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
		for(b = 0; b < bpp; ++b)
		{
		  unsigned char bit = readBitFromReversedStream(&ibp, in);
		  /*note that this function assumes the out buffer is completely 0, use setBitOfReversedStream otherwise*/
		  setBitOfReversedStream0(&obp, out, bit);
		}
	  }
	}
  }
}

static void removePaddingBits(unsigned char* out, const unsigned char* in,
							  size_t olinebits, size_t ilinebits, unsigned h)
{
  /*
  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need
  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers
  for the Adam7 code, the color convert code and the output to the user.
  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; ++y)
  {
	size_t x;
	for(x = 0; x < olinebits; ++x)
	{
	  unsigned char bit = readBitFromReversedStream(&ibp, in);
	  setBitOfReversedStream(&obp, out, bit);
	}
	ibp += diff;
  }
}

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
									 unsigned w, unsigned h, const LodePNGInfo* info_png)
{
  /*
  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= posible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  if(bpp == 0) return 31; /*error: invalid colortype*/

  if(info_png->interlace_method == 0)
  {
	if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
	{
	  CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
	  removePaddingBits(out, in, w * bpp, ((w * bpp + 7) / 8) * 8, h);
	}
	/*we can immediatly filter into the out buffer, no other steps needed*/
	else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
  }
  else /*interlace_method is 1 (Adam7)*/
  {
	unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
	unsigned i;

	Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

	for(i = 0; i != 7; ++i)
	{
	  CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
	  /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
	  move bytes instead of bits or move not at all*/
	  if(bpp < 8)
	  {
		/*remove padding bits in scanlines; after this there still may be padding
		bits between the different reduced images: each reduced image still starts nicely at a byte*/
		removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
						  ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
	  }
	}

	Adam7_deinterlace(out, in, w, h, bpp);
  }

  return 0;
}

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned pos = 0, i;
  if(color->palette) lodepng_free(color->palette);
  color->palettesize = chunkLength / 3;
  color->palette = (unsigned char*)lodepng_malloc(4 * color->palettesize);
  if(!color->palette && color->palettesize)
  {
	color->palettesize = 0;
	return 83; /*alloc fail*/
  }
  if(color->palettesize > 256) return 38; /*error: palette too big*/

  for(i = 0; i != color->palettesize; ++i)
  {
	color->palette[4 * i + 0] = data[pos++]; /*R*/
	color->palette[4 * i + 1] = data[pos++]; /*G*/
	color->palette[4 * i + 2] = data[pos++]; /*B*/
	color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
}

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned i;
  if(color->colortype == LCT_PALETTE)
  {
	/*error: more alpha values given than there are palette entries*/
	if(chunkLength > color->palettesize) return 38;

	for(i = 0; i != chunkLength; ++i) color->palette[4 * i + 3] = data[i];
  }
  else if(color->colortype == LCT_GREY)
  {
	/*error: this chunk must be 2 bytes for greyscale image*/
	if(chunkLength != 2) return 30;

	color->key_defined = 1;
	color->key_r = color->key_g = color->key_b = 256u * data[0] + data[1];
  }
  else if(color->colortype == LCT_RGB)
  {
	/*error: this chunk must be 6 bytes for RGB image*/
	if(chunkLength != 6) return 41;

	color->key_defined = 1;
	color->key_r = 256u * data[0] + data[1];
	color->key_g = 256u * data[2] + data[3];
	color->key_b = 256u * data[4] + data[5];
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/

  return 0; /* OK */
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(info->color.colortype == LCT_PALETTE)
  {
	/*error: this chunk must be 1 byte for indexed color image*/
	if(chunkLength != 1) return 43;

	info->background_defined = 1;
	info->background_r = info->background_g = info->background_b = data[0];
  }
  else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
	/*error: this chunk must be 2 bytes for greyscale image*/
	if(chunkLength != 2) return 44;

	info->background_defined = 1;
	info->background_r = info->background_g = info->background_b = 256u * data[0] + data[1];
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
	/*error: this chunk must be 6 bytes for greyscale image*/
	if(chunkLength != 6) return 45;

	info->background_defined = 1;
	info->background_r = 256u * data[0] + data[1];
	info->background_g = 256u * data[2] + data[3];
	info->background_b = 256u * data[4] + data[5];
  }

  return 0; /* OK */
}

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  char *key = 0, *str = 0;
  unsigned i;

  while(!error) /*not really a while loop, only used to break on error*/
  {
	unsigned length, string2_begin;

	length = 0;
	while(length < chunkLength && data[length] != 0) ++length;
	/*even though it's not allowed by the standard, no error is thrown if
	there's no null termination char, if the text is empty*/
	if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

	key = (char*)lodepng_malloc(length + 1);
	if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

	key[length] = 0;
	for(i = 0; i != length; ++i) key[i] = (char)data[i];

	string2_begin = length + 1; /*skip keyword null terminator*/

	length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;
	str = (char*)lodepng_malloc(length + 1);
	if(!str) CERROR_BREAK(error, 83); /*alloc fail*/

	str[length] = 0;
	for(i = 0; i != length; ++i) str[i] = (char)data[string2_begin + i];

	error = lodepng_add_text(info, key, str);

	break;
  }

  lodepng_free(key);
  lodepng_free(str);

  return error;
}

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
							   const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, string2_begin;
  char *key = 0;
  ucvector decoded;

  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
	for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
	if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
	if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

	key = (char*)lodepng_malloc(length + 1);
	if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

	key[length] = 0;
	for(i = 0; i != length; ++i) key[i] = (char)data[i];

	if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

	string2_begin = length + 2;
	if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/

	length = chunkLength - string2_begin;
	/*will fail if zlib error, e.g. if length is too small*/
	error = zlib_decompress(&decoded.data, &decoded.size,
							(unsigned char*)(&data[string2_begin]),
							length, zlibsettings);
	if(error) break;
	ucvector_push_back(&decoded, 0);

	error = lodepng_add_text(info, key, (char*)decoded.data);

	break;
  }

  lodepng_free(key);
  ucvector_cleanup(&decoded);

  return error;
}

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
							   const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
  ucvector decoded;
  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
	/*Quick check if the chunk length isn't too small. Even without check
	it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
	if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/

	/*read the key*/
	for(length = 0; length < chunkLength && data[length] != 0; ++length) ;
	if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
	if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

	key = (char*)lodepng_malloc(length + 1);
	if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

	key[length] = 0;
	for(i = 0; i != length; ++i) key[i] = (char)data[i];

	/*read the compression method*/
	compressed = data[length + 1];
	if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

	/*even though it's not allowed by the standard, no error is thrown if
	there's no null termination char, if the text is empty for the next 3 texts*/

	/*read the langtag*/
	begin = length + 3;
	length = 0;
	for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;

	langtag = (char*)lodepng_malloc(length + 1);
	if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/

	langtag[length] = 0;
	for(i = 0; i != length; ++i) langtag[i] = (char)data[begin + i];

	/*read the transkey*/
	begin += length + 1;
	length = 0;
	for(i = begin; i < chunkLength && data[i] != 0; ++i) ++length;

	transkey = (char*)lodepng_malloc(length + 1);
	if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/

	transkey[length] = 0;
	for(i = 0; i != length; ++i) transkey[i] = (char)data[begin + i];

	/*read the actual text*/
	begin += length + 1;

	length = chunkLength < begin ? 0 : chunkLength - begin;

	if(compressed)
	{
	  /*will fail if zlib error, e.g. if length is too small*/
	  error = zlib_decompress(&decoded.data, &decoded.size,
							  (unsigned char*)(&data[begin]),
							  length, zlibsettings);
	  if(error) break;
	  if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;
	  ucvector_push_back(&decoded, 0);
	}
	else
	{
	  if(!ucvector_resize(&decoded, length + 1)) CERROR_BREAK(error, 83 /*alloc fail*/);

	  decoded.data[length] = 0;
	  for(i = 0; i != length; ++i) decoded.data[i] = data[begin + i];
	}

	error = lodepng_add_itext(info, key, langtag, transkey, (char*)decoded.data);

	break;
  }

  lodepng_free(key);
  lodepng_free(langtag);
  lodepng_free(transkey);
  ucvector_cleanup(&decoded);

  return error;
}

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/

  info->time_defined = 1;
  info->time.year = 256u * data[0] + data[1];
  info->time.month = data[2];
  info->time.day = data[3];
  info->time.hour = data[4];
  info->time.minute = data[5];
  info->time.second = data[6];

  return 0; /* OK */
}

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/

  info->phys_defined = 1;
  info->phys_x = 16777216u * data[0] + 65536u * data[1] + 256u * data[2] + data[3];
  info->phys_y = 16777216u * data[4] + 65536u * data[5] + 256u * data[6] + data[7];
  info->phys_unit = data[8];

  return 0; /* OK */
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
						  LodePNGState* state,
						  const unsigned char* in, size_t insize)
{
  unsigned char IEND = 0;
  const unsigned char* chunk;
  size_t i;
  ucvector idat; /*the data from idat chunks*/
  ucvector scanlines;
  size_t predict;
  size_t numpixels;

  /*for unknown chunk order*/
  unsigned unknown = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

  /*provide some proper output values if error will happen*/
  *out = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;

  numpixels = *w * *h;

  /*multiplication overflow*/
  if(*h != 0 && numpixels / *h != *w) CERROR_RETURN(state->error, 92);
  /*multiplication overflow possible further below. Allows up to 2^31-1 pixel
  bytes with 16-bit RGBA, the rest is room for filter bytes.*/
  if(numpixels > 268435455) CERROR_RETURN(state->error, 92);

  ucvector_init(&idat);
  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error)
  {
	unsigned chunkLength;
	const unsigned char* data; /*the data in the chunk*/

	/*error: size of the in buffer too small to contain next chunk*/
	if((size_t)((chunk - in) + 12) > insize || chunk < in) CERROR_BREAK(state->error, 30);

	/*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
	chunkLength = lodepng_chunk_length(chunk);
	/*error: chunk length larger than the max PNG chunk size*/
	if(chunkLength > 2147483647) CERROR_BREAK(state->error, 63);

	if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in)
	{
	  CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
	}

	data = lodepng_chunk_data_const(chunk);

	/*IDAT chunk, containing compressed image data*/
	if(lodepng_chunk_type_equals(chunk, "IDAT"))
	{
	  size_t oldsize = idat.size;
	  if(!ucvector_resize(&idat, oldsize + chunkLength)) CERROR_BREAK(state->error, 83 /*alloc fail*/);
	  for(i = 0; i != chunkLength; ++i) idat.data[oldsize + i] = data[i];
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	  critical_pos = 3;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	}
	/*IEND chunk*/
	else if(lodepng_chunk_type_equals(chunk, "IEND"))
	{
	  IEND = 1;
	}
	/*palette chunk (PLTE)*/
	else if(lodepng_chunk_type_equals(chunk, "PLTE"))
	{
	  state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
	  if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	  critical_pos = 2;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	}
	/*palette transparency chunk (tRNS)*/
	else if(lodepng_chunk_type_equals(chunk, "tRNS"))
	{
	  state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
	  if(state->error) break;
	}
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*background color chunk (bKGD)*/
	else if(lodepng_chunk_type_equals(chunk, "bKGD"))
	{
	  state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
	  if(state->error) break;
	}
	/*text chunk (tEXt)*/
	else if(lodepng_chunk_type_equals(chunk, "tEXt"))
	{
	  if(state->decoder.read_text_chunks)
	  {
		state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
		if(state->error) break;
	  }
	}
	/*compressed text chunk (zTXt)*/
	else if(lodepng_chunk_type_equals(chunk, "zTXt"))
	{
	  if(state->decoder.read_text_chunks)
	  {
		state->error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
		if(state->error) break;
	  }
	}
	/*international text chunk (iTXt)*/
	else if(lodepng_chunk_type_equals(chunk, "iTXt"))
	{
	  if(state->decoder.read_text_chunks)
	  {
		state->error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
		if(state->error) break;
	  }
	}
	else if(lodepng_chunk_type_equals(chunk, "tIME"))
	{
	  state->error = readChunk_tIME(&state->info_png, data, chunkLength);
	  if(state->error) break;
	}
	else if(lodepng_chunk_type_equals(chunk, "pHYs"))
	{
	  state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	else /*it's not an implemented chunk type, so ignore it: skip over the data*/
	{
	  /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
	  if(!lodepng_chunk_ancillary(chunk)) CERROR_BREAK(state->error, 69);

	  unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	  if(state->decoder.remember_unknown_chunks)
	  {
		state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
											&state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
		if(state->error) break;
	  }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	}

	if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/
	{
	  if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
	}

	if(!IEND) chunk = lodepng_chunk_next_const(chunk);
  }

  ucvector_init(&scanlines);
  /*predict output size, to allocate exact size for output buffer to avoid more dynamic allocation.
  If the decompressed size does not match the prediction, the image must be corrupt.*/
  if(state->info_png.interlace_method == 0)
  {
	/*The extra *h is added because this are the filter bytes every scanline starts with*/
	predict = lodepng_get_raw_size_idat(*w, *h, &state->info_png.color) + *h;
  }
  else
  {
	/*Adam-7 interlaced: predicted size is the sum of the 7 sub-images sizes*/
	const LodePNGColorMode* color = &state->info_png.color;
	predict = 0;
	predict += lodepng_get_raw_size_idat((*w + 7) / 8, (*h + 7) / 8, color) + (*h + 7) / 8;
	if(*w > 4) predict += lodepng_get_raw_size_idat((*w + 3) / 8, (*h + 7) / 8, color) + (*h + 7) / 8;
	predict += lodepng_get_raw_size_idat((*w + 3) / 4, (*h + 3) / 8, color) + (*h + 3) / 8;
	if(*w > 2) predict += lodepng_get_raw_size_idat((*w + 1) / 4, (*h + 3) / 4, color) + (*h + 3) / 4;
	predict += lodepng_get_raw_size_idat((*w + 1) / 2, (*h + 1) / 4, color) + (*h + 1) / 4;
	if(*w > 1) predict += lodepng_get_raw_size_idat((*w + 0) / 2, (*h + 1) / 2, color) + (*h + 1) / 2;
	predict += lodepng_get_raw_size_idat((*w + 0) / 1, (*h + 0) / 2, color) + (*h + 0) / 2;
  }
  if(!state->error && !ucvector_reserve(&scanlines, predict)) state->error = 83; /*alloc fail*/
  if(!state->error)
  {
	state->error = zlib_decompress(&scanlines.data, &scanlines.size, idat.data,
								   idat.size, &state->decoder.zlibsettings);
	if(!state->error && scanlines.size != predict) state->error = 91; /*decompressed size doesn't match prediction*/
  }
  ucvector_cleanup(&idat);

  if(!state->error)
  {
	size_t outsize = lodepng_get_raw_size(*w, *h, &state->info_png.color);
	ucvector outv;
	ucvector_init(&outv);
	if(!ucvector_resizev(&outv, outsize, 0)) state->error = 83; /*alloc fail*/
	if(!state->error) state->error = postProcessScanlines(outv.data, scanlines.data, *w, *h, &state->info_png);
	*out = outv.data;
  }
  ucvector_cleanup(&scanlines);
}

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
						LodePNGState* state,
						const unsigned char* in, size_t insize)
{
  *out = 0;
  decodeGeneric(out, w, h, state, in, insize);
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color))
  {
	/*same color type, no copying or converting of data needed*/
	/*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
	the raw image has to the end user*/
	if(!state->decoder.color_convert)
	{
	  state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
	  if(state->error) return state->error;
	}
  }
  else
  {
	/*color conversion needed; sort of copy of the data*/
	unsigned char* data = *out;
	size_t outsize;

	/*TODO: check if this works according to the statement in the documentation: "The converter can convert
	from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
	if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
	   && !(state->info_raw.bitdepth == 8))
	{
	  return 56; /*unsupported color mode conversion*/
	}

	outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
	*out = (unsigned char*)lodepng_malloc(outsize);
	if(!(*out))
	{
	  state->error = 83; /*alloc fail*/
	}
	else state->error = lodepng_convert(*out, data, &state->info_raw,
										&state->info_png.color, *w, *h);
	lodepng_free(data);
  }
  return state->error;
}

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
							   size_t insize, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  error = lodepng_decode(out, w, h, &state, in, insize);
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
}

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
							 LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error;
  error = lodepng_load_file(&buffer, &buffersize, filename);
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
}

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)
{
  settings->color_convert = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
  settings->remember_unknown_chunks = 0;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
  lodepng_decompress_settings_init(&settings->zlibsettings);
}

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state)
{
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
  lodepng_info_init(&state->info_png);
  state->error = 1;
}

void lodepng_state_cleanup(LodePNGState* state)
{
  lodepng_color_mode_cleanup(&state->info_raw);
  lodepng_info_cleanup(&state->info_png);
}

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source)
{
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}

#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*chunkName must be string of 4 characters*/
static unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length)
{
  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));
  out->allocsize = out->size; /*fix the allocsize again*/
  return 0;
}

static void writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  ucvector_push_back(out, 137);
  ucvector_push_back(out, 80);
  ucvector_push_back(out, 78);
  ucvector_push_back(out, 71);
  ucvector_push_back(out, 13);
  ucvector_push_back(out, 10);
  ucvector_push_back(out, 26);
  ucvector_push_back(out, 10);
}

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
							  LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method)
{
  unsigned error = 0;
  ucvector header;
  ucvector_init(&header);

  lodepng_add32bitInt(&header, w); /*width*/
  lodepng_add32bitInt(&header, h); /*height*/
  ucvector_push_back(&header, (unsigned char)bitdepth); /*bit depth*/
  ucvector_push_back(&header, (unsigned char)colortype); /*color type*/
  ucvector_push_back(&header, 0); /*compression method*/
  ucvector_push_back(&header, 0); /*filter method*/
  ucvector_push_back(&header, interlace_method); /*interlace method*/

  error = addChunk(out, "IHDR", header.data, header.size);
  ucvector_cleanup(&header);

  return error;
}

static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector PLTE;
  ucvector_init(&PLTE);
  for(i = 0; i != info->palettesize * 4; ++i)
  {
	/*add all channels except alpha channel*/
	if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);
  }
  error = addChunk(out, "PLTE", PLTE.data, PLTE.size);
  ucvector_cleanup(&PLTE);

  return error;
}

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector tRNS;
  ucvector_init(&tRNS);
  if(info->colortype == LCT_PALETTE)
  {
	size_t amount = info->palettesize;
	/*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
	for(i = info->palettesize; i != 0; --i)
	{
	  if(info->palette[4 * (i - 1) + 3] == 255) --amount;
	  else break;
	}
	/*add only alpha channel*/
	for(i = 0; i != amount; ++i) ucvector_push_back(&tRNS, info->palette[4 * i + 3]);
  }
  else if(info->colortype == LCT_GREY)
  {
	if(info->key_defined)
	{
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));
	}
  }
  else if(info->colortype == LCT_RGB)
  {
	if(info->key_defined)
	{
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_g / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_g % 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_b / 256));
	  ucvector_push_back(&tRNS, (unsigned char)(info->key_b % 256));
	}
  }

  error = addChunk(out, "tRNS", tRNS.data, tRNS.size);
  ucvector_cleanup(&tRNS);

  return error;
}

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
							  LodePNGCompressSettings* zlibsettings)
{
  ucvector zlibdata;
  unsigned error = 0;

  /*compress with the Zlib compressor*/
  ucvector_init(&zlibdata);
  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);
  if(!error) error = addChunk(out, "IDAT", zlibdata.data, zlibdata.size);
  ucvector_cleanup(&zlibdata);

  return error;
}

static unsigned addChunk_IEND(ucvector* out)
{
  unsigned error = 0;
  error = addChunk(out, "IEND", 0, 0);
  return error;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring)
{
  unsigned error = 0;
  size_t i;
  ucvector text;
  ucvector_init(&text);
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&text, 0); /*0 termination char*/
  for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&text, (unsigned char)textstring[i]);
  error = addChunk(out, "tEXt", text.data, text.size);
  ucvector_cleanup(&text);

  return error;
}

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
							  LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data, compressed;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);
  ucvector_init(&compressed);
  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*0 termination char*/
  ucvector_push_back(&data, 0); /*compression method: 0*/

  error = zlib_compress(&compressed.data, &compressed.size,
						(unsigned char*)textstring, textsize, zlibsettings);
  if(!error)
  {
	for(i = 0; i != compressed.size; ++i) ucvector_push_back(&data, compressed.data[i]);
	error = addChunk(out, "zTXt", data.data, data.size);
  }

  ucvector_cleanup(&compressed);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,
							  const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);

  for(i = 0; keyword[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*null termination char*/
  ucvector_push_back(&data, compressed ? 1 : 0); /*compression flag*/
  ucvector_push_back(&data, 0); /*compression method*/
  for(i = 0; langtag[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)langtag[i]);
  ucvector_push_back(&data, 0); /*null termination char*/
  for(i = 0; transkey[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)transkey[i]);
  ucvector_push_back(&data, 0); /*null termination char*/

  if(compressed)
  {
	ucvector compressed_data;
	ucvector_init(&compressed_data);
	error = zlib_compress(&compressed_data.data, &compressed_data.size,
						  (unsigned char*)textstring, textsize, zlibsettings);
	if(!error)
	{
	  for(i = 0; i != compressed_data.size; ++i) ucvector_push_back(&data, compressed_data.data[i]);
	}
	ucvector_cleanup(&compressed_data);
  }
  else /*not compressed*/
  {
	for(i = 0; textstring[i] != 0; ++i) ucvector_push_back(&data, (unsigned char)textstring[i]);
  }

  if(!error) error = addChunk(out, "iTXt", data.data, data.size);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector bKGD;
  ucvector_init(&bKGD);
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_g / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_g % 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_b / 256));
	ucvector_push_back(&bKGD, (unsigned char)(info->background_b % 256));
  }
  else if(info->color.colortype == LCT_PALETTE)
  {
	ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256)); /*palette index*/
  }

  error = addChunk(out, "bKGD", bKGD.data, bKGD.size);
  ucvector_cleanup(&bKGD);

  return error;
}

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time)
{
  unsigned error = 0;
  unsigned char* data = (unsigned char*)lodepng_malloc(7);
  if(!data) return 83; /*alloc fail*/
  data[0] = (unsigned char)(time->year / 256);
  data[1] = (unsigned char)(time->year % 256);
  data[2] = (unsigned char)time->month;
  data[3] = (unsigned char)time->day;
  data[4] = (unsigned char)time->hour;
  data[5] = (unsigned char)time->minute;
  data[6] = (unsigned char)time->second;
  error = addChunk(out, "tIME", data, 7);
  lodepng_free(data);
  return error;
}

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector data;
  ucvector_init(&data);

  lodepng_add32bitInt(&data, info->phys_x);
  lodepng_add32bitInt(&data, info->phys_y);
  ucvector_push_back(&data, info->phys_unit);

  error = addChunk(out, "pHYs", data.data, data.size);
  ucvector_cleanup(&data);

  return error;
}

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
						   size_t length, size_t bytewidth, unsigned char filterType)
{
  size_t i;
  switch(filterType)
  {
	case 0: /*None*/
	  for(i = 0; i != length; ++i) out[i] = scanline[i];
	  break;
	case 1: /*Sub*/
	  for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
	  for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth];
	  break;
	case 2: /*Up*/
	  if(prevline)
	  {
		for(i = 0; i != length; ++i) out[i] = scanline[i] - prevline[i];
	  }
	  else
	  {
		for(i = 0; i != length; ++i) out[i] = scanline[i];
	  }
	  break;
	case 3: /*Average*/
	  if(prevline)
	  {
		for(i = 0; i != bytewidth; ++i) out[i] = scanline[i] - prevline[i] / 2;
		for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) / 2);
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
		for(i = bytewidth; i < length; ++i) out[i] = scanline[i] - scanline[i - bytewidth] / 2;
	  }
	  break;
	case 4: /*Paeth*/
	  if(prevline)
	  {
		/*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
		for(i = 0; i != bytewidth; ++i) out[i] = (scanline[i] - prevline[i]);
		for(i = bytewidth; i < length; ++i)
		{
		  out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
		}
	  }
	  else
	  {
		for(i = 0; i != bytewidth; ++i) out[i] = scanline[i];
		/*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
		for(i = bytewidth; i < length; ++i) out[i] = (scanline[i] - scanline[i - bytewidth]);
	  }
	  break;
	default: return; /*unexisting filter type given*/
  }
}

/* log2 approximation. A slight bit faster than std::log. */
static float flog2(float f)
{
  float result = 0;
  while(f > 32) { result += 4; f /= 16; }
  while(f > 2) { ++result; f /= 2; }
  return result + 1.442695f * (f * f * f / 3 - 3 * f * f / 2 + 3 * f - 1.83333f);
}

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
					   const LodePNGColorMode* info, const LodePNGEncoderSettings* settings)
{
  /*
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7) / 8, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(info);
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = (w * bpp + 7) / 8;
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  const unsigned char* prevline = 0;
  unsigned x, y;
  unsigned error = 0;
  LodePNGFilterStrategy strategy = settings->filter_strategy;

  /*
  There is a heuristic called the minimum sum of absolute differences heuristic, suggested by the PNG standard:
   *  If the image type is Palette, or the bit depth is smaller than 8, then do not filter the image (i.e.
	  use fixed filtering, with the filter None).
   * (The other case) If the image type is Grayscale or RGB (with or without Alpha), and the bit depth is
	 not smaller than 8, then use adaptive filtering heuristic as follows: independently for each row, apply
	 all five filters and select the filter that produces the smallest sum of absolute values per row.
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.

  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
	 (info->colortype == LCT_PALETTE || info->bitdepth < 8)) strategy = LFS_ZERO;

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy == LFS_ZERO)
  {
	for(y = 0; y != h; ++y)
	{
	  size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
	  size_t inindex = linebytes * y;
	  out[outindex] = 0; /*filter type byte*/
	  filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, 0);
	  prevline = &in[inindex];
	}
  }
  else if(strategy == LFS_MINSUM)
  {
	/*adaptive filtering*/
	size_t sum[5];
	ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
	size_t smallest = 0;
	unsigned char type, bestType = 0;

	for(type = 0; type != 5; ++type)
	{
	  ucvector_init(&attempt[type]);
	  if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/
	}

	if(!error)
	{
	  for(y = 0; y != h; ++y)
	  {
		/*try the 5 filter types*/
		for(type = 0; type != 5; ++type)
		{
		  filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);

		  /*calculate the sum of the result*/
		  sum[type] = 0;
		  if(type == 0)
		  {
			for(x = 0; x != linebytes; ++x) sum[type] += (unsigned char)(attempt[type].data[x]);
		  }
		  else
		  {
			for(x = 0; x != linebytes; ++x)
			{
			  /*For differences, each byte should be treated as signed, values above 127 are negative
			  (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
			  This means filtertype 0 is almost never chosen, but that is justified.*/
			  unsigned char s = attempt[type].data[x];
			  sum[type] += s < 128 ? s : (255U - s);
			}
		  }

		  /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
		  if(type == 0 || sum[type] < smallest)
		  {
			bestType = type;
			smallest = sum[type];
		  }
		}

		prevline = &in[y * linebytes];

		/*now fill the out values*/
		out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
		for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
	  }
	}

	for(type = 0; type != 5; ++type) ucvector_cleanup(&attempt[type]);
  }
  else if(strategy == LFS_ENTROPY)
  {
	float sum[5];
	ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
	float smallest = 0;
	unsigned type, bestType = 0;
	unsigned count[256];

	for(type = 0; type != 5; ++type)
	{
	  ucvector_init(&attempt[type]);
	  if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/
	}

	for(y = 0; y != h; ++y)
	{
	  /*try the 5 filter types*/
	  for(type = 0; type != 5; ++type)
	  {
		filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);
		for(x = 0; x != 256; ++x) count[x] = 0;
		for(x = 0; x != linebytes; ++x) ++count[attempt[type].data[x]];
		++count[type]; /*the filter type itself is part of the scanline*/
		sum[type] = 0;
		for(x = 0; x != 256; ++x)
		{
		  float p = count[x] / (float)(linebytes + 1);
		  sum[type] += count[x] == 0 ? 0 : flog2(1 / p) * p;
		}
		/*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
		if(type == 0 || sum[type] < smallest)
		{
		  bestType = type;
		  smallest = sum[type];
		}
	  }

	  prevline = &in[y * linebytes];

	  /*now fill the out values*/
	  out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
	  for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
	}

	for(type = 0; type != 5; ++type) ucvector_cleanup(&attempt[type]);
  }
  else if(strategy == LFS_PREDEFINED)
  {
	for(y = 0; y != h; ++y)
	{
	  size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
	  size_t inindex = linebytes * y;
	  unsigned char type = settings->predefined_filters[y];
	  out[outindex] = type; /*filter type byte*/
	  filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
	  prevline = &in[inindex];
	}
  }
  else if(strategy == LFS_BRUTE_FORCE)
  {
	/*brute force filter chooser.
	deflate the scanline after every filter attempt to see which one deflates best.
	This is very slow and gives only slightly smaller, sometimes even larger, result*/
	size_t size[5];
	ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
	size_t smallest = 0;
	unsigned type = 0, bestType = 0;
	unsigned char* dummy;
	LodePNGCompressSettings zlibsettings = settings->zlibsettings;
	/*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
	to simulate the true case where the tree is the same for the whole image. Sometimes it gives
	better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
	cases better compression. It does make this a bit less slow, so it's worth doing this.*/
	zlibsettings.btype = 1;
	/*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
	images only, so disable it*/
	zlibsettings.custom_zlib = 0;
	zlibsettings.custom_deflate = 0;
	for(type = 0; type != 5; ++type)
	{
	  ucvector_init(&attempt[type]);
	  ucvector_resize(&attempt[type], linebytes); /*todo: give error if resize failed*/
	}
	for(y = 0; y != h; ++y) /*try the 5 filter types*/
	{
	  for(type = 0; type != 5; ++type)
	  {
		unsigned testsize = attempt[type].size;
		/*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

		filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);
		size[type] = 0;
		dummy = 0;
		zlib_compress(&dummy, &size[type], attempt[type].data, testsize, &zlibsettings);
		lodepng_free(dummy);
		/*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
		if(type == 0 || size[type] < smallest)
		{
		  bestType = type;
		  smallest = size[type];
		}
	  }
	  prevline = &in[y * linebytes];
	  out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
	  for(x = 0; x != linebytes; ++x) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
	}
	for(type = 0; type != 5; ++type) ucvector_cleanup(&attempt[type]);
  }
  else return 88; /* unknown filter strategy */

  return error;
}

static void addPaddingBits(unsigned char* out, const unsigned char* in,
						   size_t olinebits, size_t ilinebits, unsigned h)
{
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y != h; ++y)
  {
	size_t x;
	for(x = 0; x < ilinebits; ++x)
	{
	  unsigned char bit = readBitFromReversedStream(&ibp, in);
	  setBitOfReversedStream(&obp, out, bit);
	}
	/*obp += diff; --> no, fill in some value in the padding bits too, to avoid
	"Use of uninitialised value of size ###" warning from valgrind*/
	for(x = 0; x != diff; ++x) setBitOfReversedStream(&obp, out, 0);
  }
}

/*
in: non-interlaced image with size w*h
out: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with
 no padding bits between scanlines, but between reduced images so that each
 reduced image starts at a byte.
bpp: bits per pixel
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  size_t bytewidth = bpp / 8;
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
		size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
		for(b = 0; b < bytewidth; ++b)
		{
		  out[pixeloutstart + b] = in[pixelinstart + b];
		}
	  }
	}
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
	for(i = 0; i != 7; ++i)
	{
	  unsigned x, y, b;
	  unsigned ilinebits = bpp * passw[i];
	  unsigned olinebits = bpp * w;
	  size_t obp, ibp; /*bit pointers (for out and in buffer)*/
	  for(y = 0; y < passh[i]; ++y)
	  for(x = 0; x < passw[i]; ++x)
	  {
		ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
		obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
		for(b = 0; b < bpp; ++b)
		{
		  unsigned char bit = readBitFromReversedStream(&ibp, in);
		  setBitOfReversedStream(&obp, out, bit);
		}
	  }
	}
  }
}

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
									unsigned w, unsigned h,
									const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings)
{
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= posible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  unsigned error = 0;

  if(info_png->interlace_method == 0)
  {
	*outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/
	*out = (unsigned char*)lodepng_malloc(*outsize);
	if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

	if(!error)
	{
	  /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
	  if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
	  {
		unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7) / 8));
		if(!padded) error = 83; /*alloc fail*/
		if(!error)
		{
		  addPaddingBits(padded, in, ((w * bpp + 7) / 8) * 8, w * bpp, h);
		  error = filter(*out, padded, w, h, &info_png->color, settings);
		}
		lodepng_free(padded);
	  }
	  else
	  {
		/*we can immediatly filter into the out buffer, no other steps needed*/
		error = filter(*out, in, w, h, &info_png->color, settings);
	  }
	}
  }
  else /*interlace_method is 1 (Adam7)*/
  {
	unsigned passw[7], passh[7];
	size_t filter_passstart[8], padded_passstart[8], passstart[8];
	unsigned char* adam7;

	Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

	*outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
	*out = (unsigned char*)lodepng_malloc(*outsize);
	if(!(*out)) error = 83; /*alloc fail*/

	adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
	if(!adam7 && passstart[7]) error = 83; /*alloc fail*/

	if(!error)
	{
	  unsigned i;

	  Adam7_interlace(adam7, in, w, h, bpp);
	  for(i = 0; i != 7; ++i)
	  {
		if(bpp < 8)
		{
		  unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
		  if(!padded) ERROR_BREAK(83); /*alloc fail*/
		  addPaddingBits(padded, &adam7[passstart[i]],
						 ((passw[i] * bpp + 7) / 8) * 8, passw[i] * bpp, passh[i]);
		  error = filter(&(*out)[filter_passstart[i]], padded,
						 passw[i], passh[i], &info_png->color, settings);
		  lodepng_free(padded);
		}
		else
		{
		  error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
						 passw[i], passh[i], &info_png->color, settings);
		}

		if(error) break;
	  }
	}

	lodepng_free(adam7);
  }

  return error;
}

/*
palette must have 4 * palettesize bytes allocated, and given in format RGBARGBARGBARGBA...
returns 0 if the palette is opaque,
returns 1 if the palette has a single color with alpha 0 ==> color key
returns 2 if the palette is semi-translucent.
*/
static unsigned getPaletteTranslucency(const unsigned char* palette, size_t palettesize)
{
  size_t i;
  unsigned key = 0;
  unsigned r = 0, g = 0, b = 0; /*the value of the color with alpha 0, so long as color keying is possible*/
  for(i = 0; i != palettesize; ++i)
  {
	if(!key && palette[4 * i + 3] == 0)
	{
	  r = palette[4 * i + 0]; g = palette[4 * i + 1]; b = palette[4 * i + 2];
	  key = 1;
	  i = (size_t)(-1); /*restart from beginning, to detect earlier opaque colors with key's value*/
	}
	else if(palette[4 * i + 3] != 255) return 2;
	/*when key, no opaque RGB may have key's RGB*/
	else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;
  }
  return key;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize)
{
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize)
  {
	CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
	out->allocsize = out->size; /*fix the allocsize again*/
	inchunk = lodepng_chunk_next(inchunk);
  }
  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
						const unsigned char* image, unsigned w, unsigned h,
						LodePNGState* state)
{
  LodePNGInfo info;
  ucvector outv;
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
  size_t datasize = 0;

  /*provide some proper output values if error will happen*/
  *out = 0;
  *outsize = 0;
  state->error = 0;

  lodepng_info_init(&info);
  lodepng_info_copy(&info, &state->info_png);

  if((info.color.colortype == LCT_PALETTE || state->encoder.force_palette)
	  && (info.color.palettesize == 0 || info.color.palettesize > 256))
  {
	state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
	return state->error;
  }

  if(state->encoder.auto_convert)
  {
	state->error = lodepng_auto_choose_color(&info.color, image, w, h, &state->info_raw);
  }
  if(state->error) return state->error;

  if(state->encoder.zlibsettings.btype > 2)
  {
	CERROR_RETURN_ERROR(state->error, 61); /*error: unexisting btype*/
  }
  if(state->info_png.interlace_method > 1)
  {
	CERROR_RETURN_ERROR(state->error, 71); /*error: unexisting interlace mode*/
  }

  state->error = checkColorValidity(info.color.colortype, info.color.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/

  if(!lodepng_color_mode_equal(&state->info_raw, &info.color))
  {
	unsigned char* converted;
	size_t size = (w * h * lodepng_get_bpp(&info.color) + 7) / 8;

	converted = (unsigned char*)lodepng_malloc(size);
	if(!converted && size) state->error = 83; /*alloc fail*/
	if(!state->error)
	{
	  state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h);
	}
	if(!state->error) preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
	lodepng_free(converted);
  }
  else preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);

  ucvector_init(&outv);
  while(!state->error) /*while only executed once, to break on error*/
  {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	/*write signature and chunks*/
	writeSignature(&outv);
	/*IHDR*/
	addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*unknown chunks between IHDR and PLTE*/
	if(info.unknown_chunks_data[0])
	{
	  state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	/*PLTE*/
	if(info.color.colortype == LCT_PALETTE)
	{
	  addChunk_PLTE(&outv, &info.color);
	}
	if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA))
	{
	  addChunk_PLTE(&outv, &info.color);
	}
	/*tRNS*/
	if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0)
	{
	  addChunk_tRNS(&outv, &info.color);
	}
	if((info.color.colortype == LCT_GREY || info.color.colortype == LCT_RGB) && info.color.key_defined)
	{
	  addChunk_tRNS(&outv, &info.color);
	}
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*bKGD (must come between PLTE and the IDAt chunks*/
	if(info.background_defined) addChunk_bKGD(&outv, &info);
	/*pHYs (must come before the IDAT chunks)*/
	if(info.phys_defined) addChunk_pHYs(&outv, &info);

	/*unknown chunks between PLTE and IDAT*/
	if(info.unknown_chunks_data[1])
	{
	  state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	/*IDAT (multiple IDAT chunks must be consecutive)*/
	state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
	if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
	/*tIME*/
	if(info.time_defined) addChunk_tIME(&outv, &info.time);
	/*tEXt and/or zTXt*/
	for(i = 0; i != info.text_num; ++i)
	{
	  if(strlen(info.text_keys[i]) > 79)
	  {
		state->error = 66; /*text chunk too large*/
		break;
	  }
	  if(strlen(info.text_keys[i]) < 1)
	  {
		state->error = 67; /*text chunk too small*/
		break;
	  }
	  if(state->encoder.text_compression)
	  {
		addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
	  }
	  else
	  {
		addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
	  }
	}
	/*LodePNG version id in text chunk*/
	if(state->encoder.add_id)
	{
	  unsigned alread_added_id_text = 0;
	  for(i = 0; i != info.text_num; ++i)
	  {
		if(!strcmp(info.text_keys[i], "LodePNG"))
		{
		  alread_added_id_text = 1;
		  break;
		}
	  }
	  if(alread_added_id_text == 0)
	  {
		addChunk_tEXt(&outv, "LodePNG", LODEPNG_VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
	  }
	}
	/*iTXt*/
	for(i = 0; i != info.itext_num; ++i)
	{
	  if(strlen(info.itext_keys[i]) > 79)
	  {
		state->error = 66; /*text chunk too large*/
		break;
	  }
	  if(strlen(info.itext_keys[i]) < 1)
	  {
		state->error = 67; /*text chunk too small*/
		break;
	  }
	  addChunk_iTXt(&outv, state->encoder.text_compression,
					info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
					&state->encoder.zlibsettings);
	}

	/*unknown chunks between IDAT and IEND*/
	if(info.unknown_chunks_data[2])
	{
	  state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
	  if(state->error) break;
	}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
	addChunk_IEND(&outv);

	break; /*this isn't really a while loop; no error happened so break out now!*/
  }

  lodepng_info_cleanup(&info);
  lodepng_free(data);
  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
  *outsize = outv.size;

  return state->error;
}

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
							   unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  state.info_png.color.colortype = colortype;
  state.info_png.color.bitdepth = bitdepth;
  lodepng_encode(out, outsize, image, w, h, &state);
  error = state.error;
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_encode_memory_std(unsigned char** out, size_t* outsize, const unsigned char* image,
							   unsigned w, unsigned h, unsigned colortype, unsigned bitdepth)
{
  return lodepng_encode_memory(out,outsize,image,w,h,(LodePNGColorType)colortype,bitdepth);
}

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
							 LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings)
{
  lodepng_compress_settings_init(&settings->zlibsettings);
  settings->filter_palette_zero = 1;
  settings->filter_strategy = LFS_MINSUM;
  settings->auto_convert = 1;
  settings->force_palette = 0;
  settings->predefined_filters = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
  settings->text_compression = 1;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code)
{
  switch(code)
  {
	case 0: return "no error, everything went ok";
	case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
	case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
	case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
	case 13: return "problem while processing dynamic deflate block";
	case 14: return "problem while processing dynamic deflate block";
	case 15: return "problem while processing dynamic deflate block";
	case 16: return "unexisting code while processing dynamic deflate block";
	case 17: return "end of out buffer memory reached while inflating";
	case 18: return "invalid distance code while inflating";
	case 19: return "end of out buffer memory reached while inflating";
	case 20: return "invalid deflate block BTYPE encountered while decoding";
	case 21: return "NLEN is not ones complement of LEN in a deflate block";
	 /*end of out buffer memory reached while inflating:
	 This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
	 all the pixels of the image, given the color depth and image dimensions. Something that doesn't
	 happen in a normal, well encoded, PNG image.*/
	case 22: return "end of out buffer memory reached while inflating";
	case 23: return "end of in buffer memory reached while inflating";
	case 24: return "invalid FCHECK in zlib header";
	case 25: return "invalid compression method in zlib header";
	case 26: return "FDICT encountered in zlib header while it's not used for PNG";
	case 27: return "PNG file is smaller than a PNG header";
	/*Checks the magic file header, the first 8 bytes of the PNG file*/
	case 28: return "incorrect PNG signature, it's no PNG or corrupted";
	case 29: return "first chunk is not the header chunk";
	case 30: return "chunk length too large, chunk broken off at end of file";
	case 31: return "illegal PNG color type or bpp";
	case 32: return "illegal PNG compression method";
	case 33: return "illegal PNG filter method";
	case 34: return "illegal PNG interlace method";
	case 35: return "chunk length of a chunk is too large or the chunk too small";
	case 36: return "illegal PNG filter type encountered";
	case 37: return "illegal bit depth for this color type given";
	case 38: return "the palette is too big"; /*more than 256 colors*/
	case 39: return "more palette alpha values given in tRNS chunk than there are colors in the palette";
	case 40: return "tRNS chunk has wrong size for greyscale image";
	case 41: return "tRNS chunk has wrong size for RGB image";
	case 42: return "tRNS chunk appeared while it was not allowed for this color type";
	case 43: return "bKGD chunk has wrong size for palette image";
	case 44: return "bKGD chunk has wrong size for greyscale image";
	case 45: return "bKGD chunk has wrong size for RGB image";
	/*the input data is empty, maybe a PNG file doesn't exist or is in the wrong path*/
	case 48: return "empty input or file doesn't exist";
	case 49: return "jumped past memory while generating dynamic huffman tree";
	case 50: return "jumped past memory while generating dynamic huffman tree";
	case 51: return "jumped past memory while inflating huffman block";
	case 52: return "jumped past memory while inflating";
	case 53: return "size of zlib data too small";
	case 54: return "repeat symbol in tree while there was no value symbol yet";
	/*jumped past tree while generating huffman tree, this could be when the
	tree will have more leaves than symbols after generating it out of the
	given lenghts. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
	case 55: return "jumped past tree while generating huffman tree";
	case 56: return "given output image colortype or bitdepth not supported for color conversion";
	case 57: return "invalid CRC encountered (checking CRC can be disabled)";
	case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
	case 59: return "requested color conversion not supported";
	case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
	case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
	/*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/
	case 62: return "conversion from color to greyscale not supported";
	case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk"; /*(2^31-1)*/
	/*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
	case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
	case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
	case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
	case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
	case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
	case 71: return "unexisting interlace mode given to encoder (must be 0 or 1)";
	case 72: return "while decoding, unexisting compression method encountering in zTXt or iTXt chunk (it must be 0)";
	case 73: return "invalid tIME chunk size";
	case 74: return "invalid pHYs chunk size";
	/*length could be wrong, or data chopped off*/
	case 75: return "no null termination char found while decoding text chunk";
	case 76: return "iTXt chunk too short to contain required bytes";
	case 77: return "integer overflow in buffer size";
	case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
	case 79: return "failed to open file for writing";
	case 80: return "tried creating a tree of 0 symbols";
	case 81: return "lazy matching at pos 0 is impossible";
	case 82: return "color conversion to palette requested while a color isn't in palette";
	case 83: return "memory allocation failed";
	case 84: return "given image too small to contain all pixels to be encoded";
	case 86: return "impossible offset in lz77 encoding (internal bug)";
	case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
	case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
	case 89: return "text chunk keyword too short or long: must have size 1-79";
	/*the windowsize in the LodePNGCompressSettings. Requiring POT(==> & instead of %) makes encoding 12% faster.*/
	case 90: return "windowsize must be a power of two";
	case 91: return "invalid decompressed idat size";
	case 92: return "too many pixels, not supported";
	case 93: return "zero width or height is invalid";
  }
  return "unknown error code";
}
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // C++ Wrapper                                                          // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_CPP
namespace lodepng
{

#ifdef LODEPNG_COMPILE_DISK
void load_file(std::vector<unsigned char>& buffer, const std::string& filename)
{
  std::ifstream file(filename.c_str(), std::ios::in|std::ios::binary|std::ios::ate);

  /*get filesize*/
  std::streamsize size = 0;
  if(file.seekg(0, std::ios::end).good()) size = file.tellg();
  if(file.seekg(0, std::ios::beg).good()) size -= file.tellg();

  /*read contents of the file into the vector*/
  buffer.resize(size_t(size));
  if(size > 0) file.read((char*)(&buffer[0]), size);
}

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
void save_file(const std::vector<unsigned char>& buffer, const std::string& filename)
{
  std::ofstream file(filename.c_str(), std::ios::out|std::ios::binary);
  file.write(buffer.empty() ? 0 : (char*)&buffer[0], std::streamsize(buffer.size()));
}
#endif //LODEPNG_COMPILE_DISK

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_DECODER
unsigned decompress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
					const LodePNGDecompressSettings& settings)
{
  unsigned char* buffer = 0;
  size_t buffersize = 0;
  unsigned error = zlib_decompress(&buffer, &buffersize, in, insize, &settings);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
					const LodePNGDecompressSettings& settings)
{
  return decompress(out, in.empty() ? 0 : &in[0], in.size(), settings);
}
#endif //LODEPNG_COMPILE_DECODER

#ifdef LODEPNG_COMPILE_ENCODER
unsigned compress(std::vector<unsigned char>& out, const unsigned char* in, size_t insize,
				  const LodePNGCompressSettings& settings)
{
  unsigned char* buffer = 0;
  size_t buffersize = 0;
  unsigned error = zlib_compress(&buffer, &buffersize, in, insize, &settings);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned compress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in,
				  const LodePNGCompressSettings& settings)
{
  return compress(out, in.empty() ? 0 : &in[0], in.size(), settings);
}
#endif //LODEPNG_COMPILE_ENCODER
#endif //LODEPNG_COMPILE_ZLIB

#ifdef LODEPNG_COMPILE_PNG

State::State()
{
  lodepng_state_init(this);
}

State::State(const State& other)
{
  lodepng_state_init(this);
  lodepng_state_copy(this, &other);
}

State::~State()
{
  lodepng_state_cleanup(this);
}

State& State::operator=(const State& other)
{
  lodepng_state_copy(this, &other);
  return *this;
}

#ifdef LODEPNG_COMPILE_DECODER

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const unsigned char* in,
				size_t insize, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  unsigned error = lodepng_decode_memory(&buffer, &w, &h, in, insize, colortype, bitdepth);
  if(buffer && !error)
  {
	State state;
	state.info_raw.colortype = colortype;
	state.info_raw.bitdepth = bitdepth;
	size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				const std::vector<unsigned char>& in, LodePNGColorType colortype, unsigned bitdepth)
{
  return decode(out, w, h, in.empty() ? 0 : &in[0], (unsigned)in.size(), colortype, bitdepth);
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const unsigned char* in, size_t insize)
{
  unsigned char* buffer = NULL;
  unsigned error = lodepng_decode(&buffer, &w, &h, &state, in, insize);
  if(buffer && !error)
  {
	size_t buffersize = lodepng_get_raw_size(w, h, &state.info_raw);
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
  }
  lodepng_free(buffer);
  return error;
}

unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h,
				State& state,
				const std::vector<unsigned char>& in)
{
  return decode(out, w, h, state, in.empty() ? 0 : &in[0], in.size());
}

#ifdef LODEPNG_COMPILE_DISK
unsigned decode(std::vector<unsigned char>& out, unsigned& w, unsigned& h, const std::string& filename,
				LodePNGColorType colortype, unsigned bitdepth)
{
  std::vector<unsigned char> buffer;
  load_file(buffer, filename);
  return decode(out, w, h, buffer, colortype, bitdepth);
}
#endif //LODEPNG_COMPILE_DECODER
#endif //LODEPNG_COMPILE_DISK

#ifdef LODEPNG_COMPILE_ENCODER
unsigned encode(std::vector<unsigned char>& out, const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, in, w, h, colortype, bitdepth);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
  return encode(out, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);
}

unsigned encode(std::vector<unsigned char>& out,
				const unsigned char* in, unsigned w, unsigned h,
				State& state)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode(&buffer, &buffersize, in, w, h, &state);
  if(buffer)
  {
	out.insert(out.end(), &buffer[0], &buffer[buffersize]);
	lodepng_free(buffer);
  }
  return error;
}

unsigned encode(std::vector<unsigned char>& out,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				State& state)
{
  if(lodepng_get_raw_size(w, h, &state.info_raw) > in.size()) return 84;
  return encode(out, in.empty() ? 0 : &in[0], w, h, state);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned encode(const std::string& filename,
				const unsigned char* in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  std::vector<unsigned char> buffer;
  unsigned error = encode(buffer, in, w, h, colortype, bitdepth);
  if(!error) save_file(buffer, filename);
  return error;
}

unsigned encode(const std::string& filename,
				const std::vector<unsigned char>& in, unsigned w, unsigned h,
				LodePNGColorType colortype, unsigned bitdepth)
{
  if(lodepng_get_raw_size_lct(w, h, colortype, bitdepth) > in.size()) return 84;
  return encode(filename, in.empty() ? 0 : &in[0], w, h, colortype, bitdepth);
}
#endif //LODEPNG_COMPILE_DISK
#endif //LODEPNG_COMPILE_ENCODER
#endif //LODEPNG_COMPILE_PNG
} //namespace lodepng
#endif /*LODEPNG_COMPILE_CPP*/


//#line 1 "crn2dds.hpp"
// crn2dds, based on code by SpartanJ and Evan Parker.
// - rlyeh, public domain

#ifndef CRN2DDS_INCLUDE
#define CRN2DDS_INCLUDE
#include <string>

// returns a pure dxt stream (can be uploaded to a GPU directly)
bool crn2dxt( std::string &out, const void *src, size_t len, unsigned reserved = 0 );
bool crn2dxt( std::string &out, const std::string &in, unsigned reserved = 0 );

// returns a cooked dds header + pure dxt stream (can be saved or processed somewhere else)
bool crn2dds( std::string &out, const void *src, size_t len );
bool crn2dds( std::string &out, const std::string &in );

#endif

//#undef DDS_header
#define DDS_header DDS_header3

//#line 1 "crn2dds.cpp"
// crn2dds, based on code by SpartanJ and Evan Parker.
// - rlyeh, public domain

#ifdef _WIN32
#ifndef WIN32
#define WIN32
#endif
#endif

#include <stddef.h> // For NULL, size_t
#include <cstring> // for malloc etc

#ifndef USE_MALLOC_USABLE_SIZE
// Define HAVE_MALLOC_USABLE_SIZE to 1 to indicate that the current
// system has malloc_usable_size(). Which takes the address of a malloc-ed
// pointer, and return the size of the underlying storage block.
// This is useful to optimize heap memory usage.
// Including at least one C library header is required to define symbols
// like __GLIBC__. Choose carefully because some headers like <stddef.h>
// are actually provided by the compiler, not the C library and do not
// define the macros we need.
#include <stdint.h>
#if defined(__GLIBC__)
#  include <malloc.h>
#  define USE_MALLOC_USABLE_SIZE  1
#elif defined(__APPLE__) || defined(__FreeBSD__)
#  include <malloc/malloc.h>
#  define malloc_usable_size  malloc_size
#  define USE_MALLOC_USABLE_SIZE  1
#elif defined(__ANDROID_API__)
#  include <malloc.h>
extern "C" size_t dlmalloc_usable_size(void*);
#  define malloc_usable_size dlmalloc_usable_size
#  define USE_MALLOC_USABLE_SIZE  1
#elif defined(_WIN32)
#  include <malloc.h>
#  define malloc_usable_size _msize
#  define USE_MALLOC_USABLE_SIZE  1
#else
#  define USE_MALLOC_USABLE_SIZE  0
#endif
#endif // USE_MALLOC_USABLE_SIZE


//#line 1 "crn_decomp.h"
// File: crn_decomp.h - Fast CRN->DXTc texture transcoder header file library
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
// See Copyright Notice and license at the end of this file.
//
// This single header file contains *all* of the code necessary to unpack .CRN files to raw DXTn bits.
// It does NOT depend on the crn compression library.
//
// Note: This is a single file, stand-alone C++ library which is controlled by the use of two macros:
//   If CRND_INCLUDE_CRND_H is NOT defined, the header is included.
//   If CRND_HEADER_FILE_ONLY is NOT defined, the implementation is included.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
//
#ifndef CRND_INCLUDE_CRND_H
#define CRND_INCLUDE_CRND_H

// Include crnlib.h (only to bring in some basic CRN-related types).
#include <stdint.h>

//#line 1 "crnlib.h"
// File: crnlib.h - Advanced DXTn texture compression library.
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
// See copyright notice and license at the end of this file.
//
// This header file contains the public crnlib declarations for DXTn,
// clustered DXTn, and CRN compression/decompression.
//
// Note: This library does NOT need to be linked into your game executable if
// all you want to do is transcode .CRN files to raw DXTn bits at run-time.
// The crn_decomp.h header file library contains all the code necessary for
// decompression.
//
// Important: If compiling with gcc, be sure strict aliasing is disabled: -fno-strict-aliasing
#ifndef CRNLIB_H
#define CRNLIB_H

#ifdef _MSC_VER
#pragma warning (disable: 4127) //  conditional expression is constant
#endif

#define CRNLIB_VERSION 104

#define CRNLIB_SUPPORT_ATI_COMPRESS 0
#define CRNLIB_SUPPORT_SQUISH 0

typedef unsigned char   crn_uint8;
typedef unsigned short  crn_uint16;
typedef unsigned int    crn_uint32;
typedef signed char     crn_int8;
typedef signed short    crn_int16;
typedef signed int      crn_int32;
typedef unsigned int    crn_bool;

// crnlib can compress to these file types.
enum crn_file_type
{
   // .CRN
   cCRNFileTypeCRN = 0,

   // .DDS using regular DXT or clustered DXT
   cCRNFileTypeDDS,

   cCRNFileTypeForceDWORD = 0xFFFFFFFF
};

// Supported compressed pixel formats.
// Basically all the standard DX9 formats, with some swizzled DXT5 formats
// (most of them supported by ATI's Compressonator), along with some ATI/X360 GPU specific formats.
enum crn_format
{
   cCRNFmtInvalid = -1,

   cCRNFmtDXT1 = 0,

   cCRNFmtFirstValid = cCRNFmtDXT1,

   // cCRNFmtDXT3 is not currently supported when writing to CRN - only DDS.
   cCRNFmtDXT3,

   cCRNFmtDXT5,

   // Various DXT5 derivatives
   cCRNFmtDXT5_CCxY,    // Luma-chroma
   cCRNFmtDXT5_xGxR,    // Swizzled 2-component
   cCRNFmtDXT5_xGBR,    // Swizzled 3-component
   cCRNFmtDXT5_AGBR,    // Swizzled 4-component

   // ATI 3DC and X360 DXN
   cCRNFmtDXN_XY,
   cCRNFmtDXN_YX,

   // DXT5 alpha blocks only
   cCRNFmtDXT5A,

   cCRNFmtETC1,

   cCRNFmtTotal,

   cCRNFmtForceDWORD = 0xFFFFFFFF
};

// Various library/file format limits.
enum crn_limits
{
   // Max. mipmap level resolution on any axis.
   cCRNMaxLevelResolution     = 4096,

   cCRNMinPaletteSize         = 8,
   cCRNMaxPaletteSize         = 8192,

   cCRNMaxFaces               = 6,
   cCRNMaxLevels              = 16,

   cCRNMaxHelperThreads       = 16,

   cCRNMinQualityLevel        = 0,
   cCRNMaxQualityLevel        = 255
};

// CRN/DDS compression flags.
// See the m_flags member in the crn_comp_params struct, below.
enum crn_comp_flags
{
   // Enables perceptual colorspace distance metrics if set.
   // Important: Be sure to disable this when compressing non-sRGB colorspace images, like normal maps!
   // Default: Set
   cCRNCompFlagPerceptual = 1,

   // Enables (up to) 8x8 macroblock usage if set. If disabled, only 4x4 blocks are allowed.
   // Compression ratio will be lower when disabled, but may cut down on blocky artifacts because the process used to determine
   // where large macroblocks can be used without artifacts isn't perfect.
   // Default: Set.
   cCRNCompFlagHierarchical = 2,

   // cCRNCompFlagQuick disables several output file optimizations - intended for things like quicker previews.
   // Default: Not set.
   cCRNCompFlagQuick = 4,

   // DXT1: OK to use DXT1 alpha blocks for better quality or DXT1A transparency.
   // DXT5: OK to use both DXT5 block types.
   // Currently only used when writing to .DDS files, as .CRN uses only a subset of the possible DXTn block types.
   // Default: Set.
   cCRNCompFlagUseBothBlockTypes = 8,

   // OK to use DXT1A transparent indices to encode black (assumes pixel shader ignores fetched alpha).
   // Currently only used when writing to .DDS files, .CRN never uses alpha blocks.
   // Default: Not set.
   cCRNCompFlagUseTransparentIndicesForBlack = 16,

   // Disables endpoint caching, for more deterministic output.
   // Currently only used when writing to .DDS files.
   // Default: Not set.
   cCRNCompFlagDisableEndpointCaching = 32,

   // If enabled, use the cCRNColorEndpointPaletteSize, etc. params to control the CRN palette sizes. Only useful when writing to .CRN files.
   // Default: Not set.
   cCRNCompFlagManualPaletteSizes = 64,

   // If enabled, DXT1A alpha blocks are used to encode single bit transparency.
   // Default: Not set.
   cCRNCompFlagDXT1AForTransparency = 128,

   // If enabled, the DXT1 compressor's color distance metric assumes the pixel shader will be converting the fetched RGB results to luma (Y part of YCbCr).
   // This increases quality when compressing grayscale images, because the compressor can spread the luma error amoung all three channels (i.e. it can generate blocks
   // with some chroma present if doing so will ultimately lead to lower luma error).
   // Only enable on grayscale source images.
   // Default: Not set.
   cCRNCompFlagGrayscaleSampling = 256,

   // If enabled, debug information will be output during compression.
   // Default: Not set.
   cCRNCompFlagDebugging = 0x80000000,

   cCRNCompFlagForceDWORD = 0xFFFFFFFF
};

// Controls DXTn quality vs. speed control - only used when compressing to .DDS.
enum crn_dxt_quality
{
   cCRNDXTQualitySuperFast,
   cCRNDXTQualityFast,
   cCRNDXTQualityNormal,
   cCRNDXTQualityBetter,
   cCRNDXTQualityUber,

   cCRNDXTQualityTotal,

   cCRNDXTQualityForceDWORD = 0xFFFFFFFF
};

// Which DXTn compressor to use when compressing to plain (non-clustered) .DDS.
enum crn_dxt_compressor_type
{
   cCRNDXTCompressorCRN,      // Use crnlib's ETC1 or DXTc block compressor (default, highest quality, comparable or better than ati_compress or squish, and crnlib's ETC1 is a lot fasterw with similiar quality to Erricson's)
   cCRNDXTCompressorCRNF,     // Use crnlib's "fast" DXTc block compressor
   cCRNDXTCompressorRYG,      // Use RYG's DXTc block compressor (low quality, but very fast)

#if CRNLIB_SUPPORT_ATI_COMPRESS
   cCRNDXTCompressorATI,
#endif

#if CRNLIB_SUPPORT_SQUISH
   cCRNDXTCompressorSquish,
#endif

   cCRNTotalDXTCompressors,

   cCRNDXTCompressorForceDWORD = 0xFFFFFFFF
};

// Progress callback function.
// Processing will stop prematurely (and fail) if the callback returns false.
// phase_index, total_phases - high level progress
// subphase_index, total_subphases - progress within current phase
typedef crn_bool (*crn_progress_callback_func)(crn_uint32 phase_index, crn_uint32 total_phases, crn_uint32 subphase_index, crn_uint32 total_subphases, void* pUser_data_ptr);

// CRN/DDS compression parameters struct.
struct crn_comp_params
{
   inline crn_comp_params() { clear(); }

   // Clear struct to default parameters.
   inline void clear()
   {
	  m_size_of_obj = sizeof(*this);
	  m_file_type = cCRNFileTypeCRN;
	  m_faces = 1;
	  m_width = 0;
	  m_height = 0;
	  m_levels = 1;
	  m_format = cCRNFmtDXT1;
	  m_flags = cCRNCompFlagPerceptual | cCRNCompFlagHierarchical | cCRNCompFlagUseBothBlockTypes;

	  for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
		 for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
			m_pImages[f][l] = NULL;

	  m_target_bitrate = 0.0f;
	  m_quality_level = cCRNMaxQualityLevel;
	  m_dxt1a_alpha_threshold = 128;
	  m_dxt_quality = cCRNDXTQualityUber;
	  m_dxt_compressor_type = cCRNDXTCompressorCRN;
	  m_alpha_component = 3;

	  m_crn_adaptive_tile_color_psnr_derating = 2.0f;
	  m_crn_adaptive_tile_alpha_psnr_derating = 2.0f;
	  m_crn_color_endpoint_palette_size = 0;
	  m_crn_color_selector_palette_size = 0;
	  m_crn_alpha_endpoint_palette_size = 0;
	  m_crn_alpha_selector_palette_size = 0;

	  m_num_helper_threads = 0;
	  m_userdata0 = 0;
	  m_userdata1 = 0;
	  m_pProgress_func = NULL;
	  m_pProgress_func_data = NULL;
   }

   inline bool operator== (const crn_comp_params& rhs) const
   {
#define CRNLIB_COMP(x) do { if ((x) != (rhs.x)) return false; } while(0)
	  CRNLIB_COMP(m_size_of_obj);
	  CRNLIB_COMP(m_file_type);
	  CRNLIB_COMP(m_faces);
	  CRNLIB_COMP(m_width);
	  CRNLIB_COMP(m_height);
	  CRNLIB_COMP(m_levels);
	  CRNLIB_COMP(m_format);
	  CRNLIB_COMP(m_flags);
	  CRNLIB_COMP(m_target_bitrate);
	  CRNLIB_COMP(m_quality_level);
	  CRNLIB_COMP(m_dxt1a_alpha_threshold);
	  CRNLIB_COMP(m_dxt_quality);
	  CRNLIB_COMP(m_dxt_compressor_type);
	  CRNLIB_COMP(m_alpha_component);
	  CRNLIB_COMP(m_crn_adaptive_tile_color_psnr_derating);
	  CRNLIB_COMP(m_crn_adaptive_tile_alpha_psnr_derating);
	  CRNLIB_COMP(m_crn_color_endpoint_palette_size);
	  CRNLIB_COMP(m_crn_color_selector_palette_size);
	  CRNLIB_COMP(m_crn_alpha_endpoint_palette_size);
	  CRNLIB_COMP(m_crn_alpha_selector_palette_size);
	  CRNLIB_COMP(m_num_helper_threads);
	  CRNLIB_COMP(m_userdata0);
	  CRNLIB_COMP(m_userdata1);
	  CRNLIB_COMP(m_pProgress_func);
	  CRNLIB_COMP(m_pProgress_func_data);

	  for (crn_uint32 f = 0; f < cCRNMaxFaces; f++)
		 for (crn_uint32 l = 0; l < cCRNMaxLevels; l++)
			CRNLIB_COMP(m_pImages[f][l]);

#undef CRNLIB_COMP
	  return true;
   }

   // Returns true if the input parameters are reasonable.
   inline bool check() const
   {
	  if ( (m_file_type > cCRNFileTypeDDS) ||
		 (((int)m_quality_level < (int)cCRNMinQualityLevel) || ((int)m_quality_level > (int)cCRNMaxQualityLevel)) ||
		 (m_dxt1a_alpha_threshold > 255) ||
		 ((m_faces != 1) && (m_faces != 6)) ||
		 ((m_width < 1) || (m_width > cCRNMaxLevelResolution)) ||
		 ((m_height < 1) || (m_height > cCRNMaxLevelResolution)) ||
		 ((m_levels < 1) || (m_levels > cCRNMaxLevels)) ||
		 ((m_format < cCRNFmtDXT1) || (m_format >= cCRNFmtTotal)) ||
		 ((m_crn_color_endpoint_palette_size) && ((m_crn_color_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_color_endpoint_palette_size > cCRNMaxPaletteSize))) ||
		 ((m_crn_color_selector_palette_size) && ((m_crn_color_selector_palette_size < cCRNMinPaletteSize) || (m_crn_color_selector_palette_size > cCRNMaxPaletteSize))) ||
		 ((m_crn_alpha_endpoint_palette_size) && ((m_crn_alpha_endpoint_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_endpoint_palette_size > cCRNMaxPaletteSize))) ||
		 ((m_crn_alpha_selector_palette_size) && ((m_crn_alpha_selector_palette_size < cCRNMinPaletteSize) || (m_crn_alpha_selector_palette_size > cCRNMaxPaletteSize))) ||
		 (m_alpha_component > 3) ||
		 (m_num_helper_threads > cCRNMaxHelperThreads) ||
		 (m_dxt_quality > cCRNDXTQualityUber) ||
		 (m_dxt_compressor_type >= cCRNTotalDXTCompressors) )
	  {
		 return false;
	  }
	  return true;
   }

   // Helper to set/get flags from m_flags member.
   inline bool get_flag(crn_comp_flags flag) const { return (m_flags & flag) != 0; }
   inline void set_flag(crn_comp_flags flag, bool val) { m_flags &= ~flag; if (val) m_flags |= flag; }

   crn_uint32                 m_size_of_obj;

   crn_file_type              m_file_type;               // Output file type: cCRNFileTypeCRN or cCRNFileTypeDDS.

   crn_uint32                 m_faces;                   // 1 (2D map) or 6 (cubemap)
   crn_uint32                 m_width;                   // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
   crn_uint32                 m_height;                  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK
   crn_uint32                 m_levels;                  // [1,cCRNMaxLevelResolution], non-power of 2 OK, non-square OK

   crn_format                 m_format;                  // Output pixel format.

   crn_uint32                 m_flags;                   // see crn_comp_flags enum

   // Array of pointers to 32bpp input images.
   const crn_uint32*          m_pImages[cCRNMaxFaces][cCRNMaxLevels];

   // Target bitrate - if non-zero, the compressor will use an interpolative search to find the
   // highest quality level that is <= the target bitrate. If it fails to find a bitrate high enough, it'll
   // try disabling adaptive block sizes (cCRNCompFlagHierarchical flag) and redo the search. This process can be pretty slow.
   float                      m_target_bitrate;

   // Desired quality level.
   // Currently, CRN and DDS quality levels are not compatible with eachother from an image quality standpoint.
   crn_uint32                 m_quality_level;           // [cCRNMinQualityLevel, cCRNMaxQualityLevel]

   // DXTn compression parameters.
   crn_uint32                 m_dxt1a_alpha_threshold;
   crn_dxt_quality            m_dxt_quality;
   crn_dxt_compressor_type    m_dxt_compressor_type;

   // Alpha channel's component. Defaults to 3.
   crn_uint32                 m_alpha_component;

   // Various low-level CRN specific parameters.
   float                      m_crn_adaptive_tile_color_psnr_derating;
   float                      m_crn_adaptive_tile_alpha_psnr_derating;

   crn_uint32                 m_crn_color_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
   crn_uint32                 m_crn_color_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

   crn_uint32                 m_crn_alpha_endpoint_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]
   crn_uint32                 m_crn_alpha_selector_palette_size;  // [cCRNMinPaletteSize,cCRNMaxPaletteSize]

   // Number of helper threads to create during compression. 0=no threading.
   crn_uint32                 m_num_helper_threads;

   // CRN userdata0 and userdata1 members, which are written directly to the header of the output file.
   crn_uint32                 m_userdata0;
   crn_uint32                 m_userdata1;

   // User provided progress callback.
   crn_progress_callback_func m_pProgress_func;
   void*                      m_pProgress_func_data;
};

// Mipmap generator's mode.
enum crn_mip_mode
{
   cCRNMipModeUseSourceOrGenerateMips,       // Use source texture's mipmaps if it has any, otherwise generate new mipmaps
   cCRNMipModeUseSourceMips,                 // Use source texture's mipmaps if it has any, otherwise the output has no mipmaps
   cCRNMipModeGenerateMips,                  // Always generate new mipmaps
   cCRNMipModeNoMips,                        // Output texture has no mipmaps

   cCRNMipModeTotal,

   cCRNModeForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_mode_desc(crn_mip_mode m);
const char* crn_get_mip_mode_name(crn_mip_mode m);

// Mipmap generator's filter kernel.
enum crn_mip_filter
{
   cCRNMipFilterBox,
   cCRNMipFilterTent,
   cCRNMipFilterLanczos4,
   cCRNMipFilterMitchell,
   cCRNMipFilterKaiser,                      // Kaiser=default mipmap filter

   cCRNMipFilterTotal,

   cCRNMipFilterForceDWORD = 0xFFFFFFFF
};

const char* crn_get_mip_filter_name(crn_mip_filter f);

// Mipmap generator's scale mode.
enum crn_scale_mode
{
   cCRNSMDisabled,
   cCRNSMAbsolute,
   cCRNSMRelative,
   cCRNSMLowerPow2,
   cCRNSMNearestPow2,
   cCRNSMNextPow2,

   cCRNSMTotal,

   cCRNSMForceDWORD = 0xFFFFFFFF
};

const char* crn_get_scale_mode_desc(crn_scale_mode sm);

// Mipmap generator parameters.
struct crn_mipmap_params
{
   inline crn_mipmap_params() { clear(); }

   inline void clear()
   {
	  m_size_of_obj = sizeof(*this);
	  m_mode = cCRNMipModeUseSourceOrGenerateMips;
	  m_filter = cCRNMipFilterKaiser;
	  m_gamma_filtering = true;
	  m_gamma = 2.2f;
	  // Default "blurriness" factor of .9 actually sharpens the output a little.
	  m_blurriness = .9f;
	  m_renormalize = false;
	  m_tiled = false;
	  m_max_levels = cCRNMaxLevels;
	  m_min_mip_size = 1;

	  m_scale_mode = cCRNSMDisabled;
	  m_scale_x = 1.0f;
	  m_scale_y = 1.0f;

	  m_window_left = 0;
	  m_window_top = 0;
	  m_window_right = 0;
	  m_window_bottom = 0;

	  m_clamp_scale = false;
	  m_clamp_width = 0;
	  m_clamp_height = 0;
   }

   inline bool check() const { return true; }

   inline bool operator== (const crn_mipmap_params& rhs) const
   {
#define CRNLIB_COMP(x) do { if ((x) != (rhs.x)) return false; } while(0)
	  CRNLIB_COMP(m_size_of_obj);
	  CRNLIB_COMP(m_mode);
	  CRNLIB_COMP(m_filter);
	  CRNLIB_COMP(m_gamma_filtering);
	  CRNLIB_COMP(m_gamma);
	  CRNLIB_COMP(m_blurriness);
	  CRNLIB_COMP(m_renormalize);
	  CRNLIB_COMP(m_tiled);
	  CRNLIB_COMP(m_max_levels);
	  CRNLIB_COMP(m_min_mip_size);
	  CRNLIB_COMP(m_scale_mode);
	  CRNLIB_COMP(m_scale_x);
	  CRNLIB_COMP(m_scale_y);
	  CRNLIB_COMP(m_window_left);
	  CRNLIB_COMP(m_window_top);
	  CRNLIB_COMP(m_window_right);
	  CRNLIB_COMP(m_window_bottom);
	  CRNLIB_COMP(m_clamp_scale);
	  CRNLIB_COMP(m_clamp_width);
	  CRNLIB_COMP(m_clamp_height);
	  return true;
#undef CRNLIB_COMP
   }
   crn_uint32     m_size_of_obj;

   crn_mip_mode   m_mode;
   crn_mip_filter m_filter;

   crn_bool       m_gamma_filtering;
   float          m_gamma;

   float          m_blurriness;

   crn_uint32     m_max_levels;
   crn_uint32     m_min_mip_size;

   crn_bool       m_renormalize;
   crn_bool       m_tiled;

   crn_scale_mode m_scale_mode;
   float          m_scale_x;
   float          m_scale_y;

   crn_uint32     m_window_left;
   crn_uint32     m_window_top;
   crn_uint32     m_window_right;
   crn_uint32     m_window_bottom;

   crn_bool       m_clamp_scale;
   crn_uint32     m_clamp_width;
   crn_uint32     m_clamp_height;
};

// -------- High-level helper function definitions for CDN/DDS compression.

#ifndef CRNLIB_MIN_ALLOC_ALIGNMENT
#define CRNLIB_MIN_ALLOC_ALIGNMENT sizeof(size_t) * 2
#endif

// Function to set an optional user provided memory allocation/reallocation/msize routines.
// By default, crnlib just uses malloc(), free(), etc. for all allocations.
typedef void*  (*crn_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);
typedef size_t (*crn_msize_func)(void* p, void* pUser_data);
void crn_set_memory_callbacks(crn_realloc_func pRealloc, crn_msize_func pMSize, void* pUser_data);

// Frees memory blocks allocated by crn_compress(), crn_decompress_crn_to_dds(), or crn_decompress_dds_to_images().
void crn_free_block(void *pBlock);

// Compresses a 32-bit/pixel texture to either: a regular DX9 DDS file, a "clustered" (or reduced entropy) DX9 DDS file, or a CRN file in memory.
// Input parameters:
//  comp_params is the compression parameters struct, defined above.
//  compressed_size will be set to the size of the returned memory block containing the output file.
//  The returned block must be freed by calling crn_free_block().
//  *pActual_quality_level will be set to the actual quality level used to compress the image. May be NULL.
//  *pActual_bitrate will be set to the output file's effective bitrate, possibly taking into account LZMA compression. May be NULL.
// Return value:
//  The compressed file data, or NULL on failure.
//  compressed_size will be set to the size of the returned memory buffer.
// Notes:
//  A "regular" DDS file is compressed using normal DXTn compression at the specified DXT quality level.
//  A "clustered" DDS file is compressed using clustered DXTn compression to either the target bitrate or the specified integer quality factor.
//  The output file is a standard DX9 format DDS file, except the compressor assumes you will be later losslessly compressing the DDS output file using the LZMA algorithm.
//  A texture is defined as an array of 1 or 6 "faces" (6 faces=cubemap), where each "face" consists of between [1,cCRNMaxLevels] mipmap levels.
//  Mipmap levels are simple 32-bit 2D images with a pitch of width*sizeof(uint32), arranged in the usual raster order (top scanline first).
//  The image pixels may be grayscale (YYYX bytes in memory), grayscale/alpha (YYYA in memory), 24-bit (RGBX in memory), or 32-bit (RGBA) colors (where "X"=don't care).
//  RGB color data is generally assumed to be in the sRGB colorspace. If not, be sure to clear the "cCRNCompFlagPerceptual" in the crn_comp_params struct!
void *crn_compress(const crn_comp_params &comp_params, crn_uint32 &compressed_size, crn_uint32 *pActual_quality_level = NULL, float *pActual_bitrate = NULL);

// Like the above function, except this function can also do things like generate mipmaps, and resize or crop the input texture before compression.
// The actual operations performed are controlled by the crn_mipmap_params struct members.
// Be sure to set the "m_gamma_filtering" member of crn_mipmap_params to false if the input texture is not sRGB.
void *crn_compress(const crn_comp_params &comp_params, const crn_mipmap_params &mip_params, crn_uint32 &compressed_size, crn_uint32 *pActual_quality_level = NULL, float *pActual_bitrate = NULL);

// Transcodes an entire CRN file to DDS using the crn_decomp.h header file library to do most of the heavy lifting.
// The output DDS file's format is guaranteed to be one of the DXTn formats in the crn_format enum.
// This is a fast operation, because the CRN format is explicitly designed to be efficiently transcodable to DXTn.
// For more control over decompression, see the lower-level helper functions in crn_decomp.h, which do not depend at all on crnlib.
void *crn_decompress_crn_to_dds(const void *pCRN_file_data, crn_uint32 &file_size);

// Decompresses an entire DDS file in any supported format to uncompressed 32-bit/pixel image(s).
// See the crnlib::pixel_format enum in inc/dds_defs.h for a list of the supported DDS formats.
// You are responsible for freeing each image block, either by calling crn_free_all_images() or manually calling crn_free_block() on each image pointer.
struct crn_texture_desc
{
   crn_uint32 m_faces;
   crn_uint32 m_width;
   crn_uint32 m_height;
   crn_uint32 m_levels;
   crn_uint32 m_fmt_fourcc; // Same as crnlib::pixel_format
};
bool crn_decompress_dds_to_images(const void *pDDS_file_data, crn_uint32 dds_file_size, crn_uint32 **ppImages, crn_texture_desc &tex_desc);

// Frees all images allocated by crn_decompress_dds_to_images().
void crn_free_all_images(crn_uint32 **ppImages, const crn_texture_desc &desc);

// -------- crn_format related helpers functions.

// Returns the FOURCC format equivalent to the specified crn_format.
crn_uint32 crn_get_format_fourcc(crn_format fmt);

// Returns the crn_format's bits per texel.
crn_uint32 crn_get_format_bits_per_texel(crn_format fmt);

// Returns the crn_format's number of bytes per block.
crn_uint32 crn_get_bytes_per_dxt_block(crn_format fmt);

// Returns the non-swizzled, basic DXTn version of the specified crn_format.
// This is the format you would supply D3D or OpenGL.
crn_format crn_get_fundamental_dxt_format(crn_format fmt);

// -------- String helpers.

// Converts a crn_file_type to a string.
const char* crn_get_file_type_ext(crn_file_type file_type);

// Converts a crn_format to a string.
const char* crn_get_format_string(crn_format fmt);

// Converts a crn_dxt_quality to a string.
const char* crn_get_dxt_quality_string(crn_dxt_quality q);

// -------- Low-level DXTn 4x4 block compressor API

// crnlib's DXTn endpoint optimizer actually supports any number of source pixels (i.e. from 1 to thousands, not just 16),
// but for simplicity this API only supports 4x4 texel blocks.
typedef void *crn_block_compressor_context_t;

// Create a DXTn block compressor.
// This function only supports the basic/nonswizzled "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// Avoid calling this multiple times if you intend on compressing many blocks, because it allocates some memory.
crn_block_compressor_context_t crn_create_block_compressor(const crn_comp_params &params);

// Compresses a block of 16 pixels to the destination DXTn block.
// pDst_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pPixels should be an array of 16 crn_uint32's. Each crn_uint32 must be r,g,b,a (r is always first) in memory.
void crn_compress_block(crn_block_compressor_context_t pContext, const crn_uint32 *pPixels, void *pDst_block);

// Frees a DXTn block compressor.
void crn_free_block_compressor(crn_block_compressor_context_t pContext);

// Unpacks a compressed block to pDst_pixels.
// pSrc_block should be 8 (for DXT1/DXT5A) or 16 bytes (all the others).
// pDst_pixel should be an array of 16 crn_uint32's. Each uint32 will be r,g,b,a (r is always first) in memory.
// crn_fmt should be one of the "fundamental" formats: DXT1, DXT3, DXT5, DXT5A, DXN_XY and DXN_YX.
// The various swizzled DXT5 formats (such as cCRNFmtDXT5_xGBR, etc.) will be unpacked as if they where plain DXT5.
// Returns false if the crn_fmt is invalid.
bool crn_decompress_block(const void *pSrc_block, crn_uint32 *pDst_pixels, crn_format crn_fmt);

#endif // CRNLIB_H

//------------------------------------------------------------------------------
//
// crnlib uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------


// changelog:
// v1.05 - bugfixed errors and warnings on (g++/mingw) (@r-lyeh)
//         using stdint.h types now (@r-lyeh)
// v1.04 - svn checkout
#define CRND_LIB_VERSION 105
#define CRND_VERSION_STRING "01.05"

#ifdef _DEBUG
#define CRND_BUILD_DEBUG
#else
#define CRND_BUILD_RELEASE
#endif

// CRN decompression API
namespace crnd
{
   typedef uint8_t            uint8;
   typedef int8_t             int8;
   typedef uint16_t           uint16;
   typedef int16_t            int16;
   typedef uint32_t           uint32;
   typedef int32_t            int32;
   typedef unsigned int       uint;
   typedef uint64_t           uint64;
   typedef int64_t            int64;

   // The crnd library assumes all allocation blocks have at least CRND_MIN_ALLOC_ALIGNMENT alignment.
   const uint32 CRND_MIN_ALLOC_ALIGNMENT = sizeof(uint32) * 2U;

   // realloc callback:
   // Used to allocate, resize, or free memory blocks.
   // If p is NULL, the realloc function attempts to allocate a block of at least size bytes. Returns NULL on out of memory.
   // *pActual_size must be set to the actual size of the allocated block, which must be greater than or equal to the requested size.
   // If p is not NULL, and size is 0, the realloc function frees the specified block, and always returns NULL. *pActual_size should be set to 0.
   // If p is not NULL, and size is non-zero, the realloc function attempts to resize the specified block:
   //    If movable is false, the realloc function attempts to shrink or expand the block in-place. NULL is returned if the block cannot be resized in place, or if the
   //    underlying heap implementation doesn't support in-place resizing. Otherwise, the pointer to the original block is returned.
   //    If movable is true, it is permissible to move the block's contents if it cannot be resized in place. NULL is returned if the block cannot be resized in place, and there
   //    is not enough memory to relocate the block.
   //    In all cases, *pActual_size must be set to the actual size of the allocated block, whether it was successfully resized or not.
   typedef void*  (*crnd_realloc_func)(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data);

   // msize callback: Returns the size of the memory block in bytes, or 0 if the pointer or block is invalid.
   typedef size_t (*crnd_msize_func)(void* p, void* pUser_data);

   // crnd_set_memory_callbacks() - Use to override the crnd library's memory allocation functions.
   // If any input parameters are NULL, the memory callback functions are reset to the default functions.
   // The default functions call malloc(), free(),  _msize(), _expand(), etc.
   void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data);

   struct crn_file_info
   {
	  inline crn_file_info() : m_struct_size(sizeof(crn_file_info)) { }

	  uint32 m_struct_size;
	  uint32 m_actual_data_size;
	  uint32 m_header_size;
	  uint32 m_total_palette_size;
	  uint32 m_tables_size;
	  uint32 m_levels;
	  uint32 m_level_compressed_size[cCRNMaxLevels];
	  uint32 m_color_endpoint_palette_entries;
	  uint32 m_color_selector_palette_entries;
	  uint32 m_alpha_endpoint_palette_entries;
	  uint32 m_alpha_selector_palette_entries;
   };

   struct crn_texture_info
   {
	  inline crn_texture_info() : m_struct_size(sizeof(crn_texture_info)) { }

	  uint32      m_struct_size;
	  uint32      m_width;
	  uint32      m_height;
	  uint32      m_levels;
	  uint32      m_faces;
	  uint32      m_bytes_per_block;
	  uint32      m_userdata0;
	  uint32      m_userdata1;
	  crn_format  m_format;
   };

   struct crn_level_info
   {
	  inline crn_level_info() : m_struct_size(sizeof(crn_level_info)) { }

	  uint32      m_struct_size;
	  uint32      m_width;
	  uint32      m_height;
	  uint32      m_faces;
	  uint32      m_blocks_x;
	  uint32      m_blocks_y;
	  uint32      m_bytes_per_block;
	  crn_format  m_format;
   };

   // Returns the FOURCC format code corresponding to the specified CRN format.
   uint32 crnd_crn_format_to_fourcc(crn_format fmt);

   // Returns the fundamental GPU format given a potentially swizzled DXT5 crn_format.
   crn_format crnd_get_fundamental_dxt_format(crn_format fmt);

   // Returns the size of the crn_format in bits/texel (either 4 or 8).
   uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt);

   // Returns the number of bytes per DXTn block (8 or 16).
   uint32 crnd_get_bytes_per_dxt_block(crn_format fmt);

   // Validates the entire file by checking the header and data CRC's.
   // This is not something you want to be doing much!
   // The crn_file_info.m_struct_size field must be set before calling this function.
   bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info);

   // Retrieves texture information from the CRN file.
   // The crn_texture_info.m_struct_size field must be set before calling this function.
   bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pTexture_info);

   // Retrieves mipmap level specific information from the CRN file.
   // The crn_level_info.m_struct_size field must be set before calling this function.
   bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info);

   // Transcode/unpack context handle.
   typedef void* crnd_unpack_context;

   // crnd_unpack_begin() - Decompresses the texture's decoder tables and endpoint/selector palettes.
   // Once you call this function, you may call crnd_unpack_level() to unpack one or more mip levels.
   // Don't call this once per mip level (unless you absolutely must)!
   // This function allocates enough memory to hold: Huffman decompression tables, and the endpoint/selector palettes (color and/or alpha).
   // Worst case allocation is approx. 200k, assuming all palettes contain 8192 entries.
   // pData must point to a buffer holding all of the compressed .CRN file data.
   // This buffer must be stable until crnd_unpack_end() is called.
   // Returns NULL if out of memory, or if any of the input parameters are invalid.
   crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size);

   // Returns a pointer to the compressed .CRN data associated with a crnd_unpack_context.
   // Returns false if any of the input parameters are invalid.
   bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size);

   // crnd_unpack_level() - Transcodes the specified mipmap level to a destination buffer in cached or write combined memory.
   // pContext - Context created by a call to crnd_unpack_begin().
   // ppDst - A pointer to an array of 1 or 6 destination buffer pointers. Cubemaps require an array of 6 pointers, 2D textures require an array of 1 pointer.
   // dst_size_in_bytes - Optional size of each destination buffer. Only used for debugging - OK to set to UINT32_MAX.
   // row_pitch_in_bytes - The pitch in bytes from one row of DXT blocks to the next. Must be a multiple of 4.
   // level_index - mipmap level index, where 0 is the largest/first level.
   // Returns false if any of the input parameters, or the compressed stream, are invalid.
   // This function does not allocate any memory.
   bool crnd_unpack_level(
	  crnd_unpack_context pContext,
	  void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index);

   // crnd_unpack_level_segmented() - Unpacks the specified mipmap level from a "segmented" CRN file.
   // See the crnd_create_segmented_file() API below.
   // Segmented files allow the user to control where the compressed mipmap data is stored.
   bool crnd_unpack_level_segmented(
	  crnd_unpack_context pContext,
	  const void* pSrc, uint32 src_size_in_bytes,
	  void** ppDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index);

   // crnd_unpack_end() - Frees the decompress tables and unpacked palettes associated with the specified unpack context.
   // Returns false if the context is NULL, or if it points to an invalid context.
   // This function frees all memory associated with the context.
   bool crnd_unpack_end(crnd_unpack_context pContext);

   // The following API's allow the user to create "segmented" CRN files. A segmented file contains multiple pieces:
   // - Base data: Header + compression tables
   // - Level data: Individual mipmap levels
   // This allows mipmap levels from multiple CRN files to be tightly packed together into single files.

   // Returns a pointer to the level's compressed data, and optionally returns the level's compressed data size if pSize is not NULL.
   const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize);

   // Returns the compressed size of the texture's header and compression tables (but no levels).
   uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size);

   // Creates a "segmented" CRN texture from a normal CRN texture. The new texture will be created at pBase_data, and will be crnd_get_base_data_size() bytes long.
   // base_data_size must be >= crnd_get_base_data_size().
   // The base data will contain the CRN header and compression tables, but no mipmap data.
   bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size);

} // namespace crnd

// Low-level CRN file header cracking.
namespace crnd
{
   template<unsigned int N>
   struct crn_packed_uint
   {
	  inline crn_packed_uint() { }

	  inline crn_packed_uint(unsigned int val) { *this = val; }

	  inline crn_packed_uint(const crn_packed_uint& other) { *this = other; }

	  inline crn_packed_uint& operator= (const crn_packed_uint& rhs)
	  {
		 if (this != &rhs)
			memcpy(m_buf, rhs.m_buf, sizeof(m_buf));
		 return *this;
	  }

	  inline crn_packed_uint& operator= (unsigned int val)
	  {
		 //CRND_ASSERT((N == 4U) || (val < (1U << (N * 8U))));

		 val <<= (8U * (4U - N));

		 for (unsigned int i = 0; i < N; i++)
		 {
			m_buf[i] = static_cast<unsigned char>(val >> 24U);
			val <<= 8U;
		 }

		 return *this;
	  }

	  inline operator unsigned int() const
	  {
		 switch (N)
		 {
		 case 1:  return  m_buf[0];
		 case 2:  return (m_buf[0] <<  8U) |  m_buf[1];
		 case 3:  return (m_buf[0] << 16U) | (m_buf[1] <<  8U) | (m_buf[2]);
		 default: return (m_buf[0] << 24U) | (m_buf[1] << 16U) | (m_buf[2] << 8U) | (m_buf[3]);
		 }
	  }

	  unsigned char m_buf[N];
   };

#pragma pack(push)
#pragma pack(1)
   struct crn_palette
   {
	  crn_packed_uint<3> m_ofs;
	  crn_packed_uint<3> m_size;
	  crn_packed_uint<2> m_num;
   };

   enum crn_header_flags
   {
	  // If set, the compressed mipmap level data is not located after the file's base data - it will be separately managed by the user instead.
	  cCRNHeaderFlagSegmented = 1
   };

   struct crn_header
   {
	  enum { cCRNSigValue = ('H' << 8) | 'x' };

	  crn_packed_uint<2>    m_sig;
	  crn_packed_uint<2>    m_header_size;
	  crn_packed_uint<2>    m_header_crc16;

	  crn_packed_uint<4>    m_data_size;
	  crn_packed_uint<2>    m_data_crc16;

	  crn_packed_uint<2>    m_width;
	  crn_packed_uint<2>    m_height;

	  crn_packed_uint<1>    m_levels;
	  crn_packed_uint<1>    m_faces;

	  crn_packed_uint<1>    m_format;
	  crn_packed_uint<2>    m_flags;

	  crn_packed_uint<4>    m_reserved;
	  crn_packed_uint<4>    m_userdata0;
	  crn_packed_uint<4>    m_userdata1;

	  crn_palette           m_color_endpoints;
	  crn_palette           m_color_selectors;

	  crn_palette           m_alpha_endpoints;
	  crn_palette           m_alpha_selectors;

	  crn_packed_uint<2>    m_tables_size;
	  crn_packed_uint<3>    m_tables_ofs;

	  // m_level_ofs[] is actually an array of offsets: m_level_ofs[m_levels]
	  crn_packed_uint<4>    m_level_ofs[1];
   };

   const unsigned int cCRNHeaderMinSize = 62U;

#pragma pack(pop)

} // namespace crnd

#endif // CRND_INCLUDE_CRND_H

// Internal library source follows this line.

#ifndef CRND_HEADER_FILE_ONLY

#include <stdlib.h>
#include <stdio.h>
#ifdef WIN32
#include <memory.h>
#else
#include <malloc.h>
#endif
#include <stdarg.h>
#include <new> // needed for placement new, _msize, _expand

#define CRND_RESTRICT __restrict

#ifdef _MSC_VER
#include <intrin.h>
#pragma intrinsic(_WriteBarrier)
#pragma intrinsic(_ReadWriteBarrier)
#define CRND_WRITE_BARRIER _WriteBarrier();
#define CRND_FULL_BARRIER _ReadWriteBarrier();
#else
#define CRND_WRITE_BARRIER
#define CRND_FULL_BARRIER
#endif

#ifdef _MSC_VER
#pragma warning(disable:4127) // warning C4127: conditional expression is constant
#endif

#ifdef CRND_DEVEL
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x500
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef
#define NOMINMAX
#endif
#include "windows.h" // only for IsDebuggerPresent(), DebugBreak(), and OutputDebugStringA()
#endif

// File: crnd_types.h
namespace crnd
{
   const crn_uint8 cUINT8_MIN  = 0;
   const crn_uint8 cUINT8_MAX  = 0xFFU;
   const uint16 cUINT16_MIN = 0;
   const uint16 cUINT16_MAX = 0xFFFFU;
   const uint32 cUINT32_MIN = 0;
   const uint32 cUINT32_MAX = 0xFFFFFFFFU;

   const int8  cINT8_MIN  = -128;
   const int8  cINT8_MAX  = 127;
   const int16 cINT16_MIN = -32768;
   const int16 cINT16_MAX = 32767;
   const int32 cINT32_MIN = (-2147483647 - 1);
   const int32 cINT32_MAX = 2147483647;

   enum eClear { cClear };

   const uint32 cIntBits = 32U;

#ifdef _WIN64
   typedef uint64 ptr_bits;
#else
   typedef uint32 ptr_bits;
#endif

   template<typename T> struct int_traits { enum { cMin = crnd::cINT32_MIN, cMax = crnd::cINT32_MAX, cSigned = true }; };

   template<> struct int_traits<int8> { enum { cMin = crnd::cINT8_MIN, cMax = crnd::cINT8_MAX, cSigned = true }; };
   template<> struct int_traits<int16> { enum { cMin = crnd::cINT16_MIN, cMax = crnd::cINT16_MAX, cSigned = true }; };
   template<> struct int_traits<int32> { enum { cMin = crnd::cINT32_MIN, cMax = crnd::cINT32_MAX, cSigned = true }; };

   template<> struct int_traits<uint8> { enum { cMin = 0, cMax = crnd::cUINT8_MAX, cSigned = false }; };
   template<> struct int_traits<uint16> { enum { cMin = 0, cMax = crnd::cUINT16_MAX, cSigned = false }; };
   template<> struct int_traits<uint32> { enum { cMin = 0, cMax = crnd::cUINT32_MAX, cSigned = false }; };

   struct empty_type { };

} // namespace crnd

// File: crnd_platform.h
namespace crnd
{
#ifdef _XBOX
   const bool c_crnd_little_endian_platform = false;
   const bool c_crnd_big_endian_platform = true;
#define CRND_BIG_ENDIAN_PLATFORM 1
#else
   const bool c_crnd_little_endian_platform = true;
   const bool c_crnd_big_endian_platform = false;
#endif

   bool crnd_is_debugger_present();
   void crnd_debug_break();
   void crnd_output_debug_string(const char* p);

   // actually in crnd_assert.cpp
   void crnd_assert(const char* pExp, const char* pFile, unsigned line);
   void crnd_fail(const char* pExp, const char* pFile, unsigned line);

} // namespace crnd

// File: crnd_assert.h
namespace crnd
{
   void crnd_assert(const char* pExp, const char* pFile, unsigned line);

#ifdef NDEBUG
#define CRND_ASSERT(x) ((void)0)
#undef  CRND_ASSERTS_ENABLED
#else
#define CRND_ASSERT(_exp) (void)( (!!(_exp)) || (crnd::crnd_assert(#_exp, __FILE__, __LINE__), 0) )
#define CRND_ASSERTS_ENABLED
#endif

   void crnd_trace(const char* pFmt, va_list args);
   void crnd_trace(const char* pFmt, ...);

} // namespace crnd

// File: crnd_helpers.h
namespace crnd
{
   namespace helpers
   {
	  template<typename T> struct rel_ops
	  {
		 friend bool operator!= (const T& x, const T& y) { return (!(x == y)); }
		 friend bool operator>  (const T& x, const T& y) { return (y < x); }
		 friend bool operator<= (const T& x, const T& y) { return (!(y < x)); }
		 friend bool operator>= (const T& x, const T& y) { return (!(x < y)); }
	  };

	  template <typename T>
	  inline T* construct(T* p)
	  {
		 return new (static_cast<void*>(p)) T;
	  }

	  template <typename T, typename U>
	  inline T* construct(T* p, const U& init)
	  {
		 return new (static_cast<void*>(p)) T(init);
	  }

	  template <typename T>
	  void construct_array(T* p, uint32 n)
	  {
		 T* q = p + n;
		 for ( ; p != q; ++p)
			new (static_cast<void*>(p)) T;
	  }

	  template <typename T, typename U>
	  void construct_array(T* p, uint32 n, const U& init)
	  {
		 T* q = p + n;
		 for ( ; p != q; ++p)
			new (static_cast<void*>(p)) T(init);
	  }

	  template <typename T>
	  inline void destruct(T* p)
	  {
		 p;
		 p->~T();
	  }

	  template <typename T> inline void destruct_array(T* p, uint32 n)
	  {
		 T* q = p + n;
		 for ( ; p != q; ++p)
			p->~T();
	  }

   }  // namespace helpers

}  // namespace crnd

// File: crnd_traits.h
namespace crnd
{
   template<typename T>
   struct scalar_type
   {
	  enum { cFlag = false };
	  static inline void construct(T* p) { helpers::construct(p); }
	  static inline void construct(T* p, const T& init) { helpers::construct(p, init); }
	  static inline void construct_array(T* p, uint32 n) { helpers::construct_array(p, n); }
	  static inline void destruct(T* p) { helpers::destruct(p); }
	  static inline void destruct_array(T* p, uint32 n) { helpers::destruct_array(p, n); }
   };

   template<typename T> struct scalar_type<T*>
   {
	  enum { cFlag = true };
	  static inline void construct(T** p) { memset(p, 0, sizeof(T*)); }
	  static inline void construct(T** p, T* init) { *p = init; }
	  static inline void construct_array(T** p, uint32 n) { memset(p, 0, sizeof(T*) * n); }
	  static inline void destruct(T** p) { p; }
	  static inline void destruct_array(T** p, uint32 n) { p, n; }
   };

#define CRND_DEFINE_BUILT_IN_TYPE(X) \
   template<> struct scalar_type<X> { \
   enum { cFlag = true }; \
   static inline void construct(X* p) { memset(p, 0, sizeof(X)); } \
   static inline void construct(X* p, const X& init) { memcpy(p, &init, sizeof(X)); } \
   static inline void construct_array(X* p, uint32 n) { memset(p, 0, sizeof(X) * n); } \
   static inline void destruct(X* p) { p; } \
   static inline void destruct_array(X* p, uint32 n) { p, n; } };

   CRND_DEFINE_BUILT_IN_TYPE(bool)
   CRND_DEFINE_BUILT_IN_TYPE(int8_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint8_t)
   CRND_DEFINE_BUILT_IN_TYPE(int16_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint16_t)
   CRND_DEFINE_BUILT_IN_TYPE(int32_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint32_t)
   CRND_DEFINE_BUILT_IN_TYPE(int64_t)
   CRND_DEFINE_BUILT_IN_TYPE(uint64_t)
   CRND_DEFINE_BUILT_IN_TYPE(float)
   CRND_DEFINE_BUILT_IN_TYPE(double)
   CRND_DEFINE_BUILT_IN_TYPE(long double)

#undef CRND_DEFINE_BUILT_IN_TYPE

   // See: http://erdani.org/publications/cuj-2004-06.pdf

   template<typename T>
   struct bitwise_movable { enum { cFlag = false }; };

   // Defines type Q as bitwise movable.
#define CRND_DEFINE_BITWISE_MOVABLE(Q) template<> struct bitwise_movable<Q> { enum { cFlag = true }; };

   // From yasli_traits.h:
   // Credit goes to Boost;
   // also found in the C++ Templates book by Vandevoorde and Josuttis

   typedef char (&yes_t)[1];
   typedef char (&no_t)[2];

   template <class U> yes_t class_test(int U::*);
   template <class U> no_t class_test(...);

   template <class T> struct is_class
   {
	  enum { value = (sizeof(class_test<T>(0)) == sizeof(yes_t)) };
   };

   template <typename T> struct is_pointer
   {
	  enum { value = false };
   };

   template <typename T> struct is_pointer<T*>
   {
	  enum { value = true };
   };

#define CRND_IS_POD(T) __is_pod(T)

} // namespace crnd

// File: crnd_mem.h
namespace crnd
{
   void*    crnd_malloc(size_t size, size_t* pActual_size = NULL);
   void*    crnd_realloc(void* p, size_t size, size_t* pActual_size = NULL, bool movable = true);
   void     crnd_free(void* p);
   size_t   crnd_msize(void* p);

   template<typename T>
   inline T* crnd_new()
   {
	  T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
	  if (!p)
		 return NULL;

	  return helpers::construct(p);
   }

   template<typename T>
   inline T* crnd_new(const T& init)
   {
	  T* p = static_cast<T*>(crnd_malloc(sizeof(T)));
	  if (!p)
		 return NULL;

	  return helpers::construct(p, init);
   }

   template<typename T>
   inline T* crnd_new_array(uint32 num)
   {
	  if (!num) num = 1;

	  uint8* q = static_cast<uint8*>(crnd_malloc(CRND_MIN_ALLOC_ALIGNMENT + sizeof(T) * num));
	  if (!q)
		 return NULL;

	  T* p = reinterpret_cast<T*>(q + CRND_MIN_ALLOC_ALIGNMENT);

	  reinterpret_cast<uint32*>(p)[-1] = num;
	  reinterpret_cast<uint32*>(p)[-2] = ~num;

	  helpers::construct_array(p, num);
	  return p;
   }

   template<typename T>
   inline void crnd_delete(T* p)
   {
	  if (p)
	  {
		 helpers::destruct(p);
		 crnd_free(p);
	  }
   }

   template<typename T>
   inline void crnd_delete_array(T* p)
   {
	  if (p)
	  {
		 const uint32 num = reinterpret_cast<uint32*>(p)[-1];
		 const uint32 num_check = reinterpret_cast<uint32*>(p)[-2];
		 num_check;
		 CRND_ASSERT(num && (num == ~num_check));

		 helpers::destruct_array(p, num);

		 crnd_free(reinterpret_cast<uint8*>(p) - CRND_MIN_ALLOC_ALIGNMENT);
	  }
   }

} // namespace crnd

// File: crnd_math.h
namespace crnd
{
   namespace math
   {
	  const float cNearlyInfinite = 1.0e+37f;

	  const float cDegToRad = 0.01745329252f;
	  const float cRadToDeg = 57.29577951f;

	  extern uint32 g_bitmasks[32];

	  // Yes I know these should probably be pass by ref, not val:
	  // http://www.stepanovpapers.com/notes.pdf
	  // Just don't use them on non-simple (non built-in) types!
	  template<typename T> inline T minimum(T a, T b)
	  {
		 return (a < b) ? a : b;
	  }

	  template<typename T> inline T minimum(T a, T b, T c)
	  {
		 return minimum(minimum(a, b), c);
	  }

	  template<typename T> inline T maximum(T a, T b)
	  {
		 return (a > b) ? a : b;
	  }

	  template<typename T> inline T maximum(T a, T b, T c)
	  {
		 return maximum(maximum(a, b), c);
	  }

	  template<typename T> inline T clamp(T value, T low, T high)
	  {
		 return (value < low) ? low : ((value > high) ? high : value);
	  }

	  template<typename T> inline T square(T value)
	  {
		 return value * value;
	  }

	  inline bool is_power_of_2(uint32 x)
	  {
		 return x && ((x & (x - 1U)) == 0U);
	  }

	  // From "Hackers Delight"
	  inline int next_pow2(uint32 val)
	  {
		 val--;
		 val |= val >> 16;
		 val |= val >> 8;
		 val |= val >> 4;
		 val |= val >> 2;
		 val |= val >> 1;
		 return val + 1;
	  }

	  // Returns the total number of bits needed to encode v.
	  inline uint32 total_bits(uint32 v)
	  {
		 uint32 l = 0;
		 while (v > 0U)
		 {
			v >>= 1;
			l++;
		 }
		 return l;
	  }

	  inline uint floor_log2i(uint v)
	  {
		 uint l = 0;
		 while (v > 1U)
		 {
			v >>= 1;
			l++;
		 }
		 return l;
	  }

	  inline uint ceil_log2i(uint v)
	  {
		 uint l = floor_log2i(v);
		 if ((l != cIntBits) && (v > (1U << l)))
			l++;
		 return l;
	  }
   }
}

// File: crnd_utils.h
namespace crnd
{
   namespace utils
   {
	  template<typename T> inline void zero_object(T& obj)
	  {
		 memset(&obj, 0, sizeof(obj));
	  }

	  template<typename T> inline void zero_this(T* pObj)
	  {
		 memset(pObj, 0, sizeof(*pObj));
	  }

	  template <typename T>
	  inline void swap(T& left, T& right)
	  {
		 T temp(left);
		 left = right;
		 right = temp;
	  }

	  inline void invert_buf(void* pBuf, uint32 size)
	  {
		 uint8* p = static_cast<uint8*>(pBuf);

		 const uint32 half_size = size >> 1;
		 for (uint32 i = 0; i < half_size; i++)
			swap(p[i], p[size - 1U - i]);
	  }

	  static inline uint16 swap16(uint16 x) { return static_cast<uint16>((x << 8) | (x >> 8)); }
	  static inline uint32 swap32(uint32 x) { return ((x << 24) | ((x << 8) & 0x00FF0000) | (( x >> 8) & 0x0000FF00) | (x >> 24)); }

	  uint32 compute_max_mips(uint32 width, uint32 height);

   }   // namespace utils

} // namespace crnd

// File: crnd_vector.h
namespace crnd
{
   struct elemental_vector
   {
	  void* m_p;
	  uint32 m_size;
	  uint32 m_capacity;

	  typedef void (*object_mover)(void* pDst, void* pSrc, uint32 num);

	  bool increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pRelocate);
   };

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4127) //  warning C4127: conditional expression is constant
#endif

   template<typename T>
   class vector : public helpers::rel_ops< vector<T> >
   {
   public:
	  typedef T*              iterator;
	  typedef const T*        const_iterator;
	  typedef T               value_type;
	  typedef T&              reference;
	  typedef const T&        const_reference;
	  typedef T*              pointer;
	  typedef const T*        const_pointer;

	  inline vector() :
		 m_p(NULL),
		 m_size(0),
		 m_capacity(0),
		 m_alloc_failed(false)
	  {
	  }

	  inline vector(const vector& other) :
		 m_p(NULL),
		 m_size(0),
		 m_capacity(0),
		 m_alloc_failed(false)
	  {
		 *this = other;
	  }

	  inline vector(uint32 size) :
		 m_p(NULL),
		 m_size(0),
		 m_capacity(0),
		 m_alloc_failed(false)
	  {
		 resize(size);
	  }

	  inline ~vector()
	  {
		 clear();
	  }

	  // I don't like this. Not at all. But exceptions, or just failing suck worse.
	  inline bool get_alloc_failed() const { return m_alloc_failed; }
	  inline void clear_alloc_failed() { m_alloc_failed = false; }

	  inline bool assign(const vector& other)
	  {
		 if (this == &other)
			return true;

		 if (m_capacity == other.m_size)
			resize(0);
		 else
		 {
			clear();

			if (!increase_capacity(other.m_size, false))
			   return false;
		 }

		 if (scalar_type<T>::cFlag)
			memcpy(m_p, other.m_p, other.m_size * sizeof(T));
		 else
		 {
			T* pDst = m_p;
			const T* pSrc = other.m_p;
			for (uint32 i = other.m_size; i > 0; i--)
			   helpers::construct(pDst++, *pSrc++);
		 }

		 m_size = other.m_size;

		 return true;
	  }

	  inline vector& operator= (const vector& other)
	  {
		 assign(other);
		 return *this;
	  }

	  inline const   T* begin() const  { return m_p; }
	  T* begin()        { return m_p; }

	  inline const   T* end() const  { return m_p + m_size; }
	  T* end()        { return m_p + m_size; }

	  inline bool empty() const { return !m_size; }
	  inline uint32 size() const { return m_size; }
	  inline uint32 capacity() const { return m_capacity; }

	  inline const T& operator[] (uint32 i) const  { CRND_ASSERT(i < m_size); return m_p[i]; }
	  inline       T& operator[] (uint32 i)        { CRND_ASSERT(i < m_size); return m_p[i]; }

	  inline const T& front() const  { CRND_ASSERT(m_size); return m_p[0]; }
	  inline       T& front()        { CRND_ASSERT(m_size); return m_p[0]; }

	  inline const T& back() const  { CRND_ASSERT(m_size); return m_p[m_size - 1]; }
	  inline       T& back()        { CRND_ASSERT(m_size); return m_p[m_size - 1]; }

	  inline void clear()
	  {
		 if (m_p)
		 {
			scalar_type<T>::destruct_array(m_p, m_size);
			crnd_free(m_p);
			m_p = NULL;
			m_size = 0;
			m_capacity = 0;
		 }

		 m_alloc_failed = false;
	  }

	  inline bool reserve(uint32 new_capacity)
	  {
		 if (!increase_capacity(new_capacity, false))
			return false;

		 return true;
	  }

	  inline bool resize(uint32 new_size)
	  {
		 if (m_size != new_size)
		 {
			if (new_size < m_size)
			   scalar_type<T>::destruct_array(m_p + new_size, m_size - new_size);
			else
			{
			   if (new_size > m_capacity)
			   {
				  if (!increase_capacity(new_size, new_size == (m_size + 1)))
					 return false;
			   }

			   scalar_type<T>::construct_array(m_p + m_size, new_size - m_size);
			}

			m_size = new_size;
		 }

		 return true;
	  }

	  inline bool push_back(const T& obj)
	  {
		 CRND_ASSERT(!m_p || (&obj < m_p) || (&obj >= (m_p + m_size)));

		 if (m_size >= m_capacity)
		 {
			if (!increase_capacity(m_size + 1, true))
			   return false;
		 }

		 scalar_type<T>::construct(m_p + m_size, obj);
		 m_size++;

		 return true;
	  }

	  inline void pop_back()
	  {
		 CRND_ASSERT(m_size);

		 if (m_size)
		 {
			m_size--;
			scalar_type<T>::destruct(&m_p[m_size]);
		 }
	  }

	  inline void insert(uint32 index, const T* p, uint32 n)
	  {
		 CRND_ASSERT(index <= m_size);
		 if (!n)
			return;

		 const uint32 orig_size = m_size;
		 resize(m_size + n);

		 const T* pSrc = m_p + orig_size - 1;
		 T* pDst = const_cast<T*>(pSrc) + n;

		 const uint32 num_to_move = orig_size - index;

		 for (uint32 i = 0; i < num_to_move; i++)
		 {
			CRND_ASSERT((pDst - m_p) < (int)m_size);
			*pDst-- = *pSrc--;
		 }

		 pSrc = p;
		 pDst = m_p + index;

		 for (uint32 i = 0; i < n; i++)
		 {
			CRND_ASSERT((pDst - m_p) < (int)m_size);
			*pDst++ = *p++;
		 }
	  }

	  inline void erase(uint32 start, uint32 n)
	  {
		 CRND_ASSERT((start + n) <= m_size);

		 if (!n)
			return;

		 const uint32 num_to_move = m_size - (start + n);

		 T* pDst = m_p + start;
		 T* pDst_end = pDst + num_to_move;
		 const T* pSrc = m_p + start + n;

		 while (pDst != pDst_end)
			*pDst++ = *pSrc++;

		 scalar_type<T>::destruct_array(pDst_end, n);

		 m_size -= n;
	  }

	  inline void erase(uint32 index)
	  {
		 erase(index, 1);
	  }

	  inline void erase(T* p)
	  {
		 CRND_ASSERT((p >= m_p) && (p < (m_p + m_size)));
		 erase(p - m_p);
	  }

	  inline bool operator== (const vector& rhs) const
	  {
		 if (m_size != rhs.m_size)
			return false;
		 else if (m_size)
		 {
			if (scalar_type<T>::cFlag)
			   return memcmp(m_p, rhs.m_p, sizeof(T) * m_size) == 0;
			else
			{
			   const T* pSrc = m_p;
			   const T* pDst = rhs.m_p;
			   for (uint32 i = m_size; i; i--)
				  if (!(*pSrc++ == *pDst++))
					 return false;
			}
		 }

		 return true;
	  }

	  inline bool operator< (const vector& rhs) const
	  {
		 const uint32 min_size = math::minimum(m_size, rhs.m_size);

		 const T* pSrc = m_p;
		 const T* pSrc_end = m_p + min_size;
		 const T* pDst = rhs.m_p;

		 while ((pSrc < pSrc_end) && (*pSrc == *pDst))
		 {
			pSrc++;
			pDst++;
		 }

		 if (pSrc < pSrc_end)
			return *pSrc < *pDst;

		 return m_size < rhs.m_size;
	  }

	  void swap(vector& other)
	  {
		 utils::swap(m_p, other.m_p);
		 utils::swap(m_size, other.m_size);
		 utils::swap(m_capacity, other.m_capacity);
	  }

   private:
	  T*          m_p;
	  uint32      m_size;
	  uint32      m_capacity;
	  bool        m_alloc_failed;

	  template<typename Q> struct is_vector { enum { cFlag = false }; };
	  template<typename Q> struct is_vector< vector<Q> > { enum { cFlag = true }; };

	  static void object_mover(void* pDst_void, void* pSrc_void, uint32 num)
	  {
		 T* pSrc = static_cast<T*>(pSrc_void);
		 T* const pSrc_end = pSrc + num;
		 T* pDst = static_cast<T*>(pDst_void);

		 while (pSrc != pSrc_end)
		 {
			helpers::construct<T>(pDst, *pSrc);
			pSrc->~T();
			pSrc++;
			pDst++;
		 }
	  }

	  inline bool increase_capacity(uint32 min_new_capacity, bool grow_hint)
	  {
		 if (!reinterpret_cast<elemental_vector*>(this)->increase_capacity(
			min_new_capacity, grow_hint, sizeof(T),
			((scalar_type<T>::cFlag) || (is_vector<T>::cFlag) || (bitwise_movable<T>::cFlag) || CRND_IS_POD(T)) ? NULL : object_mover))
		 {
			m_alloc_failed = true;
			return false;
		 }
		 return true;
	  }
   };

#ifdef _MSC_VER
#pragma warning(pop)
#endif

   extern void vector_test();

} // namespace crnd

// File: crnd_private.h
namespace crnd
{
   const crn_header* crnd_get_header(crn_header& header, const void* pData, uint32 data_size);

} // namespace crnd

// File: checksum.h
namespace crnd
{
   // crc16() intended for small buffers - doesn't use an acceleration table.
   const uint16 cInitCRC16 = 0;
   uint16 crc16(const void* pBuf, uint32 len, uint16 crc = cInitCRC16);

}  // namespace crnd

// File: crnd_color.h
namespace crnd
{
   template<typename component_type> struct color_quad_component_traits
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = false,
		 cMin = cUINT8_MIN,
		 cMax = cUINT8_MAX
	  };
   };

   template<> struct color_quad_component_traits<int16>
   {
	  enum
	  {
		 cSigned = true,
		 cFloat = false,
		 cMin = cINT16_MIN,
		 cMax = cINT16_MAX
	  };
   };

   template<> struct color_quad_component_traits<uint16>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = false,
		 cMin = cUINT16_MIN,
		 cMax = cUINT16_MAX
	  };
   };

   template<> struct color_quad_component_traits<int32>
   {
	  enum
	  {
		 cSigned = true,
		 cFloat = false,
		 cMin = cINT32_MIN,
		 cMax = cINT32_MAX
	  };
   };

   template<> struct color_quad_component_traits<uint32>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = false,
		 cMin = cUINT32_MIN,
		 cMax = cUINT32_MAX
	  };
   };

   template<> struct color_quad_component_traits<float>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = true,
		 cMin = cINT32_MIN,
		 cMax = cINT32_MAX
	  };
   };

   template<> struct color_quad_component_traits<double>
   {
	  enum
	  {
		 cSigned = false,
		 cFloat = true,
		 cMin = cINT32_MIN,
		 cMax = cINT32_MAX
	  };
   };

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4201) //  warning C4201: nonstandard extension used : nameless struct/union
#pragma warning(disable:4127) //  warning C4127: conditional expression is constant
#endif

   template<typename component_type, typename parameter_type>
   class color_quad : public helpers::rel_ops<color_quad<component_type, parameter_type> >
   {
	  static parameter_type clamp(parameter_type v)
	  {
		 if (component_traits::cFloat)
			return v;
		 else
		 {
			if (v < component_traits::cMin)
			   return component_traits::cMin;
			else if (v > component_traits::cMax)
			   return component_traits::cMax;
			return v;
		 }
	  }

   public:
	  typedef component_type component_t;
	  typedef parameter_type parameter_t;
	  typedef color_quad_component_traits<component_type> component_traits;

	  enum { cNumComps = 4 };

	  union
	  {
		 struct
		 {
			component_type r;
			component_type g;
			component_type b;
			component_type a;
		 };

		 component_type c[cNumComps];
	  };

	  inline color_quad()
	  {
	  }

	  inline color_quad(eClear) :
		 r(0), g(0), b(0), a(0)
	  {
	  }

	  inline color_quad(const color_quad& other) :
		 r(other.r), g(other.g), b(other.b), a(other.a)
	  {
	  }

	  inline color_quad(parameter_type y, parameter_type alpha = component_traits::cMax)
	  {
		 set(y, alpha);
	  }

	  inline color_quad(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax)
	  {
		 set(red, green, blue, alpha);
	  }

	  template<typename other_component_type, typename other_parameter_type>
	  inline color_quad(const color_quad<other_component_type, other_parameter_type>& other) :
		 r(clamp(other.r)), g(clamp(other.g)), b(clamp(other.b)), a(clamp(other.a))
	  {
	  }

	  inline void clear()
	  {
		 r = 0;
		 g = 0;
		 b = 0;
		 a = 0;
	  }

	  inline color_quad& operator= (const color_quad& other)
	  {
		 r = other.r;
		 g = other.g;
		 b = other.b;
		 a = other.a;
		 return *this;
	  }

	  template<typename other_component_type, typename other_parameter_type>
	  inline color_quad& operator=(const color_quad<other_component_type, other_parameter_type>& other)
	  {
		 r = clamp(other.r);
		 g = clamp(other.g);
		 b = clamp(other.b);
		 a = clamp(other.a);
		 return *this;
	  }

	  inline color_quad& set(parameter_type y, parameter_type alpha = component_traits::cMax)
	  {
		 y = clamp(y);
		 r = static_cast<component_type>(y);
		 g = static_cast<component_type>(y);
		 b = static_cast<component_type>(y);
		 a = static_cast<component_type>(alpha);
		 return *this;
	  }

	  inline color_quad& set(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha = component_traits::cMax)
	  {
		 r = static_cast<component_type>(clamp(red));
		 g = static_cast<component_type>(clamp(green));
		 b = static_cast<component_type>(clamp(blue));
		 a = static_cast<component_type>(clamp(alpha));
		 return *this;
	  }

	  inline color_quad& set_noclamp_rgba(parameter_type red, parameter_type green, parameter_type blue, parameter_type alpha)
	  {
		 r = static_cast<component_type>(red);
		 g = static_cast<component_type>(green);
		 b = static_cast<component_type>(blue);
		 a = static_cast<component_type>(alpha);
		 return *this;
	  }

	  inline color_quad& set_noclamp_rgb(parameter_type red, parameter_type green, parameter_type blue)
	  {
		 r = static_cast<component_type>(red);
		 g = static_cast<component_type>(green);
		 b = static_cast<component_type>(blue);
		 return *this;
	  }

	  static inline parameter_type get_min_comp() { return component_traits::cMin; }
	  static inline parameter_type get_max_comp() { return component_traits::cMax; }
	  static inline bool get_comps_are_signed() { return component_traits::cSigned; }

	  inline component_type operator[] (uint32 i) const { CRND_ASSERT(i < cNumComps); return c[i]; }
	  inline component_type& operator[] (uint32 i) { CRND_ASSERT(i < cNumComps); return c[i]; }

	  inline color_quad& set_component(uint32 i, parameter_type f)
	  {
		 CRND_ASSERT(i < cNumComps);

		 c[i] = static_cast<component_type>(clamp(f));

		 return *this;
	  }

	  inline color_quad& clamp(const color_quad& l, const color_quad& h)
	  {
		 for (uint32 i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l[i], h[i]));
		 return *this;
	  }

	  inline color_quad& clamp(parameter_type l, parameter_type h)
	  {
		 for (uint32 i = 0; i < cNumComps; i++)
			c[i] = static_cast<component_type>(math::clamp<parameter_type>(c[i], l, h));
		 return *this;
	  }

	  // Returns CCIR 601 luma (consistent with color_utils::RGB_To_Y).
	  inline parameter_type get_luma() const
	  {
		 return static_cast<parameter_type>((19595U * r + 38470U * g + 7471U * b + 32768) >> 16U);
	  }

	  // Returns REC 709 luma.
	  inline parameter_type get_luma_rec709() const
	  {
		 return static_cast<parameter_type>((13938U * r + 46869U * g + 4729U * b + 32768U) >> 16U);
	  }

	  inline uint32 squared_distance(const color_quad& c, bool alpha = true) const
	  {
		 return math::square(r - c.r) + math::square(g - c.g) + math::square(b - c.b) + (alpha ? math::square(a - c.a) : 0);
	  }

	  inline bool rgb_equals(const color_quad& rhs) const
	  {
		 return (r == rhs.r) && (g == rhs.g) && (b == rhs.b);
	  }

	  inline bool operator== (const color_quad& rhs) const
	  {
		 return (r == rhs.r) && (g == rhs.g) && (b == rhs.b) && (a == rhs.a);
	  }

	  inline bool operator< (const color_quad& rhs) const
	  {
		 for (uint32 i = 0; i < cNumComps; i++)
		 {
			if (c[i] < rhs.c[i])
			   return true;
			else if (!(c[i] == rhs.c[i]))
			   return false;
		 }
		 return false;
	  }

	  inline color_quad& operator+= (const color_quad& other)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(clamp(c[i] + other.c[i]));
		 return *this;
	  }

	  inline color_quad& operator-= (const color_quad& other)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(clamp(c[i] - other.c[i]));
		 return *this;
	  }

	  inline color_quad& operator*= (parameter_type v)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(clamp(c[i] * v));
		 return *this;
	  }

	  inline color_quad& operator/= (parameter_type v)
	  {
		 for (uint32 i = 0; i < 4; i++)
			c[i] = static_cast<component_type>(c[i] / v);
		 return *this;
	  }

	  inline color_quad get_swizzled(uint32 x, uint32 y, uint32 z, uint32 w) const
	  {
		 CRND_ASSERT((x | y | z | w) < 4);
		 return color_quad(c[x], c[y], c[z], c[w]);
	  }

	  inline friend color_quad operator+ (const color_quad& lhs, const color_quad& rhs)
	  {
		 color_quad result(lhs);
		 result += rhs;
		 return result;
	  }

	  inline friend color_quad operator- (const color_quad& lhs, const color_quad& rhs)
	  {
		 color_quad result(lhs);
		 result -= rhs;
		 return result;
	  }

	  inline friend color_quad operator* (const color_quad& lhs, parameter_type v)
	  {
		 color_quad result(lhs);
		 result *= v;
		 return result;
	  }

	  friend inline color_quad operator/ (const color_quad& lhs, parameter_type v)
	  {
		 color_quad result(lhs);
		 result /= v;
		 return result;
	  }

	  friend inline color_quad operator* (parameter_type v, const color_quad& rhs)
	  {
		 color_quad result(rhs);
		 result *= v;
		 return result;
	  }

	  inline uint32 get_min_component_index(bool alpha = true) const
	  {
		 uint32 index = 0;
		 uint32 limit = alpha ? cNumComps : (cNumComps - 1);
		 for (uint32 i = 1; i < limit; i++)
			if (c[i] < c[index])
			   index = i;
		 return index;
	  }

	  inline uint32 get_max_component_index(bool alpha = true) const
	  {
		 uint32 index = 0;
		 uint32 limit = alpha ? cNumComps : (cNumComps - 1);
		 for (uint32 i = 1; i < limit; i++)
			if (c[i] > c[index])
			   index = i;
		 return index;
	  }

	  inline void get_float4(float* pDst)
	  {
		 for (uint32 i = 0; i < 4; i++)
			pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
	  }

	  inline void get_float3(float* pDst)
	  {
		 for (uint32 i = 0; i < 3; i++)
			pDst[i] = ((*this)[i] - component_traits::cMin) / float(component_traits::cMax - component_traits::cMin);
	  }

	  static inline color_quad make_black()
	  {
		 return color_quad(0, 0, 0, component_traits::cMax);
	  }

	  static inline color_quad make_white()
	  {
		 return color_quad(component_traits::cMax, component_traits::cMax, component_traits::cMax, component_traits::cMax);
	  }
   }; // class color_quad

#ifdef _MSC_VER
#pragma warning(pop)
#endif

   template<typename c, typename q>
   struct scalar_type< color_quad<c, q> >
   {
	  enum { cFlag = true };
	  static inline void construct(color_quad<c, q>* p) { }
	  static inline void construct(color_quad<c, q>* p, const color_quad<c, q>& init) { memcpy(p, &init, sizeof(color_quad<c, q>)); }
	  static inline void construct_array(color_quad<c, q>* p, uint32 n) { p, n; }
	  static inline void destruct(color_quad<c, q>* p) { p; }
	  static inline void destruct_array(color_quad<c, q>* p, uint32 n) { p, n; }
   };

   typedef color_quad<uint8, int>      color_quad_u8;
   typedef color_quad<int16, int>      color_quad_i16;
   typedef color_quad<uint16, int>     color_quad_u16;
   typedef color_quad<int32, int>      color_quad_i32;
   typedef color_quad<uint32, uint32>    color_quad_u32;
   typedef color_quad<float, float>    color_quad_f;
   typedef color_quad<double, double>  color_quad_d;

} // namespace crnd

// File: crnd_dxt.h
namespace crnd
{
   enum dxt_format
   {
	  cDXTInvalid = -1,

	  // cDXT1/1A must appear first!
	  cDXT1,
	  cDXT1A,

	  cDXT3,
	  cDXT5,
	  cDXT5A,

	  cDXN_XY,    // inverted relative to standard ATI2, 360's DXN
	  cDXN_YX     // standard ATI2
   };

   enum dxt_constants
   {
	  cDXTBlockShift = 2U,
	  cDXTBlockSize = 1U << cDXTBlockShift,

	  cDXT1BytesPerBlock = 8U,
	  cDXT5NBytesPerBlock = 16U,

	  cDXT1SelectorBits = 2U,
	  cDXT1SelectorValues = 1U << cDXT1SelectorBits,
	  cDXT1SelectorMask = cDXT1SelectorValues - 1U,

	  cDXT5SelectorBits = 3U,
	  cDXT5SelectorValues = 1U << cDXT5SelectorBits,
	  cDXT5SelectorMask = cDXT5SelectorValues - 1U
   };

   const float cDXT1MaxLinearValue = 3.0f;
   const float cDXT1InvMaxLinearValue = 1.0f/3.0f;

   const float cDXT5MaxLinearValue = 7.0f;
   const float cDXT5InvMaxLinearValue = 1.0f/7.0f;

   // Converts DXT1 raw color selector index to a linear value.
   extern const uint8 g_dxt1_to_linear[cDXT1SelectorValues];

   // Converts DXT5 raw alpha selector index to a linear value.
   extern const uint8 g_dxt5_to_linear[cDXT5SelectorValues];

   // Converts DXT1 linear color selector index to a raw value (inverse of g_dxt1_to_linear).
   extern const uint8 g_dxt1_from_linear[cDXT1SelectorValues];

   // Converts DXT5 linear alpha selector index to a raw value (inverse of g_dxt5_to_linear).
   extern const uint8 g_dxt5_from_linear[cDXT5SelectorValues];

   extern const uint8 g_six_alpha_invert_table[cDXT5SelectorValues];
   extern const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues];

   struct dxt1_block
   {
	  uint8 m_low_color[2];
	  uint8 m_high_color[2];

	  enum { cNumSelectorBytes = 4 };
	  uint8 m_selectors[cNumSelectorBytes];

	  inline void clear()
	  {
		 utils::zero_this(this);
	  }

	  // These methods assume the in-memory rep is in LE byte order.
	  inline uint32 get_low_color() const
	  {
		 return m_low_color[0] | (m_low_color[1] << 8U);
	  }

	  inline uint32 get_high_color() const
	  {
		 return m_high_color[0] | (m_high_color[1] << 8U);
	  }

	  inline void set_low_color(uint16 c)
	  {
		 m_low_color[0] = static_cast<uint8>(c & 0xFF);
		 m_low_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
	  }

	  inline void set_high_color(uint16 c)
	  {
		 m_high_color[0] = static_cast<uint8>(c & 0xFF);
		 m_high_color[1] = static_cast<uint8>((c >> 8) & 0xFF);
	  }

	  inline uint32 get_selector(uint32 x, uint32 y) const
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U));
		 return (m_selectors[y] >> (x * cDXT1SelectorBits)) & cDXT1SelectorMask;
	  }

	  inline void set_selector(uint32 x, uint32 y, uint32 val)
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U) && (val < 4U));

		 m_selectors[y] &= (~(cDXT1SelectorMask << (x * cDXT1SelectorBits)));
		 m_selectors[y] |= (val << (x * cDXT1SelectorBits));
	  }

	  static uint16        pack_color(const color_quad_u8& color, bool scaled, uint32 bias = 127U);
	  static uint16        pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias = 127U);

	  static color_quad_u8 unpack_color(uint16 packed_color, bool scaled, uint32 alpha = 255U);
	  static void          unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled);

	  static uint32        get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1);
	  static uint32        get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1);
	  // pDst must point to an array at least cDXT1SelectorValues long.
	  static uint32        get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1);

	  static color_quad_u8 unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha = 255U);
	  static uint32        pack_endpoints(uint32 lo, uint32 hi);
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt1_block);

   struct dxt3_block
   {
	  enum { cNumAlphaBytes = 8 };
	  uint8 m_alpha[cNumAlphaBytes];

	  void set_alpha(uint32 x, uint32 y, uint32 value, bool scaled);
	  uint32 get_alpha(uint32 x, uint32 y, bool scaled) const;
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt3_block);

   struct dxt5_block
   {
	  uint8 m_endpoints[2];

	  enum { cNumSelectorBytes = 6 };
	  uint8 m_selectors[cNumSelectorBytes];

	  inline void clear()
	  {
		 utils::zero_this(this);
	  }

	  inline uint32 get_low_alpha() const
	  {
		 return m_endpoints[0];
	  }

	  inline uint32 get_high_alpha() const
	  {
		 return m_endpoints[1];
	  }

	  inline void set_low_alpha(uint32 i)
	  {
		 CRND_ASSERT(i <= cUINT8_MAX);
		 m_endpoints[0] = static_cast<uint8>(i);
	  }

	  inline void set_high_alpha(uint32 i)
	  {
		 CRND_ASSERT(i <= cUINT8_MAX);
		 m_endpoints[1] = static_cast<uint8>(i);
	  }

	  uint32 get_endpoints_as_word() const { return m_endpoints[0] | (m_endpoints[1] << 8); }

	  uint32 get_selectors_as_word(uint32 index) { CRND_ASSERT(index < 3); return m_selectors[index * 2] | (m_selectors[index * 2 + 1] << 8); }

	  inline uint32 get_selector(uint32 x, uint32 y) const
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U));

		 uint32 selector_index = (y * 4) + x;
		 uint32 bit_index = selector_index * cDXT5SelectorBits;

		 uint32 byte_index = bit_index >> 3;
		 uint32 bit_ofs = bit_index & 7;

		 uint32 v = m_selectors[byte_index];
		 if (byte_index < (cNumSelectorBytes - 1))
			v |= (m_selectors[byte_index + 1] << 8);

		 return (v >> bit_ofs) & 7;
	  }

	  inline void set_selector(uint32 x, uint32 y, uint32 val)
	  {
		 CRND_ASSERT((x < 4U) && (y < 4U) && (val < 8U));

		 uint32 selector_index = (y * 4) + x;
		 uint32 bit_index = selector_index * cDXT5SelectorBits;

		 uint32 byte_index = bit_index >> 3;
		 uint32 bit_ofs = bit_index & 7;

		 uint32 v = m_selectors[byte_index];
		 if (byte_index < (cNumSelectorBytes - 1))
			v |= (m_selectors[byte_index + 1] << 8);

		 v &= (~(7 << bit_ofs));
		 v |= (val << bit_ofs);

		 m_selectors[byte_index] = static_cast<uint8>(v);
		 if (byte_index < (cNumSelectorBytes - 1))
			m_selectors[byte_index + 1] = static_cast<uint8>(v >> 8);
	  }

	  // Results written to alpha channel.
	  static uint32          get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h);
	  static uint32          get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h);
	  static uint32          get_block_values(color_quad_u8* pDst, uint32 l, uint32 h);

	  static uint32          get_block_values6(uint32* pDst, uint32 l, uint32 h);
	  static uint32          get_block_values8(uint32* pDst, uint32 l, uint32 h);
	  // pDst must point to an array at least cDXT5SelectorValues long.
	  static uint32          get_block_values(uint32* pDst, uint32 l, uint32 h);

	  static uint32          unpack_endpoint(uint32 packed, uint32 index);
	  static uint32          pack_endpoints(uint32 lo, uint32 hi);
   };

   CRND_DEFINE_BITWISE_MOVABLE(dxt5_block);

} // namespace crnd

// File: crnd_dxt_hc_common.h
namespace crnd
{
   struct chunk_tile_desc
   {
	  // These values are in pixels, and always a multiple of cBlockPixelWidth/cBlockPixelHeight.
	  uint32 m_x_ofs;
	  uint32 m_y_ofs;
	  uint32 m_width;
	  uint32 m_height;
	  uint32 m_layout_index;
   };

   struct chunk_encoding_desc
   {
	  uint32 m_num_tiles;
	  chunk_tile_desc m_tiles[4];
   };

   const uint32 cChunkPixelWidth = 8;
   const uint32 cChunkPixelHeight = 8;
   const uint32 cChunkBlockWidth = 2;
   const uint32 cChunkBlockHeight = 2;

   const uint32 cChunkMaxTiles = 4;

   const uint32 cBlockPixelWidthShift = 2;
   const uint32 cBlockPixelHeightShift = 2;

   const uint32 cBlockPixelWidth = 4;
   const uint32 cBlockPixelHeight = 4;

   const uint32 cNumChunkEncodings = 8;
   extern chunk_encoding_desc g_chunk_encodings[cNumChunkEncodings];

   const uint32 cNumChunkTileLayouts = 9;
   const uint32 cFirst4x4ChunkTileLayout = 5;
   extern chunk_tile_desc g_chunk_tile_layouts[cNumChunkTileLayouts];

} // namespace crnd

// File: crnd_prefix_coding.h
#ifdef _XBOX
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 1
#else
#define CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE 0
#endif

namespace crnd
{
   namespace prefix_coding
   {
	  const uint32 cMaxExpectedCodeSize = 16;
	  const uint32 cMaxSupportedSyms = 8192;
	  const uint32 cMaxTableBits = 11;

	  class decoder_tables
	  {
	  public:
		 inline decoder_tables() :
			m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
		 {
		 }

		 inline decoder_tables(const decoder_tables& other) :
			m_cur_lookup_size(0), m_lookup(NULL), m_cur_sorted_symbol_order_size(0), m_sorted_symbol_order(NULL)
		 {
			*this = other;
		 }

		 decoder_tables& operator= (const decoder_tables& other)
		 {
			if (this == &other)
			   return *this;

			clear();

			memcpy(this, &other, sizeof(*this));

			if (other.m_lookup)
			{
			   m_lookup = crnd_new_array<uint32>(m_cur_lookup_size);
			   if (m_lookup)
				  memcpy(m_lookup, other.m_lookup, sizeof(m_lookup[0]) * m_cur_lookup_size);
			}

			if (other.m_sorted_symbol_order)
			{
			   m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
			   if (m_sorted_symbol_order)
				  memcpy(m_sorted_symbol_order, other.m_sorted_symbol_order, sizeof(m_sorted_symbol_order[0]) * m_cur_sorted_symbol_order_size);
			}

			return *this;
		 }

		 inline void clear()
		 {
			if (m_lookup)
			{
			   crnd_delete_array(m_lookup);
			   m_lookup = 0;
			   m_cur_lookup_size = 0;
			}

			if (m_sorted_symbol_order)
			{
			   crnd_delete_array(m_sorted_symbol_order);
			   m_sorted_symbol_order = NULL;
			   m_cur_sorted_symbol_order_size = 0;
			}
		 }

		 inline ~decoder_tables()
		 {
			if (m_lookup)
			   crnd_delete_array(m_lookup);

			if (m_sorted_symbol_order)
			   crnd_delete_array(m_sorted_symbol_order);
		 }

		 bool init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits);

		 // DO NOT use any complex classes here - it is bitwise copied.

		 uint32                  m_num_syms;
		 uint32                  m_total_used_syms;
		 uint32                  m_table_bits;
		 uint32                  m_table_shift;
		 uint32                  m_table_max_code;
		 uint32                  m_decode_start_code_size;

		 uint8                   m_min_code_size;
		 uint8                   m_max_code_size;

		 uint32                  m_max_codes[cMaxExpectedCodeSize + 1];
		 int32                   m_val_ptrs[cMaxExpectedCodeSize + 1];

		 uint32                  m_cur_lookup_size;
		 uint32*                 m_lookup;

		 uint32                  m_cur_sorted_symbol_order_size;
		 uint16*                 m_sorted_symbol_order;

		 inline uint32 get_unshifted_max_code(uint32 len) const
		 {
			CRND_ASSERT( (len >= 1) && (len <= cMaxExpectedCodeSize) );
			uint32 k = m_max_codes[len - 1];
			if (!k)
			   return crnd::cUINT32_MAX;
			return (k - 1) >> (16 - len);
		 }
	  };

   } // namespace prefix_coding

} // namespace crnd

// File: crnd_symbol_codec.h
namespace crnd
{
   class static_huffman_data_model
   {
   public:
	  static_huffman_data_model();
	  static_huffman_data_model(const static_huffman_data_model& other);
	  ~static_huffman_data_model();

	  static_huffman_data_model& operator= (const static_huffman_data_model& rhs);

	  bool init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit);
	  void clear();

	  inline bool is_valid() const { return m_pDecode_tables != NULL; }

	  inline uint32 get_total_syms() const { return m_total_syms; }

	  inline uint32 get_code_size(uint32 sym) const { return m_code_sizes[sym]; }

	  inline const uint8* get_code_sizes() const { return m_code_sizes.empty() ? NULL : &m_code_sizes[0]; }

   public:
	  uint32                           m_total_syms;
	  crnd::vector<uint8>              m_code_sizes;
	  prefix_coding::decoder_tables*   m_pDecode_tables;

   private:
	  bool prepare_decoder_tables();
	  uint compute_decoder_table_bits() const;

	  friend class symbol_codec;
   };

   class symbol_codec
   {
   public:
	  symbol_codec();

	  bool start_decoding(const uint8* pBuf, uint32 buf_size);
	  bool decode_receive_static_data_model(static_huffman_data_model& model);

	  uint32 decode_bits(uint32 num_bits);
	  uint32 decode(const static_huffman_data_model& model);

	  uint64 stop_decoding();

   public:
	  const uint8*         m_pDecode_buf;
	  const uint8*         m_pDecode_buf_next;
	  const uint8*         m_pDecode_buf_end;
	  uint32               m_decode_buf_size;

	  typedef uint32 bit_buf_type;
	  enum { cBitBufSize = 32U };
	  bit_buf_type         m_bit_buf;

	  int                  m_bit_count;

   private:
	  void get_bits_init();
	  uint32 get_bits(uint32 num_bits);
   };

} // namespace crnd

#define CRND_HUFF_DECODE_BEGIN(x)
#define CRND_HUFF_DECODE_END(x)
#define CRND_HUFF_DECODE(codec, model, symbol) symbol = codec.decode(model);

namespace crnd
{
   void crnd_assert(const char* pExp, const char* pFile, unsigned line)
   {
	  char buf[512];

#if defined(WIN32) && defined(_MSC_VER)
	  sprintf_s(buf, sizeof(buf), "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#else
	  sprintf(buf, "%s(%u): Assertion failure: \"%s\"\n", pFile, line, pExp);
#endif

	  crnd_output_debug_string(buf);

	  puts(buf);

	  if (crnd_is_debugger_present())
		 crnd_debug_break();
   }

   void crnd_trace(const char* pFmt, va_list args)
   {
	  if (crnd_is_debugger_present())
	  {
		 char buf[512];
#if defined(WIN32) && defined(_MSC_VER)
		 vsprintf_s(buf, sizeof(buf), pFmt, args);
#else
		 vsprintf(buf, pFmt, args);
#endif

		 crnd_output_debug_string(buf);
	  }
   };

   void crnd_trace(const char* pFmt, ...)
   {
	  va_list args;
	  va_start(args, pFmt);
	  crnd_trace(pFmt, args);
	  va_end(args);
   };

} // namespace crnd

// File: checksum.cpp
// From the public domain stb.h header.
namespace crnd
{
   uint16 crc16(const void* pBuf, uint32 len, uint16 crc)
   {
	  crc = ~crc;

	  const uint8* p = reinterpret_cast<const uint8*>(pBuf);
	  while (len)
	  {
		 const uint16 q = *p++ ^ (crc >> 8U);
		 crc <<= 8U;

		 uint16 r = (q >> 4U) ^ q;
		 crc ^= r;
		 r <<= 5U;
		 crc ^= r;
		 r <<= 7U;
		 crc ^= r;

		 len--;
	  }

	  return static_cast<uint16>(~crc);
   }

} // namespace crnd

// File: crnd_vector.cpp
namespace crnd
{
   bool elemental_vector::increase_capacity(uint32 min_new_capacity, bool grow_hint, uint32 element_size, object_mover pMover)
   {
	  CRND_ASSERT(m_size <= m_capacity);
	  CRND_ASSERT(min_new_capacity < (0x7FFF0000U / element_size));

	  if (m_capacity >= min_new_capacity)
		 return true;

	  uint32 new_capacity = min_new_capacity;
	  if ((grow_hint) && (!math::is_power_of_2(new_capacity)))
		 new_capacity = math::next_pow2(new_capacity);

	  CRND_ASSERT(new_capacity && (new_capacity > m_capacity));

	  const uint32 desired_size = element_size * new_capacity;
	  size_t actual_size;
	  if (!pMover)
	  {
		 void* new_p = crnd_realloc(m_p, desired_size, &actual_size, true);
		 if (!new_p)
			return false;
		 m_p = new_p;
	  }
	  else
	  {
		 void* new_p = crnd_malloc(desired_size, &actual_size);
		 if (!new_p)
			return false;

		 (*pMover)(new_p, m_p, m_size);

		 if (m_p)
			crnd_free(m_p);

		 m_p = new_p;
	  }

	  if (actual_size > desired_size)
		 m_capacity = static_cast<uint32>(actual_size / element_size);
	  else
		 m_capacity = new_capacity;

	  return true;
   }

} // namespace crnd

// File: crnd_utils.cpp
namespace crnd
{
   namespace utils
   {
	  uint32 compute_max_mips(uint32 width, uint32 height)
	  {
		 if ((width | height) == 0)
			return 0;

		 uint32 num_mips = 1;

		 while ((width > 1U) || (height > 1U))
		 {
			width >>= 1U;
			height >>= 1U;
			num_mips++;
		 }

		 return num_mips;
	  }

   } // namespace utils

} // namespace crnd

// File: crnd_prefix_coding.cpp
namespace crnd
{
   namespace prefix_coding
   {
	  bool decoder_tables::init(uint32 num_syms, const uint8* pCodesizes, uint32 table_bits)
	  {
		 uint32 min_codes[cMaxExpectedCodeSize];
		 if ((!num_syms) || (table_bits > cMaxTableBits))
			return false;

		 m_num_syms = num_syms;

		 uint32 num_codes[cMaxExpectedCodeSize + 1];
		 utils::zero_object(num_codes);

		 for (uint32 i = 0; i < num_syms; i++)
		 {
			uint32 c = pCodesizes[i];
			if (c)
			   num_codes[c]++;
		 }

		 uint32 sorted_positions[cMaxExpectedCodeSize + 1];

		 uint32 cur_code = 0;

		 uint32 total_used_syms = 0;
		 uint32 max_code_size = 0;
		 uint32 min_code_size = cUINT32_MAX;
		 for (uint32 i = 1; i <= cMaxExpectedCodeSize; i++)
		 {
			const uint32 n = num_codes[i];

			if (!n)
			   m_max_codes[i - 1] = 0;//UINT_MAX;
			else
			{
			   min_code_size = math::minimum(min_code_size, i);
			   max_code_size = math::maximum(max_code_size, i);

			   min_codes[i - 1] = cur_code;

			   m_max_codes[i - 1] = cur_code + n - 1;
			   m_max_codes[i - 1] = 1 + ((m_max_codes[i - 1] << (16 - i)) | ((1 << (16 - i)) - 1));

			   m_val_ptrs[i - 1] = total_used_syms;

			   sorted_positions[i] = total_used_syms;

			   cur_code += n;
			   total_used_syms += n;
			}

			cur_code <<= 1;
		 }

		 m_total_used_syms = total_used_syms;

		 if (total_used_syms > m_cur_sorted_symbol_order_size)
		 {
			m_cur_sorted_symbol_order_size = total_used_syms;

			if (!math::is_power_of_2(total_used_syms))
			   m_cur_sorted_symbol_order_size = math::minimum<uint32>(num_syms, math::next_pow2(total_used_syms));

			if (m_sorted_symbol_order)
			   crnd_delete_array(m_sorted_symbol_order);

			m_sorted_symbol_order = crnd_new_array<uint16>(m_cur_sorted_symbol_order_size);
			if (!m_sorted_symbol_order)
			   return false;
		 }

		 m_min_code_size = static_cast<uint8>(min_code_size);
		 m_max_code_size = static_cast<uint8>(max_code_size);

		 for (uint32 i = 0; i < num_syms; i++)
		 {
			uint32 c = pCodesizes[i];
			if (c)
			{
			   CRND_ASSERT(num_codes[c]);

			   uint32 sorted_pos = sorted_positions[c]++;

			   CRND_ASSERT(sorted_pos < total_used_syms);

			   m_sorted_symbol_order[sorted_pos] = static_cast<uint16>(i);
			}
		 }

		 if (table_bits <= m_min_code_size)
			table_bits = 0;
		 m_table_bits = table_bits;

		 if (table_bits)
		 {
			uint32 table_size = 1 << table_bits;
			if (table_size > m_cur_lookup_size)
			{
			   m_cur_lookup_size = table_size;

			   if (m_lookup)
				  crnd_delete_array(m_lookup);

			   m_lookup = crnd_new_array<uint32>(table_size);
			   if (!m_lookup)
				  return false;
			}

			memset(m_lookup, 0xFF, (uint)sizeof(m_lookup[0]) * (1UL << table_bits));

			for (uint32 codesize = 1; codesize <= table_bits; codesize++)
			{
			   if (!num_codes[codesize])
				  continue;

			   const uint32 fillsize = table_bits - codesize;
			   const uint32 fillnum = 1 << fillsize;

			   const uint32 min_code = min_codes[codesize - 1];
			   const uint32 max_code = get_unshifted_max_code(codesize);
			   const uint32 val_ptr = m_val_ptrs[codesize - 1];

			   for (uint32 code = min_code; code <= max_code; code++)
			   {
				  const uint32 sym_index = m_sorted_symbol_order[ val_ptr + code - min_code ];
				  CRND_ASSERT( pCodesizes[sym_index] == codesize );

				  for (uint32 j = 0; j < fillnum; j++)
				  {
					 const uint32 t = j + (code << fillsize);

					 CRND_ASSERT(t < (1U << table_bits));

					 CRND_ASSERT(m_lookup[t] == cUINT32_MAX);

					 m_lookup[t] = sym_index | (codesize << 16U);
				  }
			   }
			}
		 }

		 for (uint32 i = 0; i < cMaxExpectedCodeSize; i++)
			m_val_ptrs[i] -= min_codes[i];

		 m_table_max_code = 0;
		 m_decode_start_code_size = m_min_code_size;

		 if (table_bits)
		 {
			uint32 i;
			for (i = table_bits; i >= 1; i--)
			{
			   if (num_codes[i])
			   {
				  m_table_max_code = m_max_codes[i - 1];
				  break;
			   }
			}
			if (i >= 1)
			{
			   m_decode_start_code_size = table_bits + 1;
			   for (uint32 j = table_bits + 1; j <= max_code_size; j++)
			   {
				  if (num_codes[j])
				  {
					 m_decode_start_code_size = j;
					 break;
				  }
			   }
			}
		 }

		 // sentinels
		 m_max_codes[cMaxExpectedCodeSize] = cUINT32_MAX;
		 m_val_ptrs[cMaxExpectedCodeSize] = 0xFFFFF;

		 m_table_shift = 32 - m_table_bits;
		 return true;
	  }

   } // namespace prefix_codig

} // namespace crnd

// File: crnd_platform.cpp
namespace crnd
{
   bool crnd_is_debugger_present()
   {
#ifdef CRND_DEVEL
	  return IsDebuggerPresent() != 0;
#else
	  return false;
#endif
   }

   void crnd_debug_break()
   {
#ifdef CRND_DEVEL
	  DebugBreak();
#endif
   }

   void crnd_output_debug_string(const char* p)
   {
	  p;
#ifdef CRND_DEVEL
	  OutputDebugStringA(p);
#endif
   }

} // namespace crnd

// File: crnd_mem.cpp
namespace crnd
{
   const uint32 MAX_POSSIBLE_BLOCK_SIZE = 0x7FFF0000U;

   static void* crnd_default_realloc(void* p, size_t size, size_t* pActual_size, bool movable, void* pUser_data)
   {
	  pUser_data;

	  void* p_new;

	  if (!p)
	  {
		 p_new = ::malloc(size);

		 if (pActual_size)
		 {
#ifdef WIN32
			*pActual_size = p_new ? ::_msize(p_new) : 0;
#else
			*pActual_size = p_new ? malloc_usable_size(p_new) : 0;
#endif
		 }
	  }
	  else if (!size)
	  {
		 ::free(p);
		 p_new = NULL;

		 if (pActual_size)
			*pActual_size = 0;
	  }
	  else
	  {
		 void* p_final_block = p;
#ifdef WIN32
		 p_new = ::_expand(p, size);
#else
		 p_new = NULL;
#endif

		 if (p_new)
			p_final_block = p_new;
		 else if (movable)
		 {
			p_new = ::realloc(p, size);

			if (p_new)
			   p_final_block = p_new;
		 }

		 if (pActual_size)
		 {
#ifdef WIN32
			*pActual_size = ::_msize(p_final_block);
#else
			*pActual_size = ::malloc_usable_size(p_final_block);
#endif
		 }
	  }

	  return p_new;
   }

   static size_t crnd_default_msize(void* p, void* pUser_data)
   {
	  pUser_data;
#ifdef WIN32
	  return p ? _msize(p) : 0;
#else
	  return p ? malloc_usable_size(p) : 0;
#endif
   }

   static crnd_realloc_func        g_pRealloc = crnd_default_realloc;
   static crnd_msize_func          g_pMSize   = crnd_default_msize;
   static void*                   g_pUser_data;

   void crnd_set_memory_callbacks(crnd_realloc_func pRealloc, crnd_msize_func pMSize, void* pUser_data)
   {
	  if ((!pRealloc) || (!pMSize))
	  {
		 g_pRealloc = crnd_default_realloc;
		 g_pMSize = crnd_default_msize;
		 g_pUser_data = NULL;
	  }
	  else
	  {
		 g_pRealloc = pRealloc;
		 g_pMSize = pMSize;
		 g_pUser_data = pUser_data;
	  }
   }

   static inline void crnd_mem_error(const char* p_msg)
   {
	  crnd_assert(p_msg, __FILE__, __LINE__);
   }

   void* crnd_malloc(size_t size, size_t* pActual_size)
   {
	  size = (size + sizeof(uint32) - 1U) & ~(sizeof(uint32) - 1U);
	  if (!size)
		 size = sizeof(uint32);

	  if (size > MAX_POSSIBLE_BLOCK_SIZE)
	  {
		 crnd_mem_error("crnd_malloc: size too big");
		 return NULL;
	  }

	  size_t actual_size = size;
	  uint8* p_new = static_cast<uint8*>((*g_pRealloc)(NULL, size, &actual_size, true, g_pUser_data));

	  if (pActual_size)
		 *pActual_size = actual_size;

	  if ((!p_new) || (actual_size < size))
	  {
		 crnd_mem_error("crnd_malloc: out of memory");
		 return NULL;
	  }

	  CRND_ASSERT((reinterpret_cast<uintptr_t>(p_new) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

	  return p_new;
   }

   void* crnd_realloc(void* p, size_t size, size_t* pActual_size, bool movable)
   {
	  if (reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
	  {
		 crnd_mem_error("crnd_realloc: bad ptr");
		 return NULL;
	  }

	  if (size > MAX_POSSIBLE_BLOCK_SIZE)
	  {
		 crnd_mem_error("crnd_malloc: size too big");
		 return NULL;
	  }

	  size_t actual_size = size;
	  void* p_new = (*g_pRealloc)(p, size, &actual_size, movable, g_pUser_data);

	  if (pActual_size)
		 *pActual_size = actual_size;

	  CRND_ASSERT((reinterpret_cast<uintptr_t>(p_new) & (CRND_MIN_ALLOC_ALIGNMENT - 1)) == 0);

	  return p_new;
   }

   void crnd_free(void* p)
   {
	  if (!p)
		 return;

	  if (reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
	  {
		 crnd_mem_error("crnd_free: bad ptr");
		 return;
	  }

	  (*g_pRealloc)(p, 0, NULL, true, g_pUser_data);
   }

   size_t crnd_msize(void* p)
   {
	  if (!p)
		 return 0;

	  if (reinterpret_cast<uintptr_t>(p) & (CRND_MIN_ALLOC_ALIGNMENT - 1))
	  {
		 crnd_mem_error("crnd_msize: bad ptr");
		 return 0;
	  }

	  return (*g_pMSize)(p, g_pUser_data);
   }

} // namespace crnd

// File: crnd_math.cpp
namespace crnd
{
   namespace math
   {
	  uint32 g_bitmasks[32] =
	  {
		 1U <<  0U,         1U <<  1U,          1U <<  2U,        1U <<  3U,
		 1U <<  4U,         1U <<  5U,          1U <<  6U,        1U <<  7U,
		 1U <<  8U,         1U <<  9U,          1U << 10U,        1U << 11U,
		 1U << 12U,         1U << 13U,          1U << 14U,        1U << 15U,
		 1U << 16U,         1U << 17U,          1U << 18U,        1U << 19U,
		 1U << 20U,         1U << 21U,          1U << 22U,        1U << 23U,
		 1U << 24U,         1U << 25U,          1U << 26U,        1U << 27U,
		 1U << 28U,         1U << 29U,          1U << 30U,        1U << 31U
	  };

   } // namespace math
} // namespace crnd

// File: crnd_info.cpp
namespace crnd
{
#define CRND_FOURCC(a, b, c, d) ((a) | ((b) << 8U) | ((c) << 16U) | ((d) << 24U))

   uint32 crnd_crn_format_to_fourcc(crn_format fmt)
   {
	  switch (fmt)
	  {
		 case cCRNFmtDXT1:        return CRND_FOURCC('D', 'X', 'T', '1');
		 case cCRNFmtDXT3:        return CRND_FOURCC('D', 'X', 'T', '3');
		 case cCRNFmtDXT5:        return CRND_FOURCC('D', 'X', 'T', '5');
		 case cCRNFmtDXN_XY:      return CRND_FOURCC('A', '2', 'X', 'Y');
		 case cCRNFmtDXN_YX:      return CRND_FOURCC('A', 'T', 'I', '2');
		 case cCRNFmtDXT5A:       return CRND_FOURCC('A', 'T', 'I', '1');
		 case cCRNFmtDXT5_CCxY:   return CRND_FOURCC('C', 'C', 'x', 'Y');
		 case cCRNFmtDXT5_xGxR:   return CRND_FOURCC('x', 'G', 'x', 'R');
		 case cCRNFmtDXT5_xGBR:   return CRND_FOURCC('x', 'G', 'B', 'R');
		 case cCRNFmtDXT5_AGBR:   return CRND_FOURCC('A', 'G', 'B', 'R');
		 case cCRNFmtETC1:        return CRND_FOURCC('E', 'T', 'C', '1');
		 default: break;
	  }
	  CRND_ASSERT(false);
	  return 0;
   }

   crn_format crnd_get_fundamental_dxt_format(crn_format fmt)
   {
	  switch (fmt)
	  {
		 case cCRNFmtDXT5_CCxY:
		 case cCRNFmtDXT5_xGxR:
		 case cCRNFmtDXT5_xGBR:
		 case cCRNFmtDXT5_AGBR:
			return cCRNFmtDXT5;
		 default: break;
	  }
	  return fmt;
   }

   uint32 crnd_get_crn_format_bits_per_texel(crn_format fmt)
   {
	  switch (fmt)
	  {
		 case cCRNFmtDXT1:
		 case cCRNFmtDXT5A:
		 case cCRNFmtETC1:
			return 4;
		 case cCRNFmtDXT3:
		 case cCRNFmtDXT5:
		 case cCRNFmtDXN_XY:
		 case cCRNFmtDXN_YX:
		 case cCRNFmtDXT5_CCxY:
		 case cCRNFmtDXT5_xGxR:
		 case cCRNFmtDXT5_xGBR:
		 case cCRNFmtDXT5_AGBR:
			return 8;
		 default: break;
	  }
	  CRND_ASSERT(false);
	  return 0;
   }

   uint32 crnd_get_bytes_per_dxt_block(crn_format fmt)
   {
	  return (crnd_get_crn_format_bits_per_texel(fmt) << 4) >> 3;
   }

   // TODO: tmp_header isn't used/This function is a helper to support old headers.
   const crn_header* crnd_get_header(crn_header& tmp_header, const void* pData, uint32 data_size)
   {
	  tmp_header;

	  if ((!pData) || (data_size < sizeof(crn_header)))
		 return NULL;

	  const crn_header& file_header = *static_cast<const crn_header*>(pData);
	  if (file_header.m_sig != crn_header::cCRNSigValue)
		 return NULL;

	  if ((file_header.m_header_size < sizeof(crn_header)) || (data_size < file_header.m_data_size))
		 return NULL;

	  return &file_header;
   }

   bool crnd_validate_file(const void* pData, uint32 data_size, crn_file_info* pFile_info)
   {
	  if (pFile_info)
	  {
		 if (pFile_info->m_struct_size != sizeof(crn_file_info))
			return false;

		 memset(&pFile_info->m_struct_size + 1, 0, sizeof(crn_file_info) - sizeof(pFile_info->m_struct_size));
	  }

	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  const uint32 header_crc = crc16(&pHeader->m_data_size, (uint32)(pHeader->m_header_size - ((const uint8*)&pHeader->m_data_size - (const uint8*)pHeader)));
	  if (header_crc != pHeader->m_header_crc16)
		 return false;

	  const uint32 data_crc = crc16((const uint8*)pData + pHeader->m_header_size, pHeader->m_data_size - pHeader->m_header_size);
	  if (data_crc != pHeader->m_data_crc16)
		 return false;

	  if ((pHeader->m_faces != 1) && (pHeader->m_faces != 6))
		 return false;
	  if ((pHeader->m_width < 1) || (pHeader->m_width > cCRNMaxLevelResolution))
		 return false;
	  if ((pHeader->m_height < 1) || (pHeader->m_height > cCRNMaxLevelResolution))
		 return false;
	  if ((pHeader->m_levels < 1) || (pHeader->m_levels > utils::compute_max_mips(pHeader->m_width, pHeader->m_height)))
		 return false;
	  if (((int)pHeader->m_format < cCRNFmtDXT1) || ((int)pHeader->m_format >= cCRNFmtTotal))
		 return false;

	  if (pFile_info)
	  {
		 pFile_info->m_actual_data_size = pHeader->m_data_size;
		 pFile_info->m_header_size = pHeader->m_header_size;
		 pFile_info->m_total_palette_size = pHeader->m_color_endpoints.m_size + pHeader->m_color_selectors.m_size + pHeader->m_alpha_endpoints.m_size + pHeader->m_alpha_selectors.m_size;
		 pFile_info->m_tables_size = pHeader->m_tables_size;

		 pFile_info->m_levels = pHeader->m_levels;

		 for (uint32 i = 0; i < pHeader->m_levels; i++)
		 {
			uint32 next_ofs = pHeader->m_data_size;

			// assumes the levels are packed together sequentially
			if ((i + 1) < pHeader->m_levels)
			   next_ofs = pHeader->m_level_ofs[i + 1];

			pFile_info->m_level_compressed_size[i] = next_ofs - pHeader->m_level_ofs[i];
		 }

		 pFile_info->m_color_endpoint_palette_entries = pHeader->m_color_endpoints.m_num;
		 pFile_info->m_color_selector_palette_entries = pHeader->m_color_selectors.m_num;;
		 pFile_info->m_alpha_endpoint_palette_entries = pHeader->m_alpha_endpoints.m_num;;
		 pFile_info->m_alpha_selector_palette_entries = pHeader->m_alpha_selectors.m_num;;
	  }

	  return true;
   }

   bool crnd_get_texture_info(const void* pData, uint32 data_size, crn_texture_info* pInfo)
   {
	  if ((!pData) || (data_size < sizeof(crn_header)) || (!pInfo))
		 return false;

	  if (pInfo->m_struct_size != sizeof(crn_texture_info))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  pInfo->m_width = pHeader->m_width;
	  pInfo->m_height = pHeader->m_height;
	  pInfo->m_levels = pHeader->m_levels;
	  pInfo->m_faces = pHeader->m_faces;
	  pInfo->m_format = static_cast<crn_format>((uint32)pHeader->m_format);
	  pInfo->m_bytes_per_block = ((pHeader->m_format == cCRNFmtDXT1) || (pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;
	  pInfo->m_userdata0 = pHeader->m_userdata0;
	  pInfo->m_userdata1 = pHeader->m_userdata1;

	  return true;
   }

   bool crnd_get_level_info(const void* pData, uint32 data_size, uint32 level_index, crn_level_info* pLevel_info)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize) || (!pLevel_info))
		 return false;

	  if (pLevel_info->m_struct_size != sizeof(crn_level_info))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  if (level_index >= pHeader->m_levels)
		 return false;

	  uint32 width = math::maximum<uint32>(1U, pHeader->m_width >> level_index);
	  uint32 height = math::maximum<uint32>(1U, pHeader->m_height >> level_index);

	  pLevel_info->m_width = width;
	  pLevel_info->m_height = height;
	  pLevel_info->m_faces = pHeader->m_faces;
	  pLevel_info->m_blocks_x = (width + 3) >> 2;
	  pLevel_info->m_blocks_y = (height + 3) >> 2;
	  pLevel_info->m_bytes_per_block = ((pHeader->m_format == cCRNFmtDXT1) || (pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;
	  pLevel_info->m_format = static_cast<crn_format>((uint32)pHeader->m_format);

	  return true;
   }

   const void* crnd_get_level_data(const void* pData, uint32 data_size, uint32 level_index, uint32* pSize)
   {
	  if (pSize)
		 *pSize = 0;

	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return 0;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return 0;

	  if (level_index >= pHeader->m_levels)
		 return 0;

	  uint32 cur_level_ofs = pHeader->m_level_ofs[level_index];

	  if (pSize)
	  {
		 uint32 next_level_ofs = data_size;
		 if ((level_index + 1) < (pHeader->m_levels))
			next_level_ofs = pHeader->m_level_ofs[level_index + 1];

		 *pSize = next_level_ofs - cur_level_ofs;
	  }

	  return static_cast<const uint8*>(pData) + cur_level_ofs;
   }

   uint32 crnd_get_segmented_file_size(const void* pData, uint32 data_size)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  uint32 size = pHeader->m_header_size;

	  size = math::maximum(size, pHeader->m_color_endpoints.m_ofs + pHeader->m_color_endpoints.m_size);
	  size = math::maximum(size, pHeader->m_color_selectors.m_ofs + pHeader->m_color_selectors.m_size);
	  size = math::maximum(size, pHeader->m_alpha_endpoints.m_ofs + pHeader->m_alpha_endpoints.m_size);
	  size = math::maximum(size, pHeader->m_alpha_selectors.m_ofs + pHeader->m_alpha_selectors.m_size);
	  size = math::maximum(size, pHeader->m_tables_ofs + pHeader->m_tables_size);

	  return size;
   }

   bool crnd_create_segmented_file(const void* pData, uint32 data_size, void* pBase_data, uint base_data_size)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return false;

	  crn_header tmp_header;
	  const crn_header* pHeader = crnd_get_header(tmp_header, pData, data_size);
	  if (!pHeader)
		 return false;

	  if (pHeader->m_flags & cCRNHeaderFlagSegmented)
		 return false;

	  const uint actual_base_data_size = crnd_get_segmented_file_size(pData, data_size);
	  if (base_data_size < actual_base_data_size)
		 return false;

	  memcpy(pBase_data, pData, actual_base_data_size);

	  crn_header& new_header = *static_cast<crn_header*>(pBase_data);
	  new_header.m_flags = new_header.m_flags | cCRNHeaderFlagSegmented;
	  new_header.m_data_size = actual_base_data_size;

	  new_header.m_data_crc16 = crc16((const uint8*)pBase_data + new_header.m_header_size, new_header.m_data_size - new_header.m_header_size);

	  new_header.m_header_crc16 = crc16(&new_header.m_data_size, new_header.m_header_size - (uint32)((const uint8*)&new_header.m_data_size - (const uint8*)&new_header));

	  CRND_ASSERT(crnd_validate_file(&new_header, actual_base_data_size, NULL));

	  return true;
   }

} // namespace crnd

// File: symbol_codec.cpp
namespace crnd
{
   static_huffman_data_model::static_huffman_data_model() :
m_total_syms(0),
m_pDecode_tables(NULL)
{
}

static_huffman_data_model::static_huffman_data_model(const static_huffman_data_model& other) :
m_total_syms(0),
m_pDecode_tables(NULL)
{
   *this = other;
}

static_huffman_data_model::~static_huffman_data_model()
{
   if (m_pDecode_tables)
	  crnd_delete(m_pDecode_tables);
}

static_huffman_data_model& static_huffman_data_model::operator=(const static_huffman_data_model& rhs)
{
   if (this == &rhs)
	  return *this;

   m_total_syms = rhs.m_total_syms;
   m_code_sizes = rhs.m_code_sizes;
   if (m_code_sizes.get_alloc_failed())
   {
	  clear();
	  return *this;
   }

   if (rhs.m_pDecode_tables)
   {
	  if (m_pDecode_tables)
		 *m_pDecode_tables = *rhs.m_pDecode_tables;
	  else
		 m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>(*rhs.m_pDecode_tables);
   }
   else
   {
	  crnd_delete(m_pDecode_tables);
	  m_pDecode_tables = NULL;
   }

   return *this;
}

void static_huffman_data_model::clear()
{
   m_total_syms = 0;
   m_code_sizes.clear();
   if (m_pDecode_tables)
   {
	  crnd_delete(m_pDecode_tables);
	  m_pDecode_tables = NULL;
   }
}

bool static_huffman_data_model::init(uint32 total_syms, const uint8* pCode_sizes, uint32 code_size_limit)
{
   CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms) && (code_size_limit >= 1));

   code_size_limit = math::minimum(code_size_limit, prefix_coding::cMaxExpectedCodeSize);

   if (!m_code_sizes.resize(total_syms))
	  return false;

   uint32 min_code_size = cUINT32_MAX;
   uint32 max_code_size = 0;

   for (uint32 i = 0; i < total_syms; i++)
   {
	  uint32 s = pCode_sizes[i];
	  m_code_sizes[i] = static_cast<uint8>(s);
	  min_code_size = math::minimum(min_code_size, s);
	  max_code_size = math::maximum(max_code_size, s);
   }

   if ((max_code_size < 1) || (max_code_size > 32) || (min_code_size > code_size_limit))
	  return false;

   if (max_code_size > code_size_limit)
	  return false;

   if (!m_pDecode_tables)
	  m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

   if (!m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits()))
	  return false;

   return true;
}

bool static_huffman_data_model::prepare_decoder_tables()
{
   uint32 total_syms = m_code_sizes.size();

   CRND_ASSERT((total_syms >= 1) && (total_syms <= prefix_coding::cMaxSupportedSyms));

   m_total_syms = total_syms;

   if (!m_pDecode_tables)
	  m_pDecode_tables = crnd_new<prefix_coding::decoder_tables>();

   return m_pDecode_tables->init(m_total_syms, &m_code_sizes[0], compute_decoder_table_bits());
}

uint static_huffman_data_model::compute_decoder_table_bits() const
{
#if CRND_PREFIX_CODING_USE_FIXED_TABLE_SIZE
   return prefix_coding::cMaxTableBits;
#else
   uint32 decoder_table_bits = 0;
   if (m_total_syms > 16)
	  decoder_table_bits = static_cast<uint8>(math::minimum(1 + math::ceil_log2i(m_total_syms), prefix_coding::cMaxTableBits));
   return decoder_table_bits;
#endif
}

symbol_codec::symbol_codec() :
  m_pDecode_buf(NULL),
  m_pDecode_buf_next(NULL),
  m_pDecode_buf_end(NULL),
  m_decode_buf_size(0),
  m_bit_buf(0),
  m_bit_count(0)
{
}

// Code length encoding symbols:
// 0-16 - actual code lengths
const uint32 cMaxCodelengthCodes      = 21;

const uint32 cSmallZeroRunCode        = 17;
const uint32 cLargeZeroRunCode        = 18;
const uint32 cSmallRepeatCode         = 19;
const uint32 cLargeRepeatCode         = 20;

const uint32 cMinSmallZeroRunSize     = 3;
const uint32 cMaxSmallZeroRunSize     = 10;
const uint32 cMinLargeZeroRunSize     = 11;
const uint32 cMaxLargeZeroRunSize     = 138;

const uint32 cSmallMinNonZeroRunSize  = 3;
const uint32 cSmallMaxNonZeroRunSize  = 6;
const uint32 cLargeMinNonZeroRunSize  = 7;
const uint32 cLargeMaxNonZeroRunSize  = 70;

const uint32 cSmallZeroRunExtraBits   = 3;
const uint32 cLargeZeroRunExtraBits   = 7;
const uint32 cSmallNonZeroRunExtraBits = 2;
const uint32 cLargeNonZeroRunExtraBits = 6;

static const uint8 g_most_probable_codelength_codes[] =
{
   cSmallZeroRunCode, cLargeZeroRunCode,
   cSmallRepeatCode,  cLargeRepeatCode,

   0, 8,
   7, 9,
   6, 10,
   5, 11,
   4, 12,
   3, 13,
   2, 14,
   1, 15,
   16
};
const uint32 cNumMostProbableCodelengthCodes = sizeof(g_most_probable_codelength_codes) / sizeof(g_most_probable_codelength_codes[0]);

bool symbol_codec::decode_receive_static_data_model(static_huffman_data_model& model)
{
   const uint32 total_used_syms = decode_bits(math::total_bits(prefix_coding::cMaxSupportedSyms));

   if (!total_used_syms)
   {
	  model.clear();
	  return true;
   }

   if (!model.m_code_sizes.resize(total_used_syms))
	  return false;

   memset(&model.m_code_sizes[0], 0, sizeof(model.m_code_sizes[0]) * total_used_syms);

   const uint32 num_codelength_codes_to_send = decode_bits(5);
   if ((num_codelength_codes_to_send < 1) || (num_codelength_codes_to_send > cMaxCodelengthCodes))
	  return false;

   static_huffman_data_model dm;
   if (!dm.m_code_sizes.resize(cMaxCodelengthCodes))
	  return false;

   for (uint32 i = 0; i < num_codelength_codes_to_send; i++)
	  dm.m_code_sizes[g_most_probable_codelength_codes[i]] = static_cast<uint8>(decode_bits(3));

   if (!dm.prepare_decoder_tables())
	  return false;

   uint32 ofs = 0;
   while (ofs < total_used_syms)
   {
	  const uint32 num_remaining = total_used_syms - ofs;

	  uint32 code = decode(dm);
	  if (code <= 16)
		 model.m_code_sizes[ofs++] = static_cast<uint8>(code);
	  else if (code == cSmallZeroRunCode)
	  {
		 uint32 len = decode_bits(cSmallZeroRunExtraBits) + cMinSmallZeroRunSize;
		 if (len > num_remaining)
			return false;
		 ofs += len;
	  }
	  else if (code == cLargeZeroRunCode)
	  {
		 uint32 len = decode_bits(cLargeZeroRunExtraBits) + cMinLargeZeroRunSize;
		 if (len > num_remaining)
			return false;
		 ofs += len;
	  }
	  else if ((code == cSmallRepeatCode) || (code == cLargeRepeatCode))
	  {
		 uint32 len;
		 if (code == cSmallRepeatCode)
			len = decode_bits(cSmallNonZeroRunExtraBits) + cSmallMinNonZeroRunSize;
		 else
			len = decode_bits(cLargeNonZeroRunExtraBits) + cLargeMinNonZeroRunSize;

		 if ((!ofs) || (len > num_remaining))
			return false;
		 const uint32 prev = model.m_code_sizes[ofs - 1];
		 if (!prev)
			return false;
		 const uint32 end = ofs + len;
		 while (ofs < end)
			model.m_code_sizes[ofs++] = static_cast<uint8>(prev);
	  }
	  else
	  {
		 CRND_ASSERT(0);
		 return false;
	  }
   }

   if (ofs != total_used_syms)
	  return false;

   return model.prepare_decoder_tables();
}

bool symbol_codec::start_decoding(const uint8* pBuf, uint32 buf_size)
{
   if (!buf_size)
	  return false;

   m_pDecode_buf = pBuf;
   m_pDecode_buf_next = pBuf;
   m_decode_buf_size = buf_size;
   m_pDecode_buf_end = pBuf + buf_size;

   get_bits_init();

   return true;
}

void symbol_codec::get_bits_init()
{
   m_bit_buf = 0;
   m_bit_count = 0;
}

uint32 symbol_codec::decode_bits(uint32 num_bits)
{
   if (!num_bits)
	  return 0;

   if (num_bits > 16)
   {
	  uint32 a = get_bits(num_bits - 16);
	  uint32 b = get_bits(16);

	  return (a << 16) | b;
   }
   else
	  return get_bits(num_bits);
}

uint32 symbol_codec::get_bits(uint32 num_bits)
{
   CRND_ASSERT(num_bits <= 32U);

   while (m_bit_count < (int)num_bits)
   {
	  bit_buf_type c = 0;
	  if (m_pDecode_buf_next != m_pDecode_buf_end)
		 c = *m_pDecode_buf_next++;

	  m_bit_count += 8;
	  CRND_ASSERT(m_bit_count <= cBitBufSize);

	  m_bit_buf |= (c << (cBitBufSize - m_bit_count));
   }

   uint32 result = static_cast<uint32>(m_bit_buf >> (cBitBufSize - num_bits));

   m_bit_buf <<= num_bits;
   m_bit_count -= num_bits;

   return result;
}

uint32 symbol_codec::decode(const static_huffman_data_model& model)
{
   const prefix_coding::decoder_tables* pTables = model.m_pDecode_tables;

   if (m_bit_count < 24)
   {
	  if (m_bit_count < 16)
	  {
		 uint32 c0 = 0, c1 = 0;
		 const uint8* p = m_pDecode_buf_next;
		 if (p < m_pDecode_buf_end) c0 = *p++;
		 if (p < m_pDecode_buf_end) c1 = *p++;
		 m_pDecode_buf_next = p;
		 m_bit_count += 16;
		 uint32 c = (c0 << 8) | c1;
		 m_bit_buf |= (c << (32 - m_bit_count));
	  }
	  else
	  {
		 uint32 c = (m_pDecode_buf_next < m_pDecode_buf_end) ? *m_pDecode_buf_next++ : 0;
		 m_bit_count += 8;
		 m_bit_buf |= (c << (32 - m_bit_count));
	  }
   }

   uint32 k = (m_bit_buf >> 16) + 1;
   uint32 sym, len;

   if (k <= pTables->m_table_max_code)
   {
	  uint32 t = pTables->m_lookup[m_bit_buf >> (32 - pTables->m_table_bits)];

	  CRND_ASSERT(t != cUINT32_MAX);
	  sym = t & cUINT16_MAX;
	  len = t >> 16;

	  CRND_ASSERT(model.m_code_sizes[sym] == len);
   }
   else
   {
	  len = pTables->m_decode_start_code_size;

	  for ( ; ; )
	  {
		 if (k <= pTables->m_max_codes[len - 1])
			break;
		 len++;
	  }

	  int val_ptr = pTables->m_val_ptrs[len - 1] + (m_bit_buf >> (32 - len));

	  if (((uint32)val_ptr >= model.m_total_syms))
	  {
		 // corrupted stream, or a bug
		 CRND_ASSERT(0);
		 return 0;
	  }

	  sym = pTables->m_sorted_symbol_order[val_ptr];
   }

   m_bit_buf <<= len;
   m_bit_count -= len;

   return sym;
}

   uint64 symbol_codec::stop_decoding()
   {
#if 0
	  uint32 i = get_bits(4);
	  uint32 k = get_bits(3);
	  i, k;
	  CRND_ASSERT((i == 15) && (k == 3));
#endif

	  uint64 n = static_cast<uint64>(m_pDecode_buf_next - m_pDecode_buf);

	  return n;
   }

} // namespace crnd

// File: crnd_dxt_hc_common.cpp
namespace crnd
{
   chunk_encoding_desc g_chunk_encodings[cNumChunkEncodings] =
   {
	  { 1, { { 0, 0, 8, 8, 0 } } },

	  { 2, { { 0, 0, 8, 4, 1 }, { 0, 4, 8, 4, 2 } } },
	  { 2, { { 0, 0, 4, 8, 3 }, { 4, 0, 4, 8, 4 } } },

	  { 3, { { 0, 0, 8, 4, 1 }, { 0, 4, 4, 4, 7 }, { 4, 4, 4, 4, 8 } } },
	  { 3, { { 0, 4, 8, 4, 2 }, { 0, 0, 4, 4, 5 }, { 4, 0, 4, 4, 6 } } },

	  { 3, { { 0, 0, 4, 8, 3 }, { 4, 0, 4, 4, 6 }, { 4, 4, 4, 4, 8 } } },
	  { 3, { { 4, 0, 4, 8, 4 }, { 0, 0, 4, 4, 5 }, { 0, 4, 4, 4, 7 } } },

	  { 4, { { 0, 0, 4, 4, 5 }, { 4, 0, 4, 4, 6 }, { 0, 4, 4, 4, 7 }, { 4, 4, 4, 4, 8 } } }
   };

   chunk_tile_desc g_chunk_tile_layouts[cNumChunkTileLayouts] =
   {
	  // 2x2
	  { 0, 0, 8, 8, 0 },

	  // 2x1
	  { 0, 0, 8, 4, 1 },
	  { 0, 4, 8, 4, 2 },

	  // 1x2
	  { 0, 0, 4, 8, 3 },
	  { 4, 0, 4, 8, 4 },

	  // 1x1
	  { 0, 0, 4, 4, 5 },
	  { 4, 0, 4, 4, 6 },
	  { 0, 4, 4, 4, 7 },
	  { 4, 4, 4, 4, 8 }
   };

} // namespace crnd

// File: crnd_dxt.cpp
namespace crnd
{
   const uint8 g_dxt1_to_linear[cDXT1SelectorValues]     = { 0U, 3U, 1U, 2U };
   const uint8 g_dxt1_from_linear[cDXT1SelectorValues]   = { 0U, 2U, 3U, 1U };

   const uint8 g_dxt5_to_linear[cDXT5SelectorValues]     = { 0U, 7U, 1U, 2U, 3U, 4U, 5U, 6U };
   const uint8 g_dxt5_from_linear[cDXT5SelectorValues]   = { 0U, 2U, 3U, 4U, 5U, 6U, 7U, 1U };

   const uint8 g_six_alpha_invert_table[cDXT5SelectorValues] = { 1, 0, 5, 4, 3, 2, 6, 7 };
   const uint8 g_eight_alpha_invert_table[cDXT5SelectorValues] = { 1, 0, 7, 6, 5, 4, 3, 2 };

   uint16 dxt1_block::pack_color(const color_quad_u8& color, bool scaled, uint32 bias)
   {
	  uint32 r = color.r;
	  uint32 g = color.g;
	  uint32 b = color.b;

	  if (scaled)
	  {
		 r = (r * 31U + bias) / 255U;
		 g = (g * 63U + bias) / 255U;
		 b = (b * 31U + bias) / 255U;
	  }

	  r = math::minimum(r, 31U);
	  g = math::minimum(g, 63U);
	  b = math::minimum(b, 31U);

	  return static_cast<uint16>(b | (g << 5U) | (r << 11U));
   }

   uint16 dxt1_block::pack_color(uint32 r, uint32 g, uint32 b, bool scaled, uint32 bias)
   {
	  return pack_color(color_quad_u8(r, g, b, 0), scaled, bias);
   }

   color_quad_u8 dxt1_block::unpack_color(uint16 packed_color, bool scaled, uint32 alpha)
   {
	  uint32 b = packed_color & 31U;
	  uint32 g = (packed_color >> 5U) & 63U;
	  uint32 r = (packed_color >> 11U) & 31U;

	  if (scaled)
	  {
		 b = (b << 3U) | (b >> 2U);
		 g = (g << 2U) | (g >> 4U);
		 r = (r << 3U) | (r >> 2U);
	  }

	  return color_quad_u8(r, g, b, alpha);
   }

   void dxt1_block::unpack_color(uint32& r, uint32& g, uint32& b, uint16 packed_color, bool scaled)
   {
	  color_quad_u8 c(unpack_color(packed_color, scaled, 0));
	  r = c.r;
	  g = c.g;
	  b = c.b;
   }

   uint32 dxt1_block::get_block_colors3(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
	  color_quad_u8 c0(unpack_color(color0, true));
	  color_quad_u8 c1(unpack_color(color1, true));

	  pDst[0] = c0;
	  pDst[1] = c1;
	  pDst[2].set( (c0.r + c1.r) >> 1U, (c0.g + c1.g) >> 1U, (c0.b + c1.b) >> 1U, 255U);
	  pDst[3].set(0, 0, 0, 0);

	  return 3;
   }

   uint32 dxt1_block::get_block_colors4(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
	  color_quad_u8 c0(unpack_color(color0, true));
	  color_quad_u8 c1(unpack_color(color1, true));

	  pDst[0] = c0;
	  pDst[1] = c1;

	  // 12/14/09 - Supposed to round according to DX docs, but this conflicts with the OpenGL S3TC spec. ?
	  // Turns out some GPU's round and some don't. Great.
	  //pDst[2].set( (c0.r * 2 + c1.r + 1) / 3, (c0.g * 2 + c1.g + 1) / 3, (c0.b * 2 + c1.b + 1) / 3, 255U);
	  //pDst[3].set( (c1.r * 2 + c0.r + 1) / 3, (c1.g * 2 + c0.g + 1) / 3, (c1.b * 2 + c0.b + 1) / 3, 255U);

	  pDst[2].set( (c0.r * 2 + c1.r) / 3, (c0.g * 2 + c1.g) / 3, (c0.b * 2 + c1.b) / 3, 255U);
	  pDst[3].set( (c1.r * 2 + c0.r) / 3, (c1.g * 2 + c0.g) / 3, (c1.b * 2 + c0.b) / 3, 255U);

	  return 4;
   }

   uint32 dxt1_block::get_block_colors(color_quad_u8* pDst, uint16 color0, uint16 color1)
   {
	  if (color0 > color1)
		 return get_block_colors4(pDst, color0, color1);
	  else
		 return get_block_colors3(pDst, color0, color1);
   }

   color_quad_u8 dxt1_block::unpack_endpoint(uint32 endpoints, uint32 index, bool scaled, uint32 alpha)
   {
	  CRND_ASSERT(index < 2);
	  return unpack_color( static_cast<uint16>((endpoints >> (index * 16U)) & 0xFFFFU), scaled, alpha );
   }

   uint32 dxt1_block::pack_endpoints(uint32 lo, uint32 hi)
   {
	  CRND_ASSERT((lo <= 0xFFFFU) && (hi <= 0xFFFFU));
	  return lo | (hi << 16U);
   }

   void dxt3_block::set_alpha(uint32 x, uint32 y, uint32 value, bool scaled)
   {
	  CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

	  if (scaled)
	  {
		 CRND_ASSERT(value <= 0xFF);
		 value = (value * 15U + 128U) / 255U;
	  }
	  else
	  {
		 CRND_ASSERT(value <= 0xF);
	  }

	  uint32 ofs = (y << 1U) + (x >> 1U);
	  uint32 c = m_alpha[ofs];

	  c &= ~(0xF << ((x & 1U) << 2U));
	  c |= (value << ((x & 1U) << 2U));

	  m_alpha[ofs] = static_cast<uint8>(c);
   }

   uint32 dxt3_block::get_alpha(uint32 x, uint32 y, bool scaled) const
   {
	  CRND_ASSERT((x < cDXTBlockSize) && (y < cDXTBlockSize));

	  uint32 value = m_alpha[(y << 1U) + (x >> 1U)];
	  if (x & 1)
		 value >>= 4;
	  value &= 0xF;

	  if (scaled)
		 value = (value << 4U) | value;

	  return value;
   }

   uint32 dxt5_block::get_block_values6(color_quad_u8* pDst, uint32 l, uint32 h)
   {
	  pDst[0].a = static_cast<uint8>(l);
	  pDst[1].a = static_cast<uint8>(h);
	  pDst[2].a = static_cast<uint8>((l * 4 + h    ) / 5);
	  pDst[3].a = static_cast<uint8>((l * 3 + h * 2) / 5);
	  pDst[4].a = static_cast<uint8>((l * 2 + h * 3) / 5);
	  pDst[5].a = static_cast<uint8>((l     + h * 4) / 5);
	  pDst[6].a = 0;
	  pDst[7].a = 255;
	  return 6;
   }

   uint32 dxt5_block::get_block_values8(color_quad_u8* pDst, uint32 l, uint32 h)
   {
	  pDst[0].a = static_cast<uint8>(l);
	  pDst[1].a = static_cast<uint8>(h);
	  pDst[2].a = static_cast<uint8>((l * 6 + h    ) / 7);
	  pDst[3].a = static_cast<uint8>((l * 5 + h * 2) / 7);
	  pDst[4].a = static_cast<uint8>((l * 4 + h * 3) / 7);
	  pDst[5].a = static_cast<uint8>((l * 3 + h * 4) / 7);
	  pDst[6].a = static_cast<uint8>((l * 2 + h * 5) / 7);
	  pDst[7].a = static_cast<uint8>((l     + h * 6) / 7);
	  return 8;
   }

   uint32 dxt5_block::get_block_values(color_quad_u8* pDst, uint32 l, uint32 h)
   {
	  if (l > h)
		 return get_block_values8(pDst, l, h);
	  else
		 return get_block_values6(pDst, l, h);
   }

   uint32 dxt5_block::get_block_values6(uint32* pDst, uint32 l, uint32 h)
   {
	  pDst[0] = l;
	  pDst[1] = h;
	  pDst[2] = (l * 4 + h    ) / 5;
	  pDst[3] = (l * 3 + h * 2) / 5;
	  pDst[4] = (l * 2 + h * 3) / 5;
	  pDst[5] = (l     + h * 4) / 5;
	  pDst[6] = 0;
	  pDst[7] = 255;
	  return 6;
   }

   uint32 dxt5_block::get_block_values8(uint32* pDst, uint32 l, uint32 h)
   {
	  pDst[0] = l;
	  pDst[1] = h;
	  pDst[2] = (l * 6 + h    ) / 7;
	  pDst[3] = (l * 5 + h * 2) / 7;
	  pDst[4] = (l * 4 + h * 3) / 7;
	  pDst[5] = (l * 3 + h * 4) / 7;
	  pDst[6] = (l * 2 + h * 5) / 7;
	  pDst[7] = (l     + h * 6) / 7;
	  return 8;
   }

   uint32 dxt5_block::unpack_endpoint(uint32 packed, uint32 index)
   {
	  CRND_ASSERT(index < 2);
	  return (packed >> (8 * index)) & 0xFF;
   }

   uint32 dxt5_block::pack_endpoints(uint32 lo, uint32 hi)
   {
	  CRND_ASSERT((lo <= 0xFF) && (hi <= 0xFF));
	  return lo | (hi << 8U);
   }

   uint32 dxt5_block::get_block_values(uint32* pDst, uint32 l, uint32 h)
   {
	  if (l > h)
		 return get_block_values8(pDst, l, h);
	  else
		 return get_block_values6(pDst, l, h);
   }

} // namespace crnd

// File: crnd_decode.cpp
#define CRND_CREATE_BYTE_STREAMS 0

namespace crnd
{
#if CRND_CREATE_BYTE_STREAMS
   static void write_array_to_file(const char* pFilename, const vector<uint8>& buf)
   {
	  FILE* pFile = fopen(pFilename, "wb");
	  fwrite(&buf[0], buf.size(), 1, pFile);
	  fclose(pFile);
   }
#endif

   struct crnd_chunk_tile_desc
   {
	  // These values are in blocks
	  uint8 m_x_ofs;
	  uint8 m_y_ofs;
	  uint8 m_width;
	  uint8 m_height;
   };

   struct crnd_chunk_encoding_desc
   {
	  uint32 m_num_tiles;
	  chunk_tile_desc m_tiles[4];
   };

#if 0
   static crnd_chunk_encoding_desc g_crnd_chunk_encodings[cNumChunkEncodings] =
   {
	  { 1, { { 0, 0, 2, 2 } } },

	  { 2, { { 0, 0, 2, 1 }, { 0, 1, 2, 1 } } },
	  { 2, { { 0, 0, 1, 2 }, { 1, 0, 1, 2 } } },

	  { 3, { { 0, 0, 2, 1 }, { 0, 1, 1, 1 }, { 1, 1, 1, 1 } } },
	  { 3, { { 0, 1, 2, 1 }, { 0, 0, 1, 1 }, { 1, 0, 1, 1 } } },

	  { 3, { { 0, 0, 1, 2 }, { 1, 0, 1, 1 }, { 1, 1, 1, 1 } } },
	  { 3, { { 1, 0, 1, 2 }, { 0, 0, 1, 1 }, { 0, 1, 1, 1 } } },

	  { 1, { { 0, 0, 1, 1 }, { 1, 0, 1, 1 }, { 0, 1, 1, 1 }, { 1, 1, 1, 1 } } }
   };
#endif

   struct crnd_encoding_tile_indices
   {
	  uint8 m_tiles[4];
   };

   static crnd_encoding_tile_indices g_crnd_chunk_encoding_tiles[cNumChunkEncodings] =
   {
	  { { 0, 0, 0, 0 } },

	  { { 0, 0, 1, 1 } },
	  { { 0, 1, 0, 1 } },

	  { { 0, 0, 1, 2 } },
	  { { 1, 2, 0, 0 } },

	  { { 0, 1, 0, 2 } },
	  { { 1, 0, 2, 0 } },

	  { { 0, 1, 2, 3 } }
   };

   static uint8 g_crnd_chunk_encoding_num_tiles[cNumChunkEncodings] = { 1, 2, 2, 3, 3, 3, 3, 4 };

   class crn_unpacker
   {
   public:
	  inline crn_unpacker() :
		 m_magic(cMagicValue),
		 m_pData(NULL),
		 m_data_size(0),
		 m_pHeader(NULL)
	  {
	  }

	  inline ~crn_unpacker()
	  {
		 m_magic = 0;
	  }

	  inline bool is_valid() const { return m_magic == cMagicValue; }

	  bool init(const void* pData, uint32 data_size)
	  {
		 m_pHeader = crnd_get_header(m_tmp_header, pData, data_size);
		 if (!m_pHeader)
			return false;

		 m_pData = static_cast<const uint8*>(pData);
		 m_data_size = data_size;

		 if (!init_tables())
			return false;

		 if (!decode_palettes())
			return false;

		 return true;
	  }

	  bool unpack_level(
		 void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
		 uint32 level_index)
	  {
		 uint32 cur_level_ofs = m_pHeader->m_level_ofs[level_index];

		 uint32 next_level_ofs = m_data_size;
		 if ((level_index + 1) < (m_pHeader->m_levels))
			next_level_ofs = m_pHeader->m_level_ofs[level_index + 1];

		 CRND_ASSERT(next_level_ofs > cur_level_ofs);

		 return unpack_level(m_pData + cur_level_ofs, next_level_ofs - cur_level_ofs, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
	  }

	  bool unpack_level(
		 const void* pSrc, uint32 src_size_in_bytes,
		 void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
		 uint32 level_index)
	  {
		 dst_size_in_bytes;

#ifdef CRND_BUILD_DEBUG
		 for (uint32 f = 0; f < m_pHeader->m_faces; f++)
			if (!pDst[f])
			   return false;
#endif

		 const uint32 width = math::maximum(m_pHeader->m_width >> level_index, 1U);
		 const uint32 height = math::maximum(m_pHeader->m_height >> level_index, 1U);
		 const uint32 blocks_x = (width + 3U) >> 2U;
		 const uint32 blocks_y = (height + 3U) >> 2U;
		 const uint32 block_size = ((m_pHeader->m_format == cCRNFmtDXT1) || (m_pHeader->m_format == cCRNFmtDXT5A)) ? 8 : 16;

		 uint32 minimal_row_pitch = block_size * blocks_x;
		 if (!row_pitch_in_bytes)
			row_pitch_in_bytes = minimal_row_pitch;
		 else if ((row_pitch_in_bytes < minimal_row_pitch) || (row_pitch_in_bytes & 3))
			return false;
		 if (dst_size_in_bytes < row_pitch_in_bytes * blocks_y)
			return false;

		 const uint32 chunks_x = (blocks_x + 1) >> 1;
		 const uint32 chunks_y = (blocks_y + 1) >> 1;

#if CRND_CREATE_BYTE_STREAMS
		 crnd_trace("Index stream: %u bytes\n", src_size_in_bytes);
#endif

		 if (!m_codec.start_decoding(static_cast<const crnd::uint8*>(pSrc), src_size_in_bytes))
			return false;

		 bool status = false;
		 switch (m_pHeader->m_format)
		 {
		 case cCRNFmtDXT1:
			status = unpack_dxt1((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 case cCRNFmtDXT5:
		 case cCRNFmtDXT5_CCxY:
		 case cCRNFmtDXT5_xGBR:
		 case cCRNFmtDXT5_AGBR:
		 case cCRNFmtDXT5_xGxR:
			status = unpack_dxt5((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 case cCRNFmtDXT5A:
			status = unpack_dxt5a((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 case cCRNFmtDXN_XY:
		 case cCRNFmtDXN_YX:
			status = unpack_dxn((uint8**)pDst, dst_size_in_bytes, row_pitch_in_bytes, blocks_x, blocks_y, chunks_x, chunks_y);
			break;
		 default:
			return false;
		 }
		 if (!status)
			return false;

		 m_codec.stop_decoding();
		 return true;
	  }

	  inline const void* get_data() const { return m_pData; }
	  inline uint32 get_data_size() const { return m_data_size; }

   private:
	  enum { cMagicValue = 0x1EF9CABD };
	  uint32             m_magic;

	  const uint8*       m_pData;
	  uint32             m_data_size;
	  crn_header         m_tmp_header;
	  const crn_header*  m_pHeader;

	  symbol_codec       m_codec;

	  static_huffman_data_model m_chunk_encoding_dm;
	  static_huffman_data_model m_endpoint_delta_dm[2];
	  static_huffman_data_model m_selector_delta_dm[2];

	  crnd::vector<uint32> m_color_endpoints;
	  crnd::vector<uint32> m_color_selectors;

	  crnd::vector<uint16> m_alpha_endpoints;
	  crnd::vector<uint16> m_alpha_selectors;

	  bool init_tables()
	  {
		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_tables_ofs, m_pHeader->m_tables_size))
			return false;

		 if (!m_codec.decode_receive_static_data_model(m_chunk_encoding_dm))
			return false;

		 if ((!m_pHeader->m_color_endpoints.m_num) && (!m_pHeader->m_alpha_endpoints.m_num))
			return false;

		 if (m_pHeader->m_color_endpoints.m_num)
		 {
			if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[0])) return false;
			if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[0])) return false;
		 }

		 if (m_pHeader->m_alpha_endpoints.m_num)
		 {
			if (!m_codec.decode_receive_static_data_model(m_endpoint_delta_dm[1])) return false;
			if (!m_codec.decode_receive_static_data_model(m_selector_delta_dm[1])) return false;
		 }

		 m_codec.stop_decoding();

		 return true;
	  }

	  bool decode_palettes()
	  {
		 if (m_pHeader->m_color_endpoints.m_num)
		 {
			if (!decode_color_endpoints()) return false;
			if (!decode_color_selectors()) return false;
		 }

		 if (m_pHeader->m_alpha_endpoints.m_num)
		 {
			if (!decode_alpha_endpoints()) return false;
			if (!decode_alpha_selectors()) return false;
		 }

		 return true;
	  }

	  bool decode_color_endpoints()
	  {
		 const uint32 num_color_endpoints = m_pHeader->m_color_endpoints.m_num;

		 if (!m_color_endpoints.resize(num_color_endpoints))
			return false;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_color_endpoints.m_ofs, m_pHeader->m_color_endpoints.m_size))
			return false;

		 static_huffman_data_model dm[2];
		 for (uint32 i = 0; i < 2; i++)
			if (!m_codec.decode_receive_static_data_model(dm[i]))
			   return false;

		 uint32 a = 0, b = 0, c = 0;
		 uint32 d = 0, e = 0, f = 0;

		 uint32* CRND_RESTRICT pDst = &m_color_endpoints[0];

		 CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 vector<uint8> byte_stream;
#endif

		 for (uint32 i = 0; i < num_color_endpoints; i++)
		 {
			uint32 da, db, dc, dd, de, df;
			CRND_HUFF_DECODE(m_codec, dm[0], da); a = (a + da) & 31;
			CRND_HUFF_DECODE(m_codec, dm[1], db); b = (b + db) & 63;
			CRND_HUFF_DECODE(m_codec, dm[0], dc); c = (c + dc) & 31;

			CRND_HUFF_DECODE(m_codec, dm[0], dd); d = (d + dd) & 31;
			CRND_HUFF_DECODE(m_codec, dm[1], de); e = (e + de) & 63;
			CRND_HUFF_DECODE(m_codec, dm[0], df); f = (f + df) & 31;

#if CRND_CREATE_BYTE_STREAMS
			byte_stream.push_back(da);
			byte_stream.push_back(db);
			byte_stream.push_back(dc);
			byte_stream.push_back(dd);
			byte_stream.push_back(de);
			byte_stream.push_back(df);
#endif

			if (c_crnd_little_endian_platform)
			   *pDst++ = c | (b << 5U) | (a << 11U) | (f << 16U) | (e << 21U) | (d << 27U);
			else
			   *pDst++ = f | (e << 5U) | (d << 11U) | (c << 16U) | (b << 21U) | (a << 27U);
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

#if CRND_CREATE_BYTE_STREAMS
		 write_array_to_file(L"colorendpoints.bin", byte_stream);
		 crnd_trace("color endpoints: %u\n", (uint)m_pHeader->m_color_endpoints.m_size);
#endif

		 return true;
	  }

	  bool decode_color_selectors()
	  {
		 const uint32 cMaxSelectorValue = 3U;
		 const uint32 cMaxUniqueSelectorDeltas = cMaxSelectorValue * 2U + 1U;

		 const uint32 num_color_selectors = m_pHeader->m_color_selectors.m_num;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_color_selectors.m_ofs, m_pHeader->m_color_selectors.m_size))
			return false;

		 static_huffman_data_model dm;
		 if (!m_codec.decode_receive_static_data_model(dm))
			return false;

		 int32 delta0[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 delta1[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 l = -(int32)cMaxSelectorValue, m = -(int32)cMaxSelectorValue;
		 for (uint32 i = 0; i < (cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas); i++)
		 {
			delta0[i] = l;
			delta1[i] = m;

			if (++l > (int32)cMaxSelectorValue)
			{
			   l = -(int32)cMaxSelectorValue;
			   m++;
			}
		 }

		 uint32 cur[16];
		 utils::zero_object(cur);

		 if (!m_color_selectors.resize(num_color_selectors))
			return false;

		 uint32* CRND_RESTRICT pDst = &m_color_selectors[0];

		 const uint8* pFrom_linear = g_dxt1_from_linear;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 vector<uint8> byte_stream;
#endif

		 for (uint32 i = 0; i < num_color_selectors; i++)
		 {
			for (uint32 j = 0; j < 8; j++)
			{
			   int32 sym;
			   CRND_HUFF_DECODE(m_codec, dm, sym);

#if CRND_CREATE_BYTE_STREAMS
			   byte_stream.push_back(sym);
#endif

			   cur[j*2+0] = (delta0[sym] + cur[j*2+0]) & 3;
			   cur[j*2+1] = (delta1[sym] + cur[j*2+1]) & 3;
			}

			if (c_crnd_little_endian_platform)
			{
			   *pDst++ =
				  (pFrom_linear[cur[0 ]]      ) | (pFrom_linear[cur[1 ]] <<  2) | (pFrom_linear[cur[2 ]] <<  4) | (pFrom_linear[cur[3 ]] <<  6) |
				  (pFrom_linear[cur[4 ]] <<  8) | (pFrom_linear[cur[5 ]] << 10) | (pFrom_linear[cur[6 ]] << 12) | (pFrom_linear[cur[7 ]] << 14) |
				  (pFrom_linear[cur[8 ]] << 16) | (pFrom_linear[cur[9 ]] << 18) | (pFrom_linear[cur[10]] << 20) | (pFrom_linear[cur[11]] << 22) |
				  (pFrom_linear[cur[12]] << 24) | (pFrom_linear[cur[13]] << 26) | (pFrom_linear[cur[14]] << 28) | (pFrom_linear[cur[15]] << 30);
			}
			else
			{
			   *pDst++ =
				  (pFrom_linear[cur[8 ]]      ) | (pFrom_linear[cur[9 ]] <<  2) | (pFrom_linear[cur[10]] <<  4) | (pFrom_linear[cur[11]] <<  6) |
				  (pFrom_linear[cur[12]] <<  8) | (pFrom_linear[cur[13]] << 10) | (pFrom_linear[cur[14]] << 12) | (pFrom_linear[cur[15]] << 14) |
				  (pFrom_linear[cur[0 ]] << 16) | (pFrom_linear[cur[1 ]] << 18) | (pFrom_linear[cur[2 ]] << 20) | (pFrom_linear[cur[3 ]] << 22) |
				  (pFrom_linear[cur[4 ]] << 24) | (pFrom_linear[cur[5 ]] << 26) | (pFrom_linear[cur[6 ]] << 28) | (pFrom_linear[cur[7 ]] << 30);
			}
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

#if CRND_CREATE_BYTE_STREAMS
		 write_array_to_file(L"colorselectors.bin", byte_stream);
		 crnd_trace("color selectors: %u\n", (uint)m_pHeader->m_color_selectors.m_size);
#endif

		 return true;
	  }

	  bool decode_alpha_endpoints()
	  {
		 const uint32 num_alpha_endpoints = m_pHeader->m_alpha_endpoints.m_num;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_alpha_endpoints.m_ofs, m_pHeader->m_alpha_endpoints.m_size))
			return false;

		 static_huffman_data_model dm;
		 if (!m_codec.decode_receive_static_data_model(dm))
			return false;

		 if (!m_alpha_endpoints.resize(num_alpha_endpoints))
			return false;

		 uint16* CRND_RESTRICT pDst = &m_alpha_endpoints[0];
		 uint32 a = 0, b = 0;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 i = 0; i < num_alpha_endpoints; i++)
		 {
			uint sa; CRND_HUFF_DECODE(m_codec, dm, sa);
			uint sb; CRND_HUFF_DECODE(m_codec, dm, sb);

			a = (sa + a) & 255;
			b = (sb + b) & 255;

			*pDst++ = (uint16)(a | (b << 8));
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

		 return true;
	  }

	  bool decode_alpha_selectors()
	  {
		 const uint32 cMaxSelectorValue = 7U;
		 const uint32 cMaxUniqueSelectorDeltas = cMaxSelectorValue * 2U + 1U;

		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 if (!m_codec.start_decoding(m_pData + m_pHeader->m_alpha_selectors.m_ofs, m_pHeader->m_alpha_selectors.m_size))
			return false;

		 static_huffman_data_model dm;
		 if (!m_codec.decode_receive_static_data_model(dm))
			return false;

		 int32 delta0[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 delta1[cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas];
		 int32 l = -(int32)cMaxSelectorValue, m = -(int32)cMaxSelectorValue;
		 for (uint32 i = 0; i < (cMaxUniqueSelectorDeltas * cMaxUniqueSelectorDeltas); i++)
		 {
			delta0[i] = l;
			delta1[i] = m;

			if (++l > (int32)cMaxSelectorValue)
			{
			   l = -(int32)cMaxSelectorValue;
			   m++;
			}
		 }

		 uint32 cur[16];
		 utils::zero_object(cur);

		 if (!m_alpha_selectors.resize(num_alpha_selectors * 3))
			return false;

		 uint16* CRND_RESTRICT pDst = &m_alpha_selectors[0];

		 const uint8* pFrom_linear = g_dxt5_from_linear;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 i = 0; i < num_alpha_selectors; i++)
		 {
			for (uint32 j = 0; j < 8; j++)
			{
			   int32 sym;
			   CRND_HUFF_DECODE(m_codec, dm, sym);

			   cur[j*2+0] = (delta0[sym] + cur[j*2+0]) & 7;
			   cur[j*2+1] = (delta1[sym] + cur[j*2+1]) & 7;
			   //cur[j*2+0] = ((sym%15)-7 + cur[j*2+0]) & 7;
			   //cur[j*2+1] = ((sym/15)-7 + cur[j*2+1]) & 7;
			}

#if 0
			dxt5_block blk;
			for (uint32 y = 0; y < 4; y++)
			   for (uint32 x = 0; x < 4; x++)
				  blk.set_selector(x, y, pFrom_linear[cur[x+y*4]]);

			*pDst++ = blk.get_selectors_as_word(0);
			*pDst++ = blk.get_selectors_as_word(1);
			*pDst++ = blk.get_selectors_as_word(2);
#else
			*pDst++ = (uint16)((pFrom_linear[cur[0 ]]      ) | (pFrom_linear[cur[1 ]] <<  3) | (pFrom_linear[cur[2 ]] <<  6) | (pFrom_linear[cur[3 ]] <<  9) |
			   (pFrom_linear[cur[4 ]] << 12) | (pFrom_linear[cur[5 ]] << 15));

			*pDst++ = (uint16)((pFrom_linear[cur[5 ]] >> 1) | (pFrom_linear[cur[6 ]] << 2) | (pFrom_linear[cur[7 ]] << 5) |
			   (pFrom_linear[cur[8 ]] << 8) | (pFrom_linear[cur[9 ]] << 11) | (pFrom_linear[cur[10]] << 14));

			*pDst++ = (uint16)((pFrom_linear[cur[10]] >> 2) | (pFrom_linear[cur[11]] << 1) | (pFrom_linear[cur[12]] << 4) |
			   (pFrom_linear[cur[13]] << 7) | (pFrom_linear[cur[14]] << 10) | (pFrom_linear[cur[15]] << 13));
#endif
		 }

		 CRND_HUFF_DECODE_END(m_codec);

		 m_codec.stop_decoding();

		 return true;
	  }

	  static inline uint32 tiled_offset_2d_outer(uint32 y, uint32 AlignedWidth, uint32 LogBpp)
	  {
		 uint32 Macro        = ((y >> 5) * (AlignedWidth >> 5)) << (LogBpp + 7);
		 uint32 Micro        = ((y & 6) << 2) << LogBpp;

		 return Macro +
			((Micro & ~15) << 1) +
			(Micro & 15) +
			((y & 8) << (3 + LogBpp)) + ((y & 1) << 4);
	  }

	  static inline uint32 tiled_offset_2d_inner(uint32 x, uint32 y, uint32 LogBpp, uint32 BaseOffset)
	  {
		 uint32 Macro = (x >> 5) << (LogBpp + 7);
		 uint32 Micro = (x & 7) << LogBpp;
		 uint32 Offset  = BaseOffset + Macro + ((Micro & ~15) << 1) + (Micro & 15);

		 return ((Offset & ~511) << 3) + ((Offset & 448) << 2) + (Offset & 63) +
			((y & 16) << 7) +
			(((((y & 8) >> 2) + (x >> 3)) & 3) << 6);
	  }

	  static inline void limit(uint& x, uint n)
	  {
		 int v = x - n;
		 int msk = (v >> 31);
		 x = (x & msk) | (v & ~msk);
	  }

	  bool unpack_dxt1(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_color_endpoints = m_color_endpoints.size();
		 const uint32 num_color_selectors = m_color_selectors.size();

		 uint32 prev_color_endpoint_index = 0;
		 uint32 prev_color_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

		 const int32 cBytesPerBlock = 8;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 vector<uint8> tile_encoding_stream;
		 vector<uint8> endpoint_indices_stream;
		 vector<uint8> selector_indices_stream;
#endif

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 color_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
#if CRND_CREATE_BYTE_STREAMS
					 tile_encoding_stream.push_back(chunk_encoding_bits & 7);
					 tile_encoding_stream.push_back((chunk_encoding_bits >> 3) & 7);
					 tile_encoding_stream.push_back((chunk_encoding_bits >> 6) & 7);
#endif
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta;
					 CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[0], delta);
#if CRND_CREATE_BYTE_STREAMS
					 endpoint_indices_stream.push_back(delta);
#endif
					 prev_color_endpoint_index += delta;
					 limit(prev_color_endpoint_index, num_color_endpoints);
					 color_endpoints[i] = m_color_endpoints[prev_color_endpoint_index];
				  }

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  if ((!skip_bottom_row) && (!skip_right_col))
				  {
					 //CRND_ASSERT( ((uint8*)&pD[4 + row_pitch_in_dwords] - pDst) <= dst_size_in_bytes );

					 pD[0] = color_endpoints[pTile_indices[0]];
					 CRND_WRITE_BARRIER
					 uint32 delta0;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta0);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta0);
#endif
					 prev_color_selector_index += delta0;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[1] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER

					 pD[2] = color_endpoints[pTile_indices[1]];
					 CRND_WRITE_BARRIER
					 uint32 delta1;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta1);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta1);
#endif
					 prev_color_selector_index += delta1;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[3] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER

					 pD[0 + row_pitch_in_dwords] = color_endpoints[pTile_indices[2]];
					 CRND_WRITE_BARRIER
					 uint32 delta2;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta2);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta2);
#endif
					 prev_color_selector_index += delta2;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[1 + row_pitch_in_dwords] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER

					 pD[2 + row_pitch_in_dwords] = color_endpoints[pTile_indices[3]];
					 CRND_WRITE_BARRIER
					 uint32 delta3;
					 CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta3);
#if CRND_CREATE_BYTE_STREAMS
					 selector_indices_stream.push_back(delta3);
#endif
					 prev_color_selector_index += delta3;
					 limit(prev_color_selector_index, num_color_selectors);
					 pD[3 + row_pitch_in_dwords] = m_color_selectors[prev_color_selector_index];
					 CRND_WRITE_BARRIER
				  }
				  else
				  {
					 for (uint32 by = 0; by < 2; by++)
					 {
						pD = (uint32*)((uint8*)pBlock + row_pitch_in_bytes * by);
						for (uint32 bx = 0; bx < 2; bx++, pD += 2)
						{
						   uint32 delta;
						   CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta);
#if CRND_CREATE_BYTE_STREAMS
						   selector_indices_stream.push_back(delta);
#endif
						   prev_color_selector_index += delta;
						   limit(prev_color_selector_index, num_color_selectors);

						   if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						   {
							  pD[0] = color_endpoints[pTile_indices[bx + by * 2]];
							  CRND_WRITE_BARRIER
							  pD[1] = m_color_selectors[prev_color_selector_index];
							  CRND_WRITE_BARRIER
						   }
						}
					 }
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

#if CRND_CREATE_BYTE_STREAMS
		 write_array_to_file(L"tile_encodings.bin", tile_encoding_stream);
		 write_array_to_file(L"endpoint_indices.bin", endpoint_indices_stream);
		 write_array_to_file(L"selector_indices.bin", selector_indices_stream);
#endif

		 return true;
	  }

	  bool unpack_dxt5(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_color_endpoints = m_color_endpoints.size();
		 const uint32 num_color_selectors = m_color_selectors.size();
		 const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 uint32 prev_color_endpoint_index = 0;
		 uint32 prev_color_selector_index = 0;
		 uint32 prev_alpha_endpoint_index = 0;
		 uint32 prev_alpha_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 //const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

		 const int32 cBytesPerBlock = 16;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 color_endpoints[4];
				  uint32 alpha_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha_endpoint_index += delta;
					 limit(prev_alpha_endpoint_index, num_alpha_endpoints);
					 alpha_endpoints[i] = m_alpha_endpoints[prev_alpha_endpoint_index];
				  }

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[0], delta);
					 prev_color_endpoint_index += delta;
					 limit(prev_color_endpoint_index, num_color_endpoints);
					 color_endpoints[i] = m_color_endpoints[prev_color_endpoint_index];
				  }

				  pD = (uint32*)pBlock;
				  for (uint32 by = 0; by < 2; by++)
				  {
					 for (uint32 bx = 0; bx < 2; bx++, pD += 4)
					 {
						uint32 delta0; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta0);
						prev_alpha_selector_index += delta0;
						limit(prev_alpha_selector_index, num_alpha_selectors);

						uint32 delta1; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[0], delta1);
						prev_color_selector_index += delta1;
						limit(prev_color_selector_index, num_color_selectors);

						if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						{
						   const uint32 tile_index = pTile_indices[bx + by * 2];
						   const uint16* pAlpha_selectors = &m_alpha_selectors[prev_alpha_selector_index * 3];

#ifdef CRND_BIG_ENDIAN_PLATFORM
						   pD[0] = (alpha_endpoints[tile_index] << 16) | pAlpha_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[1] = (pAlpha_selectors[1] << 16) | pAlpha_selectors[2];
						   CRND_WRITE_BARRIER
						   pD[2] = color_endpoints[tile_index];
						   CRND_WRITE_BARRIER
						   pD[3] = m_color_selectors[prev_color_selector_index];
						   CRND_WRITE_BARRIER
#else
						   pD[0] = alpha_endpoints[tile_index] | (pAlpha_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[1] = pAlpha_selectors[1] | (pAlpha_selectors[2] << 16);
						   CRND_WRITE_BARRIER
						   pD[2] = color_endpoints[tile_index];
						   CRND_WRITE_BARRIER
						   pD[3] = m_color_selectors[prev_color_selector_index];
						   CRND_WRITE_BARRIER
#endif
						}
					 }

					 pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

		 return true;
	  }

	  bool unpack_dxn(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 uint32 prev_alpha0_endpoint_index = 0;
		 uint32 prev_alpha0_selector_index = 0;
		 uint32 prev_alpha1_endpoint_index = 0;
		 uint32 prev_alpha1_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 //const uint32 row_pitch_in_dwords = row_pitch_in_bytes >> 2U;

		 const int32 cBytesPerBlock = 16;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 alpha0_endpoints[4];
				  uint32 alpha1_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha0_endpoint_index += delta;
					 limit(prev_alpha0_endpoint_index, num_alpha_endpoints);
					 alpha0_endpoints[i] = m_alpha_endpoints[prev_alpha0_endpoint_index];
				  }

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha1_endpoint_index += delta;
					 limit(prev_alpha1_endpoint_index, num_alpha_endpoints);
					 alpha1_endpoints[i] = m_alpha_endpoints[prev_alpha1_endpoint_index];
				  }

				  pD = (uint32*)pBlock;
				  for (uint32 by = 0; by < 2; by++)
				  {
					 for (uint32 bx = 0; bx < 2; bx++, pD += 4)
					 {
						uint32 delta0; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta0);
						prev_alpha0_selector_index += delta0;
						limit(prev_alpha0_selector_index, num_alpha_selectors);

						uint32 delta1; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta1);
						prev_alpha1_selector_index += delta1;
						limit(prev_alpha1_selector_index, num_alpha_selectors);

						if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						{
						   const uint32 tile_index = pTile_indices[bx + by * 2];
						   const uint16* pAlpha0_selectors = &m_alpha_selectors[prev_alpha0_selector_index * 3];
						   const uint16* pAlpha1_selectors = &m_alpha_selectors[prev_alpha1_selector_index * 3];

#ifdef CRND_BIG_ENDIAN_PLATFORM
						   pD[0] = (alpha0_endpoints[tile_index] << 16) | pAlpha0_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[1] = (pAlpha0_selectors[1] << 16) | pAlpha0_selectors[2];
						   CRND_WRITE_BARRIER
						   pD[2] = (alpha1_endpoints[tile_index] << 16) | pAlpha1_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[3] = (pAlpha1_selectors[1] << 16) | pAlpha1_selectors[2];
						   CRND_WRITE_BARRIER
#else
						   pD[0] = alpha0_endpoints[tile_index] | (pAlpha0_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
						   CRND_WRITE_BARRIER
						   pD[2] = alpha1_endpoints[tile_index] | (pAlpha1_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[3] = pAlpha1_selectors[1] | (pAlpha1_selectors[2] << 16);
						   CRND_WRITE_BARRIER
#endif
						}
					 }

					 pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

		 return true;
	  }

	  bool unpack_dxt5a(uint8** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes, uint32 blocks_x, uint32 blocks_y, uint32 chunks_x, uint32 chunks_y)
	  {
		 dst_size_in_bytes;

		 uint32 chunk_encoding_bits = 1;

		 const uint32 num_alpha_endpoints = m_alpha_endpoints.size();
		 const uint32 num_alpha_selectors = m_pHeader->m_alpha_selectors.m_num;

		 uint32 prev_alpha0_endpoint_index = 0;
		 uint32 prev_alpha0_selector_index = 0;

		 const uint32 num_faces = m_pHeader->m_faces;

		 const int32 cBytesPerBlock = 8;

		 CRND_HUFF_DECODE_BEGIN(m_codec);

		 for (uint32 f = 0; f < num_faces; f++)
		 {
			uint8* CRND_RESTRICT pRow = pDst[f];

			for (uint32 y = 0; y < chunks_y; y++)
			{
			   int32 start_x = 0;
			   int32 end_x = chunks_x;
			   int32 dir_x = 1;
			   int32 block_delta = cBytesPerBlock*2;
			   uint8* CRND_RESTRICT pBlock = pRow;

			   if (y & 1)
			   {
				  start_x = chunks_x - 1;
				  end_x = -1;
				  dir_x = -1;
				  block_delta = -cBytesPerBlock*2;
				  pBlock += (chunks_x - 1) * cBytesPerBlock * 2;
			   }

			   const bool skip_bottom_row = (y == (chunks_y - 1)) && (blocks_y & 1);

			   for (int32 x = start_x; x != end_x; x += dir_x)
			   {
				  uint32 alpha0_endpoints[4];

				  if (chunk_encoding_bits == 1)
				  {
					 CRND_HUFF_DECODE(m_codec, m_chunk_encoding_dm, chunk_encoding_bits);
					 chunk_encoding_bits |= 512;
				  }

				  const uint32 chunk_encoding_index = chunk_encoding_bits & 7;
				  chunk_encoding_bits >>= 3;

				  const uint32 num_tiles = g_crnd_chunk_encoding_num_tiles[chunk_encoding_index];

				  const uint8* pTile_indices = g_crnd_chunk_encoding_tiles[chunk_encoding_index].m_tiles;

				  const bool skip_right_col = (blocks_x & 1) && (x == ((int32)chunks_x - 1));

				  uint32* CRND_RESTRICT pD = (uint32*)pBlock;

				  for (uint32 i = 0; i < num_tiles; i++)
				  {
					 uint32 delta; CRND_HUFF_DECODE(m_codec, m_endpoint_delta_dm[1], delta);
					 prev_alpha0_endpoint_index += delta;
					 limit(prev_alpha0_endpoint_index, num_alpha_endpoints);
					 alpha0_endpoints[i] = m_alpha_endpoints[prev_alpha0_endpoint_index];
				  }

				  pD = (uint32*)pBlock;
				  for (uint32 by = 0; by < 2; by++)
				  {
					 for (uint32 bx = 0; bx < 2; bx++, pD += 2)
					 {
						uint32 delta; CRND_HUFF_DECODE(m_codec, m_selector_delta_dm[1], delta);
						prev_alpha0_selector_index += delta;
						limit(prev_alpha0_selector_index, num_alpha_selectors);

						if (!((bx && skip_right_col) || (by && skip_bottom_row)))
						{
						   const uint32 tile_index = pTile_indices[bx + by * 2];
						   const uint16* pAlpha0_selectors = &m_alpha_selectors[prev_alpha0_selector_index * 3];

#if CRND_BIG_ENDIAN_PLATFORM
						   pD[0] = (alpha0_endpoints[tile_index] << 16) | pAlpha0_selectors[0];
						   CRND_WRITE_BARRIER
						   pD[1] = (pAlpha0_selectors[1] << 16) | pAlpha0_selectors[2];
						   CRND_WRITE_BARRIER
#else
						   pD[0] = alpha0_endpoints[tile_index] | (pAlpha0_selectors[0] << 16);
						   CRND_WRITE_BARRIER
						   pD[1] = pAlpha0_selectors[1] | (pAlpha0_selectors[2] << 16);
						   CRND_WRITE_BARRIER
#endif
						}
					 }

					 pD = (uint32*)((uint8*)pD - cBytesPerBlock * 2 + row_pitch_in_bytes);
				  }

				  pBlock += block_delta;

			   } // x

			   pRow += row_pitch_in_bytes * 2;

			} // y

		 } // f

		 CRND_HUFF_DECODE_END(m_codec);

		 return true;
	  }
   };

   crnd_unpack_context crnd_unpack_begin(const void* pData, uint32 data_size)
   {
	  if ((!pData) || (data_size < cCRNHeaderMinSize))
		 return NULL;

	  crn_unpacker* p = crnd_new<crn_unpacker>();
	  if (!p)
		 return NULL;

	  if (!p->init(pData, data_size))
	  {
		 crnd_delete(p);
		 return NULL;
	  }

	  return p;
   }

   bool crnd_get_data(crnd_unpack_context pContext, const void** ppData, uint32* pData_size)
   {
	  if (!pContext)
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  if (ppData)
		 *ppData = pUnpacker->get_data();

	  if (pData_size)
		 *pData_size = pUnpacker->get_data_size();

	  return true;
   }

   bool crnd_unpack_level(
	  crnd_unpack_context pContext,
	  void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index)
   {
	  if ((!pContext) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  return pUnpacker->unpack_level(pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
   }

   bool crnd_unpack_level_segmented(
	  crnd_unpack_context pContext,
	  const void* pSrc, uint32 src_size_in_bytes,
	  void** pDst, uint32 dst_size_in_bytes, uint32 row_pitch_in_bytes,
	  uint32 level_index)
   {
	  if ((!pContext) || (!pSrc) || (!pDst) || (dst_size_in_bytes < 8U) || (level_index >= cCRNMaxLevels))
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  return pUnpacker->unpack_level(pSrc, src_size_in_bytes, pDst, dst_size_in_bytes, row_pitch_in_bytes, level_index);
   }

   bool crnd_unpack_end(crnd_unpack_context pContext)
   {
	  if (!pContext)
		 return false;

	  crn_unpacker* pUnpacker = static_cast<crn_unpacker*>(pContext);

	  if (!pUnpacker->is_valid())
		 return false;

	  crnd_delete(pUnpacker);

	  return true;
   }

} // namespace crnd

#endif // CRND_HEADER_FILE_ONLY

//------------------------------------------------------------------------------
//
// crn_decomp.h uses the ZLIB license:
// http://opensource.org/licenses/Zlib
//
// Copyright (c) 2010-2012 Rich Geldreich and Tenacious Software LLC
//
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
//------------------------------------------------------------------------------

extern "C" {
	unsigned int crn_get_width(const void *src, unsigned int src_size);
	unsigned int crn_get_height(const void *src, unsigned int src_size);
	unsigned int crn_get_levels(const void *src, unsigned int src_size);
	unsigned int crn_get_dxt_format(const void *src, unsigned int src_size);
	unsigned int crn_get_uncompressed_size(const void *p, unsigned int size);
	void crn_decompress(const void *src, unsigned int src_size, void *dst, unsigned int dst_size);
}

unsigned int crn_get_width(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_width;
}

unsigned int crn_get_height(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_height;
}

unsigned int crn_get_levels(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_levels;
}

unsigned int crn_get_dxt_format(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	return tex_info.m_format;
}

unsigned int crn_get_uncompressed_size(const void *src, unsigned int src_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	const crn_uint32 width = tex_info.m_width;
	const crn_uint32 height = tex_info.m_height;
	const crn_uint32 blocks_x = (width + 3) >> 2;
	const crn_uint32 blocks_y = (height + 3) >> 2;
	const crn_uint32 row_pitch = blocks_x * crnd::crnd_get_bytes_per_dxt_block(tex_info.m_format);
	const crn_uint32 total_face_size = row_pitch * blocks_y;
	return total_face_size;
}

void crn_decompress(const void *src, unsigned int src_size, void *dst, unsigned int dst_size) {
	crnd::crn_texture_info tex_info;
	crnd::crnd_get_texture_info(static_cast<const crn_uint8*>(src), src_size, &tex_info);
	const crn_uint32 width = tex_info.m_width;
	const crn_uint32 height = tex_info.m_height;
	const crn_uint32 blocks_x = (width + 3) >> 2;
	const crn_uint32 blocks_y = (height + 3) >> 2;
	const crn_uint32 row_pitch = blocks_x * crnd::crnd_get_bytes_per_dxt_block(tex_info.m_format);

	crnd::crnd_unpack_context pContext =
	  crnd::crnd_unpack_begin(static_cast<const crn_uint8*>(src), src_size);
	void *pDecomp_images[1];
	pDecomp_images[0] = dst;
	crnd::crnd_unpack_level(pContext, pDecomp_images, dst_size, row_pitch, 0);
	crnd::crnd_unpack_end(pContext);
}

// from soil2

#include <stdint.h>

typedef struct
{
	uint32_t dwMagic;
	uint32_t dwSize;
	uint32_t dwFlags;
	uint32_t dwHeight;
	uint32_t dwWidth;
	uint32_t dwPitchOrLinearSize;
	uint32_t dwDepth;
	uint32_t dwMipMapCount;
	uint32_t dwReserved1[ 11 ];

	/*  DDPIXELFORMAT */
	struct
	{
		uint32_t dwSize;
		uint32_t dwFlags;
		uint32_t dwFourCC;
		uint32_t dwRGBBitCount;
		uint32_t dwRBitMask;
		uint32_t dwGBitMask;
		uint32_t dwBBitMask;
		uint32_t dwAlphaBitMask;
	}
	sPixelFormat;

	/*  DDCAPS2 */
	struct
	{
		uint32_t dwCaps1;
		uint32_t dwCaps2;
		uint32_t dwDDSX;
		uint32_t dwReserved;
	}
	sCaps;
	uint32_t dwReserved2;
}
DDS_header;

/*  the following constants were copied directly off the MSDN website */

/*  The dwFlags member of the original DDSURFACEDESC2 structure
  can be set to one or more of the following values.  */
#define DDSD_CAPS 0x00000001
#define DDSD_HEIGHT 0x00000002
#define DDSD_WIDTH  0x00000004
#define DDSD_PITCH  0x00000008
#define DDSD_PIXELFORMAT  0x00001000
#define DDSD_MIPMAPCOUNT  0x00020000
#define DDSD_LINEARSIZE 0x00080000
#define DDSD_DEPTH  0x00800000

/*  DirectDraw Pixel Format */
#define DDPF_ALPHAPIXELS  0x00000001
#define DDPF_FOURCC 0x00000004
#define DDPF_RGB  0x00000040

/*  The dwCaps1 member of the DDSCAPS2 structure can be
  set to one or more of the following values. */
#define DDSCAPS_COMPLEX 0x00000008
#define DDSCAPS_TEXTURE 0x00001000
#define DDSCAPS_MIPMAP  0x00400000

/*  The dwCaps2 member of the DDSCAPS2 structure can be
  set to one or more of the following values.   */
#define DDSCAPS2_CUBEMAP  0x00000200
#define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400
#define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800
#define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000
#define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000
#define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000
#define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000
#define DDSCAPS2_VOLUME 0x00200000

#include <stdlib.h>
#include <cassert>
#include <string>

// returns a pure dxt stream (can be uploaded to a GPU directly)
bool crn2dxt( std::string &out, const void *src, size_t zlen, unsigned reserved ) {
	if( zlen > 2 && ((const char *)src)[0] == 'H' && ((const char *)src)[1] == 'x' ) {
		unsigned width( crn_get_width(src,zlen) );
		unsigned height( crn_get_height(src,zlen) );
		unsigned len( crn_get_uncompressed_size(src,zlen) );

		out.resize( reserved + len );
		crn_decompress( src, zlen, &out[reserved], len );
		return true;
	}
	return false;
}
bool crn2dxt( std::string &out, const std::string &in, unsigned reserved ) {
	return crn2dxt( out, &in[0], in.size(), reserved );
}

// returns a cooked dds header + pure dxt stream (can be saved or processed somewhere else)
bool crn2dds( std::string &out, const void *src, size_t zlen ) {
	if( crn2dxt( out, src, zlen, 128 ) ) {
		assert( sizeof(DDS_header) == 128 );

		unsigned width( crn_get_width(src,zlen) );
		unsigned height( crn_get_height(src,zlen) );
		unsigned len( crn_get_uncompressed_size(src,zlen) );

		unsigned channels = 3;
		switch( crn_get_dxt_format(src,zlen) ) {
		  default:
		  case cCRNFmtDXT1: channels = 3; break;
		  case cCRNFmtDXT3: channels = 3; break;

		  case cCRNFmtDXT5:
		  // Various DXT5 derivatives
		  case cCRNFmtDXT5_CCxY:    // Luma-chroma
		  case cCRNFmtDXT5_xGxR:    // Swizzled 2-component
		  case cCRNFmtDXT5_xGBR:    // Swizzled 3-component
		  case cCRNFmtDXT5_AGBR:    // Swizzled 4-component
		  // ATI 3DC and X360 DXN
		  case cCRNFmtDXN_XY:
		  case cCRNFmtDXN_YX: channels = 4; break;

		  // DXT5 alpha blocks only
		  case cCRNFmtDXT5A: channels = 1; break;
		  case cCRNFmtETC1: channels = 3; break;
		}

		DDS_header header;
		memset( &header, 0, sizeof( DDS_header ) );
		header.dwMagic = ('D' << 0) | ('D' << 8) | ('S' << 16) | (' ' << 24);
		header.dwSize = 124;
		header.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT | DDSD_LINEARSIZE;
		header.dwWidth = width;
		header.dwHeight = height;
		header.dwPitchOrLinearSize = len;
		header.sPixelFormat.dwSize = 32;
		header.sPixelFormat.dwFlags = DDPF_FOURCC;
		if( (channels & 1) == 1 ) {
		  header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('1' << 24);
		} else {
		  header.sPixelFormat.dwFourCC = ('D' << 0) | ('X' << 8) | ('T' << 16) | ('5' << 24);
		}
		header.sCaps.dwCaps1 = DDSCAPS_TEXTURE;

		memcpy( &out[0], &header, 128 );
		return true;
	}

	return false;
}

bool crn2dds( std::string &out, const std::string &in ) {
	return crn2dds( out, &in[0], in.size() );
}


#if defined(SPOT_OPENGL_HEADER)
#   include SPOT_OPENGL_HEADER

//#line 1 "SOIL2.h"
#ifndef HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY
#define HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY

#ifdef __cplusplus
extern "C" {
#endif

/**
	The format of images that may be loaded (force_channels).
	SOIL_LOAD_AUTO leaves the image in whatever format it was found.
	SOIL_LOAD_L forces the image to load as Luminous (greyscale)
	SOIL_LOAD_LA forces the image to load as Luminous with Alpha
	SOIL_LOAD_RGB forces the image to load as Red Green Blue
	SOIL_LOAD_RGBA forces the image to load as Red Green Blue Alpha
**/
enum
{
	SOIL_LOAD_AUTO = 0,
	SOIL_LOAD_L = 1,
	SOIL_LOAD_LA = 2,
	SOIL_LOAD_RGB = 3,
	SOIL_LOAD_RGBA = 4
};

/**
	Passed in as reuse_texture_ID, will cause SOIL to
	register a new texture ID using glGenTextures().
	If the value passed into reuse_texture_ID > 0 then
	SOIL will just re-use that texture ID (great for
	reloading image assets in-game!)
**/
enum
{
	SOIL_CREATE_NEW_ID = 0
};

/**
	flags you can pass into SOIL_load_OGL_texture()
	and SOIL_create_OGL_texture().
	(note that if SOIL_FLAG_DDS_LOAD_DIRECT is used
	the rest of the flags with the exception of
	SOIL_FLAG_TEXTURE_REPEATS will be ignored while
	loading already-compressed DDS files.)

	SOIL_FLAG_POWER_OF_TWO: force the image to be POT
	SOIL_FLAG_MIPMAPS: generate mipmaps for the texture
	SOIL_FLAG_TEXTURE_REPEATS: otherwise will clamp
	SOIL_FLAG_MULTIPLY_ALPHA: for using (GL_ONE,GL_ONE_MINUS_SRC_ALPHA) blending
	SOIL_FLAG_INVERT_Y: flip the image vertically
	SOIL_FLAG_COMPRESS_TO_DXT: if the card can display them, will convert RGB to DXT1, RGBA to DXT5
	SOIL_FLAG_DDS_LOAD_DIRECT: will load DDS files directly without _ANY_ additional processing ( if supported )
	SOIL_FLAG_NTSC_SAFE_RGB: clamps RGB components to the range [16,235]
	SOIL_FLAG_CoCg_Y: Google YCoCg; RGB=>CoYCg, RGBA=>CoCgAY
	SOIL_FLAG_TEXTURE_RECTANGE: uses ARB_texture_rectangle ; pixel indexed & no repeat or MIPmaps or cubemaps
	SOIL_FLAG_PVR_LOAD_DIRECT: will load PVR files directly without _ANY_ additional processing ( if supported )
**/
enum
{
	SOIL_FLAG_POWER_OF_TWO = 1,
	SOIL_FLAG_MIPMAPS = 2,
	SOIL_FLAG_TEXTURE_REPEATS = 4,
	SOIL_FLAG_MULTIPLY_ALPHA = 8,
	SOIL_FLAG_INVERT_Y = 16,
	SOIL_FLAG_COMPRESS_TO_DXT = 32,
	SOIL_FLAG_DDS_LOAD_DIRECT = 64,
	SOIL_FLAG_NTSC_SAFE_RGB = 128,
	SOIL_FLAG_CoCg_Y = 256,
	SOIL_FLAG_TEXTURE_RECTANGLE = 512,
	SOIL_FLAG_PVR_LOAD_DIRECT = 1024,
	SOIL_FLAG_ETC1_LOAD_DIRECT = 2048,
	SOIL_FLAG_GL_MIPMAPS = 4096,
	SOIL_FLAG_SRGB_COLOR_SPACE = 8192
};

/**
	The types of images that may be saved.
	(TGA supports uncompressed RGB / RGBA)
	(BMP supports uncompressed RGB)
	(DDS supports DXT1 and DXT5)
	(PNG supports RGB / RGBA)
**/
enum
{
	SOIL_SAVE_TYPE_TGA = 0,
	SOIL_SAVE_TYPE_BMP = 1,
	SOIL_SAVE_TYPE_PNG = 2,
	SOIL_SAVE_TYPE_DDS = 3,
	SOIL_SAVE_TYPE_JPG = 4
};

/**
	Defines the order of faces in a DDS cubemap.
	I recommend that you use the same order in single
	image cubemap files, so they will be interchangeable
	with DDS cubemaps when using SOIL.
**/
#define SOIL_DDS_CUBEMAP_FACE_ORDER "EWUDNS"

/**
	The types of internal fake HDR representations

	SOIL_HDR_RGBE:		RGB * pow( 2.0, A - 128.0 )
	SOIL_HDR_RGBdivA:	RGB / A
	SOIL_HDR_RGBdivA2:	RGB / (A*A)
**/
enum
{
	SOIL_HDR_RGBE = 0,
	SOIL_HDR_RGBdivA = 1,
	SOIL_HDR_RGBdivA2 = 2
};

/**
	Loads an image from disk into an OpenGL texture.
	\param filename the name of the file to upload as a texture
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_texture
	(
		const char *filename,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 6 images from disk into an OpenGL cubemap texture.
	\param x_pos_file the name of the file to upload as the +x cube face
	\param x_neg_file the name of the file to upload as the -x cube face
	\param y_pos_file the name of the file to upload as the +y cube face
	\param y_neg_file the name of the file to upload as the -y cube face
	\param z_pos_file the name of the file to upload as the +z cube face
	\param z_neg_file the name of the file to upload as the -z cube face
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_cubemap
	(
		const char *x_pos_file,
		const char *x_neg_file,
		const char *y_pos_file,
		const char *y_neg_file,
		const char *z_pos_file,
		const char *z_neg_file,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 1 image from disk and splits it into an OpenGL cubemap texture.
	\param filename the name of the file to upload as a texture
	\param face_order the order of the faces in the file, any combination of NSWEUD, for North, South, Up, etc.
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_single_cubemap
	(
		const char *filename,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads an HDR image from disk into an OpenGL texture.
	\param filename the name of the file to upload as a texture
	\param fake_HDR_format SOIL_HDR_RGBE, SOIL_HDR_RGBdivA, SOIL_HDR_RGBdivA2
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_HDR_texture
	(
		const char *filename,
		int fake_HDR_format,
		int rescale_to_max,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads an image from RAM into an OpenGL texture.
	\param buffer the image data in RAM just as if it were still in a file
	\param buffer_length the size of the buffer in bytes
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_texture_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 6 images from memory into an OpenGL cubemap texture.
	\param x_pos_buffer the image data in RAM to upload as the +x cube face
	\param x_pos_buffer_length the size of the above buffer
	\param x_neg_buffer the image data in RAM to upload as the +x cube face
	\param x_neg_buffer_length the size of the above buffer
	\param y_pos_buffer the image data in RAM to upload as the +x cube face
	\param y_pos_buffer_length the size of the above buffer
	\param y_neg_buffer the image data in RAM to upload as the +x cube face
	\param y_neg_buffer_length the size of the above buffer
	\param z_pos_buffer the image data in RAM to upload as the +x cube face
	\param z_pos_buffer_length the size of the above buffer
	\param z_neg_buffer the image data in RAM to upload as the +x cube face
	\param z_neg_buffer_length the size of the above buffer
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_cubemap_from_memory
	(
		const unsigned char *const x_pos_buffer,
		int x_pos_buffer_length,
		const unsigned char *const x_neg_buffer,
		int x_neg_buffer_length,
		const unsigned char *const y_pos_buffer,
		int y_pos_buffer_length,
		const unsigned char *const y_neg_buffer,
		int y_neg_buffer_length,
		const unsigned char *const z_pos_buffer,
		int z_pos_buffer_length,
		const unsigned char *const z_neg_buffer,
		int z_neg_buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Loads 1 image from RAM and splits it into an OpenGL cubemap texture.
	\param buffer the image data in RAM just as if it were still in a file
	\param buffer_length the size of the buffer in bytes
	\param face_order the order of the faces in the file, any combination of NSWEUD, for North, South, Up, etc.
	\param force_channels 0-image format, 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_load_OGL_single_cubemap_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Creates a 2D OpenGL texture from raw image data.  Note that the raw data is
	_NOT_ freed after the upload (so the user can load various versions).
	\param data the raw data to be uploaded as an OpenGL texture
	\param width the pointer of the width of the image in pixels ( if the texture size change, width will be overrided with the new width )
	\param height the pointer of the height of the image in pixels ( if the texture size change, height will be overrided with the new height )
	\param channels the number of channels: 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Creates an OpenGL cubemap texture by splitting up 1 image into 6 parts.
	\param data the raw data to be uploaded as an OpenGL texture
	\param width the width of the image in pixels
	\param height the height of the image in pixels
	\param channels the number of channels: 1-luminous, 2-luminous/alpha, 3-RGB, 4-RGBA
	\param face_order the order of the faces in the file, and combination of NSWEUD, for North, South, Up, etc.
	\param reuse_texture_ID 0-generate a new texture ID, otherwise reuse the texture ID (overwriting the old texture)
	\param flags can be any of SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS | SOIL_FLAG_TEXTURE_REPEATS | SOIL_FLAG_MULTIPLY_ALPHA | SOIL_FLAG_INVERT_Y | SOIL_FLAG_COMPRESS_TO_DXT | SOIL_FLAG_DDS_LOAD_DIRECT
	\return 0-failed, otherwise returns the OpenGL texture handle
**/
unsigned int
	SOIL_create_OGL_single_cubemap
	(
		const unsigned char *const data,
		int width, int height, int channels,
		const char face_order[6],
		unsigned int reuse_texture_ID,
		unsigned int flags
	);

/**
	Captures the OpenGL window (RGB) and saves it to disk
	\return 0 if it failed, otherwise returns 1
**/
int
	SOIL_save_screenshot
	(
		const char *filename,
		int image_type,
		int x, int y,
		int width, int height
	);

/**
	Loads an image from disk into an array of unsigned chars.
	Note that *channels return the original channel count of the
	image.  If force_channels was other than SOIL_LOAD_AUTO,
	the resulting image has force_channels, but *channels may be
	different (if the original image had a different channel
	count).
	\return 0 if failed, otherwise returns 1
**/
unsigned char*
	SOIL_load_image
	(
		const char *filename,
		int *width, int *height, int *channels,
		int force_channels
	);

/**
	Loads an image from memory into an array of unsigned chars.
	Note that *channels return the original channel count of the
	image.  If force_channels was other than SOIL_LOAD_AUTO,
	the resulting image has force_channels, but *channels may be
	different (if the original image had a different channel
	count).
	\return 0 if failed, otherwise returns 1
**/
unsigned char*
	SOIL_load_image_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int *width, int *height, int *channels,
		int force_channels
	);

/**
	Saves an image from an array of unsigned chars (RGBA) to disk
	\param quality parameter only used for SOIL_SAVE_TYPE_JPG files, values accepted between 0 and 100.
	\return 0 if failed, otherwise returns 1
**/
int
	SOIL_save_image_quality
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data,
		int quality
	);

int
	SOIL_save_image
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data
	);

/**
	Frees the image data (note, this is just C's "free()"...this function is
	present mostly so C++ programmers don't forget to use "free()" and call
	"delete []" instead [8^)
**/
void
	SOIL_free_image_data
	(
		unsigned char *img_data
	);

/**
	This function resturn a pointer to a string describing the last thing
	that happened inside SOIL.  It can be used to determine why an image
	failed to load.
**/
const char*
	SOIL_last_result
	(
		void
	);

/** @return The address of the GL function proc, or NULL if the function is not found. */
void *
	SOIL_GL_GetProcAddress
	(
		const char *proc
	);

/** @return 1 if an OpenGL extension is supported for the current context, 0 otherwise. */
int
	SOIL_GL_ExtensionSupported
	(
		const char *extension
	);

/** Loads the DDS texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_DDS(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the DDS texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_DDS_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_PVR(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_PVR_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_ETC1(const char *filename,
		unsigned int reuse_texture_ID,
		int flags );

/** Loads the PVR texture directly to the GPU memory ( if supported ) */
unsigned int SOIL_direct_load_ETC1_from_memory(const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags );

#ifdef __cplusplus
}
#endif

#endif /* HEADER_SIMPLE_OPENGL_IMAGE_LIBRARY	*/



//#line 1 "SOIL2.c"
#define SOIL_CHECK_FOR_GL_ERRORS 0

#if defined( __APPLE_CC__ ) || defined ( __APPLE__ )
	#include <TargetConditionals.h>

	#if defined( __IPHONE__ ) || ( defined( TARGET_OS_IPHONE ) && TARGET_OS_IPHONE ) || ( defined( TARGET_IPHONE_SIMULATOR ) && TARGET_IPHONE_SIMULATOR )
		#define SOIL_PLATFORM_IOS
		#include <dlfcn.h>
	#else
		#define SOIL_PLATFORM_OSX
	#endif
#elif defined( __ANDROID__ ) || defined( ANDROID )
	#define SOIL_PLATFORM_ANDROID
#elif ( defined ( linux ) || defined( __linux__ ) || defined( __FreeBSD__ ) || defined(__OpenBSD__) || defined( __NetBSD__ ) || defined( __DragonFly__ ) || defined( __SVR4 ) )
	#define SOIL_X11_PLATFORM
#endif

#if ( defined( SOIL_PLATFORM_IOS ) || defined( SOIL_PLATFORM_ANDROID ) ) && ( !defined( SOIL_GLES1 ) && !defined( SOIL_GLES2 ) )
	#define SOIL_GLES2
#endif

#if ( defined( SOIL_GLES2 ) || defined( SOIL_GLES1 ) ) && !defined( SOIL_NO_EGL ) && !defined( SOIL_PLATFORM_IOS )
	#include <EGL/egl.h>
#endif

#if defined( SOIL_GLES2 )
	#ifdef SOIL_PLATFORM_IOS
		#include <OpenGLES/ES2/gl.h>
		#include <OpenGLES/ES2/glext.h>
	#else
		#include <GLES2/gl2.h>
		#include <GLES2/gl2ext.h>
	#endif

	#define APIENTRY GL_APIENTRY
#elif defined( SOIL_GLES1 )
	#ifndef GL_GLEXT_PROTOTYPES
	#define GL_GLEXT_PROTOTYPES
	#endif
	#ifdef SOIL_PLATFORM_IOS
		#include <OpenGLES/ES1/gl.h>
		#include <OpenGLES/ES1/glext.h>
	#else
		#include <GLES/gl.h>
		#include <GLES/glext.h>
	#endif

	#define APIENTRY GL_APIENTRY
#else

#if defined( __WIN32__ ) || defined( _WIN32 ) || defined( WIN32 )
	#define SOIL_PLATFORM_WIN32
	#define WIN32_LEAN_AND_MEAN
	#include <windows.h>
	#include <wingdi.h>
	#include <GL/gl.h>

	#ifndef GL_UNSIGNED_SHORT_4_4_4_4
	#define GL_UNSIGNED_SHORT_4_4_4_4 0x8033
	#endif
	#ifndef GL_UNSIGNED_SHORT_5_5_5_1
	#define GL_UNSIGNED_SHORT_5_5_5_1 0x8034
	#endif
	#ifndef GL_UNSIGNED_SHORT_5_6_5
	#define GL_UNSIGNED_SHORT_5_6_5 0x8363
	#endif
#elif defined(__APPLE__) || defined(__APPLE_CC__)
	/*	I can't test this Apple stuff!	*/
	#include <OpenGL/gl.h>
	#include <Carbon/Carbon.h>
	#define APIENTRY
#elif defined( SOIL_X11_PLATFORM )
	#include <GL/gl.h>
	#include <GL/glx.h>
#else
	#include <GL/gl.h>
#endif

#endif

#ifndef GL_BGRA
#define GL_BGRA                                             0x80E1
#endif

#ifndef GL_RG
#define GL_RG                             0x8227
#endif

#define STB_IMAGE_IMPLEMENTATION

#define STB_IMAGE_WRITE_IMPLEMENTATION


//#line 1 "jo_jpeg.h"
#ifndef JO_INCLUDE_JPEG_H
#define JO_INCLUDE_JPEG_H

// To get a header file for this, either cut and paste the header,
// or create jo_jpeg.h, #define JO_JPEG_HEADER_FILE_ONLY, and
// then include jo_jpeg.c from it.

// Returns false on failure
extern int jo_write_jpg(const char *filename, const void *data, int width, int height, int comp, int quality);

#endif // JO_INCLUDE_JPEG_H

#ifndef JO_JPEG_HEADER_FILE_ONLY

#if defined(_MSC_VER) && _MSC_VER >= 0x1400
#define _CRT_SECURE_NO_WARNINGS // suppress warnings about fopen()
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

static const unsigned char s_jo_ZigZag[] = { 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63 };

static void jo_writeBits(FILE *fp, int *bitBuf, int *bitCnt, const unsigned short *bs) {
	*bitCnt += bs[1];
	*bitBuf |= bs[0] << (24 - *bitCnt);
	while(*bitCnt >= 8) {
		unsigned char c = (*bitBuf >> 16) & 255;
		putc(c, fp);
		if(c == 255) {
			putc(0, fp);
		}
		*bitBuf <<= 8;
		*bitCnt -= 8;
	}
}

static void jo_DCT(float *d0, float *d1, float *d2, float *d3, float *d4, float *d5, float *d6, float *d7) {
	float tmp0 = *d0 + *d7;
	float tmp7 = *d0 - *d7;
	float tmp1 = *d1 + *d6;
	float tmp6 = *d1 - *d6;
	float tmp2 = *d2 + *d5;
	float tmp5 = *d2 - *d5;
	float tmp3 = *d3 + *d4;
	float tmp4 = *d3 - *d4;

	// Even part
	float tmp10 = tmp0 + tmp3;	// phase 2
	float tmp13 = tmp0 - tmp3;
	float tmp11 = tmp1 + tmp2;
	float tmp12 = tmp1 - tmp2;

	*d0 = tmp10 + tmp11; 		// phase 3
	*d4 = tmp10 - tmp11;

	float z1 = (tmp12 + tmp13) * 0.707106781f; // c4
	*d2 = tmp13 + z1; 		// phase 5
	*d6 = tmp13 - z1;

	// Odd part
	tmp10 = tmp4 + tmp5; 		// phase 2
	tmp11 = tmp5 + tmp6;
	tmp12 = tmp6 + tmp7;

	// The rotator is modified from fig 4-8 to avoid extra negations.
	float z5 = (tmp10 - tmp12) * 0.382683433f; // c6
	float z2 = tmp10 * 0.541196100f + z5; // c2-c6
	float z4 = tmp12 * 1.306562965f + z5; // c2+c6
	float z3 = tmp11 * 0.707106781f; // c4

	float z11 = tmp7 + z3;		// phase 5
	float z13 = tmp7 - z3;

	*d5 = z13 + z2;			// phase 6
	*d3 = z13 - z2;
	*d1 = z11 + z4;
	*d7 = z11 - z4;
}

static void jo_calcBits(int val, unsigned short bits[2]) {
	int tmp1 = val < 0 ? -val : val;
	val = val < 0 ? val-1 : val;
	bits[1] = 1;
	while(tmp1 >>= 1) {
		++bits[1];
	}
	bits[0] = val & ((1<<bits[1])-1);
}

static int jo_processDU(FILE *fp, int *bitBuf, int *bitCnt, float *CDU, float *fdtbl, int DC, const unsigned short HTDC[256][2], const unsigned short HTAC[256][2]) {
	const unsigned short EOB[2] = { HTAC[0x00][0], HTAC[0x00][1] };
	const unsigned short M16zeroes[2] = { HTAC[0xF0][0], HTAC[0xF0][1] };
	int dataOff, i, nrmarker;

	// DCT rows
	for(dataOff=0; dataOff<64; dataOff+=8) {
		jo_DCT(&CDU[dataOff], &CDU[dataOff+1], &CDU[dataOff+2], &CDU[dataOff+3], &CDU[dataOff+4], &CDU[dataOff+5], &CDU[dataOff+6], &CDU[dataOff+7]);
	}
	// DCT columns
	for(dataOff=0; dataOff<8; ++dataOff) {
		jo_DCT(&CDU[dataOff], &CDU[dataOff+8], &CDU[dataOff+16], &CDU[dataOff+24], &CDU[dataOff+32], &CDU[dataOff+40], &CDU[dataOff+48], &CDU[dataOff+56]);
	}
	// Quantize/descale/zigzag the coefficients
	int DU[64];
	for(i=0; i<64; ++i) {
		float v = CDU[i]*fdtbl[i];
		DU[s_jo_ZigZag[i]] = (int)(v < 0 ? ceilf(v - 0.5f) : floorf(v + 0.5f));
	}

	// Encode DC
	int diff = DU[0] - DC;
	if (diff == 0) {
		jo_writeBits(fp, bitBuf, bitCnt, HTDC[0]);
	} else {
		unsigned short bits[2];
		jo_calcBits(diff, bits);
		jo_writeBits(fp, bitBuf, bitCnt, HTDC[bits[1]]);
		jo_writeBits(fp, bitBuf, bitCnt, bits);
	}
	// Encode ACs
	int end0pos = 63;
	for(; (end0pos>0)&&(DU[end0pos]==0); --end0pos) {
	}
	// end0pos = first element in reverse order !=0
	if(end0pos == 0) {
		jo_writeBits(fp, bitBuf, bitCnt, EOB);
		return DU[0];
	}
	for(i = 1; i <= end0pos; ++i) {
		int startpos = i;
		for (; DU[i]==0 && i<=end0pos; ++i) {
		}
		int nrzeroes = i-startpos;
		if ( nrzeroes >= 16 ) {
			int lng = nrzeroes>>4;
			for (nrmarker=1; nrmarker <= lng; ++nrmarker)
				jo_writeBits(fp, bitBuf, bitCnt, M16zeroes);
			nrzeroes &= 15;
		}
		unsigned short bits[2];
		jo_calcBits(DU[i], bits);
		jo_writeBits(fp, bitBuf, bitCnt, HTAC[(nrzeroes<<4)+bits[1]]);
		jo_writeBits(fp, bitBuf, bitCnt, bits);
	}
	if(end0pos != 63) {
		jo_writeBits(fp, bitBuf, bitCnt, EOB);
	}
	return DU[0];
}

int jo_write_jpg(const char *filename, const void *data, int width, int height, int comp, int quality) {
	// Constants that don't pollute global namespace
	static const unsigned char std_dc_luminance_nrcodes[] = {0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0};
	static const unsigned char std_dc_luminance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};
	static const unsigned char std_ac_luminance_nrcodes[] = {0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d};
	static const unsigned char std_ac_luminance_values[] = {
		0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
		0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
		0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
		0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
		0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
		0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
		0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa
	};
	static const unsigned char std_dc_chrominance_nrcodes[] = {0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0};
	static const unsigned char std_dc_chrominance_values[] = {0,1,2,3,4,5,6,7,8,9,10,11};
	static const unsigned char std_ac_chrominance_nrcodes[] = {0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77};
	static const unsigned char std_ac_chrominance_values[] = {
		0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
		0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
		0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
		0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
		0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
		0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
		0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa
	};
	// Huffman tables
	static const unsigned short YDC_HT[256][2] = { {0,2},{2,3},{3,3},{4,3},{5,3},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9}};
	static const unsigned short UVDC_HT[256][2] = { {0,2},{1,2},{2,2},{6,3},{14,4},{30,5},{62,6},{126,7},{254,8},{510,9},{1022,10},{2046,11}};
	static const unsigned short YAC_HT[256][2] = {
		{10,4},{0,2},{1,2},{4,3},{11,4},{26,5},{120,7},{248,8},{1014,10},{65410,16},{65411,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{12,4},{27,5},{121,7},{502,9},{2038,11},{65412,16},{65413,16},{65414,16},{65415,16},{65416,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{28,5},{249,8},{1015,10},{4084,12},{65417,16},{65418,16},{65419,16},{65420,16},{65421,16},{65422,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{58,6},{503,9},{4085,12},{65423,16},{65424,16},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{59,6},{1016,10},{65430,16},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{122,7},{2039,11},{65438,16},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{123,7},{4086,12},{65446,16},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{250,8},{4087,12},{65454,16},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{504,9},{32704,15},{65462,16},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{505,9},{65470,16},{65471,16},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{506,9},{65479,16},{65480,16},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{1017,10},{65488,16},{65489,16},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{1018,10},{65497,16},{65498,16},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{2040,11},{65506,16},{65507,16},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{65515,16},{65516,16},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{0,0},{0,0},{0,0},{0,0},{0,0},
		{2041,11},{65525,16},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}
	};
	static const unsigned short UVAC_HT[256][2] = {
		{0,2},{1,2},{4,3},{10,4},{24,5},{25,5},{56,6},{120,7},{500,9},{1014,10},{4084,12},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{11,4},{57,6},{246,8},{501,9},{2038,11},{4085,12},{65416,16},{65417,16},{65418,16},{65419,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{26,5},{247,8},{1015,10},{4086,12},{32706,15},{65420,16},{65421,16},{65422,16},{65423,16},{65424,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{27,5},{248,8},{1016,10},{4087,12},{65425,16},{65426,16},{65427,16},{65428,16},{65429,16},{65430,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{58,6},{502,9},{65431,16},{65432,16},{65433,16},{65434,16},{65435,16},{65436,16},{65437,16},{65438,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{59,6},{1017,10},{65439,16},{65440,16},{65441,16},{65442,16},{65443,16},{65444,16},{65445,16},{65446,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{121,7},{2039,11},{65447,16},{65448,16},{65449,16},{65450,16},{65451,16},{65452,16},{65453,16},{65454,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{122,7},{2040,11},{65455,16},{65456,16},{65457,16},{65458,16},{65459,16},{65460,16},{65461,16},{65462,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{249,8},{65463,16},{65464,16},{65465,16},{65466,16},{65467,16},{65468,16},{65469,16},{65470,16},{65471,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{503,9},{65472,16},{65473,16},{65474,16},{65475,16},{65476,16},{65477,16},{65478,16},{65479,16},{65480,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{504,9},{65481,16},{65482,16},{65483,16},{65484,16},{65485,16},{65486,16},{65487,16},{65488,16},{65489,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{505,9},{65490,16},{65491,16},{65492,16},{65493,16},{65494,16},{65495,16},{65496,16},{65497,16},{65498,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{506,9},{65499,16},{65500,16},{65501,16},{65502,16},{65503,16},{65504,16},{65505,16},{65506,16},{65507,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{2041,11},{65508,16},{65509,16},{65510,16},{65511,16},{65512,16},{65513,16},{65514,16},{65515,16},{65516,16},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
		{16352,14},{65517,16},{65518,16},{65519,16},{65520,16},{65521,16},{65522,16},{65523,16},{65524,16},{65525,16},{0,0},{0,0},{0,0},{0,0},{0,0},
		{1018,10},{32707,15},{65526,16},{65527,16},{65528,16},{65529,16},{65530,16},{65531,16},{65532,16},{65533,16},{65534,16},{0,0},{0,0},{0,0},{0,0},{0,0}
	};
	static const int YQT[] = {16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99};
	static const int UVQT[] = {17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99};
	static const float aasf[] = { 1.0f * 2.828427125f, 1.387039845f * 2.828427125f, 1.306562965f * 2.828427125f, 1.175875602f * 2.828427125f, 1.0f * 2.828427125f, 0.785694958f * 2.828427125f, 0.541196100f * 2.828427125f, 0.275899379f * 2.828427125f };
	int i, row, col, x, y, k, pos;

	if(!data || !filename || !width || !height || comp > 4 || comp < 1 || comp == 2) {
		return 0;
	}

	FILE *fp = fopen(filename, "wb");
	if(!fp) {
		return 0;
	}

	quality = quality ? quality : 90;
	quality = quality < 1 ? 1 : quality > 100 ? 100 : quality;
	quality = quality < 50 ? 5000 / quality : 200 - quality * 2;

	unsigned char YTable[64], UVTable[64];
	for(i = 0; i < 64; ++i) {
		int yti = (YQT[i]*quality+50)/100;
		YTable[s_jo_ZigZag[i]] = yti < 1 ? 1 : yti > 255 ? 255 : yti;
		int uvti  = (UVQT[i]*quality+50)/100;
		UVTable[s_jo_ZigZag[i]] = uvti < 1 ? 1 : uvti > 255 ? 255 : uvti;
	}

	float fdtbl_Y[64], fdtbl_UV[64];
	for(row = 0, k = 0; row < 8; ++row) {
		for(col = 0; col < 8; ++col, ++k) {
			fdtbl_Y[k]  = 1 / (YTable [s_jo_ZigZag[k]] * aasf[row] * aasf[col]);
			fdtbl_UV[k] = 1 / (UVTable[s_jo_ZigZag[k]] * aasf[row] * aasf[col]);
		}
	}

	// Write Headers
	static const unsigned char head0[] = { 0xFF,0xD8,0xFF,0xE0,0,0x10,'J','F','I','F',0,1,1,0,0,1,0,1,0,0,0xFF,0xDB,0,0x84,0 };
	fwrite(head0, sizeof(head0), 1, fp);
	fwrite(YTable, sizeof(YTable), 1, fp);
	putc(1, fp);
	fwrite(UVTable, sizeof(UVTable), 1, fp);
	const unsigned char head1[] = { 0xFF,0xC0,0,0x11,8,(unsigned char)(height>>8),(unsigned char)(height&0xFF),(unsigned char)(width>>8),(unsigned char)(width&0xFF),3,1,0x11,0,2,0x11,1,3,0x11,1,0xFF,0xC4,0x01,0xA2,0 };
	fwrite(head1, sizeof(head1), 1, fp);
	fwrite(std_dc_luminance_nrcodes+1, sizeof(std_dc_luminance_nrcodes)-1, 1, fp);
	fwrite(std_dc_luminance_values, sizeof(std_dc_luminance_values), 1, fp);
	putc(0x10, fp); // HTYACinfo
	fwrite(std_ac_luminance_nrcodes+1, sizeof(std_ac_luminance_nrcodes)-1, 1, fp);
	fwrite(std_ac_luminance_values, sizeof(std_ac_luminance_values), 1, fp);
	putc(1, fp); // HTUDCinfo
	fwrite(std_dc_chrominance_nrcodes+1, sizeof(std_dc_chrominance_nrcodes)-1, 1, fp);
	fwrite(std_dc_chrominance_values, sizeof(std_dc_chrominance_values), 1, fp);
	putc(0x11, fp); // HTUACinfo
	fwrite(std_ac_chrominance_nrcodes+1, sizeof(std_ac_chrominance_nrcodes)-1, 1, fp);
	fwrite(std_ac_chrominance_values, sizeof(std_ac_chrominance_values), 1, fp);
	static const unsigned char head2[] = { 0xFF,0xDA,0,0xC,3,1,0,2,0x11,3,0x11,0,0x3F,0 };
	fwrite(head2, sizeof(head2), 1, fp);

	// Encode 8x8 macroblocks
	const unsigned char *imageData = (const unsigned char *)data;
	int DCY=0, DCU=0, DCV=0;
	int bitBuf=0, bitCnt=0;
	int ofsG = comp > 1 ? 1 : 0, ofsB = comp > 1 ? 2 : 0;
	for(y = 0; y < height; y += 8) {
		for(x = 0; x < width; x += 8) {
			float YDU[64], UDU[64], VDU[64];
			for(row = y, pos = 0; row < y+8; ++row) {
				for(col = x; col < x+8; ++col, ++pos) {
					int p = row*width*comp + col*comp;
					if(row >= height) {
						p -= width*comp*(row+1 - height);
					}
					if(col >= width) {
						p -= comp*(col+1 - width);
					}

					float r = imageData[p+0], g = imageData[p+ofsG], b = imageData[p+ofsB];
					YDU[pos]=+0.29900f*r+0.58700f*g+0.11400f*b-128;
					UDU[pos]=-0.16874f*r-0.33126f*g+0.50000f*b;
					VDU[pos]=+0.50000f*r-0.41869f*g-0.08131f*b;
				}
			}

			DCY = jo_processDU(fp, &bitBuf, &bitCnt, YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
			DCU = jo_processDU(fp, &bitBuf, &bitCnt, UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
			DCV = jo_processDU(fp, &bitBuf, &bitCnt, VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
		}
	}

	// Do the bit alignment of the EOI marker
	static const unsigned short fillBits[] = {0x7F, 7};
	jo_writeBits(fp, &bitBuf, &bitCnt, fillBits);

	// EOI
	putc(0xFF, fp);
	putc(0xD9, fp);

	fclose(fp);
	return 1;
}

#endif

#include <stdlib.h>
#include <string.h>

/*	error reporting	*/
const char *result_string_pointer = "SOIL initialized";

/*	for loading cube maps	*/
enum{
	SOIL_CAPABILITY_UNKNOWN = -1,
	SOIL_CAPABILITY_NONE = 0,
	SOIL_CAPABILITY_PRESENT = 1
};
static int has_cubemap_capability = SOIL_CAPABILITY_UNKNOWN;
int query_cubemap_capability( void );
#define SOIL_TEXTURE_WRAP_R					0x8072
#define SOIL_CLAMP_TO_EDGE					0x812F
#define SOIL_NORMAL_MAP						0x8511
#define SOIL_REFLECTION_MAP					0x8512
#define SOIL_TEXTURE_CUBE_MAP				0x8513
#define SOIL_TEXTURE_BINDING_CUBE_MAP		0x8514
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_X	0x8515
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X	0x8516
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y	0x8517
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y	0x8518
#define SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z	0x8519
#define SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z	0x851A
#define SOIL_PROXY_TEXTURE_CUBE_MAP			0x851B
#define SOIL_MAX_CUBE_MAP_TEXTURE_SIZE		0x851C
/*	for non-power-of-two texture	*/
#define SOIL_IS_POW2( v ) ( ( v & ( v - 1 ) ) == 0 )
static int has_NPOT_capability = SOIL_CAPABILITY_UNKNOWN;
int query_NPOT_capability( void );
/*	for texture rectangles	*/
static int has_tex_rectangle_capability = SOIL_CAPABILITY_UNKNOWN;
int query_tex_rectangle_capability( void );
#define SOIL_TEXTURE_RECTANGLE_ARB				0x84F5
#define SOIL_MAX_RECTANGLE_TEXTURE_SIZE_ARB		0x84F8
/*	for using DXT compression	*/
static int has_DXT_capability = SOIL_CAPABILITY_UNKNOWN;
int query_DXT_capability( void );
#define SOIL_GL_SRGB			0x8C40
#define SOIL_GL_SRGB_ALPHA		0x8C42
#define SOIL_RGB_S3TC_DXT1		0x83F0
#define SOIL_RGBA_S3TC_DXT1		0x83F1
#define SOIL_RGBA_S3TC_DXT3		0x83F2
#define SOIL_RGBA_S3TC_DXT5		0x83F3
#define SOIL_GL_COMPRESSED_SRGB_S3TC_DXT1_EXT  0x8C4C
#define SOIL_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT 0x8C4F
static int has_sRGB_capability = SOIL_CAPABILITY_UNKNOWN;
int query_sRGB_capability( void );
typedef void (APIENTRY * P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data);
static P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC soilGlCompressedTexImage2D = NULL;

typedef void (APIENTRY *P_SOIL_GLGENERATEMIPMAPPROC)(GLenum target);
static P_SOIL_GLGENERATEMIPMAPPROC soilGlGenerateMipmap = NULL;

static int has_gen_mipmap_capability = SOIL_CAPABILITY_UNKNOWN;
static int query_gen_mipmap_capability( void );

static int has_PVR_capability = SOIL_CAPABILITY_UNKNOWN;
int query_PVR_capability( void );
static int has_BGRA8888_capability = SOIL_CAPABILITY_UNKNOWN;
int query_BGRA8888_capability( void );
static int has_ETC1_capability = SOIL_CAPABILITY_UNKNOWN;
int query_ETC1_capability( void );

/* GL_IMG_texture_compression_pvrtc */
#define SOIL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG                      0x8C00
#define SOIL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG                      0x8C01
#define SOIL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG                     0x8C02
#define SOIL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG                     0x8C03
#define SOIL_GL_ETC1_RGB8_OES                                     0x8D64

#if defined( SOIL_X11_PLATFORM ) || defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX )
typedef const GLubyte *(APIENTRY * P_SOIL_glGetStringiFunc) (GLenum, GLuint);
static P_SOIL_glGetStringiFunc soilGlGetStringiFunc = NULL;

static int isAtLeastGL3()
{
	static int is_gl3 = SOIL_CAPABILITY_UNKNOWN;

	if ( SOIL_CAPABILITY_UNKNOWN == is_gl3 )
	{
		const char * verstr	= (const char *) glGetString( GL_VERSION );
		is_gl3				= ( verstr && ( atoi(verstr) >= 3 ) );
	}

	return is_gl3;
}
#endif

#ifdef SOIL_PLATFORM_WIN32
static HMODULE openglModule = NULL;
static int soilTestWinProcPointer(const PROC pTest)
{
	ptrdiff_t iTest;
	if(!pTest) return 0;
	iTest = (ptrdiff_t)pTest;
	if(iTest == 1 || iTest == 2 || iTest == 3 || iTest == -1) return 0;
	return 1;
}
#endif

void * SOIL_GL_GetProcAddress(const char *proc)
{
	void *func = NULL;

#if defined( SOIL_PLATFORM_IOS )
	func = dlsym( RTLD_DEFAULT, proc );
#elif defined( SOIL_GLES2 ) || defined( SOIL_GLES1 )
	#ifndef SOIL_NO_EGL
		func = eglGetProcAddress( proc );
	#else
		func = NULL;
	#endif
#elif defined( SOIL_PLATFORM_WIN32 )
	if ( NULL == openglModule )
		openglModule = LoadLibraryA("opengl32.dll");

	func =  wglGetProcAddress( proc );

	if (!soilTestWinProcPointer((const PROC)func)) {
		func = (void *)GetProcAddress(openglModule, proc);
	}

#elif defined( SOIL_PLATFORM_OSX )
	/*	I can't test this Apple stuff!	*/
	CFBundleRef bundle;
	CFURLRef bundleURL =
	CFURLCreateWithFileSystemPath(
								  kCFAllocatorDefault,
								  CFSTR("/System/Library/Frameworks/OpenGL.framework"),
								  kCFURLPOSIXPathStyle,
								  true );
	CFStringRef extensionName =
	CFStringCreateWithCString(
							  kCFAllocatorDefault,
							  proc,
							  kCFStringEncodingASCII );
	bundle = CFBundleCreate( kCFAllocatorDefault, bundleURL );
	assert( bundle != NULL );

	func = CFBundleGetFunctionPointerForName( bundle, extensionName );

	CFRelease( bundleURL );
	CFRelease( extensionName );
	CFRelease( bundle );
#elif defined( SOIL_X11_PLATFORM )
	func =
#if !defined(GLX_VERSION_1_4)
	glXGetProcAddressARB
#else
	glXGetProcAddress
#endif
	( (const GLubyte *)proc );
#endif

	return func;
}

/* Based on the SDL2 implementation */
int SOIL_GL_ExtensionSupported(const char *extension)
{
	const char *extensions;
	const char *start;
	const char *where, *terminator;

	/* Extension names should not have spaces. */
	where = strchr(extension, ' ');

	if (where || *extension == '\0')
	{
		return 0;
	}

	#if defined( SOIL_X11_PLATFORM ) || defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX )
	/* Lookup the available extensions */
	if ( isAtLeastGL3() )
	{
		GLint num_exts = 0;
		GLint i;

		if ( NULL == soilGlGetStringiFunc )
		{
			soilGlGetStringiFunc = (P_SOIL_glGetStringiFunc)SOIL_GL_GetProcAddress("glGetStringi");

			if ( NULL == soilGlGetStringiFunc )
			{
				return 0;
			}
		}

		#ifndef GL_NUM_EXTENSIONS
		#define GL_NUM_EXTENSIONS 0x821D
		#endif
		glGetIntegerv(GL_NUM_EXTENSIONS, &num_exts);
		for (i = 0; i < num_exts; i++)
		{
			const char *thisext = (const char *) soilGlGetStringiFunc(GL_EXTENSIONS, i);

			if (strcmp(thisext, extension) == 0)
			{
				return 1;
			}
		}

		return 0;
	}
	#endif

	/* Try the old way with glGetString(GL_EXTENSIONS) ... */
	extensions = (const char *) glGetString(GL_EXTENSIONS);

	if (!extensions)
	{
		return 0;
	}

	/*
	 * It takes a bit of care to be fool-proof about parsing the OpenGL
	 * extensions string. Don't be fooled by sub-strings, etc.
	 */
	start = extensions;

	for (;;) {
		where = strstr(start, extension);

		if (!where)
			break;

		terminator = where + strlen(extension);

		if (where == start || *(where - 1) == ' ')
			if (*terminator == ' ' || *terminator == '\0')
				return 1;

		start = terminator;
	}

	return 0;
}

/*	other functions	*/
unsigned int
	SOIL_internal_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags,
		unsigned int opengl_texture_type,
		unsigned int opengl_texture_target,
		unsigned int texture_check_size_enum
	);

/*	and the code magic begins here [8^)	*/
unsigned int
	SOIL_load_OGL_texture
	(
		const char *filename,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS( filename, reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR( filename, reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_ETC1( filename, reuse_texture_ID, flags );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	/*	try to load the image	*/
	img = SOIL_load_image( filename, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_HDR_texture
	(
		const char *filename,
		int fake_HDR_format,
		int rescale_to_max,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img = NULL;
	int width, height, channels;
	unsigned int tex_id;
	/*	no direct uploading of the image as a DDS file	*/
	/* error check */
	if( (fake_HDR_format != SOIL_HDR_RGBE) &&
		(fake_HDR_format != SOIL_HDR_RGBdivA) &&
		(fake_HDR_format != SOIL_HDR_RGBdivA2) )
	{
		result_string_pointer = "Invalid fake HDR format specified";
		return 0;
	}

	/* check if the image is HDR */
	if ( stbi_is_hdr( filename ) )
	{
		/*	try to load the image (only the HDR type) */
		img = stbi_load( filename, &width, &height, &channels, 4 );
	}

	/*	channels holds the original number of channels, which may have been forced	*/
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/* the load worked, do I need to convert it? */
	if( fake_HDR_format == SOIL_HDR_RGBdivA )
	{
		RGBE_to_RGBdivA( img, width, height, rescale_to_max );
	} else if( fake_HDR_format == SOIL_HDR_RGBdivA2 )
	{
		RGBE_to_RGBdivA2( img, width, height, rescale_to_max );
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_texture_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 0 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_ETC1_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	/*	try to load the image	*/
	img = SOIL_load_image_from_memory(
					buffer, buffer_length,
					&width, &height, &channels,
					force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	OK, make it a texture!	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			GL_TEXTURE_2D, GL_TEXTURE_2D,
			GL_MAX_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_cubemap
	(
		const char *x_pos_file,
		const char *x_neg_file,
		const char *y_pos_file,
		const char *y_neg_file,
		const char *z_pos_file,
		const char *z_neg_file,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	error checking	*/
	if( (x_pos_file == NULL) ||
		(x_neg_file == NULL) ||
		(y_pos_file == NULL) ||
		(y_neg_file == NULL) ||
		(z_pos_file == NULL) ||
		(z_neg_file == NULL) )
	{
		result_string_pointer = "Invalid cube map files list";
		return 0;
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st face: try to load the image	*/
	img = SOIL_load_image( x_pos_file, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	upload the texture, and create a texture ID if necessary	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_X,
			SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( x_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( y_pos_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( y_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( z_pos_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image( z_neg_file, &width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_cubemap_from_memory
	(
		const unsigned char *const x_pos_buffer,
		int x_pos_buffer_length,
		const unsigned char *const x_neg_buffer,
		int x_neg_buffer_length,
		const unsigned char *const y_pos_buffer,
		int y_pos_buffer_length,
		const unsigned char *const y_neg_buffer,
		int y_neg_buffer_length,
		const unsigned char *const z_pos_buffer,
		int z_pos_buffer_length,
		const unsigned char *const z_neg_buffer,
		int z_neg_buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels;
	unsigned int tex_id;
	/*	error checking	*/
	if( (x_pos_buffer == NULL) ||
		(x_neg_buffer == NULL) ||
		(y_pos_buffer == NULL) ||
		(y_neg_buffer == NULL) ||
		(z_pos_buffer == NULL) ||
		(z_neg_buffer == NULL) )
	{
		result_string_pointer = "Invalid cube map buffers list";
		return 0;
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st face: try to load the image	*/
	img = SOIL_load_image_from_memory(
			x_pos_buffer, x_pos_buffer_length,
			&width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	upload the texture, and create a texture ID if necessary	*/
	tex_id = SOIL_internal_create_OGL_texture(
			img, &width, &height, channels,
			reuse_texture_ID, flags,
			SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_X,
			SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	/*	and nuke the image data	*/
	SOIL_free_image_data( img );
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				x_neg_buffer, x_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				y_pos_buffer, y_pos_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				y_neg_buffer, y_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				z_pos_buffer, z_pos_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	continue?	*/
	if( tex_id != 0 )
	{
		/*	1st face: try to load the image	*/
		img = SOIL_load_image_from_memory(
				z_neg_buffer, z_neg_buffer_length,
				&width, &height, &channels, force_channels );
		/*	channels holds the original number of channels, which may have been forced	*/
		if( (force_channels >= 1) && (force_channels <= 4) )
		{
			channels = force_channels;
		}
		if( NULL == img )
		{
			/*	image loading failed	*/
			result_string_pointer = stbi_failure_reason();
			return 0;
		}
		/*	upload the texture, but reuse the assigned texture ID	*/
		tex_id = SOIL_internal_create_OGL_texture(
				img, &width, &height, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP, SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
		/*	and nuke the image data	*/
		SOIL_free_image_data( img );
	}
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_load_OGL_single_cubemap
	(
		const char *filename,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels, i;
	unsigned int tex_id = 0;
	/*	error checking	*/
	if( filename == NULL )
	{
		result_string_pointer = "Invalid single cube map file name";
		return 0;
	}
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS( filename, reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR( filename, reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		return 0;
	}

	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st off, try to load the full image	*/
	img = SOIL_load_image( filename, &width, &height, &channels, force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		SOIL_free_image_data( img );
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	try the image split and create	*/
	tex_id = SOIL_create_OGL_single_cubemap(
			img, width, height, channels,
			face_order, reuse_texture_ID, flags
			);
	/*	nuke the temporary image data and return the texture handle	*/
	SOIL_free_image_data( img );
	return tex_id;
}

unsigned int
	SOIL_load_OGL_single_cubemap_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* img;
	int width, height, channels, i;
	unsigned int tex_id = 0;
	/*	error checking	*/
	if( buffer == NULL )
	{
		result_string_pointer = "Invalid single cube map buffer";
		return 0;
	}
	/*	does the user want direct uploading of the image as a DDS file?	*/
	if( flags & SOIL_FLAG_DDS_LOAD_DIRECT )
	{
		/*	1st try direct loading of the image as a DDS file
			note: direct uploading will only load what is in the
			DDS file, no MIPmaps will be generated, the image will
			not be flipped, etc.	*/
		tex_id = SOIL_direct_load_DDS_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 1 );
		if( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_PVR_LOAD_DIRECT )
	{
		tex_id = SOIL_direct_load_PVR_from_memory(
				buffer, buffer_length,
				reuse_texture_ID, flags, 1 );
		if ( tex_id )
		{
			/*	hey, it worked!!	*/
			return tex_id;
		}
	}

	if ( flags & SOIL_FLAG_ETC1_LOAD_DIRECT )
	{
		return 0;
	}

	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	1st off, try to load the full image	*/
	img = SOIL_load_image_from_memory(
			buffer, buffer_length,
			&width, &height, &channels,
			force_channels );
	/*	channels holds the original number of channels, which may have been forced	*/
	if( (force_channels >= 1) && (force_channels <= 4) )
	{
		channels = force_channels;
	}
	if( NULL == img )
	{
		/*	image loading failed	*/
		result_string_pointer = stbi_failure_reason();
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		SOIL_free_image_data( img );
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	try the image split and create	*/
	tex_id = SOIL_create_OGL_single_cubemap(
			img, width, height, channels,
			face_order, reuse_texture_ID, flags
			);
	/*	nuke the temporary image data and return the texture handle	*/
	SOIL_free_image_data( img );
	return tex_id;
}

unsigned int
	SOIL_create_OGL_single_cubemap
	(
		const unsigned char *const data,
		int width, int height, int channels,
		const char face_order[6],
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	variables	*/
	unsigned char* sub_img;
	int dw, dh, sz, i;
	unsigned int tex_id;
	/*	error checking	*/
	if( data == NULL )
	{
		result_string_pointer = "Invalid single cube map image data";
		return 0;
	}
	/*	face order checking	*/
	for( i = 0; i < 6; ++i )
	{
		if( (face_order[i] != 'N') &&
			(face_order[i] != 'S') &&
			(face_order[i] != 'W') &&
			(face_order[i] != 'E') &&
			(face_order[i] != 'U') &&
			(face_order[i] != 'D') )
		{
			result_string_pointer = "Invalid single cube map face order";
			return 0;
		};
	}
	/*	capability checking	*/
	if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
	{
		result_string_pointer = "No cube map capability present";
		return 0;
	}
	/*	now, does this image have the right dimensions?	*/
	if( (width != 6*height) &&
		(6*width != height) )
	{
		result_string_pointer = "Single cubemap image must have a 6:1 ratio";
		return 0;
	}
	/*	which way am I stepping?	*/
	if( width > height )
	{
		dw = height;
		dh = 0;
	} else
	{
		dw = 0;
		dh = width;
	}
	sz = dw+dh;
	sub_img = (unsigned char *)malloc( sz*sz*channels );
	/*	do the splitting and uploading	*/
	tex_id = reuse_texture_ID;
	for( i = 0; i < 6; ++i )
	{
		int x, y, idx = 0;
		unsigned int cubemap_target = 0;
		/*	copy in the sub-image	*/
		for( y = i*dh; y < i*dh+sz; ++y )
		{
			for( x = i*dw*channels; x < (i*dw+sz)*channels; ++x )
			{
				sub_img[idx++] = data[y*width*channels+x];
			}
		}
		/*	what is my texture target?
			remember, this coordinate system is
			LHS if viewed from inside the cube!	*/
		switch( face_order[i] )
		{
		case 'N':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_Z;
			break;
		case 'S':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
			break;
		case 'W':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_X;
			break;
		case 'E':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_X;
			break;
		case 'U':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_POSITIVE_Y;
			break;
		case 'D':
			cubemap_target = SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Y;
			break;
		}
		/*	upload it as a texture	*/
		tex_id = SOIL_internal_create_OGL_texture(
				sub_img, &sz, &sz, channels,
				tex_id, flags,
				SOIL_TEXTURE_CUBE_MAP,
				cubemap_target,
				SOIL_MAX_CUBE_MAP_TEXTURE_SIZE );
	}
	/*	and nuke the image and sub-image data	*/
	SOIL_free_image_data( sub_img );
	/*	and return the handle, such as it is	*/
	return tex_id;
}

unsigned int
	SOIL_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	)
{
	/*	wrapper function for 2D textures	*/
	return SOIL_internal_create_OGL_texture(
				data, width, height, channels,
				reuse_texture_ID, flags,
				GL_TEXTURE_2D, GL_TEXTURE_2D,
				GL_MAX_TEXTURE_SIZE );
}

#if SOIL_CHECK_FOR_GL_ERRORS
void check_for_GL_errors( const char *calling_location )
{
	/*	check for errors	*/
	GLenum err_code = glGetError();
	while( GL_NO_ERROR != err_code )
	{
		printf( "OpenGL Error @ %s: %i", calling_location, err_code );
		err_code = glGetError();
	}
}
#else
void check_for_GL_errors( const char *calling_location )
{
	/*	no check for errors	*/
}
#endif

static void createMipmaps(const unsigned char *const img,
		int width, int height, int channels,
		unsigned int flags,
		unsigned int opengl_texture_target,
		unsigned int internal_texture_format,
		unsigned int original_texture_format,
		int DXT_mode)
{
	if ( ( flags & SOIL_FLAG_GL_MIPMAPS ) && query_gen_mipmap_capability() == SOIL_CAPABILITY_PRESENT )
	{
		soilGlGenerateMipmap(opengl_texture_target);
	}
	else
	{
		int MIPlevel = 1;
		int MIPwidth = (width+1) / 2;
		int MIPheight = (height+1) / 2;
		unsigned char *resampled = (unsigned char*)malloc( channels*MIPwidth*MIPheight );

		while( ((1<<MIPlevel) <= width) || ((1<<MIPlevel) <= height) )
		{
			/*	do this MIPmap level	*/
			mipmap_image(
					img, width, height, channels,
					resampled,
					(1 << MIPlevel), (1 << MIPlevel) );

			/*  upload the MIPmaps	*/
			if( DXT_mode == SOIL_CAPABILITY_PRESENT )
			{
				/*	user wants me to do the DXT conversion!	*/
				int DDS_size;
				unsigned char *DDS_data = NULL;
				if( (channels & 1) == 1 )
				{
					/*	RGB, use DXT1	*/
					DDS_data = convert_image_to_DXT1(
							resampled, MIPwidth, MIPheight, channels, &DDS_size );
				} else
				{
					/*	RGBA, use DXT5	*/
					DDS_data = convert_image_to_DXT5(
							resampled, MIPwidth, MIPheight, channels, &DDS_size );
				}
				if( DDS_data )
				{
					soilGlCompressedTexImage2D(
						opengl_texture_target, MIPlevel,
						internal_texture_format, MIPwidth, MIPheight, 0,
						DDS_size, DDS_data );
					check_for_GL_errors( "glCompressedTexImage2D" );
					SOIL_free_image_data( DDS_data );
				} else
				{
					/*	my compression failed, try the OpenGL driver's version	*/
					glTexImage2D(
						opengl_texture_target, MIPlevel,
						internal_texture_format, MIPwidth, MIPheight, 0,
						original_texture_format, GL_UNSIGNED_BYTE, resampled );
					check_for_GL_errors( "glTexImage2D" );
				}
			} else
			{
				/*	user want OpenGL to do all the work!	*/
				glTexImage2D(
					opengl_texture_target, MIPlevel,
					internal_texture_format, MIPwidth, MIPheight, 0,
					original_texture_format, GL_UNSIGNED_BYTE, resampled );
				check_for_GL_errors( "glTexImage2D" );
			}
			/*	prep for the next level	*/
			++MIPlevel;
			MIPwidth = (MIPwidth + 1) / 2;
			MIPheight = (MIPheight + 1) / 2;
		}

		SOIL_free_image_data( resampled );
	}
}

unsigned int
	SOIL_internal_create_OGL_texture
	(
		const unsigned char *const data,
		int *width, int *height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags,
		unsigned int opengl_texture_type,
		unsigned int opengl_texture_target,
		unsigned int texture_check_size_enum
	)
{
	/*	variables	*/
	unsigned char* img = NULL;
	unsigned int tex_id;
	unsigned int internal_texture_format = 0, original_texture_format = 0;
	int DXT_mode = SOIL_CAPABILITY_UNKNOWN;
	int sRGB_texture = query_sRGB_capability() == SOIL_CAPABILITY_PRESENT && ( flags & SOIL_FLAG_SRGB_COLOR_SPACE );;
	int max_supported_size;
	int iwidth = *width;
	int iheight = *height;
	int needCopy;
	GLint unpack_aligment;

	/*	how large of a texture can this OpenGL implementation handle?	*/
	/*	texture_check_size_enum will be GL_MAX_TEXTURE_SIZE or SOIL_MAX_CUBE_MAP_TEXTURE_SIZE	*/
	glGetIntegerv( texture_check_size_enum, &max_supported_size );

	/*	If the user wants to use the texture rectangle I kill a few flags	*/
	if( flags & SOIL_FLAG_TEXTURE_RECTANGLE )
	{
		/*	well, the user asked for it, can we do that?	*/
		if( query_tex_rectangle_capability() == SOIL_CAPABILITY_PRESENT )
		{
			/*	only allow this if the user in _NOT_ trying to do a cubemap!	*/
			if( opengl_texture_type == GL_TEXTURE_2D )
			{
				/*	clean out the flags that cannot be used with texture rectangles	*/
				flags &= ~(
						SOIL_FLAG_POWER_OF_TWO | SOIL_FLAG_MIPMAPS |
						SOIL_FLAG_TEXTURE_REPEATS
					);
				/*	and change my target	*/
				opengl_texture_target = SOIL_TEXTURE_RECTANGLE_ARB;
				opengl_texture_type = SOIL_TEXTURE_RECTANGLE_ARB;
			} else
			{
				/*	not allowed for any other uses (yes, I'm looking at you, cubemaps!)	*/
				flags &= ~SOIL_FLAG_TEXTURE_RECTANGLE;
			}

		} else
		{
			/*	can't do it, and that is a breakable offense (uv coords use pixels instead of [0,1]!)	*/
			result_string_pointer = "Texture Rectangle extension unsupported";
			return 0;
		}
	}

	/*	if the user can't support NPOT textures, make sure we force the POT option	*/
	if( (query_NPOT_capability() == SOIL_CAPABILITY_NONE) &&
		!(flags & SOIL_FLAG_TEXTURE_RECTANGLE) )
	{
		/*	add in the POT flag */
		flags |= SOIL_FLAG_POWER_OF_TWO;
	}

	needCopy = ( ( flags & SOIL_FLAG_INVERT_Y ) ||
				 ( flags & SOIL_FLAG_NTSC_SAFE_RGB ) ||
				 ( flags & SOIL_FLAG_MULTIPLY_ALPHA ) ||
				 ( flags & SOIL_FLAG_CoCg_Y )
				);

	/*	create a copy the image data only if needed */
	if ( needCopy ) {
		img = (unsigned char*)malloc( iwidth*iheight*channels );
		memcpy( img, data, iwidth*iheight*channels );
	}

	/*	does the user want me to invert the image?	*/
	if( flags & SOIL_FLAG_INVERT_Y )
	{
		int i, j;
		for( j = 0; j*2 < iheight; ++j )
		{
			int index1 = j * iwidth * channels;
			int index2 = (iheight - 1 - j) * iwidth * channels;
			for( i = iwidth * channels; i > 0; --i )
			{
				unsigned char temp = img[index1];
				img[index1] = img[index2];
				img[index2] = temp;
				++index1;
				++index2;
			}
		}
	}
	/*	does the user want me to scale the colors into the NTSC safe RGB range?	*/
	if( flags & SOIL_FLAG_NTSC_SAFE_RGB )
	{
		scale_image_RGB_to_NTSC_safe( img, iwidth, iheight, channels );
	}
	/*	does the user want me to convert from straight to pre-multiplied alpha?
		(and do we even _have_ alpha?)	*/
	if( flags & SOIL_FLAG_MULTIPLY_ALPHA )
	{
		int i;
		switch( channels )
		{
		case 2:
			for( i = 0; i < 2*iwidth*iheight; i += 2 )
			{
				img[i] = (img[i] * img[i+1] + 128) >> 8;
			}
			break;
		case 4:
			for( i = 0; i < 4*iwidth*iheight; i += 4 )
			{
				img[i+0] = (img[i+0] * img[i+3] + 128) >> 8;
				img[i+1] = (img[i+1] * img[i+3] + 128) >> 8;
				img[i+2] = (img[i+2] * img[i+3] + 128) >> 8;
			}
			break;
		default:
			/*	no other number of channels contains alpha data	*/
			break;
		}
	}

	/*	do I need to make it a power of 2?	*/
	if(
		( ( flags & SOIL_FLAG_POWER_OF_TWO) && ( !SOIL_IS_POW2(iwidth) || !SOIL_IS_POW2(iheight) ) ) ||	/*	user asked for it and the texture is not power of 2	*/
		( (flags & SOIL_FLAG_MIPMAPS)&& !( ( flags & SOIL_FLAG_GL_MIPMAPS ) &&
										   query_gen_mipmap_capability() == SOIL_CAPABILITY_PRESENT &&
										   query_NPOT_capability() == SOIL_CAPABILITY_PRESENT ) ) ||	/*	need it for the MIP-maps when mipmaps required
																											and not GL mipmaps required and supported	*/
		(iwidth > max_supported_size) ||		/*	it's too big, (make sure it's	*/
		(iheight > max_supported_size) )		/*	2^n for later down-sampling)	*/
	{
		int new_width = 1;
		int new_height = 1;
		while( new_width < iwidth )
		{
			new_width *= 2;
		}
		while( new_height < iheight )
		{
			new_height *= 2;
		}
		/*	still?	*/
		if( (new_width != iwidth) || (new_height != iheight) )
		{
			/*	yep, resize	*/
			unsigned char *resampled = (unsigned char*)malloc( channels*new_width*new_height );
			up_scale_image(
					NULL != img ? img : data, iwidth, iheight, channels,
					resampled, new_width, new_height );

			/*	nuke the old guy ( if a copy exists ), then point it at the new guy	*/
			SOIL_free_image_data( img );
			img = resampled;
			*width = new_width;
			*height = new_height;
			iwidth = new_width;
			iheight = new_height;
		}
	}
	/*	now, if it is too large...	*/
	if( (iwidth > max_supported_size) || (iheight > max_supported_size) )
	{
		/*	I've already made it a power of two, so simply use the MIPmapping
			code to reduce its size to the allowable maximum.	*/
		unsigned char *resampled;
		int reduce_block_x = 1, reduce_block_y = 1;
		int new_width, new_height;
		if( iwidth > max_supported_size )
		{
			reduce_block_x = iwidth / max_supported_size;
		}
		if( iheight > max_supported_size )
		{
			reduce_block_y = iheight / max_supported_size;
		}
		new_width = iwidth / reduce_block_x;
		new_height = iheight / reduce_block_y;
		resampled = (unsigned char*)malloc( channels*new_width*new_height );
		/*	perform the actual reduction	*/
		mipmap_image( NULL != img ? img : data, iwidth, iheight, channels,
						resampled, reduce_block_x, reduce_block_y );
		/*	nuke the old guy, then point it at the new guy	*/
		SOIL_free_image_data( img );
		img = resampled;
		*width = new_width;
		*height = new_height;
		iwidth = new_width;
		iheight = new_height;
	}
	/*	does the user want us to use YCoCg color space?	*/
	if( flags & SOIL_FLAG_CoCg_Y )
	{
		/*	this will only work with RGB and RGBA images */
		convert_RGB_to_YCoCg( img, iwidth, iheight, channels );
	}
	/*	create the OpenGL texture ID handle
		(note: allowing a forced texture ID lets me reload a texture)	*/
	tex_id = reuse_texture_ID;
	if( tex_id == 0 )
	{
		glGenTextures( 1, &tex_id );
	}
	check_for_GL_errors( "glGenTextures" );
	/* Note: sometimes glGenTextures fails (usually no OpenGL context)	*/
	if( tex_id )
	{
		/*	and what type am I using as the internal texture format?	*/
		switch( channels )
		{
		case 1:
			original_texture_format = GL_LUMINANCE;
			break;
		case 2:
			original_texture_format = GL_LUMINANCE_ALPHA;
			break;
		case 3:
			original_texture_format = GL_RGB;
			break;
		case 4:
			original_texture_format = GL_RGBA;
			break;
		}
		internal_texture_format = original_texture_format;
		/*	does the user want me to, and can I, save as DXT?	*/
		if( flags & SOIL_FLAG_COMPRESS_TO_DXT )
		{
			DXT_mode = query_DXT_capability();
			if( DXT_mode == SOIL_CAPABILITY_PRESENT )
			{
				/*	I can use DXT, whether I compress it or OpenGL does	*/
				if( (channels & 1) == 1 )
				{
					/*	1 or 3 channels = DXT1	*/
					internal_texture_format = sRGB_texture ? SOIL_GL_COMPRESSED_SRGB_S3TC_DXT1_EXT : SOIL_RGB_S3TC_DXT1;
				} else
				{
					/*	2 or 4 channels = DXT5	*/
					internal_texture_format = sRGB_texture ? SOIL_GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : SOIL_RGBA_S3TC_DXT5;
				}
			}
		}
		else if ( sRGB_texture )
		{
			switch( channels )
			{
			case 3:
				internal_texture_format = SOIL_GL_SRGB;
				break;
			case 4:
				internal_texture_format = SOIL_GL_SRGB_ALPHA;
				break;
			}
		}

		/*  bind an OpenGL texture ID	*/
		glBindTexture( opengl_texture_type, tex_id );
		check_for_GL_errors( "glBindTexture" );

		/* set the unpack aligment */
		glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack_aligment);
		if ( 1 != unpack_aligment )
		{
			glPixelStorei(GL_UNPACK_ALIGNMENT,1);
		}

		/*  upload the main image	*/
		if( DXT_mode == SOIL_CAPABILITY_PRESENT )
		{
			/*	user wants me to do the DXT conversion!	*/
			int DDS_size;
			unsigned char *DDS_data = NULL;
			if( (channels & 1) == 1 )
			{
				/*	RGB, use DXT1	*/
				DDS_data = convert_image_to_DXT1( NULL != img ? img : data, iwidth, iheight, channels, &DDS_size );
			} else
			{
				/*	RGBA, use DXT5	*/
				DDS_data = convert_image_to_DXT5( NULL != img ? img : data, iwidth, iheight, channels, &DDS_size );
			}
			if( DDS_data )
			{
				soilGlCompressedTexImage2D(
					opengl_texture_target, 0,
					internal_texture_format, iwidth, iheight, 0,
					DDS_size, DDS_data );
				check_for_GL_errors( "glCompressedTexImage2D" );
				SOIL_free_image_data( DDS_data );
				/*	printf( "Internal DXT compressor\n" );	*/
			} else
			{
				/*	my compression failed, try the OpenGL driver's version	*/
				glTexImage2D(
					opengl_texture_target, 0,
					internal_texture_format, iwidth, iheight, 0,
					original_texture_format, GL_UNSIGNED_BYTE, NULL != img ? img : data );
				check_for_GL_errors( "glTexImage2D" );
				/*	printf( "OpenGL DXT compressor\n" );	*/
			}
		} else
		{
			/*	user want OpenGL to do all the work!	*/
			glTexImage2D(
				opengl_texture_target, 0,
				internal_texture_format, iwidth, iheight, 0,
				original_texture_format, GL_UNSIGNED_BYTE, NULL != img ? img : data );

			check_for_GL_errors( "glTexImage2D" );
			/*printf( "OpenGL DXT compressor\n" );	*/
		}

		/*	are any MIPmaps desired?	*/
		if( flags & SOIL_FLAG_MIPMAPS || flags & SOIL_FLAG_GL_MIPMAPS )
		{
			createMipmaps( NULL != img ? img : data, iwidth, iheight, channels, flags, opengl_texture_target, internal_texture_format, original_texture_format, DXT_mode );

			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
			check_for_GL_errors( "GL_TEXTURE_MIN/MAG_FILTER" );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
			check_for_GL_errors( "GL_TEXTURE_MIN/MAG_FILTER" );
		}

		/* recover the unpack aligment */
		if ( 1 != unpack_aligment )
		{
			glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
		}

		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			if( opengl_texture_type == SOIL_TEXTURE_CUBE_MAP )
			{
				/*	SOIL_TEXTURE_WRAP_R is invalid if cubemaps aren't supported	*/
				glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
			}
			check_for_GL_errors( "GL_TEXTURE_WRAP_*" );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			if( opengl_texture_type == SOIL_TEXTURE_CUBE_MAP )
			{
				/*	SOIL_TEXTURE_WRAP_R is invalid if cubemaps aren't supported	*/
				glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
			}
			check_for_GL_errors( "GL_TEXTURE_WRAP_*" );
		}
		/*	done	*/
		result_string_pointer = "Image loaded as an OpenGL texture";
	} else
	{
		/*	failed	*/
		result_string_pointer = "Failed to generate an OpenGL texture name; missing OpenGL context?";
	}

	SOIL_free_image_data( img );

	return tex_id;
}

int
	SOIL_save_screenshot
	(
		const char *filename,
		int image_type,
		int x, int y,
		int width, int height
	)
{
	unsigned char *pixel_data;
	int i, j;
	int save_result;
	GLint pack_aligment;

	/*	error checks	*/
	if( (width < 1) || (height < 1) )
	{
		result_string_pointer = "Invalid screenshot dimensions";
		return 0;
	}
	if( (x < 0) || (y < 0) )
	{
		result_string_pointer = "Invalid screenshot location";
		return 0;
	}
	if( filename == NULL )
	{
		result_string_pointer = "Invalid screenshot filename";
		return 0;
	}

	glGetIntegerv(GL_PACK_ALIGNMENT, &pack_aligment);
	if ( 1 != pack_aligment )
	{
		glPixelStorei(GL_PACK_ALIGNMENT,1);
	}

	/*  Get the data from OpenGL	*/
	pixel_data = (unsigned char*)malloc( 3*width*height );
	glReadPixels (x, y, width, height, GL_RGB, GL_UNSIGNED_BYTE, pixel_data);

	if ( 1 != pack_aligment )
	{
		glPixelStorei(GL_PACK_ALIGNMENT, pack_aligment);
	}

	/*	invert the image	*/
	for( j = 0; j*2 < height; ++j )
	{
		int index1 = j * width * 3;
		int index2 = (height - 1 - j) * width * 3;
		for( i = width * 3; i > 0; --i )
		{
			unsigned char temp = pixel_data[index1];
			pixel_data[index1] = pixel_data[index2];
			pixel_data[index2] = temp;
			++index1;
			++index2;
		}
	}

	/*	save the image	*/
	save_result = SOIL_save_image( filename, image_type, width, height, 3, pixel_data);

	/*	And free the memory	*/
	SOIL_free_image_data( pixel_data );
	return save_result;
}

unsigned char*
	SOIL_load_image
	(
		const char *filename,
		int *width, int *height, int *channels,
		int force_channels
	)
{
	unsigned char *result = stbi_load( filename,
			width, height, channels, force_channels );
	if( result == NULL )
	{
		result_string_pointer = stbi_failure_reason();
	} else
	{
		result_string_pointer = "Image loaded";
	}
	return result;
}

unsigned char*
	SOIL_load_image_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int *width, int *height, int *channels,
		int force_channels
	)
{
	unsigned char *result = stbi_load_from_memory(
				buffer, buffer_length,
				width, height, channels,
				force_channels );
	if( result == NULL )
	{
		result_string_pointer = stbi_failure_reason();
	} else
	{
		result_string_pointer = "Image loaded from memory";
	}
	return result;
}

int
	SOIL_save_image
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data
	)
{
	return SOIL_save_image_quality( filename, image_type, width, height, channels, data, 80 );
}

int
	SOIL_save_image_quality
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data,
		int quality
	)
{
	int save_result;

	/*	error check	*/
	if( (width < 1) || (height < 1) ||
		(channels < 1) || (channels > 4) ||
		(data == NULL) ||
		(filename == NULL) )
	{
		return 0;
	}
	if( image_type == SOIL_SAVE_TYPE_BMP )
	{
		save_result = stbi_write_bmp( filename,
				width, height, channels, (void*)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_TGA )
	{
		save_result = stbi_write_tga( filename,
				width, height, channels, (void*)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_DDS )
	{
		save_result = save_image_as_DDS( filename,
				width, height, channels, (const unsigned char *const)data );
	} else
	if( image_type == SOIL_SAVE_TYPE_PNG )
	{
		save_result = stbi_write_png( filename,
				width, height, channels, (const unsigned char *const)data, 0 );
	} else
	if ( image_type == SOIL_SAVE_TYPE_JPG )
	{
		save_result = jo_write_jpg( filename, (const void*)data, width, height, channels, quality );
	}
	else
	{
		save_result = 0;
	}

	if( save_result == 0 )
	{
		result_string_pointer = "Saving the image failed";
	} else
	{
		result_string_pointer = "Image saved";
	}
	return save_result;
}

void
	SOIL_free_image_data
	(
		unsigned char *img_data
	)
{
	if ( img_data )
		free( (void*)img_data );
}

const char*
	SOIL_last_result
	(
		void
	)
{
	return result_string_pointer;
}

unsigned int SOIL_direct_load_DDS_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	/*	variables	*/
	DDS_header header;
	unsigned int buffer_index = 0;
	unsigned int tex_ID = 0;
	/*	file reading variables	*/
	unsigned int S3TC_type = 0;
	unsigned char *DDS_data;
	unsigned int DDS_main_size;
	unsigned int DDS_full_size;
	unsigned int width, height;
	int mipmaps, cubemap, uncompressed, block_size = 16;
	unsigned int flag;
	unsigned int cf_target, ogl_target_start, ogl_target_end;
	unsigned int opengl_texture_type;
	int i;
	/*	1st off, does the filename even exist?	*/
	if( NULL == buffer )
	{
		/*	we can't do it!	*/
		result_string_pointer = "NULL buffer";
		return 0;
	}
	if( buffer_length < sizeof( DDS_header ) )
	{
		/*	we can't do it!	*/
		result_string_pointer = "DDS file was too small to contain the DDS header";
		return 0;
	}
	/*	try reading in the header	*/
	memcpy ( (void*)(&header), (const void *)buffer, sizeof( DDS_header ) );
	buffer_index = sizeof( DDS_header );
	/*	guilty until proven innocent	*/
	result_string_pointer = "Failed to read a known DDS header";
	/*	validate the header (warning, "goto"'s ahead, shield your eyes!!)	*/
	flag = ('D'<<0)|('D'<<8)|('S'<<16)|(' '<<24);
	if( header.dwMagic != flag ) {goto quick_exit;}
	if( header.dwSize != 124 ) {goto quick_exit;}
	/*	I need all of these	*/
	flag = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
	if( (header.dwFlags & flag) != flag ) {goto quick_exit;}
	/*	According to the MSDN spec, the dwFlags should contain
		DDSD_LINEARSIZE if it's compressed, or DDSD_PITCH if
		uncompressed.  Some DDS writers do not conform to the
		spec, so I need to make my reader more tolerant	*/
	/*	I need one of these	*/
	flag = DDPF_FOURCC | DDPF_RGB;
	if( (header.sPixelFormat.dwFlags & flag) == 0 ) {goto quick_exit;}
	if( header.sPixelFormat.dwSize != 32 ) {goto quick_exit;}
	if( (header.sCaps.dwCaps1 & DDSCAPS_TEXTURE) == 0 ) {goto quick_exit;}
	/*	make sure it is a type we can upload	*/
	if( (header.sPixelFormat.dwFlags & DDPF_FOURCC) &&
		!(
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('1'<<24))) ||
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('3'<<24))) ||
		(header.sPixelFormat.dwFourCC == (('D'<<0)|('X'<<8)|('T'<<16)|('5'<<24)))
		) )
	{
		goto quick_exit;
	}
	/*	OK, validated the header, let's load the image data	*/
	result_string_pointer = "DDS header loaded and validated";
	width = header.dwWidth;
	height = header.dwHeight;
	uncompressed = 1 - (header.sPixelFormat.dwFlags & DDPF_FOURCC) / DDPF_FOURCC;
	cubemap = (header.sCaps.dwCaps2 & DDSCAPS2_CUBEMAP) / DDSCAPS2_CUBEMAP;
	if( uncompressed )
	{
		S3TC_type = GL_RGB;
		block_size = 3;
		if( header.sPixelFormat.dwFlags & DDPF_ALPHAPIXELS )
		{
			S3TC_type = GL_RGBA;
			block_size = 4;
		}
		DDS_main_size = width * height * block_size;
	} else
	{
		/*	can we even handle direct uploading to OpenGL DXT compressed images?	*/
		if( query_DXT_capability() != SOIL_CAPABILITY_PRESENT )
		{
			/*	we can't do it!	*/
			result_string_pointer = "Direct upload of S3TC images not supported by the OpenGL driver";
			return 0;
		}
		/*	well, we know it is DXT1/3/5, because we checked above	*/
		switch( (header.sPixelFormat.dwFourCC >> 24) - '0' )
		{
		case 1:
			S3TC_type = SOIL_RGBA_S3TC_DXT1;
			block_size = 8;
			break;
		case 3:
			S3TC_type = SOIL_RGBA_S3TC_DXT3;
			block_size = 16;
			break;
		case 5:
			S3TC_type = SOIL_RGBA_S3TC_DXT5;
			block_size = 16;
			break;
		}
		DDS_main_size = ((width+3)>>2)*((height+3)>>2)*block_size;
	}
	if( cubemap )
	{
		/* does the user want a cubemap?	*/
		if( !loading_as_cubemap )
		{
			/*	we can't do it!	*/
			result_string_pointer = "DDS image was a cubemap";
			return 0;
		}
		/*	can we even handle cubemaps with the OpenGL driver?	*/
		if( query_cubemap_capability() != SOIL_CAPABILITY_PRESENT )
		{
			/*	we can't do it!	*/
			result_string_pointer = "Direct upload of cubemap images not supported by the OpenGL driver";
			return 0;
		}
		ogl_target_start = SOIL_TEXTURE_CUBE_MAP_POSITIVE_X;
		ogl_target_end =   SOIL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
		opengl_texture_type = SOIL_TEXTURE_CUBE_MAP;
	} else
	{
		/* does the user want a non-cubemap?	*/
		if( loading_as_cubemap )
		{
			/*	we can't do it!	*/
			result_string_pointer = "DDS image was not a cubemap";
			return 0;
		}
		ogl_target_start = GL_TEXTURE_2D;
		ogl_target_end =   GL_TEXTURE_2D;
		opengl_texture_type = GL_TEXTURE_2D;
	}
	if( (header.sCaps.dwCaps1 & DDSCAPS_MIPMAP) && (header.dwMipMapCount > 1) )
	{
		mipmaps = header.dwMipMapCount - 1;
		DDS_full_size = DDS_main_size;
		for( i = 1; i <= mipmaps; ++ i )
		{
			int w, h;
			w = width >> i;
			h = height >> i;
			if( w < 1 )
			{
				w = 1;
			}
			if( h < 1 )
			{
				h = 1;
			}
			if ( uncompressed )
			{
				/*	uncompressed DDS, simple MIPmap size calculation	*/
				DDS_full_size += w*h*block_size;
			} else
			{
				/*	compressed DDS, MIPmap size calculation is block based	*/
				DDS_full_size += ((w+3)/4)*((h+3)/4)*block_size;
			}
		}
	} else
	{
		mipmaps = 0;
		DDS_full_size = DDS_main_size;
	}
	DDS_data = (unsigned char*)malloc( DDS_full_size );
	/*	got the image data RAM, create or use an existing OpenGL texture handle	*/
	tex_ID = reuse_texture_ID;
	if( tex_ID == 0 )
	{
		glGenTextures( 1, &tex_ID );
	}
	/*  bind an OpenGL texture ID	*/
	glBindTexture( opengl_texture_type, tex_ID );
	/*	do this for each face of the cubemap!	*/
	for( cf_target = ogl_target_start; cf_target <= ogl_target_end; ++cf_target )
	{
		if( buffer_index + DDS_full_size <= (unsigned int)buffer_length )
		{
			unsigned int byte_offset = DDS_main_size;
			memcpy( (void*)DDS_data, (const void*)(&buffer[buffer_index]), DDS_full_size );
			buffer_index += DDS_full_size;
			/*	upload the main chunk	*/
			if( uncompressed )
			{
				/*	and remember, DXT uncompressed uses BGR(A),
					so swap to RGB(A) for ALL MIPmap levels	*/
				for( i = 0; i < (int)DDS_full_size; i += block_size )
				{
					unsigned char temp = DDS_data[i];
					DDS_data[i] = DDS_data[i+2];
					DDS_data[i+2] = temp;
				}
				glTexImage2D(
					cf_target, 0,
					S3TC_type, width, height, 0,
					S3TC_type, GL_UNSIGNED_BYTE, DDS_data );
			} else
			{
				soilGlCompressedTexImage2D(
					cf_target, 0,
					S3TC_type, width, height, 0,
					DDS_main_size, DDS_data );
			}
			/*	upload the mipmaps, if we have them	*/
			for( i = 1; i <= mipmaps; ++i )
			{
				int w, h, mip_size;
				w = width >> i;
				h = height >> i;
				if( w < 1 )
				{
					w = 1;
				}
				if( h < 1 )
				{
					h = 1;
				}
				/*	upload this mipmap	*/
				if( uncompressed )
				{
					mip_size = w*h*block_size;
					glTexImage2D(
						cf_target, i,
						S3TC_type, w, h, 0,
						S3TC_type, GL_UNSIGNED_BYTE, &DDS_data[byte_offset] );
				} else
				{
					mip_size = ((w+3)/4)*((h+3)/4)*block_size;
					soilGlCompressedTexImage2D(
						cf_target, i,
						S3TC_type, w, h, 0,
						mip_size, &DDS_data[byte_offset] );
				}
				/*	and move to the next mipmap	*/
				byte_offset += mip_size;
			}
			/*	it worked!	*/
			result_string_pointer = "DDS file loaded";
		} else
		{
			glDeleteTextures( 1, & tex_ID );
			tex_ID = 0;
			cf_target = ogl_target_end + 1;
			result_string_pointer = "DDS file was too small for expected image data";
		}
	}/* end reading each face */
	SOIL_free_image_data( DDS_data );
	if( tex_ID )
	{
		/*	did I have MIPmaps?	*/
		if( mipmaps > 0 )
		{
			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
		}
		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
		}
	}

quick_exit:
	/*	report success or failure	*/
	return tex_ID;
}

unsigned int SOIL_direct_load_DDS(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	FILE *f;
	unsigned char *buffer;
	size_t buffer_length, bytes_read;
	unsigned int tex_ID = 0;
	/*	error checks	*/
	if( NULL == filename )
	{
		result_string_pointer = "NULL filename";
		return 0;
	}
	f = fopen( filename, "rb" );
	if( NULL == f )
	{
		/*	the file doesn't seem to exist (or be open-able)	*/
		result_string_pointer = "Can not find DDS file";
		return 0;
	}
	fseek( f, 0, SEEK_END );
	buffer_length = ftell( f );
	fseek( f, 0, SEEK_SET );
	buffer = (unsigned char *) malloc( buffer_length );
	if( NULL == buffer )
	{
		result_string_pointer = "malloc failed";
		fclose( f );
		return 0;
	}
	bytes_read = fread( (void*)buffer, 1, buffer_length, f );
	fclose( f );
	if( bytes_read < buffer_length )
	{
		/*	huh?	*/
		buffer_length = bytes_read;
	}
	/*	now try to do the loading	*/
	tex_ID = SOIL_direct_load_DDS_from_memory(
		(const unsigned char *const)buffer, (int)buffer_length,
		reuse_texture_ID, flags, loading_as_cubemap );
	SOIL_free_image_data( buffer );
	return tex_ID;
}

unsigned int SOIL_direct_load_PVR_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	PVR_Texture_Header* header = (PVR_Texture_Header*)buffer;
	int num_surfs = 1;
	GLuint tex_ID = 0;
	GLenum PVR_format = 0;
	GLenum PVR_type = GL_RGB;
	unsigned int opengl_texture_type = loading_as_cubemap ? SOIL_TEXTURE_CUBE_MAP : GL_TEXTURE_2D;
	int is_PVRTC_supported = query_PVR_capability() == SOIL_CAPABILITY_PRESENT;
	int is_BGRA8888_supported  = query_BGRA8888_capability() == SOIL_CAPABILITY_PRESENT;
	int is_compressed_format_supported = 0;
	int is_compressed_format = 0;
	int mipmaps = 0;
	int i;
	GLint unpack_aligment;

	// Check the header size
	if ( header->dwHeaderSize != sizeof(PVR_Texture_Header) ) {
		if ( header->dwHeaderSize == PVRTEX_V1_HEADER_SIZE ) {
			result_string_pointer = "this is an old pvr ( update the PVR file )";

			if ( loading_as_cubemap ) {
				if( header->dwpfFlags & PVRTEX_CUBEMAP ) {
					num_surfs = 6;
				} else {
					result_string_pointer = "tried to load a non-cubemap PVR as cubemap";
					return 0;
				}
			}
		} else {
			result_string_pointer = "invalid PVR header";

			return 0;
		}
	} else {
		if ( loading_as_cubemap ) {
			// Header V2
			if( header->dwNumSurfs < 1 ) {
				if( header->dwpfFlags & PVRTEX_CUBEMAP ) {
					num_surfs = 6;
				} else {
					result_string_pointer = "tried to load a non-cubemap PVR as cubemap";
					return 0;
				}
			} else {
				num_surfs = header->dwNumSurfs;
			}
		}
	}

	// Check the magic identifier
	if ( header->dwPVR != PVRTEX_IDENTIFIER ) {
		result_string_pointer = "invalid PVR header";
		return 0;
	}

	/* Only accept untwiddled data UNLESS texture format is PVRTC */
	if ( ((header->dwpfFlags & PVRTEX_TWIDDLE) == PVRTEX_TWIDDLE)
		&& ((header->dwpfFlags & PVRTEX_PIXELTYPE)!=OGL_PVRTC2)
		&& ((header->dwpfFlags & PVRTEX_PIXELTYPE)!=OGL_PVRTC4) )
	{
		// We need to load untwiddled textures -- hw will twiddle for us.
		result_string_pointer = "pvr is not compressed ( untwiddled texture )";
		return 0;
	}

	switch( header->dwpfFlags & PVRTEX_PIXELTYPE )
	{
		case OGL_RGBA_4444:
			PVR_format = GL_UNSIGNED_SHORT_4_4_4_4;
			PVR_type = GL_RGBA;
			break;
		case OGL_RGBA_5551:
			PVR_format = GL_UNSIGNED_SHORT_5_5_5_1;
			PVR_type = GL_RGBA;
			break;
		case OGL_RGBA_8888:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_RGBA;
			break;
		case OGL_RGB_565:
			PVR_format = GL_UNSIGNED_SHORT_5_6_5;
			PVR_type = GL_RGB;
			break;
		case OGL_RGB_555:
			result_string_pointer = "failed: pixel type OGL_RGB_555 not supported.";
			return 0;
		case OGL_RGB_888:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_RGB;
			break;
		case OGL_I_8:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_LUMINANCE;
			break;
		case OGL_AI_88:
			PVR_format = GL_UNSIGNED_BYTE;
			PVR_type = GL_LUMINANCE_ALPHA;
			break;
		case MGLPT_PVRTC2:
		case OGL_PVRTC2:
			if(is_PVRTC_supported) {
				is_compressed_format_supported = is_compressed_format = 1;
				PVR_format = header->dwAlphaBitMask==0 ? SOIL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG : SOIL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG ;	// PVRTC2
			} else {
				result_string_pointer = "error: PVRTC2 not supported.Decompress the texture first.";
				return 0;
			}
			break;
		case MGLPT_PVRTC4:
		case OGL_PVRTC4:
			if(is_PVRTC_supported) {
				is_compressed_format_supported = is_compressed_format = 1;
				PVR_format = header->dwAlphaBitMask==0 ? SOIL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG : SOIL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG ;	// PVRTC4
			} else {
				result_string_pointer = "error: PVRTC4 not supported. Decompress the texture first.";
				return 0;
			}
			break;
		case OGL_BGRA_8888:
			if(is_BGRA8888_supported) {
				PVR_format = GL_UNSIGNED_BYTE;
				PVR_type   = GL_BGRA;
				break;
			} else {
				result_string_pointer = "Unable to load GL_BGRA texture as extension GL_IMG_texture_format_BGRA8888 is unsupported.";
				return 0;
			}
		default:											// NOT SUPPORTED
			result_string_pointer = "failed: pixel type not supported.";
			return 0;
	}

	#ifdef SOIL_GLES1
	//  check that this data is cube map data or not.
	if( loading_as_cubemap ) {
		result_string_pointer = "cube map textures are not available in GLES1.x.";
		return 0;
	}
	#endif

	// load the texture up
	tex_ID = reuse_texture_ID;
	if( tex_ID == 0 )
	{
		glGenTextures( 1, &tex_ID );
	}

	glBindTexture( opengl_texture_type, tex_ID );

	if( glGetError() ) {
		result_string_pointer = "failed: glBindTexture() failed.";
		return 0;
	}

	glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack_aligment);
	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT,1);				// Never have row-aligned in headers
	}

	#define _MAX( a, b ) (( a <= b )? b : a)
	for(i=0; i<num_surfs; i++) {
		char *texture_ptr = (char*)buffer + header->dwHeaderSize + header->dwTextureDataSize * i;
		char *cur_texture_ptr = 0;
		int	mipmap_level;
		unsigned int width= header->dwWidth, height = header->dwHeight;
		unsigned int compressed_image_size = 0;

		mipmaps = ( ( flags & SOIL_FLAG_MIPMAPS ) && (header->dwpfFlags & PVRTEX_MIPMAP) ) ? header->dwMipMapCount : 0;

		for(mipmap_level = 0; mipmap_level <= mipmaps; width = _MAX(width/2, (unsigned int)1), height = _MAX(height/2, (unsigned int)1), mipmap_level++ ) {
			// Do Alpha-swap if needed
			cur_texture_ptr = texture_ptr;

			// Load the Texture
			/* If the texture is PVRTC then use GLCompressedTexImage2D */
			if( is_compressed_format ) {
				/* Calculate how many bytes this MIP level occupies */
				if ((header->dwpfFlags & PVRTEX_PIXELTYPE)==OGL_PVRTC2) {
					compressed_image_size = ( _MAX(width, PVRTC2_MIN_TEXWIDTH) * _MAX(height, PVRTC2_MIN_TEXHEIGHT) * header->dwBitCount + 7 ) / 8;
				} else {// PVRTC4 case
					compressed_image_size = ( _MAX(width, PVRTC4_MIN_TEXWIDTH) * _MAX(height, PVRTC4_MIN_TEXHEIGHT) * header->dwBitCount + 7 ) / 8;
				}

				if ( is_compressed_format_supported ) {
					/* Load compressed texture data at selected MIP level */
					if ( loading_as_cubemap ) {
						soilGlCompressedTexImage2D( SOIL_TEXTURE_CUBE_MAP_POSITIVE_X + i, mipmap_level, PVR_format, width, height, 0, compressed_image_size, cur_texture_ptr );
					} else {
						soilGlCompressedTexImage2D( opengl_texture_type, mipmap_level, PVR_format, width, height, 0, compressed_image_size, cur_texture_ptr );
					}
				} else {
					result_string_pointer = "failed: GPU doesnt support compressed textures";
				}
			} else {
				/* Load uncompressed texture data at selected MIP level */
				if ( loading_as_cubemap ) {
					glTexImage2D( SOIL_TEXTURE_CUBE_MAP_POSITIVE_X + i, mipmap_level, PVR_type, width, height, 0, PVR_type, PVR_format, cur_texture_ptr );
				} else {
					glTexImage2D( opengl_texture_type, mipmap_level, PVR_type, width, height, 0, PVR_type, PVR_format, cur_texture_ptr );
				}
			}

			if( glGetError() ) {
				result_string_pointer = "failed: glCompressedTexImage2D() failed.";
				if ( 1 != unpack_aligment )
				{
					glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
				}
				return 0;
			}

			// offset the texture pointer by one mip-map level
			/* PVRTC case */
			if ( is_compressed_format ) {
				texture_ptr += compressed_image_size;
			} else {
				/* New formula that takes into account bit counts inferior to 8 (e.g. 1 bpp) */
				texture_ptr += (width * height * header->dwBitCount + 7) / 8;
			}
		}
	}
	#undef _MAX

	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
	}

	if( tex_ID )
	{
		/*	did I have MIPmaps?	*/
		if( mipmaps )
		{
			/*	instruct OpenGL to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR );
		} else
		{
			/*	instruct OpenGL _NOT_ to use the MIPmaps	*/
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
		}

		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
		}
	}

	return tex_ID;
}

unsigned int SOIL_direct_load_PVR(
		const char *filename,
		unsigned int reuse_texture_ID,
		int flags,
		int loading_as_cubemap )
{
	FILE *f;
	unsigned char *buffer;
	size_t buffer_length, bytes_read;
	unsigned int tex_ID = 0;
	/*	error checks	*/
	if( NULL == filename )
	{
		result_string_pointer = "NULL filename";
		return 0;
	}
	f = fopen( filename, "rb" );
	if( NULL == f )
	{
		/*	the file doesn't seem to exist (or be open-able)	*/
		result_string_pointer = "Can not find PVR file";
		return 0;
	}
	fseek( f, 0, SEEK_END );
	buffer_length = ftell( f );
	fseek( f, 0, SEEK_SET );
	buffer = (unsigned char *) malloc( buffer_length );
	if( NULL == buffer )
	{
		result_string_pointer = "malloc failed";
		fclose( f );
		return 0;
	}
	bytes_read = fread( (void*)buffer, 1, buffer_length, f );
	fclose( f );
	if( bytes_read < buffer_length )
	{
		/*	huh?	*/
		buffer_length = bytes_read;
	}
	/*	now try to do the loading	*/
	tex_ID = SOIL_direct_load_PVR_from_memory(
		(const unsigned char *const)buffer, (int)buffer_length,
		reuse_texture_ID, flags, loading_as_cubemap );
	SOIL_free_image_data( buffer );
	return tex_ID;
}

unsigned int SOIL_direct_load_ETC1_from_memory(
		const unsigned char *const buffer,
		int buffer_length,
		unsigned int reuse_texture_ID,
		int flags )
{
	GLuint tex_ID = 0;
	PKMHeader* header = (PKMHeader*)buffer;
	unsigned int opengl_texture_type = GL_TEXTURE_2D;
	unsigned int width;
	unsigned int height;
	unsigned long compressed_image_size = buffer_length - PKM_HEADER_SIZE;
	char *texture_ptr = (char*)buffer + PKM_HEADER_SIZE;
	GLint unpack_aligment;

	if ( query_ETC1_capability() != SOIL_CAPABILITY_PRESENT ) {
		result_string_pointer = "error: ETC1 not supported. Decompress the texture first.";
		return 0;
	}

	if ( 0 != strcmp( header->aName, "PKM 10" ) ) {
		result_string_pointer = "error: PKM 10 header not found.";
		return 0;
	}

	width = (header->iWidthMSB << 8) | header->iWidthLSB;
	height = (header->iHeightMSB << 8) | header->iHeightLSB;
	compressed_image_size = (((width + 3) & ~3) * ((height + 3) & ~3)) >> 1;

	// load the texture up
	tex_ID = reuse_texture_ID;
	if( tex_ID == 0 )
	{
		glGenTextures( 1, &tex_ID );
	}

	glBindTexture( opengl_texture_type, tex_ID );

	if( glGetError() ) {
		result_string_pointer = "failed: glBindTexture() failed.";
		return 0;
	}

	glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack_aligment);
	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT,1);				// Never have row-aligned in headers
	}

	soilGlCompressedTexImage2D( opengl_texture_type, 0, SOIL_GL_ETC1_RGB8_OES, width, height, 0, compressed_image_size, texture_ptr );

	if( glGetError() ) {
		result_string_pointer = "failed: glCompressedTexImage2D() failed.";

		if ( 1 != unpack_aligment )
		{
			glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
		}
		return 0;
	}

	if ( 1 != unpack_aligment )
	{
		glPixelStorei(GL_UNPACK_ALIGNMENT, unpack_aligment);
	}

	if( tex_ID )
	{
		/* No MIPmaps for ETC1 */
		glTexParameteri( opengl_texture_type, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
		glTexParameteri( opengl_texture_type, GL_TEXTURE_MIN_FILTER, GL_LINEAR );

		/*	does the user want clamping, or wrapping?	*/
		if( flags & SOIL_FLAG_TEXTURE_REPEATS )
		{
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, GL_REPEAT );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, GL_REPEAT );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, GL_REPEAT );
		} else
		{
			unsigned int clamp_mode = SOIL_CLAMP_TO_EDGE;
			/* unsigned int clamp_mode = GL_CLAMP; */
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_S, clamp_mode );
			glTexParameteri( opengl_texture_type, GL_TEXTURE_WRAP_T, clamp_mode );
			glTexParameteri( opengl_texture_type, SOIL_TEXTURE_WRAP_R, clamp_mode );
		}
	}

	return tex_ID;
}

unsigned int SOIL_direct_load_ETC1(const char *filename,
		unsigned int reuse_texture_ID,
		int flags )
{
	FILE *f;
	unsigned char *buffer;
	size_t buffer_length, bytes_read;
	unsigned int tex_ID = 0;
	/*	error checks	*/
	if( NULL == filename )
	{
		result_string_pointer = "NULL filename";
		return 0;
	}
	f = fopen( filename, "rb" );
	if( NULL == f )
	{
		/*	the file doesn't seem to exist (or be open-able)	*/
		result_string_pointer = "Can not find PVR file";
		return 0;
	}
	fseek( f, 0, SEEK_END );
	buffer_length = ftell( f );
	fseek( f, 0, SEEK_SET );
	buffer = (unsigned char *) malloc( buffer_length );
	if( NULL == buffer )
	{
		result_string_pointer = "malloc failed";
		fclose( f );
		return 0;
	}
	bytes_read = fread( (void*)buffer, 1, buffer_length, f );
	fclose( f );
	if( bytes_read < buffer_length )
	{
		/*	huh?	*/
		buffer_length = bytes_read;
	}
	/*	now try to do the loading	*/
	tex_ID = SOIL_direct_load_ETC1_from_memory(
		(const unsigned char *const)buffer, (int)buffer_length,
		reuse_texture_ID, flags );
	SOIL_free_image_data( buffer );
	return tex_ID;
}

int query_NPOT_capability( void )
{
	/*	check for the capability	*/
	if( has_NPOT_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(0 == SOIL_GL_ExtensionSupported(
				"GL_ARB_texture_non_power_of_two" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_OES_texture_npot" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_NPOT_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_NPOT_capability = SOIL_CAPABILITY_PRESENT;
		}

		#if defined( __emscripten__ ) || defined( EMSCRIPTEN )
		has_NPOT_capability = SOIL_CAPABILITY_PRESENT;
		#endif
	}
	/*	let the user know if we can do non-power-of-two textures or not	*/
	return has_NPOT_capability;
}

int query_tex_rectangle_capability( void )
{
	/*	check for the capability	*/
	if( has_tex_rectangle_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(0 == SOIL_GL_ExtensionSupported(
				"GL_ARB_texture_rectangle" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_EXT_texture_rectangle" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_NV_texture_rectangle" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_tex_rectangle_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_tex_rectangle_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do texture rectangles or not	*/
	return has_tex_rectangle_capability;
}

int query_cubemap_capability( void )
{
	/*	check for the capability	*/
	if( has_cubemap_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if(
			(0 == SOIL_GL_ExtensionSupported(
				"GL_ARB_texture_cube_map" ) )
		&&
			(0 == SOIL_GL_ExtensionSupported(
				"GL_EXT_texture_cube_map" ) )
			)
		{
			/*	not there, flag the failure	*/
			has_cubemap_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_cubemap_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_cubemap_capability;
}

static P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC get_glCompressedTexImage2D_addr()
{
	/*	and find the address of the extension function	*/
	P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC ext_addr = NULL;

#if defined( SOIL_PLATFORM_WIN32 ) || defined( SOIL_PLATFORM_OSX ) || defined( SOIL_X11_PLATFORM )
	ext_addr = (P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC)SOIL_GL_GetProcAddress( "glCompressedTexImage2D" );
#else
	ext_addr = (P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC)&glCompressedTexImage2D;
#endif

	return ext_addr;
}

int query_DXT_capability( void )
{
	/*	check for the capability	*/
	if( has_DXT_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (	0 == SOIL_GL_ExtensionSupported(
					"GL_EXT_texture_compression_s3tc" )  &&
				0 == SOIL_GL_ExtensionSupported(
					"WEBGL_compressed_texture_s3tc ") &&
				0 == SOIL_GL_ExtensionSupported(
					"WEBKIT_WEBGL_compressed_texture_s3tc") &&
				0 == SOIL_GL_ExtensionSupported(
					"MOZ_WEBGL_compressed_texture_s3tc"
				)
			)
		{
			/*	not there, flag the failure	*/
			has_DXT_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			P_SOIL_GLCOMPRESSEDTEXIMAGE2DPROC ext_addr = get_glCompressedTexImage2D_addr();

			/*	Flag it so no checks needed later	*/
			if( NULL == ext_addr )
			{
				/*	hmm, not good!!  This should not happen, but does on my
					laptop's VIA chipset.  The GL_EXT_texture_compression_s3tc
					spec requires that ARB_texture_compression be present too.
					this means I can upload and have the OpenGL drive do the
					conversion, but I can't use my own routines or load DDS files
					from disk and upload them directly [8^(	*/
				has_DXT_capability = SOIL_CAPABILITY_NONE;
			} else
			{
				/*	all's well!	*/
				soilGlCompressedTexImage2D = ext_addr;
				has_DXT_capability = SOIL_CAPABILITY_PRESENT;
			}
		}
	}
	/*	let the user know if we can do DXT or not	*/
	return has_DXT_capability;
}

int query_PVR_capability( void )
{
	/*	check for the capability	*/
	if( has_PVR_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (0 == SOIL_GL_ExtensionSupported(
				"GL_IMG_texture_compression_pvrtc" ) )
		{
			/*	not there, flag the failure	*/
			has_PVR_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			if ( NULL == soilGlCompressedTexImage2D ) {
				soilGlCompressedTexImage2D = get_glCompressedTexImage2D_addr();
			}

			/*	it's there!	*/
			has_PVR_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_PVR_capability;
}

int query_BGRA8888_capability( void )
{
	/*	check for the capability	*/
	if( has_BGRA8888_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (0 == SOIL_GL_ExtensionSupported(
				"GL_IMG_texture_format_BGRA8888" ) )
		{
			/*	not there, flag the failure	*/
			has_BGRA8888_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/*	it's there!	*/
			has_BGRA8888_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_BGRA8888_capability;
}

int query_sRGB_capability( void )
{
	if ( has_sRGB_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		if (0 == SOIL_GL_ExtensionSupported(
				"GL_EXT_texture_sRGB" )
				&&
			0 == SOIL_GL_ExtensionSupported(
				"GL_EXT_sRGB" )
				&&
			0 == SOIL_GL_ExtensionSupported(
				"EXT_sRGB" ) )
		{
			has_sRGB_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			has_sRGB_capability = SOIL_CAPABILITY_PRESENT;
		}
	}

	return has_sRGB_capability;
}

int query_ETC1_capability( void )
{
	/*	check for the capability	*/
	if( has_ETC1_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		/*	we haven't yet checked for the capability, do so	*/
		if (0 == SOIL_GL_ExtensionSupported(
				"GL_OES_compressed_ETC1_RGB8_texture" ) )
		{
			/*	not there, flag the failure	*/
			has_ETC1_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			if ( NULL == soilGlCompressedTexImage2D ) {
				soilGlCompressedTexImage2D = get_glCompressedTexImage2D_addr();
			}

			/*	it's there!	*/
			has_ETC1_capability = SOIL_CAPABILITY_PRESENT;
		}
	}
	/*	let the user know if we can do cubemaps or not	*/
	return has_ETC1_capability;
}

int query_gen_mipmap_capability( void )
{
	/* check for the capability   */
	P_SOIL_GLGENERATEMIPMAPPROC ext_addr = NULL;

	if( has_gen_mipmap_capability == SOIL_CAPABILITY_UNKNOWN )
	{
		if (	0 == SOIL_GL_ExtensionSupported(
					"GL_ARB_framebuffer_object" )
			&&
				0 == SOIL_GL_ExtensionSupported(
					"GL_EXT_framebuffer_object" )
			&&  0 == SOIL_GL_ExtensionSupported(
					"GL_OES_framebuffer_object" )
			)
		{
			/* not there, flag the failure */
			has_gen_mipmap_capability = SOIL_CAPABILITY_NONE;
		}
		else
		{
			#if !defined( SOIL_GLES1 ) && !defined( SOIL_GLES2 )

			ext_addr = (P_SOIL_GLGENERATEMIPMAPPROC)SOIL_GL_GetProcAddress("glGenerateMipmap");

			if(ext_addr == NULL)
			{
				ext_addr = (P_SOIL_GLGENERATEMIPMAPPROC)SOIL_GL_GetProcAddress("glGenerateMipmapEXT");
			}

			#elif !defined( SOIL_NO_EGL )

			ext_addr = (P_SOIL_GLGENERATEMIPMAPPROC)SOIL_GL_GetProcAddress("glGenerateMipmapOES");

			if(ext_addr == NULL)
			{
				ext_addr = (P_SOIL_GLGENERATEMIPMAPPROC)SOIL_GL_GetProcAddress("glGenerateMipmap");
			}

			#elif defined( SOIL_GLES2 )
				ext_addr = 	&glGenerateMipmap;
			#else /** SOIL_GLES1 */
				ext_addr = &glGenerateMipmapOES;
			#endif
		}

		if(ext_addr == NULL)
		{
			/* this should never happen */
			has_gen_mipmap_capability = SOIL_CAPABILITY_NONE;
		} else
		{
			/* it's there! */
			has_gen_mipmap_capability = SOIL_CAPABILITY_PRESENT;
			soilGlGenerateMipmap = ext_addr;
		}
	}

	return has_gen_mipmap_capability;
}

#endif


//#line 1 "BitScale.cpp"

//#line 1 "BitScale.h"
#ifndef JTHLIM_BITSCALE_H
#define JTHLIM_BITSCALE_H

#include <cstdint>

namespace Javelin
{
  namespace Data
  {

	extern const uint8_t BITSCALE_5_TO_8[32];
	extern const uint8_t BITSCALE_4_TO_8[16];
	extern const uint8_t BITSCALE_3_TO_8[8];
	extern const uint8_t BITSCALE_8_TO_5_FLOOR[256];
	extern const uint8_t BITSCALE_8_TO_4_FLOOR[256];
	extern const uint8_t BITSCALE_8_TO_3_FLOOR[256];
	extern const uint8_t BITSCALE_8_TO_5_CEIL[256];
	extern const uint8_t BITSCALE_8_TO_4_CEIL[256];
	extern const uint8_t BITSCALE_8_TO_3_CEIL[256];

  } // namespace Data
} // namespace Javelin

#endif

const uint8_t Javelin::Data::BITSCALE_5_TO_8[32] = {
 0, 8, 16, 24, 32, 41, 49, 57, 65, 74,
 82, 90, 98, 106, 115, 123, 131, 139, 148, 156,
 164, 172, 180, 189, 197, 205, 213, 222, 230, 238,
 246, 255};

const uint8_t Javelin::Data::BITSCALE_4_TO_8[16] = {
 0, 17, 34, 51, 68, 85, 102, 119, 136, 153,
 170, 187, 204, 221, 238, 255};

const uint8_t Javelin::Data::BITSCALE_3_TO_8[8] = {
 0, 36, 72, 109, 145, 182, 218, 255};

const uint8_t Javelin::Data::BITSCALE_8_TO_5_FLOOR[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
 6, 6, 6, 6, 6, 6, 6, 6, 7, 7,
 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
 9, 9, 9, 10, 10, 10, 10, 10, 10, 10,
 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
 12, 12, 12, 12, 12, 12, 12, 13, 13, 13,
 13, 13, 13, 13, 13, 13, 14, 14, 14, 14,
 14, 14, 14, 14, 15, 15, 15, 15, 15, 15,
 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 18,
 18, 18, 18, 18, 18, 18, 18, 19, 19, 19,
 19, 19, 19, 19, 19, 20, 20, 20, 20, 20,
 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
 21, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 23, 23, 23, 23, 23, 23, 23, 23, 24, 24,
 24, 24, 24, 24, 24, 24, 25, 25, 25, 25,
 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
 26, 26, 26, 27, 27, 27, 27, 27, 27, 27,
 27, 28, 28, 28, 28, 28, 28, 28, 28, 29,
 29, 29, 29, 29, 29, 29, 29, 30, 30, 30,
 30, 30, 30, 30, 30, 31};

const uint8_t Javelin::Data::BITSCALE_8_TO_4_FLOOR[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
 13, 13, 13, 13, 13, 13, 13, 13, 14, 14,
 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
 14, 14, 14, 14, 14, 15};

const uint8_t Javelin::Data::BITSCALE_8_TO_3_FLOOR[256] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 7};

const uint8_t Javelin::Data::BITSCALE_8_TO_5_CEIL[256] = {
 0, 1, 1, 1, 1, 1, 1, 1, 1, 2,
 2, 2, 2, 2, 2, 2, 2, 3, 3, 3,
 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,
 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
 7, 7, 7, 7, 7, 7, 7, 7, 8, 8,
 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
 9, 9, 9, 9, 9, 10, 10, 10, 10, 10,
 10, 10, 10, 11, 11, 11, 11, 11, 11, 11,
 11, 12, 12, 12, 12, 12, 12, 12, 12, 13,
 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,
 14, 14, 14, 14, 14, 14, 15, 15, 15, 15,
 15, 15, 15, 15, 16, 16, 16, 16, 16, 16,
 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
 20, 20, 20, 20, 20, 21, 21, 21, 21, 21,
 21, 21, 21, 22, 22, 22, 22, 22, 22, 22,
 22, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,
 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,
 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
 27, 27, 27, 28, 28, 28, 28, 28, 28, 28,
 28, 29, 29, 29, 29, 29, 29, 29, 29, 30,
 30, 30, 30, 30, 30, 30, 30, 31, 31, 31,
 31, 31, 31, 31, 31, 31};

const uint8_t Javelin::Data::BITSCALE_8_TO_4_CEIL[256] = {
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
 8, 8, 8, 8, 8, 8, 8, 9, 9, 9,
 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
 9, 9, 9, 9, 10, 10, 10, 10, 10, 10,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 13, 13, 13, 13, 13,
 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
 14, 14, 14, 14, 14, 14, 14, 14, 14, 15,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
 15, 15, 15, 15, 15, 15};

const uint8_t Javelin::Data::BITSCALE_8_TO_3_CEIL[256] = {
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
 4, 4, 4, 4, 4, 4, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
 7, 7, 7, 7, 7, 7};


//#line 1 "MortonTable.cpp"

//#line 1 "MortonTable.h"
#ifndef JTHLIM_MORTONTABLE_H
#define JTHLIM_MORTONTABLE_H

namespace Javelin
{
	namespace Data
	{

		extern const unsigned short MORTON_TABLE[256];

	} // namespace Data
} // namespace Javelin

#endif

const unsigned short Javelin::Data::MORTON_TABLE[256] =
{
	0x0000, 0x0001, 0x0004, 0x0005, 0x0010, 0x0011, 0x0014, 0x0015,
	0x0040, 0x0041, 0x0044, 0x0045, 0x0050, 0x0051, 0x0054, 0x0055,
	0x0100, 0x0101, 0x0104, 0x0105, 0x0110, 0x0111, 0x0114, 0x0115,
	0x0140, 0x0141, 0x0144, 0x0145, 0x0150, 0x0151, 0x0154, 0x0155,
	0x0400, 0x0401, 0x0404, 0x0405, 0x0410, 0x0411, 0x0414, 0x0415,
	0x0440, 0x0441, 0x0444, 0x0445, 0x0450, 0x0451, 0x0454, 0x0455,
	0x0500, 0x0501, 0x0504, 0x0505, 0x0510, 0x0511, 0x0514, 0x0515,
	0x0540, 0x0541, 0x0544, 0x0545, 0x0550, 0x0551, 0x0554, 0x0555,
	0x1000, 0x1001, 0x1004, 0x1005, 0x1010, 0x1011, 0x1014, 0x1015,
	0x1040, 0x1041, 0x1044, 0x1045, 0x1050, 0x1051, 0x1054, 0x1055,
	0x1100, 0x1101, 0x1104, 0x1105, 0x1110, 0x1111, 0x1114, 0x1115,
	0x1140, 0x1141, 0x1144, 0x1145, 0x1150, 0x1151, 0x1154, 0x1155,
	0x1400, 0x1401, 0x1404, 0x1405, 0x1410, 0x1411, 0x1414, 0x1415,
	0x1440, 0x1441, 0x1444, 0x1445, 0x1450, 0x1451, 0x1454, 0x1455,
	0x1500, 0x1501, 0x1504, 0x1505, 0x1510, 0x1511, 0x1514, 0x1515,
	0x1540, 0x1541, 0x1544, 0x1545, 0x1550, 0x1551, 0x1554, 0x1555,
	0x4000, 0x4001, 0x4004, 0x4005, 0x4010, 0x4011, 0x4014, 0x4015,
	0x4040, 0x4041, 0x4044, 0x4045, 0x4050, 0x4051, 0x4054, 0x4055,
	0x4100, 0x4101, 0x4104, 0x4105, 0x4110, 0x4111, 0x4114, 0x4115,
	0x4140, 0x4141, 0x4144, 0x4145, 0x4150, 0x4151, 0x4154, 0x4155,
	0x4400, 0x4401, 0x4404, 0x4405, 0x4410, 0x4411, 0x4414, 0x4415,
	0x4440, 0x4441, 0x4444, 0x4445, 0x4450, 0x4451, 0x4454, 0x4455,
	0x4500, 0x4501, 0x4504, 0x4505, 0x4510, 0x4511, 0x4514, 0x4515,
	0x4540, 0x4541, 0x4544, 0x4545, 0x4550, 0x4551, 0x4554, 0x4555,
	0x5000, 0x5001, 0x5004, 0x5005, 0x5010, 0x5011, 0x5014, 0x5015,
	0x5040, 0x5041, 0x5044, 0x5045, 0x5050, 0x5051, 0x5054, 0x5055,
	0x5100, 0x5101, 0x5104, 0x5105, 0x5110, 0x5111, 0x5114, 0x5115,
	0x5140, 0x5141, 0x5144, 0x5145, 0x5150, 0x5151, 0x5154, 0x5155,
	0x5400, 0x5401, 0x5404, 0x5405, 0x5410, 0x5411, 0x5414, 0x5415,
	0x5440, 0x5441, 0x5444, 0x5445, 0x5450, 0x5451, 0x5454, 0x5455,
	0x5500, 0x5501, 0x5504, 0x5505, 0x5510, 0x5511, 0x5514, 0x5515,
	0x5540, 0x5541, 0x5544, 0x5545, 0x5550, 0x5551, 0x5554, 0x5555
};


//#line 1 "PvrTcDecoder.cpp"

//#line 1 "PvrTcDecoder.h"
#ifndef JTHLIM_PVRTCDECODER_H
#define JTHLIM_PVRTCDECODER_H


//#line 1 "Point2.h"
#ifndef JTHLIM_POINT2_H
#define JTHLIM_POINT2_H

namespace Javelin {

template<typename T>
class Point2 {
public:
	T x;
	T y;

	Point2(int a, int b)
		: x(a)
		, y(b) {
	}
};

}

#endif


//#line 1 "ColorRgba.h"
#ifndef JTHLIM_COLORRGBA_H
#define JTHLIM_COLORRGBA_H

namespace Javelin {

template<typename T>
class ColorRgb {
public:
	T b;
	T g;
	T r;

	ColorRgb()
		: r(0)
		, g(0)
		, b(0) {
	}

	ColorRgb(T red, T green, T blue)
		: r(red)
		, g(green)
		, b(blue) {
	}

	ColorRgb(const ColorRgb<T> &x)
		: r(x.r)
		, g(x.g)
		, b(x.b) {
	}

	ColorRgb<int> operator *(int x) {
		return ColorRgb<int>(r * x, g * x, b * x);
	}

	ColorRgb<int> operator +(const ColorRgb<T> &x) const {
		return ColorRgb<int>(r + (int)x.r, g + (int)x.g, b + (int)x.b);
	}

	ColorRgb<int> operator -(const ColorRgb<T> &x) const {
		return ColorRgb<int>(r - (int)x.r, g - (int)x.g, b - (int)x.b);
	}

	int operator %(const ColorRgb<T> &x) const {
		return r * (int)x.r + g * (int)x.g + b * (int)x.b;
	}

	bool operator ==(const ColorRgb<T> &x) const {
		return r == x.r && g == x.g && b == x.b;
	}

	bool operator !=(const ColorRgb<T> &x) const {
		return r != x.r || g != x.g || b != x.b;
	}

	void SetMin(const ColorRgb<T> &x) {
		if (x.r < r) {
			r = x.r;
		}
		if (x.g < g) {
			g = x.g;
		}
		if (x.b < b) {
			b = x.b;
		}
	}

	void SetMax(const ColorRgb<T> &x) {
		if (x.r > r) {
			r = x.r;
		}
		if (x.g > g) {
			g = x.g;
		}
		if (x.b > b) {
			b = x.b;
		}
	}
};

template<typename T>
class ColorRgba : public ColorRgb<T> {
public:
	T a;

	ColorRgba() :
		a(0) {
	}

	ColorRgba(T red, T green, T blue, T alpha)
		: ColorRgb<T>(red, green, blue)
		, a(alpha) {
	}

	ColorRgba(const ColorRgba<T> &x)
		: ColorRgb<T>(x.r, x.g, x.b)
		, a(x.a) {
	}

	ColorRgba<int> operator *(int x) {
		return ColorRgba<T>(ColorRgb<T>::r * x,
							ColorRgb<T>::g * x,
							ColorRgb<T>::b * x,
							a * x);
	}

	ColorRgba<int> operator +(const ColorRgba<T> &x) {
		return ColorRgba<T>(ColorRgb<T>::r + (int)x.r,
							ColorRgb<T>::g + (int)x.g,
							ColorRgb<T>::b + (int)x.b,
							a + (int)x.a);
	}

	ColorRgba<int> operator -(const ColorRgba<T> &x) {
		return ColorRgba<T>(ColorRgb<T>::r - (int)x.r,
							ColorRgb<T>::g - (int)x.g,
							ColorRgb<T>::b - (int)x.b,
							a - (int)x.a);
	}

	int operator %(const ColorRgba<T> &x) {
		return ColorRgb<T>::r * (int)x.r +
			   ColorRgb<T>::g * (int)x.g +
			   ColorRgb<T>::b * (int)x.b +
			   a * (int)x.a;
	}

	bool operator ==(const ColorRgba<T> &x) {
		return ColorRgb<T>::r == x.r && ColorRgb<T>::g == x.g &&
			   ColorRgb<T>::b == x.b && a == x.a;
	}

	bool operator !=(const ColorRgba<T> &x) {
		return ColorRgb<T>::r != x.r || ColorRgb<T>::g != x.g ||
			   ColorRgb<T>::b != x.b || a != x.a;
	}

	void SetMin(const ColorRgba<T> &x) {
		ColorRgb<T>::SetMin(x);
		if (x.a < a) {
			a = x.a;
		}
	}

	void SetMax(const ColorRgba<T> &x) {
		ColorRgb<T>::SetMax(x);
		if (x.a > a) {
			a = x.a;
		}
	}
};

}

#endif

namespace Javelin
{

	class PvrTcDecoder
	{
	public:
		static void DecodeRgb4Bpp(ColorRgb<unsigned char>* result, const Point2<int>& size, const void* data);
		static void DecodeRgba4Bpp(ColorRgba<unsigned char>* result, const Point2<int>& size, const void* data);

	private:
		static unsigned GetMortonNumber(int x, int y);
	};

}

#endif


//#line 1 "PvrTcPacket.h"
//
// Modulation data specifies weightings of colorA to colorB for each pixel
//
// For mode = 0
//	00: 0/8
//  01: 3/8
//  10: 5/8
//  11: 8/8
//
// For mode = 1
//  00: 0/8
//  01: 4/8
//  10: 4/8 with alpha punchthrough
//  11: 8/8
//
// For colorIsOpaque=0
//  3 bits A
//  4 bits R
//  4 bits G
//  3/4 bits B
//
// For colorIsOpaque=1
//  5 bits R
//  5 bits G
//  4/5 bits B
//

#ifndef JTHLIM_PVRTCPACKET_H
#define JTHLIM_PVRTCPACKET_H

namespace Javelin
{

	struct PvrTcPacket
	{
		unsigned int    modulationData;
		unsigned        usePunchthroughAlpha : 1;
		unsigned        colorA          	 : 14;
		unsigned        colorAIsOpaque  	 : 1;
		unsigned        colorB        		 : 15;
		unsigned        colorBIsOpaque  	 : 1;

		ColorRgb<int> GetColorRgbA() const;
		ColorRgb<int> GetColorRgbB() const;
		ColorRgba<int> GetColorRgbaA() const;
		ColorRgba<int> GetColorRgbaB() const;

		void SetColorA(const ColorRgb<unsigned char>& c);
		void SetColorB(const ColorRgb<unsigned char>& c);

		void SetColorA(const ColorRgba<unsigned char>& c);
		void SetColorB(const ColorRgba<unsigned char>& c);

		static const unsigned char BILINEAR_FACTORS[16][4];
		static const unsigned char WEIGHTS[8][4];
	};

} // namespace Javelin

#endif

#include <assert.h>

using namespace Javelin;
using Data::MORTON_TABLE;

inline unsigned PvrTcDecoder::GetMortonNumber(int x, int y)
{
	return MORTON_TABLE[x >> 8] << 17 | MORTON_TABLE[y >> 8] << 16 | MORTON_TABLE[x & 0xFF] << 1 | MORTON_TABLE[y & 0xFF];
}

void PvrTcDecoder::DecodeRgb4Bpp(ColorRgb<unsigned char>* result, const Point2<int>& size, const void* data)
{
	assert(size.x == size.y);

	const int blocks = size.x / 4;
	const int blockMask = blocks-1;
	const PvrTcPacket* packets = static_cast<const PvrTcPacket*>(data);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const PvrTcPacket* packet = packets + GetMortonNumber(x, y);

			unsigned mod = packet->modulationData;
			const unsigned char (*weights)[4] = PvrTcPacket::WEIGHTS + 4*packet->usePunchthroughAlpha;
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgb<int> ca = p0->GetColorRgbA() * (*factor)[0] +
									   p1->GetColorRgbA() * (*factor)[1] +
									   p2->GetColorRgbA() * (*factor)[2] +
									   p3->GetColorRgbA() * (*factor)[3];

					ColorRgb<int> cb = p0->GetColorRgbB() * (*factor)[0] +
									   p1->GetColorRgbB() * (*factor)[1] +
									   p2->GetColorRgbB() * (*factor)[2] +
									   p3->GetColorRgbB() * (*factor)[3];

					const unsigned char* w = weights[mod&3];
					ColorRgb<unsigned char> c;
					c.r = (ca.r * w[0] + cb.r * w[1]) >> 7;
					c.g = (ca.g * w[0] + cb.g * w[1]) >> 7;
					c.b = (ca.b * w[0] + cb.b * w[1]) >> 7;

					result[(py+y*4)*size.x + (px+x*4)] = c;
					mod >>= 2;
					factor++;
				}
			}
		}
	}
}

void PvrTcDecoder::DecodeRgba4Bpp(ColorRgba<unsigned char>* result, const Point2<int>& size, const void* data)
{
	assert(size.x == size.y);

	const int blocks = size.x / 4;
	const int blockMask = blocks-1;
	const PvrTcPacket* packets = static_cast<const PvrTcPacket*>(data);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const PvrTcPacket* packet = packets + GetMortonNumber(x, y);

			unsigned mod = packet->modulationData;
			const unsigned char (*weights)[4] = PvrTcPacket::WEIGHTS + 4*packet->usePunchthroughAlpha;
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgba<int> ca = p0->GetColorRgbaA() * (*factor)[0] +
									   	p1->GetColorRgbaA() * (*factor)[1] +
									   	p2->GetColorRgbaA() * (*factor)[2] +
										p3->GetColorRgbaA() * (*factor)[3];

					ColorRgba<int> cb = p0->GetColorRgbaB() * (*factor)[0] +
										p1->GetColorRgbaB() * (*factor)[1] +
										p2->GetColorRgbaB() * (*factor)[2] +
										p3->GetColorRgbaB() * (*factor)[3];

					const unsigned char* w = weights[mod&3];
					ColorRgba<unsigned char> c;
					c.r = (ca.r * w[0] + cb.r * w[1]) >> 7;
					c.g = (ca.g * w[0] + cb.g * w[1]) >> 7;
					c.b = (ca.b * w[0] + cb.b * w[1]) >> 7;
					c.a = (ca.a * w[2] + cb.a * w[3]) >> 7;

					result[(py+y*4)*size.x + (px+x*4)] = c;
					mod >>= 2;
					factor++;
				}
			}
		}
	}
}


//#line 1 "PvrTcEncoder.cpp"

//#line 1 "PvrTcEncoder.h"
#ifndef JTHLIM_PVRTCENCODER_H
#define JTHLIM_PVRTCENCODER_H

namespace Javelin
{

	class AlphaBitmap;
	class RgbBitmap;
	class RgbaBitmap;

	class PvrTcEncoder
	{
	public:
		// Result must be large enough for bitmap.GetArea()/4 bytes
		static void EncodeAlpha2Bpp(void* result, const AlphaBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeAlpha4Bpp(void* result, const AlphaBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeRgb4Bpp(void* result, const RgbBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeRgb4Bpp(void* result, const RgbaBitmap& bitmap);

		// Result must be large enough for bitmap.GetArea()/2 bytes
		static void EncodeRgba4Bpp(void* result, const RgbaBitmap& bitmap);

	private:
		static unsigned GetMortonNumber(int x, int y);
	};

}

#endif


//#line 1 "AlphaBitmap.h"
#ifndef JTHLIM_ALPHABITMAP_H
#define JTHLIM_ALPHABITMAP_H


//#line 1 "Bitmap.h"
#ifndef JTHLIM_BITMAP_H
#define JTHLIM_BITMAP_H

namespace Javelin {

class Bitmap {
public:
	int width;
	int height;
	unsigned char *data;

	Bitmap(int w, int h, int bytesPerPixel)
		: width(w)
		, height(h)
		, data(new unsigned char[width * height * bytesPerPixel]) {
	}

	virtual ~Bitmap() {
		delete [] data;
	}

	Point2<int> GetSize() const { return Point2<int>(width, height); }

	int GetArea() const { return width * height; }

	int GetBitmapWidth() const { return width; }

	int GetBitmapHeight() const { return height; }

	const unsigned char *GetRawData() const { return data; }
};

}

#endif

namespace Javelin {

class AlphaBitmap : public Bitmap {
public:
	AlphaBitmap(int w, int h)
		: Bitmap(w, h, 1) {
	}

	const unsigned char *GetData() const { return data; }

	unsigned char *GetData() { return data; }
};

}

#endif


//#line 1 "RgbBitmap.h"
#ifndef JTHLIM_RGBBITMAP_H
#define JTHLIM_RGBBITMAP_H

namespace Javelin {

class RgbBitmap : public Bitmap {
public:
	RgbBitmap(int w, int h)
		: Bitmap(w, h, 3) {
	}

	const ColorRgb<unsigned char> *GetData() const {
		return reinterpret_cast<ColorRgb<unsigned char> *>(data);
	}

	ColorRgb<unsigned char> *GetData() {
		return reinterpret_cast<ColorRgb<unsigned char> *>(data);
	}
};

}

#endif


//#line 1 "RgbaBitmap.h"
#ifndef JTHLIM_RGBABITMAP_H
#define JTHLIM_RGBABITMAP_H

namespace Javelin {

class RgbaBitmap : public Bitmap {
public:
	RgbaBitmap(int w, int h)
		: Bitmap(w, h, 4) {
	}

	const ColorRgba<unsigned char> *GetData() const {
		return reinterpret_cast<ColorRgba<unsigned char> *>(data);
	}

	ColorRgba<unsigned char> *GetData() {
		return reinterpret_cast<ColorRgba<unsigned char> *>(data);
	}
};

}

#endif


//#line 1 "BitUtility.h"
#ifndef JTHLIM_BITUTILITY_H
#define JTHLIM_BITUTILITY_H

namespace Javelin {

class BitUtility {
public:
	static bool IsPowerOf2(unsigned int x) {
		return (x & (x - 1)) == 0;
	}

	static unsigned int RotateRight(unsigned int value, unsigned int shift) {
		if ((shift &= sizeof(value) * 8 - 1) == 0) {
			return value;
		}
		return (value >> shift) | (value << (sizeof(value) * 8 - shift));
	}
};

}

#endif


//#line 1 "Interval.h"
#ifndef JTHLIM_INTERVAL_H
#define JTHLIM_INTERVAL_H

namespace Javelin {

template<typename T>
class Interval {
public:
	T min;
	T max;

	Interval() {
	}

	Interval<T> &operator|=(const T &x) {
		min.SetMin(x);
		max.SetMax(x);
		return *this;
	}
};

}

#endif

#include <assert.h>
#include <math.h>
#include <stdint.h>

using namespace Javelin;
using Data::MORTON_TABLE;

static const unsigned char MODULATION_LUT[16] =
{
	0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3
};

inline unsigned PvrTcEncoder::GetMortonNumber(int x, int y)
{
	return MORTON_TABLE[x >> 8] << 17 | MORTON_TABLE[y >> 8] << 16 | MORTON_TABLE[x & 0xFF] << 1 | MORTON_TABLE[y & 0xFF];
}

void PvrTcEncoder::EncodeAlpha2Bpp(void* result, const AlphaBitmap& bitmap)
{
	int size = bitmap.GetBitmapWidth();
	assert(size == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(size));

	// Blocks in each dimension.
	int xBlocks = size/8;
	int yBlocks = size/4;

	const unsigned char* bitmapData = bitmap.GetRawData();

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);
	for(int y = 0; y < yBlocks; ++y)
	{
		for(int x = 0; x < xBlocks; ++x)
		{
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->colorAIsOpaque = 0;
			packet->colorA = 0x7ff;		// White, with 0 alpha
			packet->colorBIsOpaque = 1;
			packet->colorB = 0x7fff;	// White with full alpha

			const unsigned char* blockBitmapData = &bitmapData[y*4*size + x*8];

			uint32_t modulationData = 0;
			for(int py = 0; py < 4; ++py)
			{
				const unsigned char* rowBitmapData = blockBitmapData;
				for(int px = 0; px < 8; ++px)
				{
					unsigned char pixel = *rowBitmapData++;
					modulationData = BitUtility::RotateRight(modulationData | (pixel >> 7), 1);
				}
				blockBitmapData += size;
			}
			packet->modulationData = modulationData;
		}
	}
}

void PvrTcEncoder::EncodeAlpha4Bpp(void* result, const AlphaBitmap& bitmap)
{
	int size = bitmap.GetBitmapWidth();
	assert(size == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(size));

	// Blocks in each dimension.
	int blocks = size/4;

	const unsigned char* bitmapData = bitmap.GetRawData();

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);
	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->colorAIsOpaque = 0;
			packet->colorA = 0x7ff;		// White, with 0 alpha
			packet->colorBIsOpaque = 1;
			packet->colorB = 0x7fff;	// White with full alpha

			const unsigned char* blockBitmapData = &bitmapData[(y*size + x)*4];

			uint32_t modulationData = 0;
			for(int py = 0; py < 4; ++py)
			{
				const unsigned char* rowBitmapData = blockBitmapData;
				for(int px = 0; px < 4; ++px)
				{
					unsigned char pixel = *rowBitmapData++;
					modulationData = BitUtility::RotateRight(modulationData | MODULATION_LUT[pixel>>4], 2);
				}
				blockBitmapData += size;
			}
			packet->modulationData = modulationData;
		}
	}
}

typedef Interval<ColorRgb<unsigned char>> ColorRgbBoundingBox;

static void CalculateBoundingBox(ColorRgbBoundingBox& cbb, const RgbBitmap& bitmap, int blockX, int blockY)
{
	int size = bitmap.GetBitmapWidth();
	const ColorRgb<unsigned char>* data = bitmap.GetData() + blockY * 4 * size + blockX * 4;

	cbb.min = data[0];
	cbb.max = data[0];
	cbb |= data[1];
	cbb |= data[2];
	cbb |= data[3];

	cbb |= data[size];
	cbb |= data[size+1];
	cbb |= data[size+2];
	cbb |= data[size+3];

	cbb |= data[2*size];
	cbb |= data[2*size+1];
	cbb |= data[2*size+2];
	cbb |= data[2*size+3];

	cbb |= data[3*size];
	cbb |= data[3*size+1];
	cbb |= data[3*size+2];
	cbb |= data[3*size+3];
}

void PvrTcEncoder::EncodeRgb4Bpp(void* result, const RgbBitmap& bitmap)
{
	assert(bitmap.GetBitmapWidth() == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(bitmap.GetBitmapWidth()));
	const int size = bitmap.GetBitmapWidth();
	const int blocks = size / 4;
	const int blockMask = blocks-1;

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			ColorRgbBoundingBox cbb;
			CalculateBoundingBox(cbb, bitmap, x, y);
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->SetColorA(cbb.min);
			packet->SetColorB(cbb.max);
		}
	}

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;
			const ColorRgb<unsigned char>* data = bitmap.GetData() + y * 4 * size + x * 4;

			uint32_t modulationData = 0;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgb<int> ca = p0->GetColorRgbA() * (*factor)[0] +
									   p1->GetColorRgbA() * (*factor)[1] +
									   p2->GetColorRgbA() * (*factor)[2] +
									   p3->GetColorRgbA() * (*factor)[3];

					ColorRgb<int> cb = p0->GetColorRgbB() * (*factor)[0] +
									   p1->GetColorRgbB() * (*factor)[1] +
									   p2->GetColorRgbB() * (*factor)[2] +
									   p3->GetColorRgbB() * (*factor)[3];

					const ColorRgb<unsigned char>& pixel = data[py*size + px];
					ColorRgb<int> d = cb - ca;
					ColorRgb<int> p( pixel.r*16, pixel.g*16, pixel.b*16 );
					ColorRgb<int> v = p - ca;

					// PVRTC uses weightings of 0, 3/8, 5/8 and 1
					// The boundaries for these are 3/16, 1/2 (=8/16), 13/16
					int projection = (v % d) * 16;
					int lengthSquared = d % d;
					if(projection > 3*lengthSquared) modulationData++;
					if(projection > 8*lengthSquared) modulationData++;
					if(projection > 13*lengthSquared) modulationData++;

					modulationData = BitUtility::RotateRight(modulationData, 2);

					factor++;
				}
			}

			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->modulationData = modulationData;
		}
	}
}

static void CalculateBoundingBox(ColorRgbBoundingBox& cbb, const RgbaBitmap& bitmap, int blockX, int blockY)
{
	int size = bitmap.GetBitmapWidth();
	const ColorRgba<unsigned char>* data = bitmap.GetData() + blockY * 4 * size + blockX * 4;

	cbb.min = data[0];
	cbb.max = data[0];

	cbb |= data[1];
	cbb |= data[2];
	cbb |= data[3];

	cbb |= data[size];
	cbb |= data[size+1];
	cbb |= data[size+2];
	cbb |= data[size+3];

	cbb |= data[2*size];
	cbb |= data[2*size+1];
	cbb |= data[2*size+2];
	cbb |= data[2*size+3];

	cbb |= data[3*size];
	cbb |= data[3*size+1];
	cbb |= data[3*size+2];
	cbb |= data[3*size+3];
}

void PvrTcEncoder::EncodeRgb4Bpp(void* result, const RgbaBitmap& bitmap)
{
	assert(bitmap.GetBitmapWidth() == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(bitmap.GetBitmapWidth()));
	const int size = bitmap.GetBitmapWidth();
	const int blocks = size / 4;
	const int blockMask = blocks-1;

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			ColorRgbBoundingBox cbb;
			CalculateBoundingBox(cbb, bitmap, x, y);
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->SetColorA(cbb.min);
			packet->SetColorB(cbb.max);
		}
	}

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;
			const ColorRgba<unsigned char>* data = bitmap.GetData() + y * 4 * size + x * 4;

			uint32_t modulationData = 0;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgb<int> ca = p0->GetColorRgbA() * (*factor)[0] +
									   p1->GetColorRgbA() * (*factor)[1] +
									   p2->GetColorRgbA() * (*factor)[2] +
									   p3->GetColorRgbA() * (*factor)[3];

					ColorRgb<int> cb = p0->GetColorRgbB() * (*factor)[0] +
									   p1->GetColorRgbB() * (*factor)[1] +
									   p2->GetColorRgbB() * (*factor)[2] +
									   p3->GetColorRgbB() * (*factor)[3];

					const ColorRgb<unsigned char>& pixel = data[py*size + px];
					ColorRgb<int> d = cb - ca;
					ColorRgb<int> p( pixel.r*16, pixel.g*16, pixel.b*16 );
					ColorRgb<int> v = p - ca;

					// PVRTC uses weightings of 0, 3/8, 5/8 and 1
					// The boundaries for these are 3/16, 1/2 (=8/16), 13/16
					int projection = (v % d) * 16;
					int lengthSquared = d % d;
					if(projection > 3*lengthSquared) modulationData++;
					if(projection > 8*lengthSquared) modulationData++;
					if(projection > 13*lengthSquared) modulationData++;

					modulationData = BitUtility::RotateRight(modulationData, 2);

					factor++;
				}
			}

			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->modulationData = modulationData;
		}
	}
}

typedef Interval<ColorRgba<unsigned char>> ColorRgbaBoundingBox;

static void CalculateBoundingBox(ColorRgbaBoundingBox& cbb, const RgbaBitmap& bitmap, int blockX, int blockY)
{
	int size = bitmap.GetBitmapWidth();
	const ColorRgba<unsigned char>* data = bitmap.GetData() + blockY * 4 * size + blockX * 4;

	cbb.min = data[0];
	cbb.max = data[0];

	cbb |= data[1];
	cbb |= data[2];
	cbb |= data[3];

	cbb |= data[size];
	cbb |= data[size+1];
	cbb |= data[size+2];
	cbb |= data[size+3];

	cbb |= data[2*size];
	cbb |= data[2*size+1];
	cbb |= data[2*size+2];
	cbb |= data[2*size+3];

	cbb |= data[3*size];
	cbb |= data[3*size+1];
	cbb |= data[3*size+2];
	cbb |= data[3*size+3];
}

void PvrTcEncoder::EncodeRgba4Bpp(void* result, const RgbaBitmap& bitmap)
{
	assert(bitmap.GetBitmapWidth() == bitmap.GetBitmapHeight());
	assert(BitUtility::IsPowerOf2(bitmap.GetBitmapWidth()));
	const int size = bitmap.GetBitmapWidth();
	const int blocks = size / 4;
	const int blockMask = blocks-1;

	PvrTcPacket* packets = static_cast<PvrTcPacket*>(result);

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			ColorRgbaBoundingBox cbb;
			CalculateBoundingBox(cbb, bitmap, x, y);
			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->usePunchthroughAlpha = 0;
			packet->SetColorA(cbb.min);
			packet->SetColorB(cbb.max);
		}
	}

	for(int y = 0; y < blocks; ++y)
	{
		for(int x = 0; x < blocks; ++x)
		{
			const unsigned char (*factor)[4] = PvrTcPacket::BILINEAR_FACTORS;
			const ColorRgba<unsigned char>* data = bitmap.GetData() + y * 4 * size + x * 4;

			uint32_t modulationData = 0;

			for(int py = 0; py < 4; ++py)
			{
				const int yOffset = (py < 2) ? -1 : 0;
				const int y0 = (y + yOffset) & blockMask;
				const int y1 = (y0+1) & blockMask;

				for(int px = 0; px < 4; ++px)
				{
					const int xOffset = (px < 2) ? -1 : 0;
					const int x0 = (x + xOffset) & blockMask;
					const int x1 = (x0+1) & blockMask;

					const PvrTcPacket* p0 = packets + GetMortonNumber(x0, y0);
					const PvrTcPacket* p1 = packets + GetMortonNumber(x1, y0);
					const PvrTcPacket* p2 = packets + GetMortonNumber(x0, y1);
					const PvrTcPacket* p3 = packets + GetMortonNumber(x1, y1);

					ColorRgba<int> ca = p0->GetColorRgbaA() * (*factor)[0] +
										p1->GetColorRgbaA() * (*factor)[1] +
										p2->GetColorRgbaA() * (*factor)[2] +
										p3->GetColorRgbaA() * (*factor)[3];

					ColorRgba<int> cb = p0->GetColorRgbaB() * (*factor)[0] +
										p1->GetColorRgbaB() * (*factor)[1] +
										p2->GetColorRgbaB() * (*factor)[2] +
										p3->GetColorRgbaB() * (*factor)[3];

					const ColorRgba<unsigned char>& pixel = data[py*size + px];
					ColorRgba<int> d = cb - ca;
					ColorRgba<int> p( pixel.r*16, pixel.g*16, pixel.b*16, pixel.a*16 );
					ColorRgba<int> v = p - ca;

					// PVRTC uses weightings of 0, 3/8, 5/8 and 1
					// The boundaries for these are 3/16, 1/2 (=8/16), 13/16
					int projection = (v % d) * 16;
					int lengthSquared = d % d;
					if(projection > 3*lengthSquared) modulationData++;
					if(projection > 8*lengthSquared) modulationData++;
					if(projection > 13*lengthSquared) modulationData++;

					modulationData = BitUtility::RotateRight(modulationData, 2);

					factor++;
				}
			}

			PvrTcPacket* packet = packets + GetMortonNumber(x, y);
			packet->modulationData = modulationData;
		}
	}
}


//#line 1 "PvrTcPacket.cpp"
using namespace Javelin;

const unsigned char PvrTcPacket::BILINEAR_FACTORS[16][4] =
{
	{ 4, 4, 4, 4 },
	{ 2, 6, 2, 6 },
	{ 8, 0, 8, 0 },
	{ 6, 2, 6, 2 },

	{ 2, 2, 6, 6 },
	{ 1, 3, 3, 9 },
	{ 4, 0, 12, 0 },
	{ 3, 1, 9, 3 },

	{ 8, 8, 0, 0 },
	{ 4, 12, 0, 0 },
	{ 16, 0, 0, 0 },
	{ 12, 4, 0, 0 },

	{ 6, 6, 2, 2 },
	{ 3, 9, 1, 3 },
	{ 12, 0, 4, 0 },
	{ 9, 3, 3, 1 },
};

// Weights are { colorA, colorB, alphaA, alphaB }
const unsigned char PvrTcPacket::WEIGHTS[8][4] =
{
	// Weights for Mode=0
	{ 8, 0, 8, 0 },
	{ 5, 3, 5, 3 },
	{ 3, 5, 3, 5 },
	{ 0, 8, 0, 8 },

	// Weights for Mode=1
	{ 8, 0, 8, 0 },
	{ 4, 4, 4, 4 },
	{ 4, 4, 0, 0 },
	{ 0, 8, 0, 8 },
};

ColorRgb<int> PvrTcPacket::GetColorRgbA() const
{
	if(colorAIsOpaque)
	{
		unsigned char r = colorA >> 9;
		unsigned char g = colorA >> 4 & 0x1f;
		unsigned char b = colorA & 0xf;
		return ColorRgb<int>(Data::BITSCALE_5_TO_8[r],
							 Data::BITSCALE_5_TO_8[g],
							 Data::BITSCALE_4_TO_8[b]);
	}
	else
	{
		unsigned char r = (colorA >> 7) & 0xf;
		unsigned char g = (colorA >> 3) & 0xf;
		unsigned char b = colorA & 7;
		return ColorRgb<int>(Data::BITSCALE_4_TO_8[r],
							 Data::BITSCALE_4_TO_8[g],
							 Data::BITSCALE_3_TO_8[b]);
	}
}

ColorRgb<int> PvrTcPacket::GetColorRgbB() const
{
	if(colorBIsOpaque)
	{
		unsigned char r = colorB >> 10;
		unsigned char g = colorB >> 5 & 0x1f;
		unsigned char b = colorB & 0x1f;
		return ColorRgb<int>(Data::BITSCALE_5_TO_8[r],
							 Data::BITSCALE_5_TO_8[g],
							 Data::BITSCALE_5_TO_8[b]);
	}
	else
	{
		unsigned char r = colorB >> 8 & 0xf;
		unsigned char g = colorB >> 4 & 0xf;
		unsigned char b = colorB & 0xf;
		return ColorRgb<int>(Data::BITSCALE_4_TO_8[r],
							 Data::BITSCALE_4_TO_8[g],
							 Data::BITSCALE_4_TO_8[b]);
	}
}

ColorRgba<int> PvrTcPacket::GetColorRgbaA() const
{
	if(colorAIsOpaque)
	{
		unsigned char r = colorA >> 9;
		unsigned char g = colorA >> 4 & 0x1f;
		unsigned char b = colorA & 0xf;
		return ColorRgba<int>(Data::BITSCALE_5_TO_8[r],
							  Data::BITSCALE_5_TO_8[g],
							  Data::BITSCALE_4_TO_8[b],
							  255);
	}
	else
	{
		unsigned char a = colorA >> 11 & 7;
		unsigned char r = colorA >> 7 & 0xf;
		unsigned char g = colorA >> 3 & 0xf;
		unsigned char b = colorA & 7;
		return ColorRgba<int>(Data::BITSCALE_4_TO_8[r],
							  Data::BITSCALE_4_TO_8[g],
							  Data::BITSCALE_3_TO_8[b],
							  Data::BITSCALE_3_TO_8[a]);
	}
}

ColorRgba<int> PvrTcPacket::GetColorRgbaB() const
{
	if(colorBIsOpaque)
	{
		unsigned char r = colorB >> 10;
		unsigned char g = colorB >> 5 & 0x1f;
		unsigned char b = colorB & 0x1f;
		return ColorRgba<int>(Data::BITSCALE_5_TO_8[r],
							  Data::BITSCALE_5_TO_8[g],
							  Data::BITSCALE_5_TO_8[b],
							  255);
	}
	else
	{
		unsigned char a = colorB >> 12 & 7;
		unsigned char r = colorB >> 8 & 0xf;
		unsigned char g = colorB >> 4 & 0xf;
		unsigned char b = colorB & 0xf;
		return ColorRgba<int>(Data::BITSCALE_4_TO_8[r],
							  Data::BITSCALE_4_TO_8[g],
							  Data::BITSCALE_4_TO_8[b],
							  Data::BITSCALE_3_TO_8[a]);
	}
}

void PvrTcPacket::SetColorA(const ColorRgb<unsigned char>& c)
{
	int r = Data::BITSCALE_8_TO_5_FLOOR[c.r];
	int g = Data::BITSCALE_8_TO_5_FLOOR[c.g];
	int b = Data::BITSCALE_8_TO_4_FLOOR[c.b];
	colorA = r<<9 | g<<4 | b;
	colorAIsOpaque = true;
}

void PvrTcPacket::SetColorB(const ColorRgb<unsigned char>& c)
{
	int r = Data::BITSCALE_8_TO_5_CEIL[c.r];
	int g = Data::BITSCALE_8_TO_5_CEIL[c.g];
	int b = Data::BITSCALE_8_TO_5_CEIL[c.b];
	colorB = r<<10 | g<<5 | b;
	colorBIsOpaque = true;
}

void PvrTcPacket::SetColorA(const ColorRgba<unsigned char>& c)
{
	int a = Data::BITSCALE_8_TO_3_FLOOR[c.a];
	if(a == 7)
	{
		int r = Data::BITSCALE_8_TO_5_FLOOR[c.r];
		int g = Data::BITSCALE_8_TO_5_FLOOR[c.g];
		int b = Data::BITSCALE_8_TO_4_FLOOR[c.b];
		colorA = r<<9 | g<<4 | b;
		colorAIsOpaque = true;
	}
	else
	{
		int r = Data::BITSCALE_8_TO_4_FLOOR[c.r];
		int g = Data::BITSCALE_8_TO_4_FLOOR[c.g];
		int b = Data::BITSCALE_8_TO_3_FLOOR[c.b];
		colorA = a<<11 | r<<7 | g<<3 | b;
		colorAIsOpaque = false;
	}
}

void PvrTcPacket::SetColorB(const ColorRgba<unsigned char>& c)
{
	int a = Data::BITSCALE_8_TO_3_CEIL[c.a];
	if(a == 7)
	{
		int r = Data::BITSCALE_8_TO_5_CEIL[c.r];
		int g = Data::BITSCALE_8_TO_5_CEIL[c.g];
		int b = Data::BITSCALE_8_TO_5_CEIL[c.b];
		colorB = r<<10 | g<<5 | b;
		colorBIsOpaque = true;
	}
	else
	{
		int r = Data::BITSCALE_8_TO_4_CEIL[c.r];
		int g = Data::BITSCALE_8_TO_4_CEIL[c.g];
		int b = Data::BITSCALE_8_TO_4_CEIL[c.b];
		colorB = a<<12 | r<<8 | g<<4 | b;
		colorBIsOpaque = false;
	}
}

namespace spot {

//#line 1 "pvr3.hpp"
// - rlyeh, public domain

struct pvr3 {
	enum table1 {
		PVRTC_2BPP_RGB = 0,
		PVRTC_2BPP_RGBA = 1,
		PVRTC_4BPP_RGB = 2,
		PVRTC_4BPP_RGBA = 3,
		PVRTC_II_2BPP = 4,
		PVRTC_II_4BPP = 5,
		ETC1 = 6,
		DXT1 = 7,
		DXT2 = 8,
		DXT3 = 9,
		DXT4 = 10,
		DXT5 = 11,
		BC1 = 7,
		BC2 = 9,
		BC3 = 11,
		BC4 = 12,
		BC5 = 13,
		BC6 = 14,
		BC7 = 15,
		UYVY = 16,
		YUY2 = 17,
		BW1BPP = 18,
		R9G9B9E5_SHARED_EXPONENT = 19,
		RGBG8888 = 20,
		GRGB8888 = 21,
		ETC2_RGB = 22,
		ETC2_RGBA = 23,
		ETC2_RGB_A1 = 24,
		EAC_R11_UNSIGNED = 25,
		EAC_R11_SIGNED = 26,
		EAC_RG11_UNSIGNED = 27,
		EAC_RG11_SIGNED = 28,

		// spot extensions
		SPOT_RGB888 = 254,
		SPOT_RGBA8888 = 255,
	};
	enum table2 {
		UNSIGNED_BYTE_NORMALIZED = 0,
		SIGNED_BYTE_NORMALIZED = 1,
		UNSIGNED_BYTE = 2,
		SIGNED_BYTE = 3,
		UNSIGNED_SHORT_NORMALIZED = 4,
		SIGNED_SHORT_NORMALIZED = 5,
		UNSIGNED_SHORT = 6,
		SIGNED_SHORT = 7,
		UNSIGNED_INTEGER_NORMALIZED = 8,
		SIGNED_INTEGER_NORMALIZED = 9,
		UNSIGNED_INTEGER = 10,
		SIGNED_INTEGER = 11,
		FLOAT = 12,
	};

	struct header {
		uint32_t version;           // 0x03525650, if endianess does not match ; 0x50565203, if endianess does match
		uint32_t flags;             // 0x02, colour values within the texture have been pre-multiplied by the alpha values
		uint32_t pixel_format_1;    // see table1 above
		uint32_t pixel_format_2;    // 0

		uint32_t color_space;       // 0 linear rgb, 1 standard rgb
		uint32_t channel_type;      // see table2 above
		uint32_t height;            // 1d texture
		uint32_t width;             // 2d texture; >= 1

		uint32_t depth;             // 3d texture; >= 1
		uint32_t num_surfaces;      // num surfaces in texture array; >= 1
		uint32_t num_faces;         // num faces in cubemap; >= 1
		uint32_t num_mipmaps;       // num levels of mipmaps; >= 1

		uint32_t metadata_size;     // length of following header
	} hd;
	struct metadata {
		uint32_t fourcc;            // any 'PVRx' where x[0..255] are reserved
		uint32_t key;               // opcode
		uint32_t datasize;          // length of following field
		uint32_t data;              // dummy field [raw binary data here]
	} mt;
	struct texturedata {
		uint32_t data;              // dummy field [raw binary data here]
	} tx;

	bool is_pvr() const {
		const char id[] = { 'P', 'V', 'R', '\x3' };
		return 0 == memcmp( id, &hd, sizeof(id) );
	}

	bool is_currently_supported() const {
		bool ok = true;
		ok &= is_pvr();
		ok &= hd.flags != 0x2;           // 0x02, colour values within the texture have been pre-multiplied by the alpha values
		ok &= hd.color_space == 0;       // 0 linear rgb, 1 standard rgb
		ok &= hd.channel_type == 0;      // see table2 above
		ok &= hd.height >= 1;            // 1d texture
		ok &= hd.width >= 1;             // 2d texture; >= 1
		ok &= hd.depth <= 1;             // 3d texture; >= 1
		ok &= hd.num_surfaces <= 1;      // num surfaces in texture array; >= 1
		ok &= hd.num_faces <= 1;         // num faces in cubemap; >= 1
	 // ok &= hd.num_mipmaps <= 1;       // num levels of mipmaps; >= 1
	 // ok &= hd.metadata_size == 0;     // length of following header
		ok &= hd.pixel_format_2 == 0;    // 0
		ok &= (                          // see table1 above
			   hd.pixel_format_1 == table1::ETC1
			|| hd.pixel_format_1 <= table1::PVRTC_4BPP_RGBA
		);
		return ok;
	}

	int get_spot_fmt() const {
		return hd.pixel_format_1;
	}

	std::ostream &debug( std::ostream &ss ) const {
		if( !is_pvr() ) {
			ss << "not a .pvr3 header" << std::endl;
		} else {
			ss << "supported .pvr3 file: " << is_currently_supported() << std::endl;
			ss << std::hex;
			ss << "pvr.version: 0x" << hd.version << std::endl;
			ss << "pvr.flags: 0x" << hd.flags << std::endl;
			ss << "pvr.pixel_format_1: 0x" << hd.pixel_format_1 << std::endl;
			ss << "pvr.pixel_format_2: 0x" << hd.pixel_format_2 << std::endl;
			ss << "pvr.color_space: 0x" << hd.color_space << std::endl;
			ss << "pvr.channel_type: 0x" << hd.channel_type << std::endl;
			ss << std::dec;
			ss << "pvr.height: " << hd.height << std::endl;
			ss << "pvr.width: " << hd.width << std::endl;
			ss << "pvr.depth: " << hd.depth << std::endl;
			ss << "pvr.num_surfaces: " << hd.num_surfaces << std::endl;
			ss << "pvr.num_faces: " << hd.num_faces << std::endl;
			ss << "pvr.num_mipmaps: " << hd.num_mipmaps << std::endl;
			ss << "pvr.metadata_size: " << hd.metadata_size << std::endl;
			ss << std::endl;
		}
		return ss;
	}

};



//#line 1 "pvr2.hpp"
// - rlyeh, public domain

struct pvr2 {
	enum table1 {
		MGLPT_ARGB_4444 = 0x00,
		MGLPT_ARGB_1555,
		MGLPT_RGB_565,
		MGLPT_RGB_555,
		MGLPT_RGB_888,
		MGLPT_ARGB_8888,
		MGLPT_ARGB_8332,
		MGLPT_I_8,
		MGLPT_AI_88,
		MGLPT_1_BPP,
		MGLPT_VY1UY0,
		MGLPT_Y1VY0U,
		MGLPT_PVRTC2,
		MGLPT_PVRTC4,
		MGLPT_PVRTC2_2,
		MGLPT_PVRTC2_4,

		OGL_RGBA_4444 = 0x10,
		OGL_RGBA_5551,
		OGL_RGBA_8888,
		OGL_RGB_565,
		OGL_RGB_555,
		OGL_RGB_888,
		OGL_I_8,
		OGL_AI_88,
		OGL_PVRTC2,
		OGL_PVRTC4,
	};

	enum table2 {
		MIPMAPS_ARE_PRESENT = 0x00000100,
		DATA_IS_TWIDDLED = 0x00000200,
		CONTAINS_NORMAL_DATA = 0x00000400,
		HAS_A_BORDER = 0x00000800,
		IS_A_CUBE_MAP = 0x00001000, // (EVERY_6_SURFACES_MAKE_UP_ONE_CUBE_MAP)
		MIPMAPS_HAVE_DEBUG_COLOURING = 0x00002000,
		IS_A_VOLUME_3D_TEXTURE = 0x00004000, //(NUMSURFACES_IS_INTERPRETED_AS_A_DEPTH_VALUE)
		ALPHA_CHANNEL_DATA_IS_PRESENT = 0x00008000, // (PVRTC_ONLY)
		TEXTURE_DATA_IS_VERTICALLY_FLIPPED = 0x00010000,
	};
#pragma pack(push,1)
	struct header {
		uint32_t version;           // version and header size: 44 for v1, 52 for v2
		uint32_t height;            // 1d texture
		uint32_t width;             // 2d texture; >= 1

		uint32_t num_mipmaps;       // num levels of mipmaps, excluding the top level (if >= 1, mip map flag should be set)
		uint8_t  pixel_format;      // see table1 above
		uint8_t  flags[3];          // 0x02, colour values within the texture have been pre-multiplied by the alpha values

		uint32_t surface_size;
		uint32_t bpp;               //

		uint32_t r_mask;            // see table2 above
		uint32_t g_mask;            // see table2 above
		uint32_t b_mask;            // see table2 above
		uint32_t a_mask;            // see table2 above

		uint32_t magic;             // 3d texture; >= 1
		uint32_t num_surfaces;      // num surfaces in texture array; >= 1
	} hd;
#pragma pack(pop)

	bool is_pvr() const {
		const char pvr1[] = { 44, 0, 0, 0 };
		const char pvr2[] = { 52, 0, 0, 0 };
		return 0 == memcmp( pvr1, &hd, sizeof(pvr1) ) || 0 == memcmp( pvr2, &hd, sizeof(pvr2) );
	}

	bool is_currently_supported() const {
		bool ok = true;
		ok &= is_pvr();
		return ok;
	}

	int get_spot_fmt() const {
		/*
		switch( hd.pixel_format_1 ) {
			case RGB_888:
			case RGBA_8888:
			case PVRTC2: return pvr3::table1::PVRTC_2BPP_RGB;
			case PVRTC4: return pvr3::table1::PVRTC_4BPP_RGB;
			case ETC:
		}
		*/
		return -1;
	}

	std::ostream &debug( std::ostream &ss ) const {
		if( !is_pvr() ) {
			ss << "not a .pvr2 header" << std::endl;
		} else {
			ss << "supported .pvr2 file: " << is_currently_supported() << std::endl;
			ss << std::endl;
		}
		return ss;
	}
};


//#line 1 "pkm.hpp"
// - rlyeh, public domain

struct pkm {
	struct header {
		uint32_t id;                // "PKM "
		uint16_t version;           // "10"
		uint16_t type;              // 0: ETC1_RGB_NO_MIPMAPS
		uint16_t width;             // after %4; big endian
		uint16_t height;            // after %4; big endian
		uint16_t width_src;         // original width; big endian
		uint16_t height_src;        // original height; big endian
	} hd;
	struct texturedata {
		uint32_t data;              // dummy field [raw binary data here]
	} tx;

	bool is_pkm() const {
		const char xx[] = {'P','K','M',' ','1','0'};
		return 0 == memcmp(this, xx, sizeof(xx));
	}

	bool is_currently_supported() const {
		return is_pkm() && get_spot_fmt() != -1;
	}

	int get_spot_fmt() const {
		return hd.type == 0 ? pvr3::table1::ETC1 : -1;
	}

	std::ostream &debug( std::ostream &ss ) const {
		if( !is_pkm() ) {
			ss << "not a .pkm header" << std::endl;
		} else {
			ss << "supported .pkm file: " << is_currently_supported() << std::endl;
			ss << "pkm.id: "; ss.write( (const char *)&hd.id, sizeof(hd.id) ); ss << std::endl;
			ss << "pkm.version: "; ss.write( (const char *)&hd.version, sizeof(hd.version) ); ss << std::endl;
			ss << std::hex;
			ss << "pkm.type: 0x" << hd.type << std::endl;
			ss << std::dec;
			ss << "pkm.width: " << hd.width << std::endl;
			ss << "pkm.height: " << hd.height << std::endl;
			ss << "pkm.width_src: " << hd.width_src << std::endl;
			ss << "pkm.height_src: " << hd.height_src << std::endl;
			ss << std::endl;
		}
		return ss;
	}
};


//#line 1 "ktx.hpp"
// - rlyeh, public domain

struct ktx {
	struct header {
		uint32_t identifier0;           // '+', 'K', 'T', 'X', ' ', '1', '1', ';', '\r', '\n', '\x1A', '\n'
		uint32_t identifier1;
		uint32_t identifier2;
		uint32_t endianness;            // 0x04030201 a little endian program must convert from big endian, and a big endian program must convert to little endian

		uint32_t glType;                // compressed == 0
		uint32_t glTypeSize;            // compressed == 1
		uint32_t glFormat;              // STENCIL_INDEX, DEPTH_COMPONENT, DEPTH_STENCIL, RED, GREEN, BLUE, RG, RGB, RGBA, BGR, BGRA, RED_INTEGER, GREEN_INTEGER, BLUE_INTEGER, RG_INTEGER, RGB_INTEGER, RGBA_INTEGER, BGR_INTEGER, BGRA_INTEGER,
		uint32_t glInternalFormat;      // COMPRESSED_RED, COMPRESSED_RG, COMPRESSED_RGB, COMPRESSED_RGBA, COMPRESSED_SRGB, COMPRESSED_SRGB_ALPHA, COMPRESSED_RED_RGTC1, COMPRESSED_SIGNED_RED_RGTC1, COMPRESSED_RG_RGTC2, COMPRESSED_SIGNED_RG_RGTC2, COMPRESSED_RGBA_BPTC_UNORM, COMPRESSED_SRGB_ALPHA_BPTC_UNORM, COMPRESSED_RGB_BPTC_SIGNED_FLOAT, COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC,

		uint32_t glBaseInternalFormat;  // DEPTH_COMPONENT, DEPTH_STENCIL, RED, RG, RGB, RGBA, STENCIL_INDEX,
		uint32_t pixelWidth;
		uint32_t pixelHeight;
		uint32_t pixelDepth;

		uint32_t numberOfArrayElements;
		uint32_t numberOfFaces;
		uint32_t numberOfMipmapLevels;
		uint32_t bytesOfKeyValueData;
	} hd;

	struct metadata {
		uint32_t keyAndValueByteSize;
		uint8_t  keyAndValue;
		uint8_t  valuePadding;
	} mt;

	struct texturedata {
		uint32_t size;
		uint32_t data;
	} tx;

	bool is_ktx() const {
		const char id[] = { char(0xAB), 'K', 'T', 'X', ' ', '1', '1', char(0xBB), '\r', '\n', '\x1A', '\n' };
		return 0 == memcmp( id, &hd, sizeof(id) );
	}

	bool is_currently_supported() const {
		bool ok = true;
		ok &= is_ktx();
		ok &= hd.pixelDepth <= 1;
//        ok &= hd.bytesOfKeyValueData == 0;
//        ok &= hd.numberOfMipmapLevels <= 1;
		ok &= hd.numberOfArrayElements <= 1;
		ok &= hd.numberOfFaces <= 1;
		ok &= get_spot_fmt() != -1;
		return ok;
	}

	int get_spot_fmt() const {
		if( hd.glInternalFormat == 0x8d64 && hd.glBaseInternalFormat == 0x1907 ) return pvr3::table1::ETC1;            // etc1
		if( hd.glInternalFormat == 0x8c01 && hd.glBaseInternalFormat == 0x1907 ) return pvr3::table1::PVRTC_2BPP_RGB;  // pvrtc-2bpp-rgb
		if( hd.glInternalFormat == 0x8c03 && hd.glBaseInternalFormat == 0x1908 ) return pvr3::table1::PVRTC_2BPP_RGBA; // pvrtc-2bpp-rgba
		if( hd.glInternalFormat == 0x8c00 && hd.glBaseInternalFormat == 0x1907 ) return pvr3::table1::PVRTC_4BPP_RGB;  // pvrtc-4bpp-rgb
		if( hd.glInternalFormat == 0x8c02 && hd.glBaseInternalFormat == 0x1908 ) return pvr3::table1::PVRTC_4BPP_RGBA; // pvrtc-4bpp-rgba
		return -1;
	}

	std::ostream &debug( std::ostream &ss ) const {
		if( !is_ktx() ) {
			ss << "not a .ktx header" << std::endl;
		} else {
			ss << "supported .ktx file: " << is_currently_supported() << std::endl;
			ss << std::hex;
			ss << "ktx.identifier0: 0x" << hd.identifier0 << std::endl;
			ss << "ktx.identifier1: 0x" << hd.identifier1 << std::endl;
			ss << "ktx.identifier2: 0x" << hd.identifier2 << std::endl;
			ss << "ktx.endianness: 0x" << std::hex << hd.endianness << std::endl;
			ss << "ktx.glType: 0x" << hd.glType << std::endl;
			ss << "ktx.glTypeSize: 0x" << hd.glTypeSize << std::endl;
			ss << "ktx.glFormat: 0x" << std::hex << hd.glFormat << std::endl;
			ss << "ktx.glInternalFormat: 0x" << std::hex << hd.glInternalFormat << std::endl;
			ss << "ktx.glBaseInternalFormat: 0x" << std::hex << hd.glBaseInternalFormat << std::endl;
			ss << std::dec;
			ss << "ktx.pixelWidth: " << hd.pixelWidth << std::endl;
			ss << "ktx.pixelHeight: " << hd.pixelHeight << std::endl;
			ss << "ktx.pixelDepth: " << hd.pixelDepth << std::endl;
			ss << "ktx.numberOfArrayElements: " << hd.numberOfArrayElements << std::endl;
			ss << "ktx.numberOfFaces: " << hd.numberOfFaces << std::endl;
			ss << "ktx.numberOfMipmapLevels: " << hd.numberOfMipmapLevels << std::endl;
			ss << "ktx.bytesOfKeyValueData: " << hd.bytesOfKeyValueData << std::endl;
			ss << std::endl;
		}
		return ss;
	}
};


//#line 1 "PVRTDecompress.cpp"
typedef unsigned char      PVRTuint8;
typedef unsigned short     PVRTuint16;
typedef unsigned int       PVRTuint32;

/*****************************************************************************
 * defines and consts
 *****************************************************************************/
#define PT_INDEX (2)	// The Punch-through index

#define BLK_Y_SIZE 	(4) // always 4 for all 2D block types

#define BLK_X_MAX	(8)	// Max X dimension for blocks

#define BLK_X_2BPP	(8) // dimensions for the two formats
#define BLK_X_4BPP	(4)

#define WRAP_COORD(Val, Size) ((Val) & ((Size)-1))

#define POWER_OF_2(X)   util_number_is_power_2(X)

/*
	Define an expression to either wrap or clamp large or small vals to the
	legal coordinate range
*/
#define PVRT_MIN(a,b)            (((a) < (b)) ? (a) : (b))
#define PVRT_MAX(a,b)            (((a) > (b)) ? (a) : (b))
#define PVRT_CLAMP(x, l, h)      (PVRT_MIN((h), PVRT_MAX((x), (l))))

#define LIMIT_COORD(Val, Size, AssumeImageTiles) \
	  ((AssumeImageTiles)? WRAP_COORD((Val), (Size)): PVRT_CLAMP((Val), 0, (Size)-1))

/*****************************************************************************
 * Useful typedefs
 *****************************************************************************/
typedef PVRTuint32 U32;
typedef PVRTuint8 U8;

/***********************************************************
				DECOMPRESSION ROUTINES
************************************************************/

/*!***********************************************************************
 @Struct	AMTC_BLOCK_STRUCT
 @Brief
*************************************************************************/
typedef struct
{
	// Uses 64 bits pre block
	U32 PackedData[2];
}AMTC_BLOCK_STRUCT;

 /*!***********************************************************************
  @Function		util_number_is_power_2
  @Input		input A number
  @Returns		TRUE if the number is an integer power of two, else FALSE.
  @Description	Check that a number is an integer power of two, i.e.
				1, 2, 4, 8, ... etc.
				Returns FALSE for zero.
*************************************************************************/
int util_number_is_power_2( unsigned  input )
{
  unsigned minus1;

  if( !input ) return 0;

  minus1 = input - 1;
  return ( (input | minus1) == (input ^ minus1) ) ? 1 : 0;
}

/*!***********************************************************************
 @Function		Unpack5554Colour
 @Input			pBlock
 @Input			ABColours
 @Description	Given a block, extract the colour information and convert
				to 5554 formats
*************************************************************************/
static void Unpack5554Colour(const AMTC_BLOCK_STRUCT *pBlock,
							 int   ABColours[2][4])
{
	U32 RawBits[2];

	int i;

	// Extract A and B
	RawBits[0] = pBlock->PackedData[1] & (0xFFFE); // 15 bits (shifted up by one)
	RawBits[1] = pBlock->PackedData[1] >> 16;	   // 16 bits

	// step through both colours
	for(i = 0; i < 2; i++)
	{
		// If completely opaque
		if(RawBits[i] & (1<<15))
		{
			// Extract R and G (both 5 bit)
			ABColours[i][0] = (RawBits[i] >> 10) & 0x1F;
			ABColours[i][1] = (RawBits[i] >>  5) & 0x1F;

			/*
				The precision of Blue depends on  A or B. If A then we need to
				replicate the top bit to get 5 bits in total
			*/
			ABColours[i][2] = RawBits[i] & 0x1F;
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// set 4bit alpha fully on...
			ABColours[i][3] = 0xF;
		}
		else // Else if colour has variable translucency
		{
			/*
				Extract R and G (both 4 bit).
				(Leave a space on the end for the replication of bits
			*/
			ABColours[i][0] = (RawBits[i] >>  (8-1)) & 0x1E;
			ABColours[i][1] = (RawBits[i] >>  (4-1)) & 0x1E;

			// replicate bits to truly expand to 5 bits
			ABColours[i][0] |= ABColours[i][0] >> 4;
			ABColours[i][1] |= ABColours[i][1] >> 4;

			// grab the 3(+padding) or 4 bits of blue and add an extra padding bit
			ABColours[i][2] = (RawBits[i] & 0xF) << 1;

			/*
				expand from 3 to 5 bits if this is from colour A, or 4 to 5 bits if from
				colour B
			*/
			if(i==0)
			{
				ABColours[0][2] |= ABColours[0][2] >> 3;
			}
			else
			{
				ABColours[0][2] |= ABColours[0][2] >> 4;
			}

			// Set the alpha bits to be 3 + a zero on the end
			ABColours[i][3] = (RawBits[i] >> 11) & 0xE;
		}
	}
}

/*!***********************************************************************
 @Function		UnpackModulations
 @Input			pBlock
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			StartX
 @Input			StartY
 @Description	Given the block and the texture type and it's relative
				position in the 2x2 group of blocks, extract the bit
				patterns for the fully defined pixels.
*************************************************************************/
static void	UnpackModulations(const AMTC_BLOCK_STRUCT *pBlock,
							  const int Do2bitMode,
							  int ModulationVals[8][16],
							  int ModulationModes[8][16],
							  int StartX,
							  int StartY)
{
	int BlockModMode;
	U32 ModulationBits;

	int x, y;

	BlockModMode= pBlock->PackedData[1] & 1;
	ModulationBits	= pBlock->PackedData[0];

	// if it's in an interpolated mode
	if(Do2bitMode && BlockModMode)
	{
		/*
			run through all the pixels in the block. Note we can now treat all the
			"stored" values as if they have 2bits (even when they didn't!)
		*/
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// if this is a stored value...
				if(((x^y)&1) == 0)
				{
					ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
					ModulationBits >>= 2;
				}
			}
		}
	}
	else if(Do2bitMode) // else if direct encoded 2bit mode - i.e. 1 mode bit per pixel
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_2BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				// double the bits so 0=> 00, and 1=>11
				if(ModulationBits & 1)
				{
					ModulationVals[y+StartY][x+StartX] = 0x3;
				}
				else
				{
					ModulationVals[y+StartY][x+StartX] = 0x0;
				}
				ModulationBits >>= 1;
			}
		}
	}
	else // else its the 4bpp mode so each value has 2 bits
	{
		for(y = 0; y < BLK_Y_SIZE; y++)
		{
			for(x = 0; x < BLK_X_4BPP; x++)
			{
				ModulationModes[y+StartY][x+StartX] = BlockModMode;

				ModulationVals[y+StartY][x+StartX] = ModulationBits & 3;
				ModulationBits >>= 2;
			}
		}
	}

	// make sure nothing is left over
	assert(ModulationBits==0);
}

/*!***********************************************************************
 @Function		InterpolateColours
 @Input			ColourP
 @Input			ColourQ
 @Input			ColourR
 @Input			ColourS
 @Input			Do2bitMode
 @Input			x
 @Input			y
 @Modified		Result
 @Description	This performs a HW bit accurate interpolation of either the
				A or B colours for a particular pixel.

				NOTE: It is assumed that the source colours are in ARGB 5554
				format - This means that some "preparation" of the values will
				be necessary.
*************************************************************************/
static void InterpolateColours(const int ColourP[4],
						  const int ColourQ[4],
						  const int ColourR[4],
						  const int ColourS[4],
						  const int Do2bitMode,
						  const int x,
						  const int y,
						  int Result[4])
{
	int u, v, uscale;
	int k;

	int tmp1, tmp2;

	int P[4], Q[4], R[4], S[4];

	// Copy the colours
	for(k = 0; k < 4; k++)
	{
		P[k] = ColourP[k];
		Q[k] = ColourQ[k];
		R[k] = ColourR[k];
		S[k] = ColourS[k];
	}

	// put the x and y values into the right range
	v = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		u = (x & 0x7) | ((~x & 0x4) << 1);
	else
		u = (x & 0x3) | ((~x & 0x2) << 1);

	// get the u and v scale amounts
	v  = v - BLK_Y_SIZE/2;

	if(Do2bitMode)
	{
		u = u - BLK_X_2BPP/2;
		uscale = 8;
	}
	else
	{
		u = u - BLK_X_4BPP/2;
		uscale = 4;
	}

	for(k = 0; k < 4; k++)
	{
		tmp1 = P[k] * uscale + u * (Q[k] - P[k]);
		tmp2 = R[k] * uscale + u * (S[k] - R[k]);

		tmp1 = tmp1 * 4 + v * (tmp2 - tmp1);

		Result[k] = tmp1;
	}

	// Lop off the appropriate number of bits to get us to 8 bit precision
	if(Do2bitMode)
	{
		// do RGB
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 2;
		}

		Result[3] >>= 1;
	}
	else
	{
		// do RGB  (A is ok)
		for(k = 0; k < 3; k++)
		{
			Result[k] >>= 1;
		}
	}

	// sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

	/*
		Convert from 5554 to 8888

		do RGB 5.3 => 8
	*/
	for(k = 0; k < 3; k++)
	{
		Result[k] += Result[k] >> 5;
	}

	Result[3] += Result[3] >> 4;

	// 2nd sanity check
	for(k = 0; k < 4; k++)
	{
		assert(Result[k] < 256);
	}

}

/*!***********************************************************************
 @Function		GetModulationValue
 @Input			x
 @Input			y
 @Input			Do2bitMode
 @Input			ModulationVals
 @Input			ModulationModes
 @Input			Mod
 @Input			DoPT
 @Description	Get the modulation value as a numerator of a fraction of 8ths
*************************************************************************/
static void GetModulationValue(int x,
							   int y,
							   const int Do2bitMode,
							   const int ModulationVals[8][16],
							   const int ModulationModes[8][16],
							   int *Mod,
							   int *DoPT)
{
	static const int RepVals0[4] = {0, 3, 5, 8};
	static const int RepVals1[4] = {0, 4, 4, 8};

	int ModVal;

	// Map X and Y into the local 2x2 block
	y = (y & 0x3) | ((~y & 0x2) << 1);

	if(Do2bitMode)
		x = (x & 0x7) | ((~x & 0x4) << 1);
	else
		x = (x & 0x3) | ((~x & 0x2) << 1);

	// assume no PT for now
	*DoPT = 0;

	// extract the modulation value. If a simple encoding
	if(ModulationModes[y][x]==0)
	{
		ModVal = RepVals0[ModulationVals[y][x]];
	}
	else if(Do2bitMode)
	{
		// if this is a stored value
		if(((x^y)&1)==0)
			ModVal = RepVals0[ModulationVals[y][x]];
		else if(ModulationModes[y][x] == 1) // else average from the neighbours if H&V interpolation..
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] +
					  RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 2) / 4;
		}
		else if(ModulationModes[y][x] == 2) // else if H-Only
		{
			ModVal = (RepVals0[ModulationVals[y][x-1]] +
					  RepVals0[ModulationVals[y][x+1]] + 1) / 2;
		}
		else // else it's V-Only
		{
			ModVal = (RepVals0[ModulationVals[y-1][x]] +
					  RepVals0[ModulationVals[y+1][x]] + 1) / 2;
		}
	}
	else // else it's 4BPP and PT encoding
	{
		ModVal = RepVals1[ModulationVals[y][x]];

		*DoPT = ModulationVals[y][x] == PT_INDEX;
	}

	*Mod =ModVal;
}

/*!***********************************************************************
 @Function		TwiddleUV
 @Input			YSize	Y dimension of the texture in pixels
 @Input			XSize	X dimension of the texture in pixels
 @Input			YPos	Pixel Y position
 @Input			XPos	Pixel X position
 @Returns		The twiddled offset of the pixel
 @Description	Given the Block (or pixel) coordinates and the dimension of
				the texture in blocks (or pixels) this returns the twiddled
				offset of the block (or pixel) from the start of the map.

				NOTE the dimensions of the texture must be a power of 2
*************************************************************************/
static int DisableTwiddlingRoutine = 0;

static U32 TwiddleUV(U32 YSize, U32 XSize, U32 YPos, U32 XPos)
{
	U32 Twiddled;

	U32 MinDimension;
	U32 MaxValue;

	U32 SrcBitPos;
	U32 DstBitPos;

	int ShiftCount;

	assert(YPos < YSize);
	assert(XPos < XSize);

	assert(POWER_OF_2(YSize));
	assert(POWER_OF_2(XSize));

	if(YSize < XSize)
	{
		MinDimension = YSize;
		MaxValue	 = XPos;
	}
	else
	{
		MinDimension = XSize;
		MaxValue	 = YPos;
	}

	// Nasty hack to disable twiddling
	if(DisableTwiddlingRoutine)
		return (YPos* XSize + XPos);

	// Step through all the bits in the "minimum" dimension
	SrcBitPos = 1;
	DstBitPos = 1;
	Twiddled  = 0;
	ShiftCount = 0;

	while(SrcBitPos < MinDimension)
	{
		if(YPos & SrcBitPos)
		{
			Twiddled |= DstBitPos;
		}

		if(XPos & SrcBitPos)
		{
			Twiddled |= (DstBitPos << 1);
		}

		SrcBitPos <<= 1;
		DstBitPos <<= 2;
		ShiftCount += 1;

	}

	// prepend any unused bits
	MaxValue >>= ShiftCount;

	Twiddled |=  (MaxValue << (2*ShiftCount));

	return Twiddled;
}

/***********************************************************/
/*
// Decompress
//
// Takes the compressed input data and outputs the equivalent decompressed
// image.
*/
/***********************************************************/

static void Decompress(AMTC_BLOCK_STRUCT *pCompressedData,
					   const int Do2bitMode,
					   const int XDim,
					   const int YDim,
					   const int AssumeImageTiles,
					   unsigned char* pResultImage)
{
	int x, y;
	int i, j;

	int BlkX, BlkY;
	int BlkXp1, BlkYp1;
	int XBlockSize;
	int BlkXDim, BlkYDim;

	int StartX, StartY;

	int ModulationVals[8][16];
	int ModulationModes[8][16];

	int Mod, DoPT;

	unsigned int uPosition;

	/*
	// local neighbourhood of blocks
	*/
	AMTC_BLOCK_STRUCT *pBlocks[2][2];

	AMTC_BLOCK_STRUCT *pPrevious[2][2] = {{NULL, NULL}, {NULL, NULL}};

	/*
	// Low precision colours extracted from the blocks
	*/
	struct
	{
		int Reps[2][4];
	}Colours5554[2][2];

	/*
	// Interpolated A and B colours for the pixel
	*/
	int ASig[4], BSig[4];

	int Result[4];

	if(Do2bitMode)
	{
		XBlockSize = BLK_X_2BPP;
	}
	else
	{
		XBlockSize = BLK_X_4BPP;
	}

	/*
	// For MBX don't allow the sizes to get too small
	*/
	BlkXDim = PVRT_MAX(2, XDim / XBlockSize);
	BlkYDim = PVRT_MAX(2, YDim / BLK_Y_SIZE);

	/*
	// Step through the pixels of the image decompressing each one in turn
	//
	// Note that this is a hideously inefficient way to do this!
	*/
	for(y = 0; y < YDim; y++)
	{
		for(x = 0; x < XDim; x++)
		{
			/*
			// map this pixel to the top left neighbourhood of blocks
			*/
			BlkX = (x - XBlockSize/2);
			BlkY = (y - BLK_Y_SIZE/2);

			BlkX = LIMIT_COORD(BlkX, XDim, AssumeImageTiles);
			BlkY = LIMIT_COORD(BlkY, YDim, AssumeImageTiles);

			BlkX /= XBlockSize;
			BlkY /= BLK_Y_SIZE;

			//BlkX = LIMIT_COORD(BlkX, BlkXDim, AssumeImageTiles);
			//BlkY = LIMIT_COORD(BlkY, BlkYDim, AssumeImageTiles);

			/*
			// compute the positions of the other 3 blocks
			*/
			BlkXp1 = LIMIT_COORD(BlkX+1, BlkXDim, AssumeImageTiles);
			BlkYp1 = LIMIT_COORD(BlkY+1, BlkYDim, AssumeImageTiles);

			/*
			// Map to block memory locations
			*/
			pBlocks[0][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkX);
			pBlocks[0][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkY, BlkXp1);
			pBlocks[1][0] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkX);
			pBlocks[1][1] = pCompressedData +TwiddleUV(BlkYDim, BlkXDim, BlkYp1, BlkXp1);

			/*
			// extract the colours and the modulation information IF the previous values
			// have changed.
			*/
			if(memcmp(pPrevious, pBlocks, 4*sizeof(void*)) != 0)
			{
				StartY = 0;
				for(i = 0; i < 2; i++)
				{
					StartX = 0;
					for(j = 0; j < 2; j++)
					{
						Unpack5554Colour(pBlocks[i][j], Colours5554[i][j].Reps);

						UnpackModulations(pBlocks[i][j],
							Do2bitMode,
							ModulationVals,
							ModulationModes,
							StartX, StartY);

						StartX += XBlockSize;
					}/*end for j*/

					StartY += BLK_Y_SIZE;
				}/*end for i*/

				/*
				// make a copy of the new pointers
				*/
				memcpy(pPrevious, pBlocks, 4*sizeof(void*));
			}/*end if the blocks have changed*/

			/*
			// decompress the pixel.  First compute the interpolated A and B signals
			*/
			InterpolateColours(Colours5554[0][0].Reps[0],
				Colours5554[0][1].Reps[0],
				Colours5554[1][0].Reps[0],
				Colours5554[1][1].Reps[0],
				Do2bitMode, x, y,
				ASig);

			InterpolateColours(Colours5554[0][0].Reps[1],
				Colours5554[0][1].Reps[1],
				Colours5554[1][0].Reps[1],
				Colours5554[1][1].Reps[1],
				Do2bitMode, x, y,
				BSig);

			GetModulationValue(x,y, Do2bitMode, (const int (*)[16])ModulationVals, (const int (*)[16])ModulationModes,
				&Mod, &DoPT);

			/*
			// compute the modulated colour
			*/
			for(i = 0; i < 4; i++)
			{
				Result[i] = ASig[i] * 8 + Mod * (BSig[i] - ASig[i]);
				Result[i] >>= 3;
			}
			if(DoPT)
			{
				Result[3] = 0;
			}

			/*
			// Store the result in the output image
			*/
			uPosition = (x+y*XDim)<<2;
			pResultImage[uPosition+0] = (unsigned char)Result[0];
			pResultImage[uPosition+1] = (unsigned char)Result[1];
			pResultImage[uPosition+2] = (unsigned char)Result[2];
			pResultImage[uPosition+3] = (unsigned char)Result[3];

		}/*end for x*/
	}/*end for y*/

}

}

#define Bitmap Bitmap2

//#line 1 "Bitmap.cpp"
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <string>


//#line 1 "Bitmap.hpp"
#ifndef __DARKRL__BITMAP_HPP__
#define __DARKRL__BITMAP_HPP__

#include <memory>


//#line 1 "Types.hpp"
#ifndef __DARKRL__TYPES_HPP__
#define __DARKRL__TYPES_HPP__

#include <stdint.h>

typedef unsigned int uint;

#endif


//#line 1 "Vector.hpp"
#ifndef __DARKRL__VECTOR_HPP__
#define __DARKRL__VECTOR_HPP__

#include <assert.h>
#include <algorithm>
#include <math.h>


//#line 1 "Math.hpp"
#ifndef __DARKRL__MATH_HPP__
#define __DARKRL__MATH_HPP__

#include <algorithm>

template<typename T>
inline T AlignPOT( T val )
{
	if( val == 0 ) return 1;
	val--;
	for( unsigned int i=1; i<sizeof( T ) * 8; i <<= 1 )
	{
		val |= val >> i;
	}
	return val + 1;
}

inline int CountSetBits( uint32_t val )
{
	val -= ( val >> 1 ) & 0x55555555;
	val = ( ( val >> 2 ) & 0x33333333 ) + ( val & 0x33333333 );
	val = ( ( val >> 4 ) + val ) & 0x0f0f0f0f;
	val += val >> 8;
	val += val >> 16;
	return val & 0x0000003f;
}

inline int CountLeadingZeros( uint32_t val )
{
	val |= val >> 1;
	val |= val >> 2;
	val |= val >> 4;
	val |= val >> 8;
	val |= val >> 16;
	return 32 - CountSetBits( val );
}

inline float sRGB2linear( float v )
{
	const float a = 0.055f;
	if( v <= 0.04045f )
	{
		return v / 12.92f;
	}
	else
	{
		return pow( ( v + a ) / ( 1 + a ), 2.4f );
	}
}

inline float linear2sRGB( float v )
{
	const float a = 0.055f;
	if( v <= 0.0031308f )
	{
		return 12.92f * v;
	}
	else
	{
		return ( 1 + a ) * pow( v, 1/2.4f ) - a;
	}
}

template<class T>
inline T SmoothStep( T x )
{
	return x*x*(3-2*x);
}

inline uint8_t clampu8( int32_t val )
{
	return std::min( std::max( 0, val ), 255 );
}

template<class T>
inline T sq( T val )
{
	return val * val;
}

static inline int mul8bit( int a, int b )
{
	int t = a*b + 128;
	return ( t + ( t >> 8 ) ) >> 8;
}

#endif

template<class T>
struct Vector2
{
	Vector2() : x( 0 ), y( 0 ) {}
	Vector2( T v ) : x( v ), y( v ) {}
	Vector2( T _x, T _y ) : x( _x ), y( _y ) {}

	bool operator==( const Vector2<T>& rhs ) const { return x == rhs.x && y == rhs.y; }
	bool operator!=( const Vector2<T>& rhs ) const { return !( *this == rhs ); }

	Vector2<T>& operator+=( const Vector2<T>& rhs )
	{
		x += rhs.x;
		y += rhs.y;
		return *this;
	}
	Vector2<T>& operator-=( const Vector2<T>& rhs )
	{
		x -= rhs.x;
		y -= rhs.y;
		return *this;
	}
	Vector2<T>& operator*=( const Vector2<T>& rhs )
	{
		x *= rhs.x;
		y *= rhs.y;
		return *this;
	}

	T x, y;
};

template<class T>
Vector2<T> operator+( const Vector2<T>& lhs, const Vector2<T>& rhs )
{
	return Vector2<T>( lhs.x + rhs.x, lhs.y + rhs.y );
}

template<class T>
Vector2<T> operator-( const Vector2<T>& lhs, const Vector2<T>& rhs )
{
	return Vector2<T>( lhs.x - rhs.x, lhs.y - rhs.y );
}

template<class T>
Vector2<T> operator*( const Vector2<T>& lhs, const float& rhs )
{
	return Vector2<T>( lhs.x * rhs, lhs.y * rhs );
}

template<class T>
Vector2<T> operator/( const Vector2<T>& lhs, const T& rhs )
{
	return Vector2<T>( lhs.x / rhs, lhs.y / rhs );
}

typedef Vector2<int32_t> v2i;
typedef Vector2<float> v2f;

template<class T>
struct Vector3
{
	Vector3() : x( 0 ), y( 0 ), z( 0 ) {}
	Vector3( T v ) : x( v ), y( v ), z( v ) {}
	Vector3( T _x, T _y, T _z ) : x( _x ), y( _y ), z( _z ) {}
	template<class Y>
	Vector3( const Vector3<Y>& v ) : x( T( v.x ) ), y( T( v.y ) ), z( T( v.z ) ) {}

	T Luminance() const { return T( x * 0.3f + y * 0.59f + z * 0.11f ); }
	void Clamp()
	{
		x = std::min( T(1), std::max( T(0), x ) );
		y = std::min( T(1), std::max( T(0), y ) );
		z = std::min( T(1), std::max( T(0), z ) );
	}

	bool operator==( const Vector3<T>& rhs ) const { return x == rhs.x && y == rhs.y && z == rhs.z; }
	bool operator!=( const Vector2<T>& rhs ) const { return !( *this == rhs ); }

	T& operator[]( uint idx ) { assert( idx < 3 ); return ((T*)this)[idx]; }
	const T& operator[]( uint idx ) const { assert( idx < 3 ); return ((T*)this)[idx]; }

	Vector3<T> operator+=( const Vector3<T>& rhs )
	{
		x += rhs.x;
		y += rhs.y;
		z += rhs.z;
		return *this;
	}

	Vector3<T> operator*=( const Vector3<T>& rhs )
	{
		x *= rhs.x;
		y *= rhs.y;
		z *= rhs.z;
		return *this;
	}

	Vector3<T> operator*=( const float& rhs )
	{
		x *= rhs;
		y *= rhs;
		z *= rhs;
		return *this;
	}

	T x, y, z;
	T padding;
};

template<class T>
Vector3<T> operator+( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return Vector3<T>( lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z );
}

template<class T>
Vector3<T> operator-( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return Vector3<T>( lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z );
}

template<class T>
Vector3<T> operator*( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return Vector3<T>( lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z );
}

template<class T>
Vector3<T> operator*( const Vector3<T>& lhs, const float& rhs )
{
	return Vector3<T>( T( lhs.x * rhs ), T( lhs.y * rhs ), T( lhs.z * rhs ) );
}

template<class T>
Vector3<T> operator/( const Vector3<T>& lhs, const T& rhs )
{
	return Vector3<T>( lhs.x / rhs, lhs.y / rhs, lhs.z / rhs );
}

template<class T>
bool operator<( const Vector3<T>& lhs, const Vector3<T>& rhs )
{
	return lhs.Luminance() < rhs.Luminance();
}

typedef Vector3<int32_t> v3i;
typedef Vector3<float> v3f;
typedef Vector3<uint8_t> v3b;

static inline v3b v3f_to_v3b( const v3f& v )
{
	return v3b( uint8_t( std::min( 1.f, v.x ) * 255 ), uint8_t( std::min( 1.f, v.y ) * 255 ), uint8_t( std::min( 1.f, v.z ) * 255 ) );
}

template<class T>
Vector3<T> Mix( const Vector3<T>& v1, const Vector3<T>& v2, float amount )
{
	return v1 + ( v2 - v1 ) * amount;
}

template<>
inline v3b Mix( const v3b& v1, const v3b& v2, float amount )
{
	return v3b( v3f( v1 ) + ( v3f( v2 ) - v3f( v1 ) ) * amount );
}

template<class T>
Vector3<T> Desaturate( const Vector3<T>& v )
{
	T l = v.Luminance();
	return Vector3<T>( l, l, l );
}

template<class T>
Vector3<T> Desaturate( const Vector3<T>& v, float mul )
{
	T l = T( v.Luminance() * mul );
	return Vector3<T>( l, l, l );
}

template<class T>
Vector3<T> pow( const Vector3<T>& base, float exponent )
{
	return Vector3<T>(
		pow( base.x, exponent ),
		pow( base.y, exponent ),
		pow( base.z, exponent ) );
}

template<class T>
Vector3<T> sRGB2linear( const Vector3<T>& v )
{
	return Vector3<T>(
		sRGB2linear( v.x ),
		sRGB2linear( v.y ),
		sRGB2linear( v.z ) );
}

template<class T>
Vector3<T> linear2sRGB( const Vector3<T>& v )
{
	return Vector3<T>(
		linear2sRGB( v.x ),
		linear2sRGB( v.y ),
		linear2sRGB( v.z ) );
}

#endif

class Bitmap
{
public:
	Bitmap( const uint32_t* data, uint len, uint width, uint height, uint lines );
	Bitmap( const v2i& size );
	virtual ~Bitmap();

	const uint32_t* Data() const { return m_data; }
	const v2i& Size() const { return m_size; }
	bool Alpha() const { return m_alpha; }

	const uint32_t* NextBlock( uint& lines, bool& done );

protected:
	Bitmap( const Bitmap& src, uint lines );

	const uint32_t* m_data;
	const uint32_t* m_block;
	uint m_lines;
	uint m_linesLeft;
	uint32_t *m_padding;
	v2i m_size;
	bool m_alpha;
};

typedef std::shared_ptr<Bitmap> BitmapPtr;

#endif


//#line 1 "Common.hpp"
#ifndef __DARKRL__UTILS_HPP__
#define __DARKRL__UTILS_HPP__

#include <assert.h>
#include <stddef.h>

#ifdef DEBUG
#  include <sstream>
#  include <stdlib.h>
#  define DBGPRINT(msg) do { std::stringstream __buf; __buf << msg; printf( "%s", __buf.str().c_str() ); } while(0)
#else
#  define DBGPRINT(msg) do { ((void)0); } while(0)
#endif

float CalcMSE3( const Bitmap& bmp, const Bitmap& out );
float CalcMSE1( const Bitmap& bmp, const Bitmap& out );
void Dither( uint8_t* data );

inline int NumberOfMipLevels( const v2i& size )
{
	//return (int)floor( log2( std::max( size.x, size.y ) ) ) + 1;
	double log2n = log( std::max( size.x, size.y ) ) / log( 2. );
	return (int)floor( log2n ) + 1;
}

extern const int32_t g_table[8][4];
extern const int64_t g_table256[8][4];

extern const uint32_t g_id[4][16];

extern const uint32_t g_avg2[16];

// process {
uint64_t ProcessAlpha( const uint8_t* src );
uint64_t ProcessRGB( const uint8_t* src );

template<class T>
static size_t GetLeastError( const T* err, size_t num )
{
	size_t idx = 0;
	for( size_t i=1; i<num; i++ )
	{
		if( err[i] < err[idx] )
		{
			idx = i;
		}
	}
	return idx;
}

static uint64_t FixByteOrder( uint64_t d )
{
	return ( ( d & 0x00000000FFFFFFFF ) ) |
		   ( ( d & 0xFF00000000000000 ) >> 24 ) |
		   ( ( d & 0x000000FF00000000 ) << 24 ) |
		   ( ( d & 0x00FF000000000000 ) >> 8 ) |
		   ( ( d & 0x0000FF0000000000 ) << 8 );
}

template<class T>
static uint64_t EncodeSelectors( uint64_t d, const T terr[2][8], const uint tsel[16][8], const uint32_t* id )
{
	size_t tidx[2];
	tidx[0] = GetLeastError( terr[0], 8 );
	tidx[1] = GetLeastError( terr[1], 8 );

	d |= tidx[0] << 26;
	d |= tidx[1] << 29;
	for( int i=0; i<16; i++ )
	{
		uint64_t t = tsel[i][tidx[id[i]%2]];
		d |= ( t & 0x1 ) << ( i + 32 );
		d |= ( t & 0x2 ) << ( i + 47 );
	}

	return d;
}
// }

#endif

Bitmap::Bitmap( const uint32_t* data, uint len, uint width, uint height, uint lines )
	: m_block( nullptr )
	, m_lines( lines )
	, m_padding( 0 )
	, m_alpha( false ) //len > width * height * 3 )
{
	m_size.x = ( width / 4 ) * 4;
	m_size.y = ( height / 4 ) * 4;

	// crop right border if not multiple of 4
	if( width > m_size.x ) {
		m_padding = new uint32_t [m_size.x * m_size.y];
		for( unsigned y = 0; y < m_size.y; ++y ) {
			memcpy( &m_padding[ y * m_size.x ], &data[ y * width ], m_size.x * 4 );
		}
		data = m_padding;
	}

	m_block = m_data = (const uint32_t *)data;
	m_linesLeft = m_size.y / 4;
}

Bitmap::Bitmap( const Bitmap& src, uint lines )
	: m_lines( lines )
	, m_linesLeft( 0)
	, m_padding( 0 )
	, m_alpha( src.Alpha() )
{
}

Bitmap::~Bitmap() {
	if( m_padding ) {
		delete [] m_padding;
	}
}

const uint32_t* Bitmap::NextBlock( uint& lines, bool& done )
{
	lines = std::min( m_lines, m_linesLeft );
	auto ret = m_block;
	m_block += m_size.x * 4 * lines;
	m_linesLeft -= lines;
	done = m_linesLeft == 0;
	return ret;
}



//#line 1 "BlockBitmap.cpp"
#include <assert.h>
#include <utility>


//#line 1 "BlockBitmap.hpp"
#ifndef __BLOCKBITMAP_HPP__
#define __BLOCKBITMAP_HPP__

#include <memory>

enum class Channels
{
	RGB,
	Alpha
};

class BlockBitmap
{
public:
	BlockBitmap( const uint32_t* data, const v2i& size, Channels type );
	BlockBitmap( const BitmapPtr& bmp, Channels type );
	~BlockBitmap();

	void Dither();

	const uint8_t* Data() const { return m_data; }
	const v2i& Size() const { return m_size; }
	const Channels Type() const { return m_type; }

private:
	void Process( const uint32_t* src );

	uint8_t* m_data;
	v2i m_size;
	Channels m_type;
};

typedef std::shared_ptr<BlockBitmap> BlockBitmapPtr;

#endif

BlockBitmap::BlockBitmap( const uint32_t* data, const v2i& size, Channels type )
	: m_data( new uint8_t[std::max( 4, size.x ) * std::max( 4, size.y ) * ( type == Channels::RGB ? 4 : 4 )] )
	, m_size( size )
	, m_type( type )
{
	Process( data );
}

BlockBitmap::BlockBitmap( const BitmapPtr& bmp, Channels type )
	: m_data( new uint8_t[std::max( 4, bmp->Size().x ) * std::max( 4, bmp->Size().y ) * ( type == Channels::RGB ? 4 : 4 )] )
	, m_size( bmp->Size() )
	, m_type( type )
{
	Process( bmp->Data() );
}

void BlockBitmap::Process( const uint32_t* __restrict src )
{
	uint8_t* __restrict dst = m_data;

	int w = std::max( 4, m_size.x );
	int h = std::max( 4, m_size.y );

	assert( w % 4 == 0 && h % 4 == 0 );

	if( m_type == Channels::RGB )
	{
		for( int by=0; by<h/4; by++ )
		{
			for( int bx=0; bx<w/4; bx++ )
			{
				for( int x=0; x<4; x++ )
				{
					for( int y=0; y<4; y++ )
					{
						const uint32_t c = *src;
						src += m_size.x;
						*dst++ = ( c & 0x00FF0000 ) >> 16;
						*dst++ = ( c & 0x0000FF00 ) >> 8;
						*dst++ =   c & 0x000000FF;
						*dst++ = 0;
					}
					src -= m_size.x * 4 - 1;
				}
			}
			src += m_size.x * 3;
		}
	}
	else
	{
		for( int by=0; by<h/4; by++ )
		{
			for( int bx=0; bx<w/4; bx++ )
			{
				for( int x=0; x<4; x++ )
				{
					for( int y=0; y<4; y++ )
					{
						*dst++ = *src >> 24;
						*dst++ = *src >> 24;
						*dst++ = *src >> 24;
						*dst++ = 0;
						src += m_size.x;
					}
					src -= m_size.x * 4 - 1;
				}
			}
			src += m_size.x * 3;
		}
	}
}

BlockBitmap::~BlockBitmap()
{
	delete[] m_data;
}

void BlockBitmap::Dither()
{
	assert( m_type == Channels::RGB );

	int w = std::max( 4, m_size.x );
	int h = std::max( 4, m_size.y );

	uint8_t* ptr = m_data;

	for( int by=0; by<h/4; by++ )
	{
		for( int bx=0; bx<w/4; bx++ )
		{
			::Dither( ptr );
			ptr += 64;
		}
	}
}


//#line 1 "BlockData.cpp"
#include <assert.h>
#include <string.h>


//#line 1 "BlockData.hpp"
#ifndef __BLOCKDATA_HPP__
#define __BLOCKDATA_HPP__

#include <future>
#include <memory>
#include <mutex>
#include <vector>

class BlockData
{
public:
	BlockData( const v2i& size, bool mipmap );
	~BlockData();

	void Process( const uint8_t* src, uint32_t blocks, size_t offset, uint quality, Channels type );
	void Finish();

	uint8_t* m_data;
	v2i m_size;
	size_t m_dataOffset;
private:

	BlockBitmapPtr m_bmp;
	bool m_done;
	std::vector<std::future<void>> m_work;
	std::mutex m_lock;
	size_t m_maplen;
};

typedef std::shared_ptr<BlockData> BlockDataPtr;

#endif

//#include "ColorSpace.hpp"


//#line 1 "ProcessCommon.hpp"
#ifndef __PROCESSCOMMON_HPP__
#define __PROCESSCOMMON_HPP__

#endif

static int AdjustSizeForMipmaps( const v2i& size, int levels )
{
	int len = 0;
	v2i current = size;
	for( int i=1; i<levels; i++ )
	{
		assert( current.x != 1 || current.y != 1 );
		current.x = std::max( 1, current.x / 2 );
		current.y = std::max( 1, current.y / 2 );
		len += std::max( 4, current.x ) * std::max( 4, current.y ) / 2;
	}
	assert( current.x == 1 && current.y == 1 );
	return len;
}

BlockData::BlockData( const v2i& size, bool mipmap )
	: m_size( size )
	, m_done( false )
	, m_dataOffset( 52 )
	, m_maplen( 52 + m_size.x*m_size.y/2 )
{
	assert( m_size.x%4 == 0 && m_size.y%4 == 0 );
	if( mipmap )
	{
		const int levels = NumberOfMipLevels( size );
		m_maplen += AdjustSizeForMipmaps( size, levels );
	}
	m_data = new uint8_t[m_maplen];
}

BlockData::~BlockData()
{
	if( !m_done ) Finish();
	delete[] m_data;
}

void BlockData::Process( const uint8_t* src, uint32_t blocks, size_t offset, uint quality, Channels type )
{
	auto dst = ((uint64_t*)( m_data + m_dataOffset )) + offset;

	std::lock_guard<std::mutex> lock( m_lock );

	if( type == Channels::Alpha )
	{
		m_work.push_back( std::async( [src, dst, blocks, this]() mutable { do { *dst++ = ProcessAlpha( src ); src += 4*4; } while( --blocks ); } ) );
	}
	else
	{
		switch( quality )
		{
		case 0:
			m_work.push_back( std::async( [src, dst, blocks, this]() mutable { do { *dst++ = ProcessRGB( src ); src += 4*4*4; } while( --blocks ); } ) );
			break;
		case 1:
			//m_work.push_back( std::async( [src, dst, blocks, this]{ ProcessBlocksLab( src, dst, blocks ); } ) );
			break;
		default:
			assert( false );
			break;
		}
	}
}

void BlockData::Finish()
{
	assert( !m_done );
	assert( !m_work.empty() );
	for( auto& f : m_work )
	{
		f.wait();
	}
	m_done = true;
	m_work.clear();
	m_bmp.reset();
}


//#line 1 "Dither.cpp"
#include <algorithm>
#include <string.h>

#if 1
static const uint8_t e5[32] = {
	 0,     8,    16,    24,    33,    41,    49,    57,    66,    74,    82,    90,    99,   107,   115,   123,
   132,   140,   148,   156,   165,   173,   181,   189,   198,   206,   214,   222,   231,   239,   247,   255};
static const uint8_t e6[64] = {
	 0,     4,     8,    12,    16,    20,    24,    28,    32,    36,    40,    44,    48,    52,    56,    60,
	65,    69,    73,    77,    81,    85,    89,    93,    97,   101,   105,   109,   113,   117,   121,   125,
   130,   134,   138,   142,   146,   150,   154,   158,   162,   166,   170,   174,   178,   182,   186,   190,
   195,   199,   203,   207,   211,   215,   219,   223,   227,   231,   235,   239,   243,   247,   251,   255};
static const uint8_t qrb[256+16] = {
	 0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     8,     8,     8,
	 8,     8,     8,     8,     8,    16,    16,    16,    16,    16,    16,    16,    16,    24,    24,    24,
	24,    24,    24,    24,    24,    33,    33,    33,    33,    33,    33,    33,    33,    33,    41,    41,
	41,    41,    41,    41,    41,    41,    49,    49,    49,    49,    49,    49,    49,    49,    57,    57,
	57,    57,    57,    57,    57,    57,    66,    66,    66,    66,    66,    66,    66,    66,    74,    74,
	74,    74,    74,    74,    74,    74,    74,    82,    82,    82,    82,    82,    82,    82,    82,    90,
	90,    90,    90,    90,    90,    90,    90,    99,    99,    99,    99,    99,    99,    99,    99,   107,
   107,   107,   107,   107,   107,   107,   107,   107,   115,   115,   115,   115,   115,   115,   115,   115,
   123,   123,   123,   123,   123,   123,   123,   123,   132,   132,   132,   132,   132,   132,   132,   132,
   140,   140,   140,   140,   140,   140,   140,   140,   148,   148,   148,   148,   148,   148,   148,   148,
   148,   156,   156,   156,   156,   156,   156,   156,   156,   165,   165,   165,   165,   165,   165,   165,
   165,   173,   173,   173,   173,   173,   173,   173,   173,   181,   181,   181,   181,   181,   181,   181,
   181,   181,   189,   189,   189,   189,   189,   189,   189,   189,   198,   198,   198,   198,   198,   198,
   198,   198,   206,   206,   206,   206,   206,   206,   206,   206,   214,   214,   214,   214,   214,   214,
   214,   214,   222,   222,   222,   222,   222,   222,   222,   222,   222,   231,   231,   231,   231,   231,
   231,   231,   231,   239,   239,   239,   239,   239,   239,   239,   239,   247,   247,   247,   247,   247,
   247,   247,   247,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255};
static const uint8_t qg[256+16] = {
	 0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     4,     4,     4,     4,     8,
	 8,     8,     8,    12,    12,    12,    12,    16,    16,    16,    16,    20,    20,    20,    20,    24,
	24,    24,    24,    28,    28,    28,    28,    32,    32,    32,    32,    36,    36,    36,    36,    40,
	40,    40,    40,    44,    44,    44,    44,    48,    48,    48,    48,    52,    52,    52,    52,    56,
	56,    56,    56,    60,    60,    60,    60,    65,    65,    65,    65,    69,    69,    69,    69,    73,
	73,    73,    73,    77,    77,    77,    77,    81,    81,    81,    81,    85,    85,    85,    85,    85,
	89,    89,    89,    89,    93,    93,    93,    93,    97,    97,    97,    97,   101,   101,   101,   101,
   105,   105,   105,   105,   109,   109,   109,   109,   113,   113,   113,   113,   117,   117,   117,   117,
   121,   121,   121,   121,   125,   125,   125,   125,   130,   130,   130,   130,   134,   134,   134,   134,
   138,   138,   138,   138,   142,   142,   142,   142,   146,   146,   146,   146,   150,   150,   150,   150,
   154,   154,   154,   154,   158,   158,   158,   158,   162,   162,   162,   162,   166,   166,   166,   166,
   170,   170,   170,   170,   170,   174,   174,   174,   174,   178,   178,   178,   178,   182,   182,   182,
   182,   186,   186,   186,   186,   190,   190,   190,   190,   195,   195,   195,   195,   199,   199,   199,
   199,   203,   203,   203,   203,   207,   207,   207,   207,   211,   211,   211,   211,   215,   215,   215,
   215,   219,   219,   219,   219,   223,   223,   223,   223,   227,   227,   227,   227,   231,   231,   231,
   231,   235,   235,   235,   235,   239,   239,   239,   239,   243,   243,   243,   243,   247,   247,   247,
   247,   251,   251,   251,   251,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255,   255};
#else
static uint8_t e5[32];
static uint8_t e6[64];
static uint8_t qrb[256+16];
static uint8_t qg[256+16];

void InitDither()
{
	for( int i=0; i<32; i++ )
	{
		e5[i] = (i<<3) | (i>>2);
	}
	for( int i=0; i<64; i++ )
	{
		e6[i] = (i<<2) | (i>>4);
	}
	for( int i=0; i<256+16; i++ )
	{
		int v = std::min( std::max( 0, i-8 ), 255 );
		qrb[i] = e5[mul8bit( v, 31 )];
		qg[i] = e6[mul8bit( v, 63 )];
	}
}
#endif

void Dither( uint8_t* data )
{
	int err[8];
	int* ep1 = err;
	int* ep2 = err+4;

	for( int ch=0; ch<3; ch++ )
	{
		uint8_t* ptr = data + ch;
		const uint8_t* quant = (ch == 1) ? qg + 8 : qrb + 8;
		memset( err, 0, sizeof( err ) );

		for( int y=0; y<4; y++ )
		{
			uint8_t tmp;
			tmp = quant[ptr[0] + ( ( 3 * ep2[1] + 5 * ep2[0] ) >> 4 )];
			ep1[0] = ptr[0] - tmp;
			ptr[0] = tmp;
			tmp = quant[ptr[4] + ( ( 7 * ep1[0] + 3 * ep2[2] + 5 * ep2[1] + ep2[0] ) >> 4 )];
			ep1[1] = ptr[4] - tmp;
			ptr[4] = tmp;
			tmp = quant[ptr[8] + ( ( 7 * ep1[1] + 3 * ep2[3] + 5 * ep2[2] + ep2[1] ) >> 4 )];
			ep1[2] = ptr[8] - tmp;
			ptr[8] = tmp;
			tmp = quant[ptr[12] + ( ( 7 * ep1[2] + 5 * ep2[3] + ep2[2] ) >> 4 )];
			ep1[3] = ptr[12] - tmp;
			ptr[12] = tmp;
			ptr += 16;
			std::swap( ep1, ep2 );
		}
	}
}


//#line 1 "MSE.cpp"
float CalcMSE3( const Bitmap& bmp, const Bitmap& out )
{
	float err = 0;

	const uint32_t* p1 = bmp.Data();
	const uint32_t* p2 = out.Data();
	size_t cnt = bmp.Size().x * bmp.Size().y;

	for( size_t i=0; i<cnt; i++ )
	{
		uint32_t c1 = *p1++;
		uint32_t c2 = *p2++;

		err += sq( ( c1 & 0x000000FF ) - ( c2 & 0x000000FF ) );
		err += sq( ( ( c1 & 0x0000FF00 ) >> 8 ) - ( ( c2 & 0x0000FF00 ) >> 8 ) );
		err += sq( ( ( c1 & 0x00FF0000 ) >> 16 ) - ( ( c2 & 0x00FF0000 ) >> 16 ) );
	}

	err /= cnt * 3;

	return err;
}

float CalcMSE1( const Bitmap& bmp, const Bitmap& out )
{
	float err = 0;

	const uint32_t* p1 = bmp.Data();
	const uint32_t* p2 = out.Data();
	size_t cnt = bmp.Size().x * bmp.Size().y;

	for( size_t i=0; i<cnt; i++ )
	{
		uint32_t c1 = *p1++;
		uint32_t c2 = *p2++;

		err += sq( ( c1 >> 24 ) - ( c2 & 0xFF ) );
	}

	err /= cnt;

	return err;
}


//#line 1 "ProcessAlpha.cpp"
static uint Average1( const uint8_t* data )
{
	uint32_t a = 0;
	for( int i=0; i<8; i++ )
	{
		a += *data++;
	}
	return a / 8;
}

static void CalcErrorBlock( const uint8_t* data, uint err[2] )
{
	for( int i=0; i<8; i++ )
	{
		uint v = *data++;
		err[0] += v;
		err[1] += v*v;
	}
}

static uint CalcError( const uint block[2], uint average )
{
	uint err = block[1];
	err -= block[0] * 2 * average;
	err += 8 * sq( average );
	return err;
}

static void ProcessAverages( uint* a )
{
	for( int i=0; i<2; i++ )
	{
		int c1 = mul8bit( a[i*2+1], 31 );
		int c2 = mul8bit( a[i*2], 31 );

		int diff = c2 - c1;
		if( diff > 3 ) diff = 3;
		else if( diff < -4 ) diff = -4;

		int co = c1 + diff;

		a[5+i*2] = ( c1 << 3 ) | ( c1 >> 2 );
		a[4+i*2] = ( co << 3 ) | ( co >> 2 );
	}
	for( int i=0; i<4; i++ )
	{
		a[i] = g_avg2[mul8bit( a[i], 15 )];
	}
}

static void EncodeAverages( uint64_t& _d, const uint* a, size_t idx )
{
	auto d = _d;
	d |= ( idx << 24 );
	size_t base = idx << 1;

	uint v;
	if( ( idx & 0x2 ) == 0 )
	{
		v = ( a[base+0] >> 4 ) | ( a[base+1] & 0xF0 );
	}
	else
	{
		v = a[base+1] & 0xF8;
		int32_t c = ( ( a[base+0] & 0xF8 ) - ( a[base+1] & 0xF8 ) ) >> 3;
		v |= c & ~0xFFFFFFF8;
	}
	d |= v | ( v << 8 ) | ( v << 16 );
	_d = d;
}

uint64_t ProcessAlpha( const uint8_t* src )
{
	uint64_t d = 0;

	{
		bool solid = true;
		const uint8_t* ptr = src + 1;
		for( int i=1; i<16; i++ )
		{
			if( *src != *ptr++ )
			{
				solid = false;
				break;
			}
		}
		if( solid )
		{
			uint c = *src & 0xF8;
			d |= 0x02000000 | ( c << 16 ) | ( c << 8 ) | c;
			return d;
		}
	}

	uint8_t b23[2][8];
	const uint8_t* b[4] = { src+8, src, b23[0], b23[1] };

	for( int i=0; i<4; i++ )
	{
		*(b23[1]+i*2) = *(src+i*4);
		*(b23[0]+i*2) = *(src+i*4+3);
	}

	uint a[8];
	for( int i=0; i<4; i++ )
	{
		a[i] = Average1( b[i] );
	}
	ProcessAverages( a );

	uint err[4] = {};
	for( int i=0; i<4; i++ )
	{
		uint errblock[2] = {};
		CalcErrorBlock( b[i], errblock );
		err[i/2] += CalcError( errblock, a[i] );
		err[2+i/2] += CalcError( errblock, a[i+4] );
	}
	size_t idx = GetLeastError( err, 4 );

	EncodeAverages( d, a, idx );

	uint terr[2][8] = {};
	uint tsel[16][8];
	auto id = g_id[idx];
	const uint8_t* data = src;
	for( size_t i=0; i<16; i++ )
	{
		uint* sel = tsel[i];
		uint bid = id[i];
		uint* ter = terr[bid%2];

		uint8_t c = *data++;
		int32_t pix = a[bid] - c;

		for( int t=0; t<8; t++ )
		{
			const int32_t* tab = g_table[t];
			uint idx = 0;
			uint err = sq( tab[0] + pix );
			for( int j=1; j<4; j++ )
			{
				uint local = sq( tab[j] + pix );
				if( local < err )
				{
					err = local;
					idx = j;
				}
			}
			*sel++ = idx;
			*ter++ += err;
		}
	}

	return FixByteOrder( EncodeSelectors( d, terr, tsel, id ) );
}

#define CalcErrorBlock CalcErrorBlock2

//#line 1 "ProcessRGB.cpp"
#include <string.h>

static v3i Average( const uint8_t* data )
{
	uint32_t r = 0, g = 0, b = 0;
	for( int i=0; i<8; i++ )
	{
		b += *data++;
		g += *data++;
		r += *data++;
		data++;
	}
	return v3i( r / 8, g / 8, b / 8 );
}

static void CalcErrorBlock( const uint8_t* data, uint err[4] )
{
	for( int i=0; i<8; i++ )
	{
		uint d = *data++;
		err[0] += d;
		err[3] += d*d;
		d = *data++;
		err[1] += d;
		err[3] += d*d;
		d = *data++;
		err[2] += d;
		err[3] += d*d;
		data++;
	}
}

static uint CalcError( const uint block[4], const v3i& average )
{
	uint err = block[3];
	err -= block[0] * 2 * average.z;
	err -= block[1] * 2 * average.y;
	err -= block[2] * 2 * average.x;
	err += 8 * ( sq( average.x ) + sq( average.y ) + sq( average.z ) );
	return err;
}

static void ProcessAverages( v3i* a )
{
	for( int i=0; i<2; i++ )
	{
		for( int j=0; j<3; j++ )
		{
			int32_t c1 = mul8bit( a[i*2+1][j], 31 );
			int32_t c2 = mul8bit( a[i*2][j], 31 );

			int32_t diff = c2 - c1;
			if( diff > 3 ) diff = 3;
			else if( diff < -4 ) diff = -4;

			int32_t co = c1 + diff;

			a[5+i*2][j] = ( c1 << 3 ) | ( c1 >> 2 );
			a[4+i*2][j] = ( co << 3 ) | ( co >> 2 );
		}
	}
	for( int i=0; i<4; i++ )
	{
		a[i].x = g_avg2[mul8bit( a[i].x, 15 )];
		a[i].y = g_avg2[mul8bit( a[i].y, 15 )];
		a[i].z = g_avg2[mul8bit( a[i].z, 15 )];
	}
}

static void EncodeAverages( uint64_t& _d, const v3i* a, size_t idx )
{
	auto d = _d;
	d |= ( idx << 24 );
	size_t base = idx << 1;

	if( ( idx & 0x2 ) == 0 )
	{
		for( int i=0; i<3; i++ )
		{
			d |= uint64_t( a[base+0][i] >> 4 ) << ( i*8 );
			d |= uint64_t( a[base+1][i] >> 4 ) << ( i*8 + 4 );
		}
	}
	else
	{
		for( int i=0; i<3; i++ )
		{
			d |= uint64_t( a[base+1][i] & 0xF8 ) << ( i*8 );
			int32_t c = ( ( a[base+0][i] & 0xF8 ) - ( a[base+1][i] & 0xF8 ) ) >> 3;
			c &= ~0xFFFFFFF8;
			d |= ((uint64_t)c) << ( i*8 );
		}
	}
	_d = d;
}

static uint64_t CheckSolid( const uint8_t* src )
{
	const uint8_t* ptr = src + 4;
	for( int i=1; i<16; i++ )
	{
		if( memcmp( src, ptr, 4 ) != 0 )
		{
			return 0;
		}
		ptr += 4;
	}
	return 0x02000000 |
		( uint( src[0] & 0xF8 ) << 16 ) |
		( uint( src[1] & 0xF8 ) << 8 ) |
		( uint( src[2] & 0xF8 ) );
}

static void PrepareBuffers( uint8_t b23[2][32], const uint8_t* src )
{
	for( int i=0; i<4; i++ )
	{
		memcpy( b23[1]+i*8, src+i*16, 8 );
		memcpy( b23[0]+i*8, src+i*16+8, 8 );
	}
}

static void PrepareAverages( v3i a[8], const uint8_t* b[4], uint err[4] )
{
	for( int i=0; i<4; i++ )
	{
		a[i] = Average( b[i] );
	}
	ProcessAverages( a );

	for( int i=0; i<4; i++ )
	{
		uint errblock[4] = {};
		CalcErrorBlock( b[i], errblock );
		err[i/2] += CalcError( errblock, a[i] );
		err[2+i/2] += CalcError( errblock, a[i+4] );
	}
}

static void FindBestFit( uint64_t terr[2][8], uint tsel[16][8], v3i a[8], const uint32_t* id, const uint8_t* data )
{
	for( size_t i=0; i<16; i++ )
	{
		uint* sel = tsel[i];
		uint bid = id[i];
		uint64_t* ter = terr[bid%2];

		uint8_t b = *data++;
		uint8_t g = *data++;
		uint8_t r = *data++;
		data++;

		int dr = a[bid].x - r;
		int dg = a[bid].y - g;
		int db = a[bid].z - b;

		int pix = dr * 77 + dg * 151 + db * 28;

		for( int t=0; t<8; t++ )
		{
			const int64_t* tab = g_table256[t];
			uint idx = 0;
			uint64_t err = sq( tab[0] + pix );
			for( int j=1; j<4; j++ )
			{
				uint64_t local = sq( tab[j] + pix );
				if( local < err )
				{
					err = local;
					idx = j;
				}
			}
			*sel++ = idx;
			*ter++ += err;
		}
	}
}

uint64_t ProcessRGB( const uint8_t* src )
{
	uint64_t d = CheckSolid( src );
	if( d != 0 ) return d;

	uint8_t b23[2][32];
	const uint8_t* b[4] = { src+32, src, b23[0], b23[1] };
	PrepareBuffers( b23, src );

	v3i a[8];
	uint err[4] = {};
	PrepareAverages( a, b, err );
	size_t idx = GetLeastError( err, 4 );
	EncodeAverages( d, a, idx );

	uint64_t terr[2][8] = {};
	uint tsel[16][8];
	auto id = g_id[idx];
	FindBestFit( terr, tsel, a, id, src );

	return FixByteOrder( EncodeSelectors( d, terr, tsel, id ) );
}



//#line 1 "Tables.cpp"
const int32_t g_table[8][4] = {
	{  2,  8,   -2,   -8 },
	{  5, 17,   -5,  -17 },
	{  9, 29,   -9,  -29 },
	{ 13, 42,  -13,  -42 },
	{ 18, 60,  -18,  -60 },
	{ 24, 80,  -24,  -80 },
	{ 33, 106, -33, -106 },
	{ 47, 183, -47, -183 }
};

const int64_t g_table256[8][4] = {
	{  2*256,  8*256,   -2*256,   -8*256 },
	{  5*256, 17*256,   -5*256,  -17*256 },
	{  9*256, 29*256,   -9*256,  -29*256 },
	{ 13*256, 42*256,  -13*256,  -42*256 },
	{ 18*256, 60*256,  -18*256,  -60*256 },
	{ 24*256, 80*256,  -24*256,  -80*256 },
	{ 33*256, 106*256, -33*256, -106*256 },
	{ 47*256, 183*256, -47*256, -183*256 }
};

const uint32_t g_id[4][16] = {
	{ 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2, 3, 3, 2, 2 },
	{ 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4 },
	{ 7, 7, 6, 6, 7, 7, 6, 6, 7, 7, 6, 6, 7, 7, 6, 6 }
};

extern const uint32_t g_avg2[16] = {
	0x00,
	0x11,
	0x22,
	0x33,
	0x44,
	0x55,
	0x66,
	0x77,
	0x88,
	0x99,
	0xAA,
	0xBB,
	0xCC,
	0xDD,
	0xEE,
	0xFF
};


//#line 1 "unifont.hpp"
// an embeddable/compact console font that supports most european/greek/cyrillic unicode codepoints. aimed to gamedev.
// - rlyeh, zlib/libpng licensed.

// using:
// - [PressStart2P.ttf v2.14](http://www.zone38.net/font/) by Cody "CodeMan38" Boisclair (SIL Open Font License).
// - [UTF-8 dfa decoder](http://bjoern.hoehrmann.de/utf-8/decoder/dfa/) by Bjoern Hoehrmann (MIT license).
// - Gradient retro style mask taken from [DoDonPachi arcade](http://en.wikipedia.org/wiki/DoDonPachi).

////#pragma once
#include <stdint.h>
#include <vector>
#include <map>

#define UNIFONT_VERSION "v1.0.0 (C++0x version)"

template<typename color>
struct unifont {

	struct dim {
		uint32_t w, h;
	};

	enum {
		NORMAL = 0,
		INVERT = 1,
		SHADOW = 2,
		RETRO  = 4,
	};

	struct framebuffer {
		color *pixel;
		uint32_t width;
		color (*make_rgba)( uint8_t r, uint8_t g, uint8_t b, uint8_t a );
	} fb;

	std::vector<color> gradient;   // precomputed gradient colors [8][8]
	std::vector<color> flat;       // precomputed flat colors [8][8]
	color Z, W, P;                 // precomputed base colors

	unifont( color *pixel, uint32_t width, color (*make_rgba)( uint8_t r, uint8_t g, uint8_t b, uint8_t a )  )
		: PressStart2P_ttf(get_font())
	{
		fb.pixel = pixel;
		fb.width = width;
		fb.make_rgba = make_rgba;

		Z = (*fb.make_rgba)(   0,   0,   0, 255 );
		W = (*fb.make_rgba)( 255, 255, 255, 255 );
		P = (*fb.make_rgba)( 255,   0, 255, 255 );

		color A = (*fb.make_rgba)( 255, 165,  82, 255 );
		color B = (*fb.make_rgba)( 255, 115,  33, 255 );
		color C = (*fb.make_rgba)( 247,  66,  16, 255 );
		color D = (*fb.make_rgba)( 206,  24,   8, 255 );
		color E = (*fb.make_rgba)( 156,   0,   0, 255 );
		color F = (*fb.make_rgba)( 115,   0,   0, 255 );

		flat = std::vector<color>( 64, W ); // default white (flat) gradient
		// do don pachi gradient style
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C);
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C);
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D);
		gradient.push_back(A),gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D);
		gradient.push_back(A),gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E);
		gradient.push_back(B),gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E),gradient.push_back(E);
		gradient.push_back(B),gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E),gradient.push_back(E),gradient.push_back(F);
		gradient.push_back(C),gradient.push_back(C),gradient.push_back(D),gradient.push_back(D),gradient.push_back(E),gradient.push_back(E),gradient.push_back(F),gradient.push_back(F);
	}

	dim render_line( int x0, int y0, int x1, int y1, const color &c ) const {
		if( x1 == x0 ) {
			for( ; y0 < y1 ; ++y0 ) {
				fb.pixel[ x0 + y0 * fb.width ] = c;
			}
		} else {
			float deltax = x1 - x0;
			float deltay = y1 - y0;
			float error = 0.0f;
			float deltaerr = abs(deltay / deltax);
			float y = y0;
			for( float x = x0; x < x1; ++x) {
				fb.pixel[ (uint32_t)(x + y * fb.width) ] = c;
				error += deltaerr;
				while( error >= 0.5f ) {
					fb.pixel[ (uint32_t)(x + y * fb.width) ] = c;
					y += y1 - y0 > 0 ? 1 : -1;
					error -= 1.0f;
				}
			}
		}
		return dim { unsigned(x1 - x0), unsigned(y1 - y0) };
	}

	dim render_string( int ox, int oy, int mode, const std::vector<uint64_t> &glyphs, const color *mask8x8 = 0 ) const {
		if( !mask8x8 ) mask8x8 = (mode & 4 ? &gradient[0] : &flat[0]);

		auto *ptr = &fb.pixel[ ox + oy * fb.width ];
		for( const auto &rune : glyphs ) {
			for( unsigned y = 0; y < 8; ++y ) {
				const unsigned y64 = ( 7 - y ) * 8;
				if( mode & SHADOW ) {
				ptr += fb.width + 1;
				ptr[0] = rune & (0x80ULL << y64) ? Z : ptr[0];
				ptr[1] = rune & (0x40ULL << y64) ? Z : ptr[1];
				ptr[2] = rune & (0x20ULL << y64) ? Z : ptr[2];
				ptr[3] = rune & (0x10ULL << y64) ? Z : ptr[3];
				ptr[4] = rune & (0x08ULL << y64) ? Z : ptr[4];
				ptr[5] = rune & (0x04ULL << y64) ? Z : ptr[5];
				ptr[6] = rune & (0x02ULL << y64) ? Z : ptr[6];
				ptr[7] = rune & (0x01ULL << y64) ? Z : ptr[7];
				ptr -= fb.width + 1;
				}
				if( mode & INVERT ) {
				ptr[0] = rune & (0x80ULL << y64) ? ptr[0] : mask8x8[0+y*8];
				ptr[1] = rune & (0x40ULL << y64) ? ptr[1] : mask8x8[1+y*8];
				ptr[2] = rune & (0x20ULL << y64) ? ptr[2] : mask8x8[2+y*8];
				ptr[3] = rune & (0x10ULL << y64) ? ptr[3] : mask8x8[3+y*8];
				ptr[4] = rune & (0x08ULL << y64) ? ptr[4] : mask8x8[4+y*8];
				ptr[5] = rune & (0x04ULL << y64) ? ptr[5] : mask8x8[5+y*8];
				ptr[6] = rune & (0x02ULL << y64) ? ptr[6] : mask8x8[6+y*8];
				ptr[7] = rune & (0x01ULL << y64) ? ptr[7] : mask8x8[7+y*8];
				} else { // NORMAL
				ptr[0] = rune & (0x80ULL << y64) ? mask8x8[0+y*8] : ptr[0];
				ptr[1] = rune & (0x40ULL << y64) ? mask8x8[1+y*8] : ptr[1];
				ptr[2] = rune & (0x20ULL << y64) ? mask8x8[2+y*8] : ptr[2];
				ptr[3] = rune & (0x10ULL << y64) ? mask8x8[3+y*8] : ptr[3];
				ptr[4] = rune & (0x08ULL << y64) ? mask8x8[4+y*8] : ptr[4];
				ptr[5] = rune & (0x04ULL << y64) ? mask8x8[5+y*8] : ptr[5];
				ptr[6] = rune & (0x02ULL << y64) ? mask8x8[6+y*8] : ptr[6];
				ptr[7] = rune & (0x01ULL << y64) ? mask8x8[7+y*8] : ptr[7];
				}
				ptr += fb.width;
			}
			ptr -= fb.width * 8;
			ptr += 8;
		}

		dim d; d.w = unsigned(glyphs.size() * 8), d.h = unsigned((!glyphs.empty()) * 8);
		return d;
	}

	dim render_string( int ox, int oy, int mode, const std::vector<int32_t> &codepoints, const color *mask8x8 = 0 ) const {
		std::vector<uint64_t> glyphs;
		for( auto &cp : codepoints ) {
			auto found = PressStart2P_ttf.find(cp);
			if( found != PressStart2P_ttf.end() ) {
				glyphs.push_back( found->second );
			} else {
				glyphs.push_back( 0 );
			}
		}
		return render_string( ox, oy, mode, glyphs, mask8x8 );
	}

	dim render_string( int ox, int oy, int mode, const char *utf8, const color *mask8x8 = 0 ) const {
		auto decode = []( std::vector<int32_t> &codepoints, const char *utf8 ) -> const char * {
			uint32_t result, state = 0;
			while( *utf8 ) {
				// Decode utf8 codepoint a byte at a time. Uses explictly user provided state variable,
				// that should be initialized to zero before first use. Places the result to codep.
				// Returns UTF8_ACCEPT when a full codepoint achieved
				enum { UTF8_ACCEPT = 0, UTF8_REJECT = 1 };
				auto decode_state = []( uint32_t *state, uint32_t *codep, uint32_t byte ) -> uint32_t {
					static const uint8_t utf8d[] = {
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f
					  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f
					  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f
					  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf
					  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df
					  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef
					  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff
					  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0
					  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2
					  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4
					  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6
					  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8
					};
					uint32_t type = utf8d[byte];
					*codep = (*state != UTF8_ACCEPT) ? (byte & 0x3fu) | (*codep << 6) : (0xff >> type) & (byte);
					*state = utf8d[256 + *state*16 + type];
					return *state;
				};
				uint32_t res = decode_state( &state, &result, (unsigned char)(*utf8++) );
				/**/ if(res == UTF8_ACCEPT) return codepoints.push_back( result ), utf8;
				else if(res == UTF8_REJECT) break;
			}
			return codepoints.push_back( 0xfffd ), utf8;
		};
		std::vector<int32_t> codepoints;
		while( *utf8 ) {
			utf8 = decode( codepoints, utf8 );
		}
		return render_string( ox, oy, mode, codepoints, mask8x8 );
	}

	dim render_glyphs( int ox, int oy, int mode, const color *mask8x8 = 0 ) const {
		uint32_t h = (PressStart2P_ttf.size() / 16) + 1;
		for( uint32_t y = 0; y < h; y++ ) {
			render_line( ox, oy + y*9, ox + 16*9, oy + y*9, P );
			for( uint32_t x = 0; x < 16; x++ ) {
				render_line( ox + x*9, oy, ox + x*9, oy + h*9, P );
				auto it = PressStart2P_ttf.cbegin();
				std::advance( it, x + y * 16 );
				render_string( 1 + ox + x*9, 1 + oy + y*9, mode, std::vector<int32_t> { it->first }, mask8x8 );
			}
		}
		dim d; d. w =16*9, d.h = h*9; return d;
	}

	dim render_string( int ox, int oy, int mode, const std::vector<uint64_t> &glyphs, const color &c ) {
		return render_string( ox, oy, mode, glyphs, &std::vector<color>( 64, c )[0] );
	}
	dim render_string( int ox, int oy, int mode, const std::vector<int32_t> &codepoints, const color &c ){
		return render_string( ox, oy, mode, codepoints, &std::vector<color>( 64, c )[0] );
	}
	dim render_string( int ox, int oy, int mode, const char *utf8, const color &c ) {
		return render_string( ox, oy, mode, utf8, &std::vector<color>( 64, c )[0] );
	}
	dim render_glyphs( int ox, int oy, int mode, const color &c ) {
		return render_glyphs( ox, oy, mode, &std::vector<color>( 64, c )[0] );
	}

	/* generated by ttf2mono.cc - https://github.com/r-lyeh */
	const std::map<int,uint64_t> &PressStart2P_ttf;
	static const std::map<int,uint64_t> &get_font() {
	static std::map<int,uint64_t> map;
	if( !map.empty() ) return map; else return
	map[0x0020]=0x0000000000000000,map[0x0021]=0x3838383030003000,map[0x0022]=0x6c6c6c0000000000,
	map[0x0023]=0x6cfe6c6c6cfe6c00,map[0x0024]=0x107cd07c16fc1000,map[0x0025]=0x62a4c810264a8c00,
	map[0x0026]=0x70d8d870dacc7e00,map[0x0027]=0x3030300000000000,map[0x0028]=0x0c18303030180c00,
	map[0x0029]=0x6030181818306000,map[0x002a]=0x006c38fe386c0000,map[0x002b]=0x0018187e18180000,
	map[0x002c]=0x0000000000303060,map[0x002d]=0x0000007e00000000,map[0x002e]=0x0000000000303000,
	map[0x002f]=0x0204081020408000,map[0x0030]=0x384cc6c6c6643800,map[0x0031]=0x1838181818187e00,
	map[0x0032]=0x7cc60e3c78e0fe00,map[0x0033]=0x7e0c183c06c67c00,map[0x0034]=0x1c3c6cccfe0c0c00,
	map[0x0035]=0xfcc0fc0606c67c00,map[0x0036]=0x3c60c0fcc6c67c00,map[0x0037]=0xfec60c1830303000,
	map[0x0038]=0x78c4e4789e867c00,map[0x0039]=0x7cc6c67e060c7800,map[0x003a]=0x0030300030300000,
	map[0x003b]=0x0030300030306000,map[0x003c]=0x0c18306030180c00,map[0x003d]=0x0000fe00fe000000,
	map[0x003e]=0x6030180c18306000,map[0x003f]=0x7cfec60c38003800,map[0x0040]=0x7c82baaabe807c00,
	map[0x0041]=0x386cc6c6fec6c600,map[0x0042]=0xfcc6c6fcc6c6fc00,map[0x0043]=0x3c66c0c0c0663c00,
	map[0x0044]=0xf8ccc6c6c6ccf800,map[0x0045]=0xfec0c0fcc0c0fe00,map[0x0046]=0xfec0c0fcc0c0c000,
	map[0x0047]=0x3e60c0cec6663e00,map[0x0048]=0xc6c6c6fec6c6c600,map[0x0049]=0x7e18181818187e00,
	map[0x004a]=0x0606060606c67c00,map[0x004b]=0xc6ccd8f0f8dcce00,map[0x004c]=0x6060606060607e00,
	map[0x004d]=0xc6eefefed6c6c600,map[0x004e]=0xc6e6f6fedecec600,map[0x004f]=0x7cc6c6c6c6c67c00,
	map[0x0050]=0xfcc6c6c6fcc0c000,map[0x0051]=0x7cc6c6c6decc7a00,map[0x0052]=0xfcc6c6cef8dcce00,
	map[0x0053]=0x78ccc07c06c67c00,map[0x0054]=0x7e18181818181800,map[0x0055]=0xc6c6c6c6c6c67c00,
	map[0x0056]=0xc6c6c6ee7c381000,map[0x0057]=0xc6c6d6fefeeec600,map[0x0058]=0xc6ee7c387ceec600,
	map[0x0059]=0x6666663c18181800,map[0x005a]=0xfe0e1c3870e0fe00,map[0x005b]=0x3c30303030303c00,
	map[0x005c]=0x8040201008040200,map[0x005d]=0x7818181818187800,map[0x005e]=0x386c000000000000,
	map[0x005f]=0x00000000000000fe,map[0x0060]=0x1008000000000000,map[0x0061]=0x00007c067ec67e00,
	map[0x0062]=0xc0c0fcc6c6c67c00,map[0x0063]=0x00007ec0c0c07e00,map[0x0064]=0x06067ec6c6c67e00,
	map[0x0065]=0x00007cc6fec07c00,map[0x0066]=0x0e187e1818181800,map[0x0067]=0x00007ec6c67e067c,
	map[0x0068]=0xc0c0fcc6c6c6c600,map[0x0069]=0x1800381818187e00,map[0x006a]=0x0c001c0c0c0c0c78,
	map[0x006b]=0xc0c0cefcf8dcce00,map[0x006c]=0x3818181818187e00,map[0x006d]=0x0000fcb6b6b6b600,
	map[0x006e]=0x0000fcc6c6c6c600,map[0x006f]=0x00007cc6c6c67c00,map[0x0070]=0x0000fcc6c6fcc0c0,
	map[0x0071]=0x00007ec6c67e0606,map[0x0072]=0x00006e7060606000,map[0x0073]=0x00007cc07c06fc00,
	map[0x0074]=0x18187e1818181800,map[0x0075]=0x0000c6c6c6c67e00,map[0x0076]=0x00006666663c1800,
	map[0x0077]=0x0000b6b6b6b67e00,map[0x0078]=0x0000c6fe38fec600,map[0x0079]=0x0000c6c6c67e067c,
	map[0x007a]=0x0000fe1c3870fe00,map[0x007b]=0x0c18183018180c00,map[0x007c]=0x1818181818181800,
	map[0x007d]=0x6030301830306000,map[0x007e]=0x000070ba1c000000,map[0x007f]=0x00000000006c6c00,
	map[0x00a0]=0x0000000000000000,map[0x00a1]=0x1800181838383800,map[0x00a2]=0x107cd6d0d67c1000,
	map[0x00a3]=0x3c6660fc6060fe00,map[0x00a4]=0x005a2424245a0000,map[0x00a5]=0x66663c7e187e1800,
	map[0x00a6]=0x1818180018181800,map[0x00a7]=0x3c6678241e663c00,map[0x00a8]=0x6c00000000000000,
	map[0x00a9]=0x3c4299a1a199423c,map[0x00aa]=0x783c6c3c00000000,map[0x00ab]=0x00366cd86c360000,
	map[0x00ac]=0x00007e0606000000,map[0x00ad]=0x0000007e00000000,map[0x00ae]=0x3c42b9a5b9a5423c,
	map[0x00af]=0x7c00000000000000,map[0x00b0]=0x1028100000000000,map[0x00b1]=0x18187e1818007e00,
	map[0x00b2]=0x380c183c00000000,map[0x00b3]=0x3c180c3800000000,map[0x00b4]=0x0810000000000000,
	map[0x00b5]=0x0000ccccccccf6c0,map[0x00b6]=0x3e6a4a6a3e0a0a00,map[0x00b7]=0x0000003030000000,
	map[0x00b8]=0x0000000000000830,map[0x00b9]=0x1838183c00000000,map[0x00ba]=0x386c6c3800000000,
	map[0x00bb]=0x00d86c366cd80000,map[0x00bc]=0x42c44852264e8200,map[0x00bd]=0x42c4485622448e00,
	map[0x00be]=0xe24428d2264e8200,map[0x00bf]=0x38003860c6fe7c00,map[0x00c0]=0x2010386cc6fec600,
	map[0x00c1]=0x0810386cc6fec600,map[0x00c2]=0x386c386cc6fec600,map[0x00c3]=0x3458386cc6fec600,
	map[0x00c4]=0x6c00386cc6fec600,map[0x00c5]=0x1028386cc6fec600,map[0x00c6]=0x3e78d8def8d8de00,
	map[0x00c7]=0x3c66c0c0663c0830,map[0x00c8]=0x2010fec0fcc0fe00,map[0x00c9]=0x0810fec0fcc0fe00,
	map[0x00ca]=0x386cfec0fcc0fe00,map[0x00cb]=0x6c00fec0fcc0fe00,map[0x00cc]=0x10087e1818187e00,
	map[0x00cd]=0x08107e1818187e00,map[0x00ce]=0x183c7e1818187e00,map[0x00cf]=0x66007e1818187e00,
	map[0x00d0]=0x786c66f6666c7800,map[0x00d1]=0x3458e6f6fedece00,map[0x00d2]=0x20107cc6c6c67c00,
	map[0x00d3]=0x08107cc6c6c67c00,map[0x00d4]=0x386c7cc6c6c67c00,map[0x00d5]=0x34587cc6c6c67c00,
	map[0x00d6]=0x6c007cc6c6c67c00,map[0x00d7]=0x0044281028440000,map[0x00d8]=0x7cc6ced6e6c67c00,
	map[0x00d9]=0x2010c6c6c6c67c00,map[0x00da]=0x0810c6c6c6c67c00,map[0x00db]=0x386c00c6c6c67c00,
	map[0x00dc]=0x6c00c6c6c6c67c00,map[0x00dd]=0x081066663c181800,map[0x00de]=0xc0fcc6c6c6fcc000,
	map[0x00df]=0x3c66666c66766c00,map[0x00e0]=0x20107c067ec67e00,map[0x00e1]=0x08107c067ec67e00,
	map[0x00e2]=0x386c7c067ec67e00,map[0x00e3]=0x34587c067ec67e00,map[0x00e4]=0x6c007c067ec67e00,
	map[0x00e5]=0x10287c067ec67e00,map[0x00e6]=0x00007c167ed07c00,map[0x00e7]=0x00007ec0c07e0830,
	map[0x00e8]=0x20107cc6fec07c00,map[0x00e9]=0x08107cc6fec07c00,map[0x00ea]=0x386c7cc6fec07c00,
	map[0x00eb]=0x6c007cc6fec07c00,map[0x00ec]=0x2010003818187e00,map[0x00ed]=0x0810003818187e00,
	map[0x00ee]=0x386c003818187e00,map[0x00ef]=0x6c00381818187e00,map[0x00f0]=0x6478987cc6c67c00,
	map[0x00f1]=0x3458fcc6c6c6c600,map[0x00f2]=0x20107cc6c6c67c00,map[0x00f3]=0x08107cc6c6c67c00,
	map[0x00f4]=0x386c7cc6c6c67c00,map[0x00f5]=0x34587cc6c6c67c00,map[0x00f6]=0x6c007cc6c6c67c00,
	map[0x00f7]=0x0018007e00180000,map[0x00f8]=0x00007cced6e67c00,map[0x00f9]=0x2010c6c6c6c67e00,
	map[0x00fa]=0x0810c6c6c6c67e00,map[0x00fb]=0x386c00c6c6c67e00,map[0x00fc]=0x6c00c6c6c6c67e00,
	map[0x00fd]=0x0810c6c6c67e067c,map[0x00fe]=0xc0c0fcc6c6fcc0c0,map[0x00ff]=0x6c00c6c6c67e067c,
	map[0x0100]=0x7c00386cc6fec600,map[0x0101]=0x7c007c067ec67e00,map[0x0102]=0x4438386cc6fec600,
	map[0x0103]=0x44387c067ec67e00,map[0x0104]=0x386cc6fec6040806,map[0x0105]=0x7c067ec67e102018,
	map[0x0106]=0x08103c66c0663c00,map[0x0107]=0x08107ec0c0c07e00,map[0x0108]=0x386c3c66c0663c00,
	map[0x0109]=0x386c7ec0c0c07e00,map[0x010a]=0x18003c66c0663c00,map[0x010b]=0x18007ec0c0c07e00,
	map[0x010c]=0x663c3c66c0663c00,map[0x010d]=0x6c387ec0c0c07e00,map[0x010e]=0x6c38f8ccc6ccf800,
	map[0x010f]=0x1b1b7ad8d8d87800,map[0x0110]=0x786c66f6666c7800,map[0x0111]=0x0c1e7ccccccc7c00,
	map[0x0112]=0x7c00fec0fcc0fe00,map[0x0113]=0x7c007cc6fec07c00,map[0x0114]=0x4438fec0fcc0fe00,
	map[0x0115]=0x44387cc6fec07c00,map[0x0116]=0x1800fec0fcc0fe00,map[0x0117]=0x18007cc6fec07c00,
	map[0x0118]=0xfec0fcc0fe102018,map[0x0119]=0x7cc6fec07c102018,map[0x011a]=0x6c38fec0fcc0fe00,
	map[0x011b]=0x6c387cc6fec07c00,map[0x011c]=0x386c7ec0cec67e00,map[0x011d]=0x386c7ec6c67e067c,
	map[0x011e]=0x44387ec0cec67e00,map[0x011f]=0x44387ec6c67e067c,map[0x0120]=0x18007ec0cec67e00,
	map[0x0121]=0x18007ec6c67e067c,map[0x0122]=0x3e60c0ce663e1830,map[0x0123]=0x18307ec6c67e067c,
	map[0x0124]=0x38eec6c6fec6c600,map[0x0125]=0x38ecc0fcc6c6c600,map[0x0126]=0xc6fec6fec6c6c600,
	map[0x0127]=0x60f07c6666666600,map[0x0128]=0x324c7e1818187e00,map[0x0129]=0x324c003818187e00,
	map[0x012a]=0x7e007e1818187e00,map[0x012b]=0x7c00381818187e00,map[0x012c]=0x24187e1818187e00,
	map[0x012d]=0x4438381818187e00,map[0x012e]=0x7e1818187e102018,map[0x012f]=0x180038187e102018,
	map[0x0130]=0x18007e1818187e00,map[0x0131]=0x0000381818187e00,map[0x0132]=0xf6666666f6067c00,
	map[0x0133]=0x6600ee666666063c,map[0x0134]=0x1c36060606c67c00,map[0x0135]=0x1c36001c0c0c0c78,
	map[0x0136]=0xccd8f0f8dcce3060,map[0x0137]=0xc0cefcf8dcce3060,map[0x0138]=0x0000c6ccf8ccc600,
	map[0x0139]=0x0870606060607e00,map[0x013a]=0x102070303030fc00,map[0x013b]=0x60606060607e1830,
	map[0x013c]=0x38181818187e1830,map[0x013d]=0x6666646060607e00,map[0x013e]=0x763634303030fc00,
	map[0x013f]=0x60606c6c60607e00,map[0x0140]=0x703036363030fc00,map[0x0141]=0x606070e060607e00,
	map[0x0142]=0x38181c3818187e00,map[0x0143]=0x0810e6f6fedece00,map[0x0144]=0x0810fcc6c6c6c600,
	map[0x0145]=0xe6f6fedecec61830,map[0x0146]=0x00fcc6c6c6c61830,map[0x0147]=0x6c38e6f6fedece00,
	map[0x0148]=0x6c38fcc6c6c6c600,map[0x0149]=0xc0c0bc3636363600,map[0x014a]=0xe6f6fedecec6063c,
	map[0x014b]=0x00fcc6c6c6c6063c,map[0x014c]=0x7c007cc6c6c67c00,map[0x014d]=0x7c007cc6c6c67c00,
	map[0x014e]=0x44387cc6c6c67c00,map[0x014f]=0x44387cc6c6c67c00,map[0x0150]=0x24487cc6c6c67c00,
	map[0x0151]=0x24487cc6c6c67c00,map[0x0152]=0x7ed8d8ded8d87e00,map[0x0153]=0x00007cd6ded07c00,
	map[0x0154]=0x0810fccef8dcce00,map[0x0155]=0x08106e7060606000,map[0x0156]=0xfcc6cef8dcce1830,
	map[0x0157]=0x006e706060603060,map[0x0158]=0x2810fccef8dcce00,map[0x0159]=0x361c6e7060606000,
	map[0x015a]=0x08107cc07c06fc00,map[0x015b]=0x08107cc07c06fc00,map[0x015c]=0x386c7cc07c06fc00,
	map[0x015d]=0x386c7cc07c06fc00,map[0x015e]=0x7cc07c06c67c0830,map[0x015f]=0x007cc07c06fc0830,
	map[0x0160]=0x6c387cc07c06fc00,map[0x0161]=0x6c387cc07c06fc00,map[0x0162]=0x7e18181818180830,
	map[0x0163]=0x18187e1818180830,map[0x0164]=0x24187e1818181800,map[0x0165]=0x2418187e18181800,
	map[0x0166]=0x7e18181c38181800,map[0x0167]=0x18187e181c381800,map[0x0168]=0x3458c6c6c6c67c00,
	map[0x0169]=0x3458c6c6c6c67e00,map[0x016a]=0x7c00c6c6c6c67c00,map[0x016b]=0x7c00c6c6c6c67e00,
	map[0x016c]=0x4438c6c6c6c67c00,map[0x016d]=0x4438c6c6c6c67e00,map[0x016e]=0x386cbac6c6c67c00,
	map[0x016f]=0x386cbac6c6c67e00,map[0x0170]=0x2448c6c6c6c67c00,map[0x0171]=0x2448c6c6c6c67e00,
	map[0x0172]=0xc6c6c6c67c102018,map[0x0173]=0xc6c6c6c67e102018,map[0x0174]=0x386cc6d6fefeee00,
	map[0x0175]=0x386cb6b6b6b67e00,map[0x0176]=0x182466663c181800,map[0x0177]=0x386cc6c6c67e067c,
	map[0x0178]=0x660066663c181800,map[0x0179]=0x0810fe1c3870fe00,map[0x017a]=0x0810fe1c3870fe00,
	map[0x017b]=0x1800fe1c3870fe00,map[0x017c]=0x1800fe1c3870fe00,map[0x017d]=0x6c38fe1c3870fe00,
	map[0x017e]=0x6c38fe1c3870fe00,map[0x017f]=0x0e18181818181800,map[0x0192]=0x0e187e1818187000,
	map[0x02c6]=0x386c000000000000,map[0x02c7]=0x6c38000000000000,map[0x02c9]=0x7c00000000000000,
	map[0x02ca]=0x0810000000000000,map[0x02cb]=0x1008000000000000,map[0x02d7]=0x0000007c00000000,
	map[0x02d8]=0x4438000000000000,map[0x02d9]=0x1800000000000000,map[0x02da]=0x386c380000000000,
	map[0x02db]=0x0000000000102018,map[0x02dc]=0x3458000000000000,map[0x02dd]=0x2448000000000000,
	map[0x037a]=0x000000000000100c,map[0x037e]=0x0030300030306000,map[0x0384]=0x0810000000000000,
	map[0x0385]=0x4a10000000000000,map[0x0386]=0x58bc66667e666600,map[0x0387]=0x0000003030000000,
	map[0x0388]=0x7fb0303c30303f00,map[0x0389]=0x73b3333f33333300,map[0x038a]=0x5e8c0c0c0c0c1e00,
	map[0x038c]=0x5eb3333333331e00,map[0x038e]=0x73b3331e0c0c0c00,map[0x038f]=0x5cb6636363367700,
	map[0x0390]=0x9420703030301c00,map[0x0391]=0x386cc6c6fec6c600,map[0x0392]=0xfcc6c6fcc6c6fc00,
	map[0x0393]=0x7e60606060606000,map[0x0394]=0x386cc6c6c6c6fe00,map[0x0395]=0xfec0c0fcc0c0fe00,
	map[0x0396]=0xfe0e1c3870e0fe00,map[0x0397]=0xc6c6c6fec6c6c600,map[0x0398]=0x7cc6c6fec6c67c00,
	map[0x0399]=0x7e18181818187e00,map[0x039a]=0xc6ccd8f0f8dcce00,map[0x039b]=0x386cc6c6c6c6c600,
	map[0x039c]=0xc6eefefed6c6c600,map[0x039d]=0xc6e6f6fedecec600,map[0x039e]=0xfe00007c0000fe00,
	map[0x039f]=0x7cc6c6c6c6c67c00,map[0x03a0]=0xfec6c6c6c6c6c600,map[0x03a1]=0xfcc6c6c6fcc0c000,
	map[0x03a3]=0xfe66301c3066fe00,map[0x03a4]=0x7e18181818181800,map[0x03a5]=0x6666663c18181800,
	map[0x03a6]=0x107cd6d6d67c1000,map[0x03a7]=0xc6ee7c387ceec600,map[0x03a8]=0xdbdbdb7e18183c00,
	map[0x03a9]=0x386cc6c6c66cee00,map[0x03aa]=0x66007e1818187e00,map[0x03ab]=0x660066663c181800,
	map[0x03ac]=0x08107ec6c6c67e00,map[0x03ad]=0x08107ec07cc07e00,map[0x03ae]=0x0810dc6666666606,
	map[0x03af]=0x1020703030301c00,map[0x03b0]=0x9420cc6666663c00,map[0x03b1]=0x00007ec6c6c67e00,
	map[0x03b2]=0x7cc6c6fcc6c6fcc0,map[0x03b3]=0x0000c666663c1818,map[0x03b4]=0x0e180c7ec6c67c00,
	map[0x03b5]=0x00007ec07cc07e00,map[0x03b6]=0x7c3060c0c07c060c,map[0x03b7]=0x0000dc6666666606,
	map[0x03b8]=0x386cc6fec66c3800,map[0x03b9]=0x0000703030301c00,map[0x03ba]=0x0000c6ccf8ccc600,
	map[0x03bb]=0xc06030386cc6c600,map[0x03bc]=0x0000ccccccccf6c0,map[0x03bd]=0x0000c666663c1800,
	map[0x03be]=0xfc603860c0780c18,map[0x03bf]=0x00007cc6c6c67c00,map[0x03c0]=0x0000fe6c6c6ce600,
	map[0x03c1]=0x00007cc6c6fcc0c0,map[0x03c2]=0x00007cc0c07c067c,map[0x03c3]=0x00007ed8cccc7800,
	map[0x03c4]=0x00007e1818180e00,map[0x03c5]=0x0000cc6666663c00,map[0x03c6]=0x00004cd6d6d67c10,
	map[0x03c7]=0x0000c66c386cc6c6,map[0x03c8]=0x0018dbdbdbdb7e18,map[0x03c9]=0x000044d6d6d66c00,
	map[0x03ca]=0xd800703030301c00,map[0x03cb]=0x6c00cc6666663c00,map[0x03cc]=0x08107cc6c6c67c00,
	map[0x03cd]=0x0810cc6666663c00,map[0x03ce]=0x081044d6d6d66c00,map[0x0400]=0x2010fec0fcc0fe00,
	map[0x0401]=0x6c00fec0fcc0fe00,map[0x0402]=0xf8607c666666660c,map[0x0403]=0x08107e6060606000,
	map[0x0404]=0x3c66c0fcc0663c00,map[0x0405]=0x78ccc07c06c67c00,map[0x0406]=0x7e18181818187e00,
	map[0x0407]=0x66007e1818187e00,map[0x0408]=0x0606060606c67c00,map[0x0409]=0x3070dcd6d6d6dc00,
	map[0x040a]=0xd0d0dcf6d6d6dc00,map[0x040b]=0xf8607c6666666600,map[0x040c]=0x0810c6ccf8ccc600,
	map[0x040d]=0x2010cedefef6e600,map[0x040e]=0x4438c6c67e06fc00,map[0x040f]=0xc6c6c6c6c6c6fe10,
	map[0x0410]=0x386cc6c6fec6c600,map[0x0411]=0xfcc0c0fcc6c6fc00,map[0x0412]=0xfcc6c6fcc6c6fc00,
	map[0x0413]=0x7e60606060606000,map[0x0414]=0x1e3636666666fec3,map[0x0415]=0xfec0c0fcc0c0fe00,
	map[0x0416]=0xd6d67c387cd6d600,map[0x0417]=0x7cc6063c06c67c00,map[0x0418]=0xc6cedefef6e6c600,
	map[0x0419]=0x4438cedefef6e600,map[0x041a]=0xc6ccd8f0f8dcce00,map[0x041b]=0x1e366666c6c6c600,
	map[0x041c]=0xc6eefefed6c6c600,map[0x041d]=0xc6c6c6fec6c6c600,map[0x041e]=0x7cc6c6c6c6c67c00,
	map[0x041f]=0xfec6c6c6c6c6c600,map[0x0420]=0xfcc6c6c6fcc0c000,map[0x0421]=0x3c66c0c0c0663c00,
	map[0x0422]=0x7e18181818181800,map[0x0423]=0xc6c6c67e06c67c00,map[0x0424]=0x107cd6d6d67c1000,
	map[0x0425]=0xc6ee7c387ceec600,map[0x0426]=0xccccccccccccfe06,map[0x0427]=0xc6c6c67e06060600,
	map[0x0428]=0xd6d6d6d6d6d6fe00,map[0x0429]=0xd6d6d6d6d6d6ff03,map[0x042a]=0xe0607c6666667c00,
	map[0x042b]=0xc6c6f6dededef600,map[0x042c]=0xc0c0fcc6c6c6fc00,map[0x042d]=0x78cc067e06cc7800,
	map[0x042e]=0xcedbdbfbdbdbce00,map[0x042f]=0x7ec6c6e63e76e600,map[0x0430]=0x00007c067ec67e00,
	map[0x0431]=0x7ec0dce6c6c67c00,map[0x0432]=0x0000fcc6fcc6fc00,map[0x0433]=0x00007e6060606000,
	map[0x0434]=0x00007ec6c67e067c,map[0x0435]=0x00007cc6fec07c00,map[0x0436]=0x0000d6d67cd6d600,
	map[0x0437]=0x0000fc067c06fc00,map[0x0438]=0x0000c6ced6e6c600,map[0x0439]=0x4438c6ced6e6c600,
	map[0x043a]=0x0000c6ccf8ccc600,map[0x043b]=0x00003e6666c6c600,map[0x043c]=0x0000c6eed6d6c600,
	map[0x043d]=0x0000c6c6fec6c600,map[0x043e]=0x00007cc6c6c67c00,map[0x043f]=0x0000fec6c6c6c600,
	map[0x0440]=0x0000fcc6c6fcc0c0,map[0x0441]=0x00007ec0c0c07e00,map[0x0442]=0x00007e1818181800,
	map[0x0443]=0x0000c6c6c67e067c,map[0x0444]=0x00107cd6d6d67c10,map[0x0445]=0x0000c6fe38fec600,
	map[0x0446]=0x0000ccccccccfe06,map[0x0447]=0x0000c6c67e060600,map[0x0448]=0x0000d6d6d6d6fe00,
	map[0x0449]=0x0000d6d6d6d6ff03,map[0x044a]=0x0000e0607c667c00,map[0x044b]=0x0000c6c6f6def600,
	map[0x044c]=0x0000c0c0fcc6fc00,map[0x044d]=0x00007cc61ec67c00,map[0x044e]=0x0000cedbfbdbce00,
	map[0x044f]=0x00007ec67ec6c600,map[0x0450]=0x20107cc6fec07c00,map[0x0451]=0x6c007cc6fec07c00,
	map[0x0452]=0x60f8607c6666660c,map[0x0453]=0x08107e6060606000,map[0x0454]=0x00007cc6f0c67c00,
	map[0x0455]=0x00007cc07c06fc00,map[0x0456]=0x1800381818187e00,map[0x0457]=0x6c00381818187e00,
	map[0x0458]=0x0c001c0c0c0c0c78,map[0x0459]=0x0000307cd6d6dc00,map[0x045a]=0x0000d0dcf6d6dc00,
	map[0x045b]=0x60f8607c66666600,map[0x045c]=0x0810c6ccf8ccc600,map[0x045d]=0x2010c6ced6e6c600,
	map[0x045e]=0x4438c6c6c67e067c,map[0x045f]=0x0000c6c6c6c6fe10,map[0x2013]=0x000000fe00000000,
	map[0x2014]=0x000000ff00000000,map[0x2015]=0x000000fe00000000,map[0x2018]=0x1830300000000000,
	map[0x2019]=0x1818300000000000,map[0x201a]=0x0000000018183000,map[0x201c]=0x366c6c0000000000,
	map[0x201d]=0x36366c0000000000,map[0x201e]=0x000000006c6cd800,map[0x2020]=0x18187e1818181800,
	map[0x2021]=0x18187e187e181800,map[0x2022]=0x0000183c3c180000,map[0x2026]=0x0000000000929200,
	map[0x2030]=0x62a4c8102f559e00,map[0x2039]=0x000c1830180c0000,map[0x203a]=0x0060301830600000,
	map[0x2044]=0x0204081020408000,map[0x20ac]=0x1c36f860f8361c00,map[0x20af]=0x6090949a9a9aec08,
	map[0x2116]=0xc4aaaaaaa4a0ae00,map[0x2122]=0x7e2e2a2a00000000,map[0x2190]=0x10307fff7f301000,
	map[0x2191]=0x10387cfe38383838,map[0x2192]=0x080cfefffe0c0800,map[0x2193]=0x38383838fe7c3810,
	map[0x2202]=0x78cc067ec6c67c00,map[0x2206]=0x386cc6c6c6c6fe00,map[0x220f]=0xfec6c6c6c6c6c600,
	map[0x2211]=0xfe66301c3066fe00,map[0x221a]=0x1e181818d8783800,map[0x221e]=0x00006c92926c0000,
	map[0x222b]=0x0c1a181818185830,map[0x2248]=0x0064980064980000,map[0x2260]=0x0204fe10fe408000,
	map[0x2264]=0x0c1830180c003c00,map[0x2265]=0x30180c1830003c00,map[0x25b2]=0x101038387c7cfe00,
	map[0x25b6]=0x80e0f8fef8e08000,map[0x25bc]=0xfe7c7c3838101000,map[0x25c0]=0x020e3efe3e0e0200,
	map[0x25ca]=0x1028448244281000,map[0x2605]=0x1010fe7c386c4400,map[0x2606]=0x1010ee44287c4400,
	map[0x2660]=0x10387cfefe387c00,map[0x2663]=0x1818666618183c00,map[0x2665]=0x6cfefefe7c381000,
	map[0x2666]=0x10387cfe7c381000,map[0x266a]=0x1018141274f06000,map[0xf101]=0x00000000001c7c00,
	map[0xf8ff]=0x0876fdfdfb7e2c00,map[0xfb01]=0x3860fe6666666600,map[0xfb02]=0x3e66fe6666666600, map; }
};


//#line 1 "tinyexr.cc"
#define TINYEXR_IMPLEMENTATION

//#line 1 "tinyexr.h"
#ifndef __TINYEXR_H__
#define __TINYEXR_H__

//
//
//   Do this:
//    #define TINYEXR_IMPLEMENTATION
//   before you include this file in *one* C or C++ file to create the
//   implementation.
//
//   // i.e. it should look like this:
//   #include ...
//   #include ...
//   #include ...
//   #define TINYEXR_IMPLEMENTATION
//   #include "tinyexr.h"
//
//

#include <stddef.h> // for size_t

#ifdef __cplusplus
extern "C" {
#endif

// pixel type: possible values are: UINT = 0 HALF = 1 FLOAT = 2
#define TINYEXR_PIXELTYPE_UINT (0)
#define TINYEXR_PIXELTYPE_HALF (1)
#define TINYEXR_PIXELTYPE_FLOAT (2)

#define TINYEXR_MAX_ATTRIBUTES (128)

#define TINYEXR_COMPRESSIONTYPE_NONE (0)
//#define TINYEXR_COMPRESSIONTYPE_RLE  (1)  // not supported yet
#define TINYEXR_COMPRESSIONTYPE_ZIPS (2)
#define TINYEXR_COMPRESSIONTYPE_ZIP (3)
#define TINYEXR_COMPRESSIONTYPE_PIZ (4)

typedef struct _EXRAttribute {
  char *name;
  char *type;
  int size;
  unsigned char *value; // uint8_t*
} EXRAttribute;

typedef struct _EXRImage {
  // Custom attributes(exludes required attributes(e.g. `channels`,
  // `compression`, etc)
  EXRAttribute custom_attributes[TINYEXR_MAX_ATTRIBUTES];
  int num_custom_attributes;

  int num_channels;
  const char **channel_names;

  unsigned char **images; // image[channels][pixels]
  int *pixel_types; // Loaded pixel type(TINYEXR_PIXELTYPE_*) of `images` for
					// each channel

  int *requested_pixel_types; // Filled initially by
							  // ParseEXRHeaderFrom(Meomory|File), then users
							  // can edit it(only valid for HALF pixel type
							  // channel)

  int width;
  int height;
  float pixel_aspect_ratio;
  int compression; // compression type(TINYEXR_COMPRESSIONTYPE_*)
  int line_order;
  int data_window[4];
  int display_window[4];
  float screen_window_center[2];
  float screen_window_width;
} EXRImage;

typedef struct _DeepImage {
  int num_channels;
  const char **channel_names;
  float ***image;     // image[channels][scanlines][samples]
  int **offset_table; // offset_table[scanline][offsets]
  int width;
  int height;
} DeepImage;

// @deprecated { to be removed. }
// Loads single-frame OpenEXR image. Assume EXR image contains RGB(A) channels.
// Application must free image data as returned by `out_rgba`
// Result image format is: float x RGBA x width x hight
// Return 0 if success
// Returns error string in `err` when there's an error
extern int LoadEXR(float **out_rgba, int *width, int *height,
				   const char *filename, const char **err);

// Parse single-frame OpenEXR header from a file and initialize `EXRImage`
// struct.
// Users then call LoadMultiChannelEXRFromFile to actually load image data into
// `EXRImage`
extern int ParseMultiChannelEXRHeaderFromFile(EXRImage *image,
											  const char *filename,
											  const char **err);

// Parse single-frame OpenEXR header from a memory and initialize `EXRImage`
// struct.
// Users then call LoadMultiChannelEXRFromMemory to actually load image data
// into `EXRImage`
extern int ParseMultiChannelEXRHeaderFromMemory(EXRImage *image,
												const unsigned char *memory,
												const char **err);

// Loads multi-channel, single-frame OpenEXR image from a file.
// Application must setup `ParseMultiChannelEXRHeaderFromFile` before calling
// `LoadMultiChannelEXRFromFile`.
// Application can free EXRImage using `FreeExrImage`
// Return 0 if success
// Returns error string in `err` when there's an error
extern int LoadMultiChannelEXRFromFile(EXRImage *image, const char *filename,
									   const char **err);

// Loads multi-channel, single-frame OpenEXR image from a memory.
// Application must setup `EXRImage` with `ParseMultiChannelEXRHeaderFromMemory`
// before calling `LoadMultiChannelEXRFromMemory`.
// Application can free EXRImage using `FreeExrImage`
// Return 0 if success
// Returns error string in `err` when there's an error
extern int LoadMultiChannelEXRFromMemory(EXRImage *image,
										 const unsigned char *memory,
										 const char **err);

// Saves floating point RGBA image as OpenEXR.
// Image is compressed using EXRImage.compression value.
// Return 0 if success
// Returns error string in `err` when there's an error
// extern int SaveEXR(const float *in_rgba, int width, int height,
//                   const char *filename, const char **err);

// Saves multi-channel, single-frame OpenEXR image to a file.
// `compression_type` is one of TINYEXR_COMPRESSIONTYPE_*.
// Returns 0 if success
// Returns error string in `err` when there's an error
extern int SaveMultiChannelEXRToFile(const EXRImage *image,
									 const char *filename, const char **err);

// Saves multi-channel, single-frame OpenEXR image to a memory.
// Image is compressed using EXRImage.compression value.
// Return the number of bytes if succes.
// Retruns 0 if success, negative number when failed.
// Returns error string in `err` when there's an error
extern size_t SaveMultiChannelEXRToMemory(const EXRImage *image,
										  unsigned char **memory,
										  const char **err);

// Loads single-frame OpenEXR deep image.
// Application must free memory of variables in DeepImage(image, offset_table)
// Returns 0 if success
// Returns error string in `err` when there's an error
extern int LoadDeepEXR(DeepImage *out_image, const char *filename,
					   const char **err);

// NOT YET IMPLEMENTED:
// Saves single-frame OpenEXR deep image.
// Return 0 if success
// Returns error string in `err` when there's an error
// extern int SaveDeepEXR(const DeepImage *in_image, const char *filename,
//                       const char **err);

// NOT YET IMPLEMENTED:
// Loads multi-part OpenEXR deep image.
// Application must free memory of variables in DeepImage(image, offset_table)
// extern int LoadMultiPartDeepEXR(DeepImage **out_image, int num_parts, const
// char *filename,
//                       const char **err);

// Initialize of EXRImage struct
extern void InitEXRImage(EXRImage *exrImage);

// Free's internal data of EXRImage struct
// Returns 0 if success.
extern int FreeEXRImage(EXRImage *exrImage);

// For emscripten.
// Parse single-frame OpenEXR header from memory.
// Return 0 if success
extern int ParseEXRHeaderFromMemory(EXRAttribute *customAttributes,
									int *numCustomAttributes, int *width,
									int *height, const unsigned char *memory);

// For emscripten.
// Loads single-frame OpenEXR image from memory. Assume EXR image contains
// RGB(A) channels.
// `out_rgba` must have enough memory(at least sizeof(float) x 4(RGBA) x width x
// hight)
// Return 0 if success
// Returns error string in `err` when there's an error
extern int LoadEXRFromMemory(float *out_rgba, const unsigned char *memory,
							 const char **err);

#ifdef __cplusplus
}
#endif

#ifdef TINYEXR_IMPLEMENTATION
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cstring>
#include <algorithm>

#include <string>
#include <vector>

#ifdef _OPENMP
#include <omp.h>
#endif

namespace {

namespace miniz {

/* miniz.c v1.15 - public domain deflate/inflate, zlib-subset, ZIP
   reading/writing/appending, PNG writing
   See "unlicense" statement at the end of this file.
   Rich Geldreich <richgel99@gmail.com>, last updated Oct. 13, 2013
   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951:
   http://www.ietf.org/rfc/rfc1951.txt

   Most API's defined in miniz.c are optional. For example, to disable the
   archive related functions just define
   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO
   (see the list below for more macros).

   * Change History
	 10/13/13 v1.15 r4 - Interim bugfix release while I work on the next major
   release with Zip64 support (almost there!):
	   - Critical fix for the MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY bug
   (thanks kahmyong.moon@hp.com) which could cause locate files to not find
   files. This bug
		would only have occured in earlier versions if you explicitly used this
   flag, OR if you used mz_zip_extract_archive_file_to_heap() or
   mz_zip_add_mem_to_archive_file_in_place()
		(which used this flag). If you can't switch to v1.15 but want to fix
   this bug, just remove the uses of this flag from both helper funcs (and of
   course don't use the flag).
	   - Bugfix in mz_zip_reader_extract_to_mem_no_alloc() from kymoon when
   pUser_read_buf is not NULL and compressed size is > uncompressed size
	   - Fixing mz_zip_reader_extract_*() funcs so they don't try to extract
   compressed data from directory entries, to account for weird zipfiles which
   contain zero-size compressed data on dir entries.
		 Hopefully this fix won't cause any issues on weird zip archives,
   because it assumes the low 16-bits of zip external attributes are DOS
   attributes (which I believe they always are in practice).
	   - Fixing mz_zip_reader_is_file_a_directory() so it doesn't check the
   internal attributes, just the filename and external attributes
	   - mz_zip_reader_init_file() - missing MZ_FCLOSE() call if the seek failed
	   - Added cmake support for Linux builds which builds all the examples,
   tested with clang v3.3 and gcc v4.6.
	   - Clang fix for tdefl_write_image_to_png_file_in_memory() from toffaletti
	   - Merged MZ_FORCEINLINE fix from hdeanclark
	   - Fix <time.h> include before config #ifdef, thanks emil.brink
	   - Added tdefl_write_image_to_png_file_in_memory_ex(): supports Y flipping
   (super useful for OpenGL apps), and explicit control over the compression
   level (so you can
		set it to 1 for real-time compression).
	   - Merged in some compiler fixes from paulharris's github repro.
	   - Retested this build under Windows (VS 2010, including static analysis),
   tcc  0.9.26, gcc v4.6 and clang v3.3.
	   - Added example6.c, which dumps an image of the mandelbrot set to a PNG
   file.
	   - Modified example2 to help test the
   MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY flag more.
	   - In r3: Bugfix to mz_zip_writer_add_file() found during merge: Fix
   possible src file fclose() leak if alignment bytes+local header file write
   faiiled
				 - In r4: Minor bugfix to mz_zip_writer_add_from_zip_reader():
   Was pushing the wrong central dir header offset, appears harmless in this
   release, but it became a problem in the zip64 branch
	 5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE,
   #include <time.h> (thanks fermtect).
	 5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix
   mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.
	   - Temporarily/locally slammed in "typedef unsigned long mz_ulong" and
   re-ran a randomized regression test on ~500k files.
	   - Eliminated a bunch of warnings when compiling with GCC 32-bit/64.
	   - Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze
   (static analysis) option and fixed all warnings (except for the silly
		"Use of the comma-operator in a tested expression.." analysis warning,
   which I purposely use to work around a MSVC compiler warning).
	   - Created 32-bit and 64-bit Codeblocks projects/workspace. Built and
   tested Linux executables. The codeblocks workspace is compatible with
   Linux+Win32/x64.
	   - Added miniz_tester solution/project, which is a useful little app
   derived from LZHAM's tester app that I use as part of the regression test.
	   - Ran miniz.c and tinfl.c through another series of regression testing on
   ~500,000 files and archives.
	   - Modified example5.c so it purposely disables a bunch of high-level
   functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the
   MINIZ_NO_STDIO bug report.)
	   - Fix ftell() usage in examples so they exit with an error on files which
   are too large (a limitation of the examples, not miniz itself).
	 4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple
   minor level_and_flags issues in the archive API's.
	  level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce
   Dawson <bruced@valvesoftware.com> for the feedback/bug report.
	 5/28/11 v1.11 - Added statement from unlicense.org
	 5/27/11 v1.10 - Substantial compressor optimizations:
	  - Level 1 is now ~4x faster than before. The L1 compressor's throughput
   now varies between 70-110MB/sec. on a
	  - Core i7 (actual throughput varies depending on the type of data, and x64
   vs. x86).
	  - Improved baseline L2-L9 compression perf. Also, greatly improved
   compression perf. issues on some file types.
	  - Refactored the compression code for better readability and
   maintainability.
	  - Added level 10 compression level (L10 has slightly better ratio than
   level 9, but could have a potentially large
	   drop in throughput on some files).
	 5/15/11 v1.09 - Initial stable release.

   * Low-level Deflate/Inflate implementation notes:

	 Compression: Use the "tdefl" API's. The compressor supports raw, static,
   and dynamic blocks, lazy or
	 greedy parsing, match length filtering, RLE-only, and Huffman-only streams.
   It performs and compresses
	 approximately as well as zlib.

	 Decompression: Use the "tinfl" API's. The entire decompressor is
   implemented as a single function
	 coroutine: see tinfl_decompress(). It supports decompression into a 32KB
   (or larger power of 2) wrapping buffer, or into a memory
	 block large enough to hold the entire file.

	 The low-level tdefl/tinfl API's do not make any use of dynamic memory
   allocation.

   * zlib-style API notes:

	 miniz.c implements a fairly large subset of zlib. There's enough
   functionality present for it to be a drop-in
	 zlib replacement in many apps:
		The z_stream struct, optional memory allocation callbacks
		deflateInit/deflateInit2/deflate/deflateReset/deflateEnd/deflateBound
		inflateInit/inflateInit2/inflate/inflateEnd
		compress, compress2, compressBound, uncompress
		CRC-32, Adler-32 - Using modern, minimal code size, CPU cache friendly
   routines.
		Supports raw deflate streams or standard zlib streams with adler-32
   checking.

	 Limitations:
	  The callback API's are not implemented yet. No support for gzip headers or
   zlib static dictionaries.
	  I've tried to closely emulate zlib's various flavors of stream flushing
   and return status codes, but
	  there are no guarantees that miniz.c pulls this off perfectly.

   * PNG writing: See the tdefl_write_image_to_png_file_in_memory() function,
   originally written by
	 Alex Evans. Supports 1-4 bytes/pixel images.

   * ZIP archive API notes:

	 The ZIP archive API's where designed with simplicity and efficiency in
   mind, with just enough abstraction to
	 get the job done with minimal fuss. There are simple API's to retrieve file
   information, read files from
	 existing archives, create new archives, append new files to existing
   archives, or clone archive data from
	 one archive to another. It supports archives located in memory or the heap,
   on disk (using stdio.h),
	 or you can specify custom file read/write callbacks.

	 - Archive reading: Just call this function to read a single file from a
   disk archive:

	  void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename, const
   char *pArchive_name,
		size_t *pSize, mz_uint zip_flags);

	 For more complex cases, use the "mz_zip_reader" functions. Upon opening an
   archive, the entire central
	 directory is located and read as-is into memory, and subsequent file access
   only occurs when reading individual files.

	 - Archives file scanning: The simple way is to use this function to scan a
   loaded archive for a specific file:

	 int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,
   const char *pComment, mz_uint flags);

	 The locate operation can optionally check file comments too, which (as one
   example) can be used to identify
	 multiple versions of the same file in an archive. This function uses a
   simple linear search through the central
	 directory, so it's not very fast.

	 Alternately, you can iterate through all the files in an archive (using
   mz_zip_reader_get_num_files()) and
	 retrieve detailed info on each file by calling mz_zip_reader_file_stat().

	 - Archive creation: Use the "mz_zip_writer" functions. The ZIP writer
   immediately writes compressed file data
	 to disk and builds an exact image of the central directory in memory. The
   central directory image is written
	 all at once at the end of the archive file when the archive is finalized.

	 The archive writer can optionally align each file's local header and file
   data to any power of 2 alignment,
	 which can be useful when the archive will be read from optical media. Also,
   the writer supports placing
	 arbitrary data blobs at the very beginning of ZIP archives. Archives
   written using either feature are still
	 readable by any ZIP tool.

	 - Archive appending: The simple way to add a single file to an archive is
   to call this function:

	  mz_bool mz_zip_add_mem_to_archive_file_in_place(const char *pZip_filename,
   const char *pArchive_name,
		const void *pBuf, size_t buf_size, const void *pComment, mz_uint16
   comment_size, mz_uint level_and_flags);

	 The archive will be created if it doesn't already exist, otherwise it'll be
   appended to.
	 Note the appending is done in-place and is not an atomic operation, so if
   something goes wrong
	 during the operation it's possible the archive could be left without a
   central directory (although the local
	 file headers and file data will be fine, so the archive will be
   recoverable).

	 For more complex archive modification scenarios:
	 1. The safest way is to use a mz_zip_reader to read the existing archive,
   cloning only those bits you want to
	 preserve into a new archive using using the
   mz_zip_writer_add_from_zip_reader() function (which compiles the
	 compressed file data as-is). When you're done, delete the old archive and
   rename the newly written archive, and
	 you're done. This is safe but requires a bunch of temporary disk space or
   heap memory.

	 2. Or, you can convert an mz_zip_reader in-place to an mz_zip_writer using
   mz_zip_writer_init_from_reader(),
	 append new files as needed, then finalize the archive which will write an
   updated central directory to the
	 original archive. (This is basically what
   mz_zip_add_mem_to_archive_file_in_place() does.) There's a
	 possibility that the archive's central directory could be lost with this
   method if anything goes wrong, though.

	 - ZIP archive support limitations:
	 No zip64 or spanning support. Extraction functions can only handle
   unencrypted, stored or deflated files.
	 Requires streams capable of seeking.

   * This is a header file library, like stb_image.c. To get only a header file,
   either cut and paste the
	 below header, or create miniz.h, #define MINIZ_HEADER_FILE_ONLY, and then
   include miniz.c from it.

   * Important: For best perf. be sure to customize the below macros for your
   target platform:
	 #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
	 #define MINIZ_LITTLE_ENDIAN 1
	 #define MINIZ_HAS_64BIT_REGISTERS 1

   * On platforms using glibc, Be sure to "#define _LARGEFILE64_SOURCE 1" before
   including miniz.c to ensure miniz
	 uses the 64-bit variants: fopen64(), stat64(), etc. Otherwise you won't be
   able to process large files
	 (i.e. 32-bit stat() fails for me on files > 0x7FFFFFFF bytes).
*/

#ifndef MINIZ_HEADER_INCLUDED
#define MINIZ_HEADER_INCLUDED

#include <stdlib.h>

// Defines to completely disable specific portions of miniz.c:
// If all macros here are defined the only functionality remaining will be
// CRC-32, adler-32, tinfl, and tdefl.

// Define MINIZ_NO_STDIO to disable all usage and any functions which rely on
// stdio for file I/O.
//#define MINIZ_NO_STDIO

// If MINIZ_NO_TIME is specified then the ZIP archive functions will not be able
// to get the current time, or
// get/set file times, and the C run-time funcs that get/set times won't be
// called.
// The current downside is the times written to your archives will be from 1979.
//#define MINIZ_NO_TIME

// Define MINIZ_NO_ARCHIVE_APIS to disable all ZIP archive API's.
//#define MINIZ_NO_ARCHIVE_APIS

// Define MINIZ_NO_ARCHIVE_APIS to disable all writing related ZIP archive
// API's.
//#define MINIZ_NO_ARCHIVE_WRITING_APIS

// Define MINIZ_NO_ZLIB_APIS to remove all ZLIB-style compression/decompression
// API's.
//#define MINIZ_NO_ZLIB_APIS

// Define MINIZ_NO_ZLIB_COMPATIBLE_NAME to disable zlib names, to prevent
// conflicts against stock zlib.
//#define MINIZ_NO_ZLIB_COMPATIBLE_NAMES

// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.
// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom
// user alloc/free/realloc
// callbacks to the zlib and archive API's, and a few stand-alone helper API's
// which don't provide custom user
// functions (such as tdefl_compress_mem_to_heap() and
// tinfl_decompress_mem_to_heap()) won't work.
//#define MINIZ_NO_MALLOC

#if defined(__TINYC__) && (defined(__linux) || defined(__linux__))
// TODO: Work around "error: include file 'sys\utime.h' when compiling with tcc
// on Linux
#define MINIZ_NO_TIME
#endif

#if !defined(MINIZ_NO_TIME) && !defined(MINIZ_NO_ARCHIVE_APIS)
#include <time.h>
#endif

#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) ||                \
	defined(__i386) || defined(__i486__) || defined(__i486) ||                 \
	defined(i386) || defined(__ia64__) || defined(__x86_64__)
// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.
#define MINIZ_X86_OR_X64_CPU 1
#endif

#if defined(__sparcv9)
// Big endian
#else
#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU
// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.
#define MINIZ_LITTLE_ENDIAN 1
#endif
#endif

#if MINIZ_X86_OR_X64_CPU
// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient
// integer loads and stores from unaligned addresses.
//#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1
#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES                                   \
  0 // disable to suppress compiler warnings
#endif

#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) ||              \
	defined(_LP64) || defined(__LP64__) || defined(__ia64__) ||                \
	defined(__x86_64__)
// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are
// reasonably fast (and don't involve compiler generated calls to helper
// functions).
#define MINIZ_HAS_64BIT_REGISTERS 1
#endif

#ifdef __cplusplus
extern "C" {
#endif

// ------------------- zlib-style API Definitions.

// For more compatibility with zlib, miniz.c uses unsigned long for some
// parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!
typedef unsigned long mz_ulong;

// mz_free() internally uses the MZ_FREE() macro (which by default calls free()
// unless you've modified the MZ_MALLOC macro) to release a block allocated from
// the heap.
void mz_free(void *p);

#define MZ_ADLER32_INIT (1)
// mz_adler32() returns the initial adler-32 value to use when called with
// ptr==NULL.
mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);

#define MZ_CRC32_INIT (0)
// mz_crc32() returns the initial CRC-32 value to use when called with
// ptr==NULL.
mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);

// Compression strategies.
enum {
  MZ_DEFAULT_STRATEGY = 0,
  MZ_FILTERED = 1,
  MZ_HUFFMAN_ONLY = 2,
  MZ_RLE = 3,
  MZ_FIXED = 4
};

// Method
#define MZ_DEFLATED 8

#ifndef MINIZ_NO_ZLIB_APIS

// Heap allocation callbacks.
// Note that mz_alloc_func parameter types purpsosely differ from zlib's:
// items/size is size_t, not unsigned long.
typedef void *(*mz_alloc_func)(void *opaque, size_t items, size_t size);
typedef void (*mz_free_func)(void *opaque, void *address);
typedef void *(*mz_realloc_func)(void *opaque, void *address, size_t items,
								 size_t size);

#define MZ_VERSION "9.1.15"
#define MZ_VERNUM 0x91F0
#define MZ_VER_MAJOR 9
#define MZ_VER_MINOR 1
#define MZ_VER_REVISION 15
#define MZ_VER_SUBREVISION 0

// Flush values. For typical usage you only need MZ_NO_FLUSH and MZ_FINISH. The
// other values are for advanced use (refer to the zlib docs).
enum {
  MZ_NO_FLUSH = 0,
  MZ_PARTIAL_FLUSH = 1,
  MZ_SYNC_FLUSH = 2,
  MZ_FULL_FLUSH = 3,
  MZ_FINISH = 4,
  MZ_BLOCK = 5
};

// Return status codes. MZ_PARAM_ERROR is non-standard.
enum {
  MZ_OK = 0,
  MZ_STREAM_END = 1,
  MZ_NEED_DICT = 2,
  MZ_ERRNO = -1,
  MZ_STREAM_ERROR = -2,
  MZ_DATA_ERROR = -3,
  MZ_MEM_ERROR = -4,
  MZ_BUF_ERROR = -5,
  MZ_VERSION_ERROR = -6,
  MZ_PARAM_ERROR = -10000
};

// Compression levels: 0-9 are the standard zlib-style levels, 10 is best
// possible compression (not zlib compatible, and may be very slow),
// MZ_DEFAULT_COMPRESSION=MZ_DEFAULT_LEVEL.
enum {
  MZ_NO_COMPRESSION = 0,
  MZ_BEST_SPEED = 1,
  MZ_BEST_COMPRESSION = 9,
  MZ_UBER_COMPRESSION = 10,
  MZ_DEFAULT_LEVEL = 6,
  MZ_DEFAULT_COMPRESSION = -1
};

// Window bits
#define MZ_DEFAULT_WINDOW_BITS 15

struct mz_internal_state;

// Compression/decompression stream struct.
typedef struct mz_stream_s {
  const unsigned char *next_in; // pointer to next byte to read
  unsigned int avail_in;        // number of bytes available at next_in
  mz_ulong total_in;            // total number of bytes consumed so far

  unsigned char *next_out; // pointer to next byte to write
  unsigned int avail_out;  // number of bytes that can be written to next_out
  mz_ulong total_out;      // total number of bytes produced so far

  char *msg;                       // error msg (unused)
  struct mz_internal_state *state; // internal state, allocated by zalloc/zfree

  mz_alloc_func
	  zalloc;         // optional heap allocation function (defaults to malloc)
  mz_free_func zfree; // optional heap free function (defaults to free)
  void *opaque;       // heap alloc function user pointer

  int data_type;     // data_type (unused)
  mz_ulong adler;    // adler32 of the source or uncompressed data
  mz_ulong reserved; // not used
} mz_stream;

typedef mz_stream *mz_streamp;

// Returns the version string of miniz.c.
const char *mz_version(void);

// mz_deflateInit() initializes a compressor with default options:
// Parameters:
//  pStream must point to an initialized mz_stream struct.
//  level must be between [MZ_NO_COMPRESSION, MZ_BEST_COMPRESSION].
//  level 1 enables a specially optimized compression function that's been
//  optimized purely for performance, not ratio.
//  (This special func. is currently only enabled when
//  MINIZ_USE_UNALIGNED_LOADS_AND_STORES and MINIZ_LITTLE_ENDIAN are defined.)
// Return values:
//  MZ_OK on success.
//  MZ_STREAM_ERROR if the stream is bogus.
//  MZ_PARAM_ERROR if the input parameters are bogus.
//  MZ_MEM_ERROR on out of memory.
int mz_deflateInit(mz_streamp pStream, int level);

// mz_deflateInit2() is like mz_deflate(), except with more control:
// Additional parameters:
//   method must be MZ_DEFLATED
//   window_bits must be MZ_DEFAULT_WINDOW_BITS (to wrap the deflate stream with
//   zlib header/adler-32 footer) or -MZ_DEFAULT_WINDOW_BITS (raw deflate/no
//   header or footer)
//   mem_level must be between [1, 9] (it's checked but ignored by miniz.c)
int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,
					int mem_level, int strategy);

// Quickly resets a compressor without having to reallocate anything. Same as
// calling mz_deflateEnd() followed by mz_deflateInit()/mz_deflateInit2().
int mz_deflateReset(mz_streamp pStream);

// mz_deflate() compresses the input to output, consuming as much of the input
// and producing as much output as possible.
// Parameters:
//   pStream is the stream to read from and write to. You must initialize/update
//   the next_in, avail_in, next_out, and avail_out members.
//   flush may be MZ_NO_FLUSH, MZ_PARTIAL_FLUSH/MZ_SYNC_FLUSH, MZ_FULL_FLUSH, or
//   MZ_FINISH.
// Return values:
//   MZ_OK on success (when flushing, or if more input is needed but not
//   available, and/or there's more output to be written but the output buffer
//   is full).
//   MZ_STREAM_END if all input has been consumed and all output bytes have been
//   written. Don't call mz_deflate() on the stream anymore.
//   MZ_STREAM_ERROR if the stream is bogus.
//   MZ_PARAM_ERROR if one of the parameters is invalid.
//   MZ_BUF_ERROR if no forward progress is possible because the input and/or
//   output buffers are empty. (Fill up the input buffer or free up some output
//   space and try again.)
int mz_deflate(mz_streamp pStream, int flush);

// mz_deflateEnd() deinitializes a compressor:
// Return values:
//  MZ_OK on success.
//  MZ_STREAM_ERROR if the stream is bogus.
int mz_deflateEnd(mz_streamp pStream);

// mz_deflateBound() returns a (very) conservative upper bound on the amount of
// data that could be generated by deflate(), assuming flush is set to only
// MZ_NO_FLUSH or MZ_FINISH.
mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len);

// Single-call compression functions mz_compress() and mz_compress2():
// Returns MZ_OK on success, or one of the error codes from mz_deflate() on
// failure.
int mz_compress(unsigned char *pDest, mz_ulong *pDest_len,
				const unsigned char *pSource, mz_ulong source_len);
int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,
				 const unsigned char *pSource, mz_ulong source_len, int level);

// mz_compressBound() returns a (very) conservative upper bound on the amount of
// data that could be generated by calling mz_compress().
mz_ulong mz_compressBound(mz_ulong source_len);

// Initializes a decompressor.
int mz_inflateInit(mz_streamp pStream);

// mz_inflateInit2() is like mz_inflateInit() with an additional option that
// controls the window size and whether or not the stream has been wrapped with
// a zlib header/footer:
// window_bits must be MZ_DEFAULT_WINDOW_BITS (to parse zlib header/footer) or
// -MZ_DEFAULT_WINDOW_BITS (raw deflate).
int mz_inflateInit2(mz_streamp pStream, int window_bits);

// Decompresses the input stream to the output, consuming only as much of the
// input as needed, and writing as much to the output as possible.
// Parameters:
//   pStream is the stream to read from and write to. You must initialize/update
//   the next_in, avail_in, next_out, and avail_out members.
//   flush may be MZ_NO_FLUSH, MZ_SYNC_FLUSH, or MZ_FINISH.
//   On the first call, if flush is MZ_FINISH it's assumed the input and output
//   buffers are both sized large enough to decompress the entire stream in a
//   single call (this is slightly faster).
//   MZ_FINISH implies that there are no more source bytes available beside
//   what's already in the input buffer, and that the output buffer is large
//   enough to hold the rest of the decompressed data.
// Return values:
//   MZ_OK on success. Either more input is needed but not available, and/or
//   there's more output to be written but the output buffer is full.
//   MZ_STREAM_END if all needed input has been consumed and all output bytes
//   have been written. For zlib streams, the adler-32 of the decompressed data
//   has also been verified.
//   MZ_STREAM_ERROR if the stream is bogus.
//   MZ_DATA_ERROR if the deflate stream is invalid.
//   MZ_PARAM_ERROR if one of the parameters is invalid.
//   MZ_BUF_ERROR if no forward progress is possible because the input buffer is
//   empty but the inflater needs more input to continue, or if the output
//   buffer is not large enough. Call mz_inflate() again
//   with more input data, or with more room in the output buffer (except when
//   using single call decompression, described above).
int mz_inflate(mz_streamp pStream, int flush);

// Deinitializes a decompressor.
int mz_inflateEnd(mz_streamp pStream);

// Single-call decompression.
// Returns MZ_OK on success, or one of the error codes from mz_inflate() on
// failure.
int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,
				  const unsigned char *pSource, mz_ulong source_len);

// Returns a string description of the specified error code, or NULL if the
// error code is invalid.
const char *mz_error(int err);

// Redefine zlib-compatible names to miniz equivalents, so miniz.c can be used
// as a drop-in replacement for the subset of zlib that miniz.c supports.
// Define MINIZ_NO_ZLIB_COMPATIBLE_NAMES to disable zlib-compatibility if you
// use zlib in the same project.
#ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef mz_ulong uLong;
typedef Byte Bytef;
typedef uInt uIntf;
typedef char charf;
typedef int intf;
typedef void *voidpf;
typedef uLong uLongf;
typedef void *voidp;
typedef void *const voidpc;
#define Z_NULL 0
#define Z_NO_FLUSH MZ_NO_FLUSH
#define Z_PARTIAL_FLUSH MZ_PARTIAL_FLUSH
#define Z_SYNC_FLUSH MZ_SYNC_FLUSH
#define Z_FULL_FLUSH MZ_FULL_FLUSH
#define Z_FINISH MZ_FINISH
#define Z_BLOCK MZ_BLOCK
#define Z_OK MZ_OK
#define Z_STREAM_END MZ_STREAM_END
#define Z_NEED_DICT MZ_NEED_DICT
#define Z_ERRNO MZ_ERRNO
#define Z_STREAM_ERROR MZ_STREAM_ERROR
#define Z_DATA_ERROR MZ_DATA_ERROR
#define Z_MEM_ERROR MZ_MEM_ERROR
#define Z_BUF_ERROR MZ_BUF_ERROR
#define Z_VERSION_ERROR MZ_VERSION_ERROR
#define Z_PARAM_ERROR MZ_PARAM_ERROR
#define Z_NO_COMPRESSION MZ_NO_COMPRESSION
#define Z_BEST_SPEED MZ_BEST_SPEED
#define Z_BEST_COMPRESSION MZ_BEST_COMPRESSION
#define Z_DEFAULT_COMPRESSION MZ_DEFAULT_COMPRESSION
#define Z_DEFAULT_STRATEGY MZ_DEFAULT_STRATEGY
#define Z_FILTERED MZ_FILTERED
#define Z_HUFFMAN_ONLY MZ_HUFFMAN_ONLY
#define Z_RLE MZ_RLE
#define Z_FIXED MZ_FIXED
#define Z_DEFLATED MZ_DEFLATED
#define Z_DEFAULT_WINDOW_BITS MZ_DEFAULT_WINDOW_BITS
#define alloc_func mz_alloc_func
#define free_func mz_free_func
#define internal_state mz_internal_state
#define z_stream mz_stream
#define deflateInit mz_deflateInit
#define deflateInit2 mz_deflateInit2
#define deflateReset mz_deflateReset
#define deflate mz_deflate
#define deflateEnd mz_deflateEnd
#define deflateBound mz_deflateBound
#define compress mz_compress
#define compress2 mz_compress2
#define compressBound mz_compressBound
#define inflateInit mz_inflateInit
#define inflateInit2 mz_inflateInit2
#define inflate mz_inflate
#define inflateEnd mz_inflateEnd
#define uncompress mz_uncompress
#define crc32 mz_crc32
#define adler32 mz_adler32
#define MAX_WBITS 15
#define MAX_MEM_LEVEL 9
#define zError mz_error
#define ZLIB_VERSION MZ_VERSION
#define ZLIB_VERNUM MZ_VERNUM
#define ZLIB_VER_MAJOR MZ_VER_MAJOR
#define ZLIB_VER_MINOR MZ_VER_MINOR
#define ZLIB_VER_REVISION MZ_VER_REVISION
#define ZLIB_VER_SUBREVISION MZ_VER_SUBREVISION
#define zlibVersion mz_version
#define zlib_version mz_version()
#endif // #ifndef MINIZ_NO_ZLIB_COMPATIBLE_NAMES

#endif // MINIZ_NO_ZLIB_APIS

// ------------------- Types and macros

typedef unsigned char mz_uint8;
typedef signed short mz_int16;
typedef unsigned short mz_uint16;
typedef unsigned int mz_uint32;
typedef unsigned int mz_uint;
typedef long long mz_int64;
typedef unsigned long long mz_uint64;
typedef int mz_bool;

#define MZ_FALSE (0)
#define MZ_TRUE (1)

// An attempt to work around MSVC's spammy "warning C4127: conditional
// expression is constant" message.
#ifdef _MSC_VER
#define MZ_MACRO_END while (0, 0)
#else
#define MZ_MACRO_END while (0)
#endif

// ------------------- ZIP archive reading/writing

#ifndef MINIZ_NO_ARCHIVE_APIS

enum {
  MZ_ZIP_MAX_IO_BUF_SIZE = 64 * 1024,
  MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE = 260,
  MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE = 256
};

typedef struct {
  mz_uint32 m_file_index;
  mz_uint32 m_central_dir_ofs;
  mz_uint16 m_version_made_by;
  mz_uint16 m_version_needed;
  mz_uint16 m_bit_flag;
  mz_uint16 m_method;
#ifndef MINIZ_NO_TIME
  time_t m_time;
#endif
  mz_uint32 m_crc32;
  mz_uint64 m_comp_size;
  mz_uint64 m_uncomp_size;
  mz_uint16 m_internal_attr;
  mz_uint32 m_external_attr;
  mz_uint64 m_local_header_ofs;
  mz_uint32 m_comment_size;
  char m_filename[MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE];
  char m_comment[MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE];
} mz_zip_archive_file_stat;

typedef size_t (*mz_file_read_func)(void *pOpaque, mz_uint64 file_ofs,
									void *pBuf, size_t n);
typedef size_t (*mz_file_write_func)(void *pOpaque, mz_uint64 file_ofs,
									 const void *pBuf, size_t n);

struct mz_zip_internal_state_tag;
typedef struct mz_zip_internal_state_tag mz_zip_internal_state;

typedef enum {
  MZ_ZIP_MODE_INVALID = 0,
  MZ_ZIP_MODE_READING = 1,
  MZ_ZIP_MODE_WRITING = 2,
  MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED = 3
} mz_zip_mode;

typedef struct mz_zip_archive_tag {
  mz_uint64 m_archive_size;
  mz_uint64 m_central_directory_file_ofs;
  mz_uint m_total_files;
  mz_zip_mode m_zip_mode;

  mz_uint m_file_offset_alignment;

  mz_alloc_func m_pAlloc;
  mz_free_func m_pFree;
  mz_realloc_func m_pRealloc;
  void *m_pAlloc_opaque;

  mz_file_read_func m_pRead;
  mz_file_write_func m_pWrite;
  void *m_pIO_opaque;

  mz_zip_internal_state *m_pState;

} mz_zip_archive;

typedef enum {
  MZ_ZIP_FLAG_CASE_SENSITIVE = 0x0100,
  MZ_ZIP_FLAG_IGNORE_PATH = 0x0200,
  MZ_ZIP_FLAG_COMPRESSED_DATA = 0x0400,
  MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY = 0x0800
} mz_zip_flags;

// ZIP archive reading

// Inits a ZIP archive reader.
// These functions read and validate the archive's central directory.
mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,
						   mz_uint32 flags);
mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,
							   size_t size, mz_uint32 flags);

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,
								mz_uint32 flags);
#endif

// Returns the total number of files in the archive.
mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip);

// Returns detailed information about an archive file entry.
mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,
								mz_zip_archive_file_stat *pStat);

// Determines if an archive file entry is a directory entry.
mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,
										  mz_uint file_index);
mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,
										mz_uint file_index);

// Retrieves the filename of an archive file entry.
// Returns the number of bytes written to pFilename, or if filename_buf_size is
// 0 this function returns the number of bytes needed to fully store the
// filename.
mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,
								   char *pFilename, mz_uint filename_buf_size);

// Attempts to locates a file in the archive's central directory.
// Valid flags: MZ_ZIP_FLAG_CASE_SENSITIVE, MZ_ZIP_FLAG_IGNORE_PATH
// Returns -1 if the file cannot be found.
int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,
							  const char *pComment, mz_uint flags);

// Extracts a archive file to a memory buffer using no memory allocation.
mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,
											  mz_uint file_index, void *pBuf,
											  size_t buf_size, mz_uint flags,
											  void *pUser_read_buf,
											  size_t user_read_buf_size);
mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(
	mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,
	mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size);

// Extracts a archive file to a memory buffer.
mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,
									 void *pBuf, size_t buf_size,
									 mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,
										  const char *pFilename, void *pBuf,
										  size_t buf_size, mz_uint flags);

// Extracts a archive file to a dynamically allocated heap buffer.
void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,
									size_t *pSize, mz_uint flags);
void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,
										 const char *pFilename, size_t *pSize,
										 mz_uint flags);

// Extracts a archive file using a callback function to output the file's data.
mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,
										  mz_uint file_index,
										  mz_file_write_func pCallback,
										  void *pOpaque, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,
											   const char *pFilename,
											   mz_file_write_func pCallback,
											   void *pOpaque, mz_uint flags);

#ifndef MINIZ_NO_STDIO
// Extracts a archive file to a disk file and sets its last accessed and
// modified times.
// This function only extracts files, not archive directory records.
mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,
									  const char *pDst_filename, mz_uint flags);
mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,
										   const char *pArchive_filename,
										   const char *pDst_filename,
										   mz_uint flags);
#endif

// Ends archive reading, freeing all allocations, and closing the input archive
// file if mz_zip_reader_init_file() was used.
mz_bool mz_zip_reader_end(mz_zip_archive *pZip);

// ZIP archive writing

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

// Inits a ZIP archive writer.
mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size);
mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,
								size_t size_to_reserve_at_beginning,
								size_t initial_allocation_size);

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,
								mz_uint64 size_to_reserve_at_beginning);
#endif

// Converts a ZIP archive reader object into a writer object, to allow efficient
// in-place file appends to occur on an existing archive.
// For archives opened using mz_zip_reader_init_file, pFilename must be the
// archive's filename so it can be reopened for writing. If the file can't be
// reopened, mz_zip_reader_end() will be called.
// For archives opened using mz_zip_reader_init_mem, the memory block must be
// growable using the realloc callback (which defaults to realloc unless you've
// overridden it).
// Finally, for archives opened using mz_zip_reader_init, the mz_zip_archive's
// user provided m_pWrite function cannot be NULL.
// Note: In-place archive modification is not recommended unless you know what
// you're doing, because if execution stops or something goes wrong before
// the archive is finalized the file's central directory will be hosed.
mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,
									   const char *pFilename);

// Adds the contents of a memory buffer to an archive. These functions record
// the current local time into the archive.
// To add a directory entry, call this method with an archive name ending in a
// forwardslash with empty buffer.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,
// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or
// just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,
							  const void *pBuf, size_t buf_size,
							  mz_uint level_and_flags);
mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,
								 const char *pArchive_name, const void *pBuf,
								 size_t buf_size, const void *pComment,
								 mz_uint16 comment_size,
								 mz_uint level_and_flags, mz_uint64 uncomp_size,
								 mz_uint32 uncomp_crc32);

#ifndef MINIZ_NO_STDIO
// Adds the contents of a disk file to an archive. This function also records
// the disk file's modified time into the archive.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,
// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or
// just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,
							   const char *pSrc_filename, const void *pComment,
							   mz_uint16 comment_size, mz_uint level_and_flags);
#endif

// Adds a file to an archive by fully cloning the data from another archive.
// This function fully clones the source file's compressed data (no
// recompression), along with its full filename, extra data, and comment fields.
mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,
										  mz_zip_archive *pSource_zip,
										  mz_uint file_index);

// Finalizes the archive by writing the central directory records followed by
// the end of central directory record.
// After an archive is finalized, the only valid call on the mz_zip_archive
// struct is mz_zip_writer_end().
// An archive must be manually finalized by calling this function for it to be
// valid.
mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip);
mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,
											size_t *pSize);

// Ends archive writing, freeing all allocations, and closing the output file if
// mz_zip_writer_init_file() was used.
// Note for the archive to be valid, it must have been finalized before ending.
mz_bool mz_zip_writer_end(mz_zip_archive *pZip);

// Misc. high-level helper functions:

// mz_zip_add_mem_to_archive_file_in_place() efficiently (but not atomically)
// appends a memory blob to a ZIP archive.
// level_and_flags - compression level (0-10, see MZ_BEST_SPEED,
// MZ_BEST_COMPRESSION, etc.) logically OR'd with zero or more mz_zip_flags, or
// just set to MZ_DEFAULT_COMPRESSION.
mz_bool mz_zip_add_mem_to_archive_file_in_place(
	const char *pZip_filename, const char *pArchive_name, const void *pBuf,
	size_t buf_size, const void *pComment, mz_uint16 comment_size,
	mz_uint level_and_flags);

// Reads a single file from an archive into a heap block.
// Returns NULL on failure.
void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,
										  const char *pArchive_name,
										  size_t *pSize, mz_uint zip_flags);

#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

#endif // #ifndef MINIZ_NO_ARCHIVE_APIS

// ------------------- Low-level Decompression API Definitions

// Decompression flags used by tinfl_decompress().
// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and
// ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the
// input is a raw deflate stream.
// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available
// beyond the end of the supplied input buffer. If clear, the input buffer
// contains all remaining input.
// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large
// enough to hold the entire decompressed stream. If clear, the output buffer is
// at least the size of the dictionary (typically 32KB).
// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the
// decompressed bytes.
enum {
  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,
  TINFL_FLAG_HAS_MORE_INPUT = 2,
  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,
  TINFL_FLAG_COMPUTE_ADLER32 = 8
};

// High level decompression functions:
// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block
// allocated via malloc().
// On entry:
//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data
//  to decompress.
// On return:
//  Function returns a pointer to the decompressed data, or NULL on failure.
//  *pOut_len will be set to the decompressed data's size, which could be larger
//  than src_buf_len on uncompressible data.
//  The caller must call mz_free() on the returned block when it's no longer
//  needed.
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
								   size_t *pOut_len, int flags);

// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block
// in memory.
// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes
// written on success.
#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))
size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
								   const void *pSrc_buf, size_t src_buf_len,
								   int flags);

// tinfl_decompress_mem_to_callback() decompresses a block in memory to an
// internal 32KB buffer, and a user provided callback function will be called to
// flush the buffer.
// Returns 1 on success or 0 on failure.
typedef int (*tinfl_put_buf_func_ptr)(const void *pBuf, int len, void *pUser);
int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,
									 tinfl_put_buf_func_ptr pPut_buf_func,
									 void *pPut_buf_user, int flags);

struct tinfl_decompressor_tag;
typedef struct tinfl_decompressor_tag tinfl_decompressor;

// Max size of LZ dictionary.
#define TINFL_LZ_DICT_SIZE 32768

// Return status.
typedef enum {
  TINFL_STATUS_BAD_PARAM = -3,
  TINFL_STATUS_ADLER32_MISMATCH = -2,
  TINFL_STATUS_FAILED = -1,
  TINFL_STATUS_DONE = 0,
  TINFL_STATUS_NEEDS_MORE_INPUT = 1,
  TINFL_STATUS_HAS_MORE_OUTPUT = 2
} tinfl_status;

// Initializes the decompressor to its initial state.
#define tinfl_init(r)                                                          \
  do {                                                                         \
	(r)->m_state = 0;                                                          \
  }                                                                            \
  MZ_MACRO_END
#define tinfl_get_adler32(r) (r)->m_check_adler32

// Main low-level decompressor coroutine function. This is the only function
// actually needed for decompression. All the other functions are just
// high-level helpers for improved usability.
// This is a universal API, i.e. it can be used as a building block to build any
// desired higher level decompression API. In the limit case, it can be called
// once per every byte input or output.
tinfl_status tinfl_decompress(tinfl_decompressor *r,
							  const mz_uint8 *pIn_buf_next,
							  size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,
							  mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
							  const mz_uint32 decomp_flags);

// Internal/private bits follow.
enum {
  TINFL_MAX_HUFF_TABLES = 3,
  TINFL_MAX_HUFF_SYMBOLS_0 = 288,
  TINFL_MAX_HUFF_SYMBOLS_1 = 32,
  TINFL_MAX_HUFF_SYMBOLS_2 = 19,
  TINFL_FAST_LOOKUP_BITS = 10,
  TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS
};

typedef struct {
  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];
  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE],
	  m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];
} tinfl_huff_table;

#if MINIZ_HAS_64BIT_REGISTERS
#define TINFL_USE_64BIT_BITBUF 1
#endif

#if TINFL_USE_64BIT_BITBUF
typedef mz_uint64 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (64)
#else
typedef mz_uint32 tinfl_bit_buf_t;
#define TINFL_BITBUF_SIZE (32)
#endif

struct tinfl_decompressor_tag {
  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type,
	  m_check_adler32, m_dist, m_counter, m_num_extra,
	  m_table_sizes[TINFL_MAX_HUFF_TABLES];
  tinfl_bit_buf_t m_bit_buf;
  size_t m_dist_from_out_buf_start;
  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];
  mz_uint8 m_raw_header[4],
	  m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];
};

// ------------------- Low-level Compression API Definitions

// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly
// slower, and raw/dynamic blocks will be output more frequently).
#define TDEFL_LESS_MEMORY 0

// tdefl_init() compression flags logically OR'd together (low 12 bits contain
// the max. number of probes per dictionary search):
// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes
// per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap
// compression), 4095=Huffman+LZ (slowest/best compression).
enum {
  TDEFL_HUFFMAN_ONLY = 0,
  TDEFL_DEFAULT_MAX_PROBES = 128,
  TDEFL_MAX_PROBES_MASK = 0xFFF
};

// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before
// the deflate data, and the Adler-32 of the source data at the end. Otherwise,
// you'll get raw deflate data.
// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even
// when not writing zlib headers).
// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more
// efficient lazy parsing.
// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's
// initialization time to the minimum, but the output may vary from run to run
// given the same input (depending on the contents of memory).
// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)
// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.
// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.
// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.
// The low 12 bits are reserved to control the max # of hash probes per
// dictionary lookup (see TDEFL_MAX_PROBES_MASK).
enum {
  TDEFL_WRITE_ZLIB_HEADER = 0x01000,
  TDEFL_COMPUTE_ADLER32 = 0x02000,
  TDEFL_GREEDY_PARSING_FLAG = 0x04000,
  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,
  TDEFL_RLE_MATCHES = 0x10000,
  TDEFL_FILTER_MATCHES = 0x20000,
  TDEFL_FORCE_ALL_STATIC_BLOCKS = 0x40000,
  TDEFL_FORCE_ALL_RAW_BLOCKS = 0x80000
};

// High level compression functions:
// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block
// allocated via malloc().
// On entry:
//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.
//  flags: The max match finder probes (default is 128) logically OR'd against
//  the above flags. Higher probes are slower but improve compression.
// On return:
//  Function returns a pointer to the compressed data, or NULL on failure.
//  *pOut_len will be set to the compressed data's size, which could be larger
//  than src_buf_len on uncompressible data.
//  The caller must free() the returned block when it's no longer needed.
void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
								 size_t *pOut_len, int flags);

// tdefl_compress_mem_to_mem() compresses a block in memory to another block in
// memory.
// Returns 0 on failure.
size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
								 const void *pSrc_buf, size_t src_buf_len,
								 int flags);

// Compresses an image to a compressed PNG file in memory.
// On entry:
//  pImage, w, h, and num_chans describe the image to compress. num_chans may be
//  1, 2, 3, or 4.
//  The image pitch in bytes per scanline will be w*num_chans. The leftmost
//  pixel on the top scanline is stored first in memory.
//  level may range from [0,10], use MZ_NO_COMPRESSION, MZ_BEST_SPEED,
//  MZ_BEST_COMPRESSION, etc. or a decent default is MZ_DEFAULT_LEVEL
//  If flip is true, the image will be flipped on the Y axis (useful for OpenGL
//  apps).
// On return:
//  Function returns a pointer to the compressed data, or NULL on failure.
//  *pLen_out will be set to the size of the PNG image file.
//  The caller must mz_free() the returned heap block (which will typically be
//  larger than *pLen_out) when it's no longer needed.
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,
												 int h, int num_chans,
												 size_t *pLen_out,
												 mz_uint level, mz_bool flip);
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,
											  int num_chans, size_t *pLen_out);

// Output stream interface. The compressor uses this interface to write
// compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.
typedef mz_bool (*tdefl_put_buf_func_ptr)(const void *pBuf, int len,
										  void *pUser);

// tdefl_compress_mem_to_output() compresses a block to an output stream. The
// above helpers use this function internally.
mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,
									 tdefl_put_buf_func_ptr pPut_buf_func,
									 void *pPut_buf_user, int flags);

enum {
  TDEFL_MAX_HUFF_TABLES = 3,
  TDEFL_MAX_HUFF_SYMBOLS_0 = 288,
  TDEFL_MAX_HUFF_SYMBOLS_1 = 32,
  TDEFL_MAX_HUFF_SYMBOLS_2 = 19,
  TDEFL_LZ_DICT_SIZE = 32768,
  TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1,
  TDEFL_MIN_MATCH_LEN = 3,
  TDEFL_MAX_MATCH_LEN = 258
};

// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed
// output block (using static/fixed Huffman codes).
#if TDEFL_LESS_MEMORY
enum {
  TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024,
  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
  TDEFL_MAX_HUFF_SYMBOLS = 288,
  TDEFL_LZ_HASH_BITS = 12,
  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#else
enum {
  TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024,
  TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13) / 10,
  TDEFL_MAX_HUFF_SYMBOLS = 288,
  TDEFL_LZ_HASH_BITS = 15,
  TDEFL_LEVEL1_HASH_SIZE_MASK = 4095,
  TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3,
  TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS
};
#endif

// The low-level tdefl functions below may be used directly if the above helper
// functions aren't flexible enough. The low-level functions don't make any heap
// allocations, unlike the above helper functions.
typedef enum {
  TDEFL_STATUS_BAD_PARAM = -2,
  TDEFL_STATUS_PUT_BUF_FAILED = -1,
  TDEFL_STATUS_OKAY = 0,
  TDEFL_STATUS_DONE = 1,
} tdefl_status;

// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums
typedef enum {
  TDEFL_NO_FLUSH = 0,
  TDEFL_SYNC_FLUSH = 2,
  TDEFL_FULL_FLUSH = 3,
  TDEFL_FINISH = 4
} tdefl_flush;

// tdefl's compression state structure.
typedef struct {
  tdefl_put_buf_func_ptr m_pPut_buf_func;
  void *m_pPut_buf_user;
  mz_uint m_flags, m_max_probes[2];
  int m_greedy_parsing;
  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;
  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;
  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in,
	  m_bit_buffer;
  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit,
	  m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index,
	  m_wants_to_finish;
  tdefl_status m_prev_return_status;
  const void *m_pIn_buf;
  void *m_pOut_buf;
  size_t *m_pIn_buf_size, *m_pOut_buf_size;
  tdefl_flush m_flush;
  const mz_uint8 *m_pSrc;
  size_t m_src_buf_left, m_out_buf_ofs;
  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];
  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];
  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];
  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];
  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];
  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];
} tdefl_compressor;

// Initializes the compressor.
// There is no corresponding deinit() function because the tdefl API's do not
// dynamically allocate memory.
// pBut_buf_func: If NULL, output data will be supplied to the specified
// callback. In this case, the user should call the tdefl_compress_buffer() API
// for compression.
// If pBut_buf_func is NULL the user should always call the tdefl_compress()
// API.
// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER,
// etc.)
tdefl_status tdefl_init(tdefl_compressor *d,
						tdefl_put_buf_func_ptr pPut_buf_func,
						void *pPut_buf_user, int flags);

// Compresses a block of data, consuming as much of the specified input buffer
// as possible, and writing as much compressed data to the specified output
// buffer as possible.
tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,
							size_t *pIn_buf_size, void *pOut_buf,
							size_t *pOut_buf_size, tdefl_flush flush);

// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a
// non-NULL tdefl_put_buf_func_ptr.
// tdefl_compress_buffer() always consumes the entire input buffer.
tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,
								   size_t in_buf_size, tdefl_flush flush);

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);
mz_uint32 tdefl_get_adler32(tdefl_compressor *d);

// Can't use tdefl_create_comp_flags_from_zip_params if MINIZ_NO_ZLIB_APIS isn't
// defined, because it uses some of its macros.
#ifndef MINIZ_NO_ZLIB_APIS
// Create tdefl_compress() flags given zlib-style compression parameters.
// level may range from [0,10] (where 10 is absolute max compression, but may be
// much slower on some files)
// window_bits may be -15 (raw deflate) or 15 (zlib)
// strategy may be either MZ_DEFAULT_STRATEGY, MZ_FILTERED, MZ_HUFFMAN_ONLY,
// MZ_RLE, or MZ_FIXED
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,
												int strategy);
#endif // #ifndef MINIZ_NO_ZLIB_APIS

#ifdef __cplusplus
}
#endif

#endif // MINIZ_HEADER_INCLUDED

// ------------------- End of Header: Implementation follows. (If you only want
// the header, define MINIZ_HEADER_FILE_ONLY.)

#ifndef MINIZ_HEADER_FILE_ONLY

typedef unsigned char mz_validate_uint16[sizeof(mz_uint16) == 2 ? 1 : -1];
typedef unsigned char mz_validate_uint32[sizeof(mz_uint32) == 4 ? 1 : -1];
typedef unsigned char mz_validate_uint64[sizeof(mz_uint64) == 8 ? 1 : -1];

#include <string.h>
#include <assert.h>

#define MZ_ASSERT(x) assert(x)

#ifdef MINIZ_NO_MALLOC
#define MZ_MALLOC(x) NULL
#define MZ_FREE(x) (void) x, ((void)0)
#define MZ_REALLOC(p, x) NULL
#else
#define MZ_MALLOC(x) malloc(x)
#define MZ_FREE(x) free(x)
#define MZ_REALLOC(p, x) realloc(p, x)
#endif

#define MZ_MAX(a, b) (((a) > (b)) ? (a) : (b))
#define MZ_MIN(a, b) (((a) < (b)) ? (a) : (b))
#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))
#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))
#else
#define MZ_READ_LE16(p)                                                        \
  ((mz_uint32)(((const mz_uint8 *)(p))[0]) |                                   \
   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))
#define MZ_READ_LE32(p)                                                        \
  ((mz_uint32)(((const mz_uint8 *)(p))[0]) |                                   \
   ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) |                           \
   ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) |                          \
   ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))
#endif

#ifdef _MSC_VER
#define MZ_FORCEINLINE __forceinline
#elif defined(__GNUC__)
#define MZ_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define MZ_FORCEINLINE inline
#endif

#ifdef __cplusplus
extern "C" {
#endif

// ------------------- zlib-style API's

mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len) {
  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16);
  size_t block_len = buf_len % 5552;
  if (!ptr)
	return MZ_ADLER32_INIT;
  while (buf_len) {
	for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
	  s1 += ptr[0], s2 += s1;
	  s1 += ptr[1], s2 += s1;
	  s1 += ptr[2], s2 += s1;
	  s1 += ptr[3], s2 += s1;
	  s1 += ptr[4], s2 += s1;
	  s1 += ptr[5], s2 += s1;
	  s1 += ptr[6], s2 += s1;
	  s1 += ptr[7], s2 += s1;
	}
	for (; i < block_len; ++i)
	  s1 += *ptr++, s2 += s1;
	s1 %= 65521U, s2 %= 65521U;
	buf_len -= block_len;
	block_len = 5552;
  }
  return (s2 << 16) + s1;
}

// Karl Malbrain's compact CRC-32. See "A compact CCITT crc16 and crc32 C
// implementation that balances processor cache usage against speed":
// http://www.geocities.com/malbrain/
mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len) {
  static const mz_uint32 s_crc32[16] = {
	  0,          0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4,
	  0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
	  0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c};
  mz_uint32 crcu32 = (mz_uint32)crc;
  if (!ptr)
	return MZ_CRC32_INIT;
  crcu32 = ~crcu32;
  while (buf_len--) {
	mz_uint8 b = *ptr++;
	crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)];
	crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)];
  }
  return ~crcu32;
}

void mz_free(void *p) { MZ_FREE(p); }

#ifndef MINIZ_NO_ZLIB_APIS

static void *def_alloc_func(void *opaque, size_t items, size_t size) {
  (void)opaque, (void)items, (void)size;
  return MZ_MALLOC(items * size);
}
static void def_free_func(void *opaque, void *address) {
  (void)opaque, (void)address;
  MZ_FREE(address);
}
static void *def_realloc_func(void *opaque, void *address, size_t items,
							  size_t size) {
  (void)opaque, (void)address, (void)items, (void)size;
  return MZ_REALLOC(address, items * size);
}

const char *mz_version(void) { return MZ_VERSION; }

int mz_deflateInit(mz_streamp pStream, int level) {
  return mz_deflateInit2(pStream, level, MZ_DEFLATED, MZ_DEFAULT_WINDOW_BITS, 9,
						 MZ_DEFAULT_STRATEGY);
}

int mz_deflateInit2(mz_streamp pStream, int level, int method, int window_bits,
					int mem_level, int strategy) {
  tdefl_compressor *pComp;
  mz_uint comp_flags =
	  TDEFL_COMPUTE_ADLER32 |
	  tdefl_create_comp_flags_from_zip_params(level, window_bits, strategy);

  if (!pStream)
	return MZ_STREAM_ERROR;
  if ((method != MZ_DEFLATED) || ((mem_level < 1) || (mem_level > 9)) ||
	  ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&
	   (-window_bits != MZ_DEFAULT_WINDOW_BITS)))
	return MZ_PARAM_ERROR;

  pStream->data_type = 0;
  pStream->adler = MZ_ADLER32_INIT;
  pStream->msg = NULL;
  pStream->reserved = 0;
  pStream->total_in = 0;
  pStream->total_out = 0;
  if (!pStream->zalloc)
	pStream->zalloc = def_alloc_func;
  if (!pStream->zfree)
	pStream->zfree = def_free_func;

  pComp = (tdefl_compressor *)pStream->zalloc(pStream->opaque, 1,
											  sizeof(tdefl_compressor));
  if (!pComp)
	return MZ_MEM_ERROR;

  pStream->state = (struct mz_internal_state *)pComp;

  if (tdefl_init(pComp, NULL, NULL, comp_flags) != TDEFL_STATUS_OKAY) {
	mz_deflateEnd(pStream);
	return MZ_PARAM_ERROR;
  }

  return MZ_OK;
}

int mz_deflateReset(mz_streamp pStream) {
  if ((!pStream) || (!pStream->state) || (!pStream->zalloc) ||
	  (!pStream->zfree))
	return MZ_STREAM_ERROR;
  pStream->total_in = pStream->total_out = 0;
  tdefl_init((tdefl_compressor *)pStream->state, NULL, NULL,
			 ((tdefl_compressor *)pStream->state)->m_flags);
  return MZ_OK;
}

int mz_deflate(mz_streamp pStream, int flush) {
  size_t in_bytes, out_bytes;
  mz_ulong orig_total_in, orig_total_out;
  int mz_status = MZ_OK;

  if ((!pStream) || (!pStream->state) || (flush < 0) || (flush > MZ_FINISH) ||
	  (!pStream->next_out))
	return MZ_STREAM_ERROR;
  if (!pStream->avail_out)
	return MZ_BUF_ERROR;

  if (flush == MZ_PARTIAL_FLUSH)
	flush = MZ_SYNC_FLUSH;

  if (((tdefl_compressor *)pStream->state)->m_prev_return_status ==
	  TDEFL_STATUS_DONE)
	return (flush == MZ_FINISH) ? MZ_STREAM_END : MZ_BUF_ERROR;

  orig_total_in = pStream->total_in;
  orig_total_out = pStream->total_out;
  for (;;) {
	tdefl_status defl_status;
	in_bytes = pStream->avail_in;
	out_bytes = pStream->avail_out;

	defl_status = tdefl_compress((tdefl_compressor *)pStream->state,
								 pStream->next_in, &in_bytes, pStream->next_out,
								 &out_bytes, (tdefl_flush)flush);
	pStream->next_in += (mz_uint)in_bytes;
	pStream->avail_in -= (mz_uint)in_bytes;
	pStream->total_in += (mz_uint)in_bytes;
	pStream->adler = tdefl_get_adler32((tdefl_compressor *)pStream->state);

	pStream->next_out += (mz_uint)out_bytes;
	pStream->avail_out -= (mz_uint)out_bytes;
	pStream->total_out += (mz_uint)out_bytes;

	if (defl_status < 0) {
	  mz_status = MZ_STREAM_ERROR;
	  break;
	} else if (defl_status == TDEFL_STATUS_DONE) {
	  mz_status = MZ_STREAM_END;
	  break;
	} else if (!pStream->avail_out)
	  break;
	else if ((!pStream->avail_in) && (flush != MZ_FINISH)) {
	  if ((flush) || (pStream->total_in != orig_total_in) ||
		  (pStream->total_out != orig_total_out))
		break;
	  return MZ_BUF_ERROR; // Can't make forward progress without some input.
	}
  }
  return mz_status;
}

int mz_deflateEnd(mz_streamp pStream) {
  if (!pStream)
	return MZ_STREAM_ERROR;
  if (pStream->state) {
	pStream->zfree(pStream->opaque, pStream->state);
	pStream->state = NULL;
  }
  return MZ_OK;
}

mz_ulong mz_deflateBound(mz_streamp pStream, mz_ulong source_len) {
  (void)pStream;
  // This is really over conservative. (And lame, but it's actually pretty
  // tricky to compute a true upper bound given the way tdefl's blocking works.)
  return MZ_MAX(128 + (source_len * 110) / 100,
				128 + source_len + ((source_len / (31 * 1024)) + 1) * 5);
}

int mz_compress2(unsigned char *pDest, mz_ulong *pDest_len,
				 const unsigned char *pSource, mz_ulong source_len, int level) {
  int status;
  mz_stream stream;
  memset(&stream, 0, sizeof(stream));

  // In case mz_ulong is 64-bits (argh I hate longs).
  if ((source_len | *pDest_len) > 0xFFFFFFFFU)
	return MZ_PARAM_ERROR;

  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;

  status = mz_deflateInit(&stream, level);
  if (status != MZ_OK)
	return status;

  status = mz_deflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END) {
	mz_deflateEnd(&stream);
	return (status == MZ_OK) ? MZ_BUF_ERROR : status;
  }

  *pDest_len = stream.total_out;
  return mz_deflateEnd(&stream);
}

int mz_compress(unsigned char *pDest, mz_ulong *pDest_len,
				const unsigned char *pSource, mz_ulong source_len) {
  return mz_compress2(pDest, pDest_len, pSource, source_len,
					  MZ_DEFAULT_COMPRESSION);
}

mz_ulong mz_compressBound(mz_ulong source_len) {
  return mz_deflateBound(NULL, source_len);
}

typedef struct {
  tinfl_decompressor m_decomp;
  mz_uint m_dict_ofs, m_dict_avail, m_first_call, m_has_flushed;
  int m_window_bits;
  mz_uint8 m_dict[TINFL_LZ_DICT_SIZE];
  tinfl_status m_last_status;
} inflate_state;

int mz_inflateInit2(mz_streamp pStream, int window_bits) {
  inflate_state *pDecomp;
  if (!pStream)
	return MZ_STREAM_ERROR;
  if ((window_bits != MZ_DEFAULT_WINDOW_BITS) &&
	  (-window_bits != MZ_DEFAULT_WINDOW_BITS))
	return MZ_PARAM_ERROR;

  pStream->data_type = 0;
  pStream->adler = 0;
  pStream->msg = NULL;
  pStream->total_in = 0;
  pStream->total_out = 0;
  pStream->reserved = 0;
  if (!pStream->zalloc)
	pStream->zalloc = def_alloc_func;
  if (!pStream->zfree)
	pStream->zfree = def_free_func;

  pDecomp = (inflate_state *)pStream->zalloc(pStream->opaque, 1,
											 sizeof(inflate_state));
  if (!pDecomp)
	return MZ_MEM_ERROR;

  pStream->state = (struct mz_internal_state *)pDecomp;

  tinfl_init(&pDecomp->m_decomp);
  pDecomp->m_dict_ofs = 0;
  pDecomp->m_dict_avail = 0;
  pDecomp->m_last_status = TINFL_STATUS_NEEDS_MORE_INPUT;
  pDecomp->m_first_call = 1;
  pDecomp->m_has_flushed = 0;
  pDecomp->m_window_bits = window_bits;

  return MZ_OK;
}

int mz_inflateInit(mz_streamp pStream) {
  return mz_inflateInit2(pStream, MZ_DEFAULT_WINDOW_BITS);
}

int mz_inflate(mz_streamp pStream, int flush) {
  inflate_state *pState;
  mz_uint n, first_call, decomp_flags = TINFL_FLAG_COMPUTE_ADLER32;
  size_t in_bytes, out_bytes, orig_avail_in;
  tinfl_status status;

  if ((!pStream) || (!pStream->state))
	return MZ_STREAM_ERROR;
  if (flush == MZ_PARTIAL_FLUSH)
	flush = MZ_SYNC_FLUSH;
  if ((flush) && (flush != MZ_SYNC_FLUSH) && (flush != MZ_FINISH))
	return MZ_STREAM_ERROR;

  pState = (inflate_state *)pStream->state;
  if (pState->m_window_bits > 0)
	decomp_flags |= TINFL_FLAG_PARSE_ZLIB_HEADER;
  orig_avail_in = pStream->avail_in;

  first_call = pState->m_first_call;
  pState->m_first_call = 0;
  if (pState->m_last_status < 0)
	return MZ_DATA_ERROR;

  if (pState->m_has_flushed && (flush != MZ_FINISH))
	return MZ_STREAM_ERROR;
  pState->m_has_flushed |= (flush == MZ_FINISH);

  if ((flush == MZ_FINISH) && (first_call)) {
	// MZ_FINISH on the first call implies that the input and output buffers are
	// large enough to hold the entire compressed/decompressed file.
	decomp_flags |= TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF;
	in_bytes = pStream->avail_in;
	out_bytes = pStream->avail_out;
	status = tinfl_decompress(&pState->m_decomp, pStream->next_in, &in_bytes,
							  pStream->next_out, pStream->next_out, &out_bytes,
							  decomp_flags);
	pState->m_last_status = status;
	pStream->next_in += (mz_uint)in_bytes;
	pStream->avail_in -= (mz_uint)in_bytes;
	pStream->total_in += (mz_uint)in_bytes;
	pStream->adler = tinfl_get_adler32(&pState->m_decomp);
	pStream->next_out += (mz_uint)out_bytes;
	pStream->avail_out -= (mz_uint)out_bytes;
	pStream->total_out += (mz_uint)out_bytes;

	if (status < 0)
	  return MZ_DATA_ERROR;
	else if (status != TINFL_STATUS_DONE) {
	  pState->m_last_status = TINFL_STATUS_FAILED;
	  return MZ_BUF_ERROR;
	}
	return MZ_STREAM_END;
  }
  // flush != MZ_FINISH then we must assume there's more input.
  if (flush != MZ_FINISH)
	decomp_flags |= TINFL_FLAG_HAS_MORE_INPUT;

  if (pState->m_dict_avail) {
	n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
	memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
	pStream->next_out += n;
	pStream->avail_out -= n;
	pStream->total_out += n;
	pState->m_dict_avail -= n;
	pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);
	return ((pState->m_last_status == TINFL_STATUS_DONE) &&
			(!pState->m_dict_avail))
			   ? MZ_STREAM_END
			   : MZ_OK;
  }

  for (;;) {
	in_bytes = pStream->avail_in;
	out_bytes = TINFL_LZ_DICT_SIZE - pState->m_dict_ofs;

	status = tinfl_decompress(
		&pState->m_decomp, pStream->next_in, &in_bytes, pState->m_dict,
		pState->m_dict + pState->m_dict_ofs, &out_bytes, decomp_flags);
	pState->m_last_status = status;

	pStream->next_in += (mz_uint)in_bytes;
	pStream->avail_in -= (mz_uint)in_bytes;
	pStream->total_in += (mz_uint)in_bytes;
	pStream->adler = tinfl_get_adler32(&pState->m_decomp);

	pState->m_dict_avail = (mz_uint)out_bytes;

	n = MZ_MIN(pState->m_dict_avail, pStream->avail_out);
	memcpy(pStream->next_out, pState->m_dict + pState->m_dict_ofs, n);
	pStream->next_out += n;
	pStream->avail_out -= n;
	pStream->total_out += n;
	pState->m_dict_avail -= n;
	pState->m_dict_ofs = (pState->m_dict_ofs + n) & (TINFL_LZ_DICT_SIZE - 1);

	if (status < 0)
	  return MZ_DATA_ERROR; // Stream is corrupted (there could be some
							// uncompressed data left in the output dictionary -
							// oh well).
	else if ((status == TINFL_STATUS_NEEDS_MORE_INPUT) && (!orig_avail_in))
	  return MZ_BUF_ERROR; // Signal caller that we can't make forward progress
						   // without supplying more input or by setting flush
						   // to MZ_FINISH.
	else if (flush == MZ_FINISH) {
	  // The output buffer MUST be large to hold the remaining uncompressed data
	  // when flush==MZ_FINISH.
	  if (status == TINFL_STATUS_DONE)
		return pState->m_dict_avail ? MZ_BUF_ERROR : MZ_STREAM_END;
	  // status here must be TINFL_STATUS_HAS_MORE_OUTPUT, which means there's
	  // at least 1 more byte on the way. If there's no more room left in the
	  // output buffer then something is wrong.
	  else if (!pStream->avail_out)
		return MZ_BUF_ERROR;
	} else if ((status == TINFL_STATUS_DONE) || (!pStream->avail_in) ||
			   (!pStream->avail_out) || (pState->m_dict_avail))
	  break;
  }

  return ((status == TINFL_STATUS_DONE) && (!pState->m_dict_avail))
			 ? MZ_STREAM_END
			 : MZ_OK;
}

int mz_inflateEnd(mz_streamp pStream) {
  if (!pStream)
	return MZ_STREAM_ERROR;
  if (pStream->state) {
	pStream->zfree(pStream->opaque, pStream->state);
	pStream->state = NULL;
  }
  return MZ_OK;
}

int mz_uncompress(unsigned char *pDest, mz_ulong *pDest_len,
				  const unsigned char *pSource, mz_ulong source_len) {
  mz_stream stream;
  int status;
  memset(&stream, 0, sizeof(stream));

  // In case mz_ulong is 64-bits (argh I hate longs).
  if ((source_len | *pDest_len) > 0xFFFFFFFFU)
	return MZ_PARAM_ERROR;

  stream.next_in = pSource;
  stream.avail_in = (mz_uint32)source_len;
  stream.next_out = pDest;
  stream.avail_out = (mz_uint32)*pDest_len;

  status = mz_inflateInit(&stream);
  if (status != MZ_OK)
	return status;

  status = mz_inflate(&stream, MZ_FINISH);
  if (status != MZ_STREAM_END) {
	mz_inflateEnd(&stream);
	return ((status == MZ_BUF_ERROR) && (!stream.avail_in)) ? MZ_DATA_ERROR
															: status;
  }
  *pDest_len = stream.total_out;

  return mz_inflateEnd(&stream);
}

const char *mz_error(int err) {
  static struct {
	int m_err;
	const char *m_pDesc;
  } s_error_descs[] = {{MZ_OK, ""},
					   {MZ_STREAM_END, "stream end"},
					   {MZ_NEED_DICT, "need dictionary"},
					   {MZ_ERRNO, "file error"},
					   {MZ_STREAM_ERROR, "stream error"},
					   {MZ_DATA_ERROR, "data error"},
					   {MZ_MEM_ERROR, "out of memory"},
					   {MZ_BUF_ERROR, "buf error"},
					   {MZ_VERSION_ERROR, "version error"},
					   {MZ_PARAM_ERROR, "parameter error"}};
  mz_uint i;
  for (i = 0; i < sizeof(s_error_descs) / sizeof(s_error_descs[0]); ++i)
	if (s_error_descs[i].m_err == err)
	  return s_error_descs[i].m_pDesc;
  return NULL;
}

#endif // MINIZ_NO_ZLIB_APIS

// ------------------- Low-level Decompression (completely independent from all
// compression API's)

#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)
#define TINFL_MEMSET(p, c, l) memset(p, c, l)

#define TINFL_CR_BEGIN                                                         \
  switch (r->m_state) {                                                        \
  case 0:
#define TINFL_CR_RETURN(state_index, result)                                   \
  do {                                                                         \
	status = result;                                                           \
	r->m_state = state_index;                                                  \
	goto common_exit;                                                          \
  case state_index:                                                            \
	;                                                                          \
  }                                                                            \
  MZ_MACRO_END
#define TINFL_CR_RETURN_FOREVER(state_index, result)                           \
  do {                                                                         \
	for (;;) {                                                                 \
	  TINFL_CR_RETURN(state_index, result);                                    \
	}                                                                          \
  }                                                                            \
  MZ_MACRO_END
#define TINFL_CR_FINISH }

// TODO: If the caller has indicated that there's no more input, and we attempt
// to read beyond the input buf, then something is wrong with the input because
// the inflator never
// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of
// the stream with 0's in this scenario.
#define TINFL_GET_BYTE(state_index, c)                                         \
  do {                                                                         \
	if (pIn_buf_cur >= pIn_buf_end) {                                          \
	  for (;;) {                                                               \
		if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {                        \
		  TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT);         \
		  if (pIn_buf_cur < pIn_buf_end) {                                     \
			c = *pIn_buf_cur++;                                                \
			break;                                                             \
		  }                                                                    \
		} else {                                                               \
		  c = 0;                                                               \
		  break;                                                               \
		}                                                                      \
	  }                                                                        \
	} else                                                                     \
	  c = *pIn_buf_cur++;                                                      \
  }                                                                            \
  MZ_MACRO_END

#define TINFL_NEED_BITS(state_index, n)                                        \
  do {                                                                         \
	mz_uint c;                                                                 \
	TINFL_GET_BYTE(state_index, c);                                            \
	bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                             \
	num_bits += 8;                                                             \
  } while (num_bits < (mz_uint)(n))
#define TINFL_SKIP_BITS(state_index, n)                                        \
  do {                                                                         \
	if (num_bits < (mz_uint)(n)) {                                             \
	  TINFL_NEED_BITS(state_index, n);                                         \
	}                                                                          \
	bit_buf >>= (n);                                                           \
	num_bits -= (n);                                                           \
  }                                                                            \
  MZ_MACRO_END
#define TINFL_GET_BITS(state_index, b, n)                                      \
  do {                                                                         \
	if (num_bits < (mz_uint)(n)) {                                             \
	  TINFL_NEED_BITS(state_index, n);                                         \
	}                                                                          \
	b = bit_buf & ((1 << (n)) - 1);                                            \
	bit_buf >>= (n);                                                           \
	num_bits -= (n);                                                           \
  }                                                                            \
  MZ_MACRO_END

// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes
// remaining in the input buffer falls below 2.
// It reads just enough bytes from the input stream that are needed to decode
// the next Huffman code (and absolutely no more). It works by trying to fully
// decode a
// Huffman code by using whatever bits are currently present in the bit buffer.
// If this fails, it reads another byte, and tries again until it succeeds or
// until the
// bit buffer contains >=15 bits (deflate's max. Huffman code size).
#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff)                             \
  do {                                                                         \
	temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)];         \
	if (temp >= 0) {                                                           \
	  code_len = temp >> 9;                                                    \
	  if ((code_len) && (num_bits >= code_len))                                \
		break;                                                                 \
	} else if (num_bits > TINFL_FAST_LOOKUP_BITS) {                            \
	  code_len = TINFL_FAST_LOOKUP_BITS;                                       \
	  do {                                                                     \
		temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];         \
	  } while ((temp < 0) && (num_bits >= (code_len + 1)));                    \
	  if (temp >= 0)                                                           \
		break;                                                                 \
	}                                                                          \
	TINFL_GET_BYTE(state_index, c);                                            \
	bit_buf |= (((tinfl_bit_buf_t)c) << num_bits);                             \
	num_bits += 8;                                                             \
  } while (num_bits < 15);

// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex
// than you would initially expect because the zlib API expects the decompressor
// to never read
// beyond the final byte of the deflate stream. (In other words, when this macro
// wants to read another byte from the input, it REALLY needs another byte in
// order to fully
// decode the next Huffman code.) Handling this properly is particularly
// important on raw deflate (non-zlib) streams, which aren't followed by a byte
// aligned adler-32.
// The slow path is only executed at the very end of the input buffer.
#define TINFL_HUFF_DECODE(state_index, sym, pHuff)                             \
  do {                                                                         \
	int temp;                                                                  \
	mz_uint code_len, c;                                                       \
	if (num_bits < 15) {                                                       \
	  if ((pIn_buf_end - pIn_buf_cur) < 2) {                                   \
		TINFL_HUFF_BITBUF_FILL(state_index, pHuff);                            \
	  } else {                                                                 \
		bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) |           \
				   (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8));      \
		pIn_buf_cur += 2;                                                      \
		num_bits += 16;                                                        \
	  }                                                                        \
	}                                                                          \
	if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= \
		0)                                                                     \
	  code_len = temp >> 9, temp &= 511;                                       \
	else {                                                                     \
	  code_len = TINFL_FAST_LOOKUP_BITS;                                       \
	  do {                                                                     \
		temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)];         \
	  } while (temp < 0);                                                      \
	}                                                                          \
	sym = temp;                                                                \
	bit_buf >>= code_len;                                                      \
	num_bits -= code_len;                                                      \
  }                                                                            \
  MZ_MACRO_END

tinfl_status tinfl_decompress(tinfl_decompressor *r,
							  const mz_uint8 *pIn_buf_next,
							  size_t *pIn_buf_size, mz_uint8 *pOut_buf_start,
							  mz_uint8 *pOut_buf_next, size_t *pOut_buf_size,
							  const mz_uint32 decomp_flags) {
  static const int s_length_base[31] = {
	  3,  4,  5,  6,  7,  8,  9,  10,  11,  13,  15,  17,  19,  23, 27, 31,
	  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0,  0};
  static const int s_length_extra[31] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
										 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,
										 4, 4, 5, 5, 5, 5, 0, 0, 0};
  static const int s_dist_base[32] = {
	  1,    2,    3,    4,    5,    7,     9,     13,    17,  25,   33,
	  49,   65,   97,   129,  193,  257,   385,   513,   769, 1025, 1537,
	  2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0,   0};
  static const int s_dist_extra[32] = {0, 0, 0,  0,  1,  1,  2,  2,  3,  3,
									   4, 4, 5,  5,  6,  6,  7,  7,  8,  8,
									   9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
  static const mz_uint8 s_length_dezigzag[19] = {
	  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
  static const int s_min_table_sizes[3] = {257, 1, 4};

  tinfl_status status = TINFL_STATUS_FAILED;
  mz_uint32 num_bits, dist, counter, num_extra;
  tinfl_bit_buf_t bit_buf;
  const mz_uint8 *pIn_buf_cur = pIn_buf_next,
				 *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;
  mz_uint8 *pOut_buf_cur = pOut_buf_next,
		   *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;
  size_t out_buf_size_mask =
			 (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)
				 ? (size_t)-1
				 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1,
		 dist_from_out_buf_start;

  // Ensure the output buffer's size is a power of 2, unless the output buffer
  // is large enough to hold the entire output file (in which case it doesn't
  // matter).
  if (((out_buf_size_mask + 1) & out_buf_size_mask) ||
	  (pOut_buf_next < pOut_buf_start)) {
	*pIn_buf_size = *pOut_buf_size = 0;
	return TINFL_STATUS_BAD_PARAM;
  }

  num_bits = r->m_num_bits;
  bit_buf = r->m_bit_buf;
  dist = r->m_dist;
  counter = r->m_counter;
  num_extra = r->m_num_extra;
  dist_from_out_buf_start = r->m_dist_from_out_buf_start;
  TINFL_CR_BEGIN

  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0;
  r->m_z_adler32 = r->m_check_adler32 = 1;
  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
	TINFL_GET_BYTE(1, r->m_zhdr0);
	TINFL_GET_BYTE(2, r->m_zhdr1);
	counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) ||
			   (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));
	if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))
	  counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) ||
				  ((out_buf_size_mask + 1) <
				   (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));
	if (counter) {
	  TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED);
	}
  }

  do {
	TINFL_GET_BITS(3, r->m_final, 3);
	r->m_type = r->m_final >> 1;
	if (r->m_type == 0) {
	  TINFL_SKIP_BITS(5, num_bits & 7);
	  for (counter = 0; counter < 4; ++counter) {
		if (num_bits)
		  TINFL_GET_BITS(6, r->m_raw_header[counter], 8);
		else
		  TINFL_GET_BYTE(7, r->m_raw_header[counter]);
	  }
	  if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) !=
		  (mz_uint)(0xFFFF ^
					(r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) {
		TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED);
	  }
	  while ((counter) && (num_bits)) {
		TINFL_GET_BITS(51, dist, 8);
		while (pOut_buf_cur >= pOut_buf_end) {
		  TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT);
		}
		*pOut_buf_cur++ = (mz_uint8)dist;
		counter--;
	  }
	  while (counter) {
		size_t n;
		while (pOut_buf_cur >= pOut_buf_end) {
		  TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT);
		}
		while (pIn_buf_cur >= pIn_buf_end) {
		  if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) {
			TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);
		  } else {
			TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);
		  }
		}
		n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur),
						  (size_t)(pIn_buf_end - pIn_buf_cur)),
				   counter);
		TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n);
		pIn_buf_cur += n;
		pOut_buf_cur += n;
		counter -= (mz_uint)n;
	  }
	} else if (r->m_type == 3) {
	  TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);
	} else {
	  if (r->m_type == 1) {
		mz_uint8 *p = r->m_tables[0].m_code_size;
		mz_uint i;
		r->m_table_sizes[0] = 288;
		r->m_table_sizes[1] = 32;
		TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);
		for (i = 0; i <= 143; ++i)
		  *p++ = 8;
		for (; i <= 255; ++i)
		  *p++ = 9;
		for (; i <= 279; ++i)
		  *p++ = 7;
		for (; i <= 287; ++i)
		  *p++ = 8;
	  } else {
		for (counter = 0; counter < 3; counter++) {
		  TINFL_GET_BITS(11, r->m_table_sizes[counter], "\05\05\04"[counter]);
		  r->m_table_sizes[counter] += s_min_table_sizes[counter];
		}
		MZ_CLEAR_OBJ(r->m_tables[2].m_code_size);
		for (counter = 0; counter < r->m_table_sizes[2]; counter++) {
		  mz_uint s;
		  TINFL_GET_BITS(14, s, 3);
		  r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s;
		}
		r->m_table_sizes[2] = 19;
	  }
	  for (; (int)r->m_type >= 0; r->m_type--) {
		int tree_next, tree_cur;
		tinfl_huff_table *pTable;
		mz_uint i, j, used_syms, total, sym_index, next_code[17],
			total_syms[16];
		pTable = &r->m_tables[r->m_type];
		MZ_CLEAR_OBJ(total_syms);
		MZ_CLEAR_OBJ(pTable->m_look_up);
		MZ_CLEAR_OBJ(pTable->m_tree);
		for (i = 0; i < r->m_table_sizes[r->m_type]; ++i)
		  total_syms[pTable->m_code_size[i]]++;
		used_syms = 0, total = 0;
		next_code[0] = next_code[1] = 0;
		for (i = 1; i <= 15; ++i) {
		  used_syms += total_syms[i];
		  next_code[i + 1] = (total = ((total + total_syms[i]) << 1));
		}
		if ((65536 != total) && (used_syms > 1)) {
		  TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);
		}
		for (tree_next = -1, sym_index = 0;
			 sym_index < r->m_table_sizes[r->m_type]; ++sym_index) {
		  mz_uint rev_code = 0, l, cur_code,
				  code_size = pTable->m_code_size[sym_index];
		  if (!code_size)
			continue;
		  cur_code = next_code[code_size]++;
		  for (l = code_size; l > 0; l--, cur_code >>= 1)
			rev_code = (rev_code << 1) | (cur_code & 1);
		  if (code_size <= TINFL_FAST_LOOKUP_BITS) {
			mz_int16 k = (mz_int16)((code_size << 9) | sym_index);
			while (rev_code < TINFL_FAST_LOOKUP_SIZE) {
			  pTable->m_look_up[rev_code] = k;
			  rev_code += (1 << code_size);
			}
			continue;
		  }
		  if (0 ==
			  (tree_cur = pTable->m_look_up[rev_code &
											(TINFL_FAST_LOOKUP_SIZE - 1)])) {
			pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] =
				(mz_int16)tree_next;
			tree_cur = tree_next;
			tree_next -= 2;
		  }
		  rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);
		  for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--) {
			tree_cur -= ((rev_code >>= 1) & 1);
			if (!pTable->m_tree[-tree_cur - 1]) {
			  pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next;
			  tree_cur = tree_next;
			  tree_next -= 2;
			} else
			  tree_cur = pTable->m_tree[-tree_cur - 1];
		  }
		  tree_cur -= ((rev_code >>= 1) & 1);
		  pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;
		}
		if (r->m_type == 2) {
		  for (counter = 0;
			   counter < (r->m_table_sizes[0] + r->m_table_sizes[1]);) {
			mz_uint s;
			TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]);
			if (dist < 16) {
			  r->m_len_codes[counter++] = (mz_uint8)dist;
			  continue;
			}
			if ((dist == 16) && (!counter)) {
			  TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);
			}
			num_extra = "\02\03\07"[dist - 16];
			TINFL_GET_BITS(18, s, num_extra);
			s += "\03\03\013"[dist - 16];
			TINFL_MEMSET(r->m_len_codes + counter,
						 (dist == 16) ? r->m_len_codes[counter - 1] : 0, s);
			counter += s;
		  }
		  if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter) {
			TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);
		  }
		  TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes,
					   r->m_table_sizes[0]);
		  TINFL_MEMCPY(r->m_tables[1].m_code_size,
					   r->m_len_codes + r->m_table_sizes[0],
					   r->m_table_sizes[1]);
		}
	  }
	  for (;;) {
		mz_uint8 *pSrc;
		for (;;) {
		  if (((pIn_buf_end - pIn_buf_cur) < 4) ||
			  ((pOut_buf_end - pOut_buf_cur) < 2)) {
			TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);
			if (counter >= 256)
			  break;
			while (pOut_buf_cur >= pOut_buf_end) {
			  TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT);
			}
			*pOut_buf_cur++ = (mz_uint8)counter;
		  } else {
			int sym2;
			mz_uint code_len;
#if TINFL_USE_64BIT_BITBUF
			if (num_bits < 30) {
			  bit_buf |=
				  (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits);
			  pIn_buf_cur += 4;
			  num_bits += 32;
			}
#else
			if (num_bits < 15) {
			  bit_buf |=
				  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
			  pIn_buf_cur += 2;
			  num_bits += 16;
			}
#endif
			if ((sym2 =
					 r->m_tables[0]
						 .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=
				0)
			  code_len = sym2 >> 9;
			else {
			  code_len = TINFL_FAST_LOOKUP_BITS;
			  do {
				sym2 = r->m_tables[0]
						   .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
			  } while (sym2 < 0);
			}
			counter = sym2;
			bit_buf >>= code_len;
			num_bits -= code_len;
			if (counter & 256)
			  break;

#if !TINFL_USE_64BIT_BITBUF
			if (num_bits < 15) {
			  bit_buf |=
				  (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits);
			  pIn_buf_cur += 2;
			  num_bits += 16;
			}
#endif
			if ((sym2 =
					 r->m_tables[0]
						 .m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >=
				0)
			  code_len = sym2 >> 9;
			else {
			  code_len = TINFL_FAST_LOOKUP_BITS;
			  do {
				sym2 = r->m_tables[0]
						   .m_tree[~sym2 + ((bit_buf >> code_len++) & 1)];
			  } while (sym2 < 0);
			}
			bit_buf >>= code_len;
			num_bits -= code_len;

			pOut_buf_cur[0] = (mz_uint8)counter;
			if (sym2 & 256) {
			  pOut_buf_cur++;
			  counter = sym2;
			  break;
			}
			pOut_buf_cur[1] = (mz_uint8)sym2;
			pOut_buf_cur += 2;
		  }
		}
		if ((counter &= 511) == 256)
		  break;

		num_extra = s_length_extra[counter - 257];
		counter = s_length_base[counter - 257];
		if (num_extra) {
		  mz_uint extra_bits;
		  TINFL_GET_BITS(25, extra_bits, num_extra);
		  counter += extra_bits;
		}

		TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);
		num_extra = s_dist_extra[dist];
		dist = s_dist_base[dist];
		if (num_extra) {
		  mz_uint extra_bits;
		  TINFL_GET_BITS(27, extra_bits, num_extra);
		  dist += extra_bits;
		}

		dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;
		if ((dist > dist_from_out_buf_start) &&
			(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) {
		  TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);
		}

		pSrc = pOut_buf_start +
			   ((dist_from_out_buf_start - dist) & out_buf_size_mask);

		if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end) {
		  while (counter--) {
			while (pOut_buf_cur >= pOut_buf_end) {
			  TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT);
			}
			*pOut_buf_cur++ =
				pOut_buf_start[(dist_from_out_buf_start++ - dist) &
							   out_buf_size_mask];
		  }
		  continue;
		}
#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
		else if ((counter >= 9) && (counter <= dist)) {
		  const mz_uint8 *pSrc_end = pSrc + (counter & ~7);
		  do {
			((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];
			((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];
			pOut_buf_cur += 8;
		  } while ((pSrc += 8) < pSrc_end);
		  if ((counter &= 7) < 3) {
			if (counter) {
			  pOut_buf_cur[0] = pSrc[0];
			  if (counter > 1)
				pOut_buf_cur[1] = pSrc[1];
			  pOut_buf_cur += counter;
			}
			continue;
		  }
		}
#endif
		do {
		  pOut_buf_cur[0] = pSrc[0];
		  pOut_buf_cur[1] = pSrc[1];
		  pOut_buf_cur[2] = pSrc[2];
		  pOut_buf_cur += 3;
		  pSrc += 3;
		} while ((int)(counter -= 3) > 2);
		if ((int)counter > 0) {
		  pOut_buf_cur[0] = pSrc[0];
		  if ((int)counter > 1)
			pOut_buf_cur[1] = pSrc[1];
		  pOut_buf_cur += counter;
		}
	  }
	}
  } while (!(r->m_final & 1));
  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) {
	TINFL_SKIP_BITS(32, num_bits & 7);
	for (counter = 0; counter < 4; ++counter) {
	  mz_uint s;
	  if (num_bits)
		TINFL_GET_BITS(41, s, 8);
	  else
		TINFL_GET_BYTE(42, s);
	  r->m_z_adler32 = (r->m_z_adler32 << 8) | s;
	}
  }
  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);
  TINFL_CR_FINISH

common_exit:
  r->m_num_bits = num_bits;
  r->m_bit_buf = bit_buf;
  r->m_dist = dist;
  r->m_counter = counter;
  r->m_num_extra = num_extra;
  r->m_dist_from_out_buf_start = dist_from_out_buf_start;
  *pIn_buf_size = pIn_buf_cur - pIn_buf_next;
  *pOut_buf_size = pOut_buf_cur - pOut_buf_next;
  if ((decomp_flags &
	   (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) &&
	  (status >= 0)) {
	const mz_uint8 *ptr = pOut_buf_next;
	size_t buf_len = *pOut_buf_size;
	mz_uint32 i, s1 = r->m_check_adler32 & 0xffff,
				 s2 = r->m_check_adler32 >> 16;
	size_t block_len = buf_len % 5552;
	while (buf_len) {
	  for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {
		s1 += ptr[0], s2 += s1;
		s1 += ptr[1], s2 += s1;
		s1 += ptr[2], s2 += s1;
		s1 += ptr[3], s2 += s1;
		s1 += ptr[4], s2 += s1;
		s1 += ptr[5], s2 += s1;
		s1 += ptr[6], s2 += s1;
		s1 += ptr[7], s2 += s1;
	  }
	  for (; i < block_len; ++i)
		s1 += *ptr++, s2 += s1;
	  s1 %= 65521U, s2 %= 65521U;
	  buf_len -= block_len;
	  block_len = 5552;
	}
	r->m_check_adler32 = (s2 << 16) + s1;
	if ((status == TINFL_STATUS_DONE) &&
		(decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) &&
		(r->m_check_adler32 != r->m_z_adler32))
	  status = TINFL_STATUS_ADLER32_MISMATCH;
  }
  return status;
}

// Higher level helper functions.
void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
								   size_t *pOut_len, int flags) {
  tinfl_decompressor decomp;
  void *pBuf = NULL, *pNew_buf;
  size_t src_buf_ofs = 0, out_buf_capacity = 0;
  *pOut_len = 0;
  tinfl_init(&decomp);
  for (;;) {
	size_t src_buf_size = src_buf_len - src_buf_ofs,
		   dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;
	tinfl_status status = tinfl_decompress(
		&decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size,
		(mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL,
		&dst_buf_size, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |
						   TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
	if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT)) {
	  MZ_FREE(pBuf);
	  *pOut_len = 0;
	  return NULL;
	}
	src_buf_ofs += src_buf_size;
	*pOut_len += dst_buf_size;
	if (status == TINFL_STATUS_DONE)
	  break;
	new_out_buf_capacity = out_buf_capacity * 2;
	if (new_out_buf_capacity < 128)
	  new_out_buf_capacity = 128;
	pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);
	if (!pNew_buf) {
	  MZ_FREE(pBuf);
	  *pOut_len = 0;
	  return NULL;
	}
	pBuf = pNew_buf;
	out_buf_capacity = new_out_buf_capacity;
  }
  return pBuf;
}

size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
								   const void *pSrc_buf, size_t src_buf_len,
								   int flags) {
  tinfl_decompressor decomp;
  tinfl_status status;
  tinfl_init(&decomp);
  status =
	  tinfl_decompress(&decomp, (const mz_uint8 *)pSrc_buf, &src_buf_len,
					   (mz_uint8 *)pOut_buf, (mz_uint8 *)pOut_buf, &out_buf_len,
					   (flags & ~TINFL_FLAG_HAS_MORE_INPUT) |
						   TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);
  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED
									   : out_buf_len;
}

int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size,
									 tinfl_put_buf_func_ptr pPut_buf_func,
									 void *pPut_buf_user, int flags) {
  int result = 0;
  tinfl_decompressor decomp;
  mz_uint8 *pDict = (mz_uint8 *)MZ_MALLOC(TINFL_LZ_DICT_SIZE);
  size_t in_buf_ofs = 0, dict_ofs = 0;
  if (!pDict)
	return TINFL_STATUS_FAILED;
  tinfl_init(&decomp);
  for (;;) {
	size_t in_buf_size = *pIn_buf_size - in_buf_ofs,
		   dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;
	tinfl_status status =
		tinfl_decompress(&decomp, (const mz_uint8 *)pIn_buf + in_buf_ofs,
						 &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,
						 (flags &
						  ~(TINFL_FLAG_HAS_MORE_INPUT |
							TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));
	in_buf_ofs += in_buf_size;
	if ((dst_buf_size) &&
		(!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))
	  break;
	if (status != TINFL_STATUS_HAS_MORE_OUTPUT) {
	  result = (status == TINFL_STATUS_DONE);
	  break;
	}
	dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);
  }
  MZ_FREE(pDict);
  *pIn_buf_size = in_buf_ofs;
  return result;
}

// ------------------- Low-level Compression (independent from all decompression
// API's)

// Purposely making these tables static for faster init and thread safety.
static const mz_uint16 s_tdefl_len_sym[256] = {
	257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268,
	268, 269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272,
	272, 272, 273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274,
	274, 274, 274, 275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276,
	276, 276, 276, 276, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,
	277, 277, 277, 277, 277, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
	278, 278, 278, 278, 278, 278, 279, 279, 279, 279, 279, 279, 279, 279, 279,
	279, 279, 279, 279, 279, 279, 279, 280, 280, 280, 280, 280, 280, 280, 280,
	280, 280, 280, 280, 280, 280, 280, 280, 281, 281, 281, 281, 281, 281, 281,
	281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,
	281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 282, 282, 282, 282, 282,
	282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,
	282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 283, 283, 283,
	283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,
	283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 284,
	284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,
	284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,
	285};

static const mz_uint8 s_tdefl_len_extra[256] = {
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0};

static const mz_uint8 s_tdefl_small_dist_sym[512] = {
	0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,
	8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10,
	10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11,
	11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
	12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
	12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
	13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14,
	14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
	14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
	14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
	14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
	16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
	17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
	17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
	17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
	17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
	17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
	17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17};

static const mz_uint8 s_tdefl_small_dist_extra[512] = {
	0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
	6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7};

static const mz_uint8 s_tdefl_large_dist_sym[128] = {
	0,  0,  18, 19, 20, 20, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24,
	24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
	26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27,
	27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
	28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29};

static const mz_uint8 s_tdefl_large_dist_extra[128] = {
	0,  0,  8,  8,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12,
	12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
	12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
	13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
	13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
	13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};

// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted
// values.
typedef struct { mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;
static tdefl_sym_freq *tdefl_radix_sort_syms(mz_uint num_syms,
											 tdefl_sym_freq *pSyms0,
											 tdefl_sym_freq *pSyms1) {
  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2];
  tdefl_sym_freq *pCur_syms = pSyms0, *pNew_syms = pSyms1;
  MZ_CLEAR_OBJ(hist);
  for (i = 0; i < num_syms; i++) {
	mz_uint freq = pSyms0[i].m_key;
	hist[freq & 0xFF]++;
	hist[256 + ((freq >> 8) & 0xFF)]++;
  }
  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256]))
	total_passes--;
  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8) {
	const mz_uint32 *pHist = &hist[pass << 8];
	mz_uint offsets[256], cur_ofs = 0;
	for (i = 0; i < 256; i++) {
	  offsets[i] = cur_ofs;
	  cur_ofs += pHist[i];
	}
	for (i = 0; i < num_syms; i++)
	  pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] =
		  pCur_syms[i];
	{
	  tdefl_sym_freq *t = pCur_syms;
	  pCur_syms = pNew_syms;
	  pNew_syms = t;
	}
  }
  return pCur_syms;
}

// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat,
// alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.
static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n) {
  int root, leaf, next, avbl, used, dpth;
  if (n == 0)
	return;
  else if (n == 1) {
	A[0].m_key = 1;
	return;
  }
  A[0].m_key += A[1].m_key;
  root = 0;
  leaf = 2;
  for (next = 1; next < n - 1; next++) {
	if (leaf >= n || A[root].m_key < A[leaf].m_key) {
	  A[next].m_key = A[root].m_key;
	  A[root++].m_key = (mz_uint16)next;
	} else
	  A[next].m_key = A[leaf++].m_key;
	if (leaf >= n || (root < next && A[root].m_key < A[leaf].m_key)) {
	  A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key);
	  A[root++].m_key = (mz_uint16)next;
	} else
	  A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);
  }
  A[n - 2].m_key = 0;
  for (next = n - 3; next >= 0; next--)
	A[next].m_key = A[A[next].m_key].m_key + 1;
  avbl = 1;
  used = dpth = 0;
  root = n - 2;
  next = n - 1;
  while (avbl > 0) {
	while (root >= 0 && (int)A[root].m_key == dpth) {
	  used++;
	  root--;
	}
	while (avbl > used) {
	  A[next--].m_key = (mz_uint16)(dpth);
	  avbl--;
	}
	avbl = 2 * used;
	dpth++;
	used = 0;
  }
}

// Limits canonical Huffman code table's max code size.
enum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };
static void tdefl_huffman_enforce_max_code_size(int *pNum_codes,
												int code_list_len,
												int max_code_size) {
  int i;
  mz_uint32 total = 0;
  if (code_list_len <= 1)
	return;
  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++)
	pNum_codes[max_code_size] += pNum_codes[i];
  for (i = max_code_size; i > 0; i--)
	total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));
  while (total != (1UL << max_code_size)) {
	pNum_codes[max_code_size]--;
	for (i = max_code_size - 1; i > 0; i--)
	  if (pNum_codes[i]) {
		pNum_codes[i]--;
		pNum_codes[i + 1] += 2;
		break;
	  }
	total--;
  }
}

static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num,
										 int table_len, int code_size_limit,
										 int static_table) {
  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE];
  mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1];
  MZ_CLEAR_OBJ(num_codes);
  if (static_table) {
	for (i = 0; i < table_len; i++)
	  num_codes[d->m_huff_code_sizes[table_num][i]]++;
  } else {
	tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS],
		*pSyms;
	int num_used_syms = 0;
	const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];
	for (i = 0; i < table_len; i++)
	  if (pSym_count[i]) {
		syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i];
		syms0[num_used_syms++].m_sym_index = (mz_uint16)i;
	  }

	pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1);
	tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);

	for (i = 0; i < num_used_syms; i++)
	  num_codes[pSyms[i].m_key]++;

	tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms,
										code_size_limit);

	MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]);
	MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);
	for (i = 1, j = num_used_syms; i <= code_size_limit; i++)
	  for (l = num_codes[i]; l > 0; l--)
		d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);
  }

  next_code[1] = 0;
  for (j = 0, i = 2; i <= code_size_limit; i++)
	next_code[i] = j = ((j + num_codes[i - 1]) << 1);

  for (i = 0; i < table_len; i++) {
	mz_uint rev_code = 0, code, code_size;
	if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0)
	  continue;
	code = next_code[code_size]++;
	for (l = code_size; l > 0; l--, code >>= 1)
	  rev_code = (rev_code << 1) | (code & 1);
	d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;
  }
}

#define TDEFL_PUT_BITS(b, l)                                                   \
  do {                                                                         \
	mz_uint bits = b;                                                          \
	mz_uint len = l;                                                           \
	MZ_ASSERT(bits <= ((1U << len) - 1U));                                     \
	d->m_bit_buffer |= (bits << d->m_bits_in);                                 \
	d->m_bits_in += len;                                                       \
	while (d->m_bits_in >= 8) {                                                \
	  if (d->m_pOutput_buf < d->m_pOutput_buf_end)                             \
		*d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer);                     \
	  d->m_bit_buffer >>= 8;                                                   \
	  d->m_bits_in -= 8;                                                       \
	}                                                                          \
  }                                                                            \
  MZ_MACRO_END

#define TDEFL_RLE_PREV_CODE_SIZE()                                             \
  {                                                                            \
	if (rle_repeat_count) {                                                    \
	  if (rle_repeat_count < 3) {                                              \
		d->m_huff_count[2][prev_code_size] = (mz_uint16)(                      \
			d->m_huff_count[2][prev_code_size] + rle_repeat_count);            \
		while (rle_repeat_count--)                                             \
		  packed_code_sizes[num_packed_code_sizes++] = prev_code_size;         \
	  } else {                                                                 \
		d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1);      \
		packed_code_sizes[num_packed_code_sizes++] = 16;                       \
		packed_code_sizes[num_packed_code_sizes++] =                           \
			(mz_uint8)(rle_repeat_count - 3);                                  \
	  }                                                                        \
	  rle_repeat_count = 0;                                                    \
	}                                                                          \
  }

#define TDEFL_RLE_ZERO_CODE_SIZE()                                             \
  {                                                                            \
	if (rle_z_count) {                                                         \
	  if (rle_z_count < 3) {                                                   \
		d->m_huff_count[2][0] =                                                \
			(mz_uint16)(d->m_huff_count[2][0] + rle_z_count);                  \
		while (rle_z_count--)                                                  \
		  packed_code_sizes[num_packed_code_sizes++] = 0;                      \
	  } else if (rle_z_count <= 10) {                                          \
		d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1);      \
		packed_code_sizes[num_packed_code_sizes++] = 17;                       \
		packed_code_sizes[num_packed_code_sizes++] =                           \
			(mz_uint8)(rle_z_count - 3);                                       \
	  } else {                                                                 \
		d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1);      \
		packed_code_sizes[num_packed_code_sizes++] = 18;                       \
		packed_code_sizes[num_packed_code_sizes++] =                           \
			(mz_uint8)(rle_z_count - 11);                                      \
	  }                                                                        \
	  rle_z_count = 0;                                                         \
	}                                                                          \
  }

static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = {
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

static void tdefl_start_dynamic_block(tdefl_compressor *d) {
  int num_lit_codes, num_dist_codes, num_bit_lengths;
  mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count,
	  rle_repeat_count, packed_code_sizes_index;
  mz_uint8
	  code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],
	  packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1],
	  prev_code_size = 0xFF;

  d->m_huff_count[0][256] = 1;

  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);
  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);

  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--)
	if (d->m_huff_code_sizes[0][num_lit_codes - 1])
	  break;
  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--)
	if (d->m_huff_code_sizes[1][num_dist_codes - 1])
	  break;

  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);
  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0],
		 num_dist_codes);
  total_code_sizes_to_pack = num_lit_codes + num_dist_codes;
  num_packed_code_sizes = 0;
  rle_z_count = 0;
  rle_repeat_count = 0;

  memset(&d->m_huff_count[2][0], 0,
		 sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);
  for (i = 0; i < total_code_sizes_to_pack; i++) {
	mz_uint8 code_size = code_sizes_to_pack[i];
	if (!code_size) {
	  TDEFL_RLE_PREV_CODE_SIZE();
	  if (++rle_z_count == 138) {
		TDEFL_RLE_ZERO_CODE_SIZE();
	  }
	} else {
	  TDEFL_RLE_ZERO_CODE_SIZE();
	  if (code_size != prev_code_size) {
		TDEFL_RLE_PREV_CODE_SIZE();
		d->m_huff_count[2][code_size] =
			(mz_uint16)(d->m_huff_count[2][code_size] + 1);
		packed_code_sizes[num_packed_code_sizes++] = code_size;
	  } else if (++rle_repeat_count == 6) {
		TDEFL_RLE_PREV_CODE_SIZE();
	  }
	}
	prev_code_size = code_size;
  }
  if (rle_repeat_count) {
	TDEFL_RLE_PREV_CODE_SIZE();
  } else {
	TDEFL_RLE_ZERO_CODE_SIZE();
  }

  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);

  TDEFL_PUT_BITS(2, 2);

  TDEFL_PUT_BITS(num_lit_codes - 257, 5);
  TDEFL_PUT_BITS(num_dist_codes - 1, 5);

  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--)
	if (d->m_huff_code_sizes
			[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]])
	  break;
  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1));
  TDEFL_PUT_BITS(num_bit_lengths - 4, 4);
  for (i = 0; (int)i < num_bit_lengths; i++)
	TDEFL_PUT_BITS(
		d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);

  for (packed_code_sizes_index = 0;
	   packed_code_sizes_index < num_packed_code_sizes;) {
	mz_uint code = packed_code_sizes[packed_code_sizes_index++];
	MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);
	TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);
	if (code >= 16)
	  TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++],
					 "\02\03\07"[code - 16]);
  }
}

static void tdefl_start_static_block(tdefl_compressor *d) {
  mz_uint i;
  mz_uint8 *p = &d->m_huff_code_sizes[0][0];

  for (i = 0; i <= 143; ++i)
	*p++ = 8;
  for (; i <= 255; ++i)
	*p++ = 9;
  for (; i <= 279; ++i)
	*p++ = 7;
  for (; i <= 287; ++i)
	*p++ = 8;

  memset(d->m_huff_code_sizes[1], 5, 32);

  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);
  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);

  TDEFL_PUT_BITS(1, 2);
}

static const mz_uint mz_bitmasks[17] = {
	0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
	0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF};

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN &&             \
	MINIZ_HAS_64BIT_REGISTERS
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {
  mz_uint flags;
  mz_uint8 *pLZ_codes;
  mz_uint8 *pOutput_buf = d->m_pOutput_buf;
  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;
  mz_uint64 bit_buffer = d->m_bit_buffer;
  mz_uint bits_in = d->m_bits_in;

#define TDEFL_PUT_BITS_FAST(b, l)                                              \
  {                                                                            \
	bit_buffer |= (((mz_uint64)(b)) << bits_in);                               \
	bits_in += (l);                                                            \
  }

  flags = 1;
  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end;
	   flags >>= 1) {
	if (flags == 1)
	  flags = *pLZ_codes++ | 0x100;

	if (flags & 1) {
	  mz_uint s0, s1, n0, n1, sym, num_extra_bits;
	  mz_uint match_len = pLZ_codes[0],
			  match_dist = *(const mz_uint16 *)(pLZ_codes + 1);
	  pLZ_codes += 3;

	  MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
	  TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],
						  d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
	  TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],
						  s_tdefl_len_extra[match_len]);

	  // This sequence coaxes MSVC into using cmov's vs. jmp's.
	  s0 = s_tdefl_small_dist_sym[match_dist & 511];
	  n0 = s_tdefl_small_dist_extra[match_dist & 511];
	  s1 = s_tdefl_large_dist_sym[match_dist >> 8];
	  n1 = s_tdefl_large_dist_extra[match_dist >> 8];
	  sym = (match_dist < 512) ? s0 : s1;
	  num_extra_bits = (match_dist < 512) ? n0 : n1;

	  MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
	  TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym],
						  d->m_huff_code_sizes[1][sym]);
	  TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits],
						  num_extra_bits);
	} else {
	  mz_uint lit = *pLZ_codes++;
	  MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
	  TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],
						  d->m_huff_code_sizes[0][lit]);

	  if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
		flags >>= 1;
		lit = *pLZ_codes++;
		MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
		TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],
							d->m_huff_code_sizes[0][lit]);

		if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end)) {
		  flags >>= 1;
		  lit = *pLZ_codes++;
		  MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
		  TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit],
							  d->m_huff_code_sizes[0][lit]);
		}
	  }
	}

	if (pOutput_buf >= d->m_pOutput_buf_end)
	  return MZ_FALSE;

	*(mz_uint64 *)pOutput_buf = bit_buffer;
	pOutput_buf += (bits_in >> 3);
	bit_buffer >>= (bits_in & ~7);
	bits_in &= 7;
  }

#undef TDEFL_PUT_BITS_FAST

  d->m_pOutput_buf = pOutput_buf;
  d->m_bits_in = 0;
  d->m_bit_buffer = 0;

  while (bits_in) {
	mz_uint32 n = MZ_MIN(bits_in, 16);
	TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);
	bit_buffer >>= n;
	bits_in -= n;
  }

  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#else
static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d) {
  mz_uint flags;
  mz_uint8 *pLZ_codes;

  flags = 1;
  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf;
	   flags >>= 1) {
	if (flags == 1)
	  flags = *pLZ_codes++ | 0x100;
	if (flags & 1) {
	  mz_uint sym, num_extra_bits;
	  mz_uint match_len = pLZ_codes[0],
			  match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8));
	  pLZ_codes += 3;

	  MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
	  TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]],
					 d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);
	  TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]],
					 s_tdefl_len_extra[match_len]);

	  if (match_dist < 512) {
		sym = s_tdefl_small_dist_sym[match_dist];
		num_extra_bits = s_tdefl_small_dist_extra[match_dist];
	  } else {
		sym = s_tdefl_large_dist_sym[match_dist >> 8];
		num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];
	  }
	  MZ_ASSERT(d->m_huff_code_sizes[1][sym]);
	  TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);
	  TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);
	} else {
	  mz_uint lit = *pLZ_codes++;
	  MZ_ASSERT(d->m_huff_code_sizes[0][lit]);
	  TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);
	}
  }

  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);

  return (d->m_pOutput_buf < d->m_pOutput_buf_end);
}
#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN &&
	   // MINIZ_HAS_64BIT_REGISTERS

static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block) {
  if (static_block)
	tdefl_start_static_block(d);
  else
	tdefl_start_dynamic_block(d);
  return tdefl_compress_lz_codes(d);
}

static int tdefl_flush_block(tdefl_compressor *d, int flush) {
  mz_uint saved_bit_buf, saved_bits_in;
  mz_uint8 *pSaved_output_buf;
  mz_bool comp_block_succeeded = MZ_FALSE;
  int n, use_raw_block =
			 ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) &&
			 (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;
  mz_uint8 *pOutput_buf_start =
	  ((d->m_pPut_buf_func == NULL) &&
	   ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE))
		  ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs)
		  : d->m_output_buf;

  d->m_pOutput_buf = pOutput_buf_start;
  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;

  MZ_ASSERT(!d->m_output_flush_remaining);
  d->m_output_flush_ofs = 0;
  d->m_output_flush_remaining = 0;

  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);
  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);

  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index)) {
	TDEFL_PUT_BITS(0x78, 8);
	TDEFL_PUT_BITS(0x01, 8);
  }

  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);

  pSaved_output_buf = d->m_pOutput_buf;
  saved_bit_buf = d->m_bit_buffer;
  saved_bits_in = d->m_bits_in;

  if (!use_raw_block)
	comp_block_succeeded =
		tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) ||
									(d->m_total_lz_bytes < 48));

  // If the block gets expanded, forget the current contents of the output
  // buffer and send a raw block instead.
  if (((use_raw_block) ||
	   ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >=
								  d->m_total_lz_bytes))) &&
	  ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size)) {
	mz_uint i;
	d->m_pOutput_buf = pSaved_output_buf;
	d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
	TDEFL_PUT_BITS(0, 2);
	if (d->m_bits_in) {
	  TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
	}
	for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF) {
	  TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);
	}
	for (i = 0; i < d->m_total_lz_bytes; ++i) {
	  TDEFL_PUT_BITS(
		  d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK],
		  8);
	}
  }
  // Check for the extremely unlikely (if not impossible) case of the compressed
  // block not fitting into the output buffer when using dynamic codes.
  else if (!comp_block_succeeded) {
	d->m_pOutput_buf = pSaved_output_buf;
	d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;
	tdefl_compress_block(d, MZ_TRUE);
  }

  if (flush) {
	if (flush == TDEFL_FINISH) {
	  if (d->m_bits_in) {
		TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
	  }
	  if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) {
		mz_uint i, a = d->m_adler32;
		for (i = 0; i < 4; i++) {
		  TDEFL_PUT_BITS((a >> 24) & 0xFF, 8);
		  a <<= 8;
		}
	  }
	} else {
	  mz_uint i, z = 0;
	  TDEFL_PUT_BITS(0, 3);
	  if (d->m_bits_in) {
		TDEFL_PUT_BITS(0, 8 - d->m_bits_in);
	  }
	  for (i = 2; i; --i, z ^= 0xFFFF) {
		TDEFL_PUT_BITS(z & 0xFFFF, 16);
	  }
	}
  }

  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);

  memset(&d->m_huff_count[0][0], 0,
		 sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
  memset(&d->m_huff_count[1][0], 0,
		 sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);

  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
  d->m_pLZ_flags = d->m_lz_code_buf;
  d->m_num_flags_left = 8;
  d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes;
  d->m_total_lz_bytes = 0;
  d->m_block_index++;

  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0) {
	if (d->m_pPut_buf_func) {
	  *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
	  if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))
		return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);
	} else if (pOutput_buf_start == d->m_output_buf) {
	  int bytes_to_copy = (int)MZ_MIN(
		  (size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));
	  memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf,
			 bytes_to_copy);
	  d->m_out_buf_ofs += bytes_to_copy;
	  if ((n -= bytes_to_copy) != 0) {
		d->m_output_flush_ofs = bytes_to_copy;
		d->m_output_flush_remaining = n;
	  }
	} else {
	  d->m_out_buf_ofs += n;
	}
  }

  return d->m_output_flush_remaining;
}

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES
#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16 *)(p)
static MZ_FORCEINLINE void
tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,
				 mz_uint max_match_len, mz_uint *pMatch_dist,
				 mz_uint *pMatch_len) {
  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,
				match_len = *pMatch_len, probe_pos = pos, next_probe_pos,
				probe_len;
  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
  const mz_uint16 *s = (const mz_uint16 *)(d->m_dict + pos), *p, *q;
  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]),
			s01 = TDEFL_READ_UNALIGNED_WORD(s);
  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
  if (max_match_len <= match_len)
	return;
  for (;;) {
	for (;;) {
	  if (--num_probes_left == 0)
		return;
#define TDEFL_PROBE                                                            \
  next_probe_pos = d->m_next[probe_pos];                                       \
  if ((!next_probe_pos) ||                                                     \
	  ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))       \
	return;                                                                    \
  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                        \
  if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) \
	break;
	  TDEFL_PROBE;
	  TDEFL_PROBE;
	  TDEFL_PROBE;
	}
	if (!dist)
	  break;
	q = (const mz_uint16 *)(d->m_dict + probe_pos);
	if (TDEFL_READ_UNALIGNED_WORD(q) != s01)
	  continue;
	p = s;
	probe_len = 32;
	do {
	} while (
		(TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
		(TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
		(TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
		(TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&
		(--probe_len > 0));
	if (!probe_len) {
	  *pMatch_dist = dist;
	  *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN);
	  break;
	} else if ((probe_len = ((mz_uint)(p - s) * 2) +
							(mz_uint)(*(const mz_uint8 *)p ==
									  *(const mz_uint8 *)q)) > match_len) {
	  *pMatch_dist = dist;
	  if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) ==
		  max_match_len)
		break;
	  c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);
	}
  }
}
#else
static MZ_FORCEINLINE void
tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist,
				 mz_uint max_match_len, mz_uint *pMatch_dist,
				 mz_uint *pMatch_len) {
  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK,
				match_len = *pMatch_len, probe_pos = pos, next_probe_pos,
				probe_len;
  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];
  const mz_uint8 *s = d->m_dict + pos, *p, *q;
  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];
  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN);
  if (max_match_len <= match_len)
	return;
  for (;;) {
	for (;;) {
	  if (--num_probes_left == 0)
		return;
#define TDEFL_PROBE                                                            \
  next_probe_pos = d->m_next[probe_pos];                                       \
  if ((!next_probe_pos) ||                                                     \
	  ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist))       \
	return;                                                                    \
  probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK;                        \
  if ((d->m_dict[probe_pos + match_len] == c0) &&                              \
	  (d->m_dict[probe_pos + match_len - 1] == c1))                            \
	break;
	  TDEFL_PROBE;
	  TDEFL_PROBE;
	  TDEFL_PROBE;
	}
	if (!dist)
	  break;
	p = s;
	q = d->m_dict + probe_pos;
	for (probe_len = 0; probe_len < max_match_len; probe_len++)
	  if (*p++ != *q++)
		break;
	if (probe_len > match_len) {
	  *pMatch_dist = dist;
	  if ((*pMatch_len = match_len = probe_len) == max_match_len)
		return;
	  c0 = d->m_dict[pos + match_len];
	  c1 = d->m_dict[pos + match_len - 1];
	}
  }
}
#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
static mz_bool tdefl_compress_fast(tdefl_compressor *d) {
  // Faster, minimally featured LZRW1-style match+parse loop with better
  // register utilization. Intended for applications where raw throughput is
  // valued more highly than ratio.
  mz_uint lookahead_pos = d->m_lookahead_pos,
		  lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size,
		  total_lz_bytes = d->m_total_lz_bytes,
		  num_flags_left = d->m_num_flags_left;
  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;
  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;

  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size))) {
	const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;
	mz_uint dst_pos =
		(lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;
	mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(
		d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);
	d->m_src_buf_left -= num_bytes_to_process;
	lookahead_size += num_bytes_to_process;

	while (num_bytes_to_process) {
	  mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);
	  memcpy(d->m_dict + dst_pos, d->m_pSrc, n);
	  if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
		memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc,
			   MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));
	  d->m_pSrc += n;
	  dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;
	  num_bytes_to_process -= n;
	}

	dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);
	if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE))
	  break;

	while (lookahead_size >= 4) {
	  mz_uint cur_match_dist, cur_match_len = 1;
	  mz_uint8 *pCur_dict = d->m_dict + cur_pos;
	  mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;
	  mz_uint hash =
		  (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) &
		  TDEFL_LEVEL1_HASH_SIZE_MASK;
	  mz_uint probe_pos = d->m_hash[hash];
	  d->m_hash[hash] = (mz_uint16)lookahead_pos;

	  if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <=
		   dict_size) &&
		  ((*(const mz_uint32 *)(d->m_dict +
								 (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) &
			0xFFFFFF) == first_trigram)) {
		const mz_uint16 *p = (const mz_uint16 *)pCur_dict;
		const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);
		mz_uint32 probe_len = 32;
		do {
		} while ((TDEFL_READ_UNALIGNED_WORD(++p) ==
				  TDEFL_READ_UNALIGNED_WORD(++q)) &&
				 (TDEFL_READ_UNALIGNED_WORD(++p) ==
				  TDEFL_READ_UNALIGNED_WORD(++q)) &&
				 (TDEFL_READ_UNALIGNED_WORD(++p) ==
				  TDEFL_READ_UNALIGNED_WORD(++q)) &&
				 (TDEFL_READ_UNALIGNED_WORD(++p) ==
				  TDEFL_READ_UNALIGNED_WORD(++q)) &&
				 (--probe_len > 0));
		cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) +
						(mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);
		if (!probe_len)
		  cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;

		if ((cur_match_len < TDEFL_MIN_MATCH_LEN) ||
			((cur_match_len == TDEFL_MIN_MATCH_LEN) &&
			 (cur_match_dist >= 8U * 1024U))) {
		  cur_match_len = 1;
		  *pLZ_code_buf++ = (mz_uint8)first_trigram;
		  *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
		  d->m_huff_count[0][(mz_uint8)first_trigram]++;
		} else {
		  mz_uint32 s0, s1;
		  cur_match_len = MZ_MIN(cur_match_len, lookahead_size);

		  MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) &&
					(cur_match_dist >= 1) &&
					(cur_match_dist <= TDEFL_LZ_DICT_SIZE));

		  cur_match_dist--;

		  pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);
		  *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;
		  pLZ_code_buf += 3;
		  *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);

		  s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];
		  s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];
		  d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;

		  d->m_huff_count[0][s_tdefl_len_sym[cur_match_len -
											 TDEFL_MIN_MATCH_LEN]]++;
		}
	  } else {
		*pLZ_code_buf++ = (mz_uint8)first_trigram;
		*pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
		d->m_huff_count[0][(mz_uint8)first_trigram]++;
	  }

	  if (--num_flags_left == 0) {
		num_flags_left = 8;
		pLZ_flags = pLZ_code_buf++;
	  }

	  total_lz_bytes += cur_match_len;
	  lookahead_pos += cur_match_len;
	  dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);
	  cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;
	  MZ_ASSERT(lookahead_size >= cur_match_len);
	  lookahead_size -= cur_match_len;

	  if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
		int n;
		d->m_lookahead_pos = lookahead_pos;
		d->m_lookahead_size = lookahead_size;
		d->m_dict_size = dict_size;
		d->m_total_lz_bytes = total_lz_bytes;
		d->m_pLZ_code_buf = pLZ_code_buf;
		d->m_pLZ_flags = pLZ_flags;
		d->m_num_flags_left = num_flags_left;
		if ((n = tdefl_flush_block(d, 0)) != 0)
		  return (n < 0) ? MZ_FALSE : MZ_TRUE;
		total_lz_bytes = d->m_total_lz_bytes;
		pLZ_code_buf = d->m_pLZ_code_buf;
		pLZ_flags = d->m_pLZ_flags;
		num_flags_left = d->m_num_flags_left;
	  }
	}

	while (lookahead_size) {
	  mz_uint8 lit = d->m_dict[cur_pos];

	  total_lz_bytes++;
	  *pLZ_code_buf++ = lit;
	  *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);
	  if (--num_flags_left == 0) {
		num_flags_left = 8;
		pLZ_flags = pLZ_code_buf++;
	  }

	  d->m_huff_count[0][lit]++;

	  lookahead_pos++;
	  dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);
	  cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
	  lookahead_size--;

	  if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) {
		int n;
		d->m_lookahead_pos = lookahead_pos;
		d->m_lookahead_size = lookahead_size;
		d->m_dict_size = dict_size;
		d->m_total_lz_bytes = total_lz_bytes;
		d->m_pLZ_code_buf = pLZ_code_buf;
		d->m_pLZ_flags = pLZ_flags;
		d->m_num_flags_left = num_flags_left;
		if ((n = tdefl_flush_block(d, 0)) != 0)
		  return (n < 0) ? MZ_FALSE : MZ_TRUE;
		total_lz_bytes = d->m_total_lz_bytes;
		pLZ_code_buf = d->m_pLZ_code_buf;
		pLZ_flags = d->m_pLZ_flags;
		num_flags_left = d->m_num_flags_left;
	  }
	}
  }

  d->m_lookahead_pos = lookahead_pos;
  d->m_lookahead_size = lookahead_size;
  d->m_dict_size = dict_size;
  d->m_total_lz_bytes = total_lz_bytes;
  d->m_pLZ_code_buf = pLZ_code_buf;
  d->m_pLZ_flags = pLZ_flags;
  d->m_num_flags_left = num_flags_left;
  return MZ_TRUE;
}
#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN

static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d,
												mz_uint8 lit) {
  d->m_total_lz_bytes++;
  *d->m_pLZ_code_buf++ = lit;
  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1);
  if (--d->m_num_flags_left == 0) {
	d->m_num_flags_left = 8;
	d->m_pLZ_flags = d->m_pLZ_code_buf++;
  }
  d->m_huff_count[0][lit]++;
}

static MZ_FORCEINLINE void
tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist) {
  mz_uint32 s0, s1;

  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) &&
			(match_dist <= TDEFL_LZ_DICT_SIZE));

  d->m_total_lz_bytes += match_len;

  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);

  match_dist -= 1;
  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);
  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8);
  d->m_pLZ_code_buf += 3;

  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80);
  if (--d->m_num_flags_left == 0) {
	d->m_num_flags_left = 8;
	d->m_pLZ_flags = d->m_pLZ_code_buf++;
  }

  s0 = s_tdefl_small_dist_sym[match_dist & 511];
  s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];
  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;

  if (match_len >= TDEFL_MIN_MATCH_LEN)
	d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;
}

static mz_bool tdefl_compress_normal(tdefl_compressor *d) {
  const mz_uint8 *pSrc = d->m_pSrc;
  size_t src_buf_left = d->m_src_buf_left;
  tdefl_flush flush = d->m_flush;

  while ((src_buf_left) || ((flush) && (d->m_lookahead_size))) {
	mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;
	// Update dictionary and hash chains. Keeps the lookahead size equal to
	// TDEFL_MAX_MATCH_LEN.
	if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1)) {
	  mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &
						TDEFL_LZ_DICT_SIZE_MASK,
			  ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;
	  mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]
					  << TDEFL_LZ_HASH_SHIFT) ^
					 d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];
	  mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(
		  src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);
	  const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;
	  src_buf_left -= num_bytes_to_process;
	  d->m_lookahead_size += num_bytes_to_process;
	  while (pSrc != pSrc_end) {
		mz_uint8 c = *pSrc++;
		d->m_dict[dst_pos] = c;
		if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
		  d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
		hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);
		d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
		d->m_hash[hash] = (mz_uint16)(ins_pos);
		dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;
		ins_pos++;
	  }
	} else {
	  while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN)) {
		mz_uint8 c = *pSrc++;
		mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) &
						  TDEFL_LZ_DICT_SIZE_MASK;
		src_buf_left--;
		d->m_dict[dst_pos] = c;
		if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))
		  d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;
		if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN) {
		  mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;
		  mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK]
						   << (TDEFL_LZ_HASH_SHIFT * 2)) ^
						  (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK]
						   << TDEFL_LZ_HASH_SHIFT) ^
						  c) &
						 (TDEFL_LZ_HASH_SIZE - 1);
		  d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash];
		  d->m_hash[hash] = (mz_uint16)(ins_pos);
		}
	  }
	}
	d->m_dict_size =
		MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);
	if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))
	  break;

	// Simple lazy/greedy parsing state machine.
	len_to_move = 1;
	cur_match_dist = 0;
	cur_match_len =
		d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1);
	cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;
	if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS)) {
	  if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) {
		mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];
		cur_match_len = 0;
		while (cur_match_len < d->m_lookahead_size) {
		  if (d->m_dict[cur_pos + cur_match_len] != c)
			break;
		  cur_match_len++;
		}
		if (cur_match_len < TDEFL_MIN_MATCH_LEN)
		  cur_match_len = 0;
		else
		  cur_match_dist = 1;
	  }
	} else {
	  tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size,
					   d->m_lookahead_size, &cur_match_dist, &cur_match_len);
	}
	if (((cur_match_len == TDEFL_MIN_MATCH_LEN) &&
		 (cur_match_dist >= 8U * 1024U)) ||
		(cur_pos == cur_match_dist) ||
		((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5))) {
	  cur_match_dist = cur_match_len = 0;
	}
	if (d->m_saved_match_len) {
	  if (cur_match_len > d->m_saved_match_len) {
		tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);
		if (cur_match_len >= 128) {
		  tdefl_record_match(d, cur_match_len, cur_match_dist);
		  d->m_saved_match_len = 0;
		  len_to_move = cur_match_len;
		} else {
		  d->m_saved_lit = d->m_dict[cur_pos];
		  d->m_saved_match_dist = cur_match_dist;
		  d->m_saved_match_len = cur_match_len;
		}
	  } else {
		tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);
		len_to_move = d->m_saved_match_len - 1;
		d->m_saved_match_len = 0;
	  }
	} else if (!cur_match_dist)
	  tdefl_record_literal(d,
						   d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);
	else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) ||
			 (cur_match_len >= 128)) {
	  tdefl_record_match(d, cur_match_len, cur_match_dist);
	  len_to_move = cur_match_len;
	} else {
	  d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)];
	  d->m_saved_match_dist = cur_match_dist;
	  d->m_saved_match_len = cur_match_len;
	}
	// Move the lookahead forward by len_to_move bytes.
	d->m_lookahead_pos += len_to_move;
	MZ_ASSERT(d->m_lookahead_size >= len_to_move);
	d->m_lookahead_size -= len_to_move;
	d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, (mz_uint)TDEFL_LZ_DICT_SIZE);
	// Check if it's time to flush the current LZ codes to the internal output
	// buffer.
	if ((d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||
		((d->m_total_lz_bytes > 31 * 1024) &&
		 (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >=
		   d->m_total_lz_bytes) ||
		  (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))) {
	  int n;
	  d->m_pSrc = pSrc;
	  d->m_src_buf_left = src_buf_left;
	  if ((n = tdefl_flush_block(d, 0)) != 0)
		return (n < 0) ? MZ_FALSE : MZ_TRUE;
	}
  }

  d->m_pSrc = pSrc;
  d->m_src_buf_left = src_buf_left;
  return MZ_TRUE;
}

static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d) {
  if (d->m_pIn_buf_size) {
	*d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;
  }

  if (d->m_pOut_buf_size) {
	size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs,
					  d->m_output_flush_remaining);
	memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs,
		   d->m_output_buf + d->m_output_flush_ofs, n);
	d->m_output_flush_ofs += (mz_uint)n;
	d->m_output_flush_remaining -= (mz_uint)n;
	d->m_out_buf_ofs += n;

	*d->m_pOut_buf_size = d->m_out_buf_ofs;
  }

  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE
														 : TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf,
							size_t *pIn_buf_size, void *pOut_buf,
							size_t *pOut_buf_size, tdefl_flush flush) {
  if (!d) {
	if (pIn_buf_size)
	  *pIn_buf_size = 0;
	if (pOut_buf_size)
	  *pOut_buf_size = 0;
	return TDEFL_STATUS_BAD_PARAM;
  }

  d->m_pIn_buf = pIn_buf;
  d->m_pIn_buf_size = pIn_buf_size;
  d->m_pOut_buf = pOut_buf;
  d->m_pOut_buf_size = pOut_buf_size;
  d->m_pSrc = (const mz_uint8 *)(pIn_buf);
  d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;
  d->m_out_buf_ofs = 0;
  d->m_flush = flush;

  if (((d->m_pPut_buf_func != NULL) ==
	   ((pOut_buf != NULL) || (pOut_buf_size != NULL))) ||
	  (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||
	  (d->m_wants_to_finish && (flush != TDEFL_FINISH)) ||
	  (pIn_buf_size && *pIn_buf_size && !pIn_buf) ||
	  (pOut_buf_size && *pOut_buf_size && !pOut_buf)) {
	if (pIn_buf_size)
	  *pIn_buf_size = 0;
	if (pOut_buf_size)
	  *pOut_buf_size = 0;
	return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);
  }
  d->m_wants_to_finish |= (flush == TDEFL_FINISH);

  if ((d->m_output_flush_remaining) || (d->m_finished))
	return (d->m_prev_return_status = tdefl_flush_output_buffer(d));

#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&
	  ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&
	  ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS |
					  TDEFL_RLE_MATCHES)) == 0)) {
	if (!tdefl_compress_fast(d))
	  return d->m_prev_return_status;
  } else
#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN
  {
	if (!tdefl_compress_normal(d))
	  return d->m_prev_return_status;
  }

  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) &&
	  (pIn_buf))
	d->m_adler32 =
		(mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf,
							  d->m_pSrc - (const mz_uint8 *)pIn_buf);

  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) &&
	  (!d->m_output_flush_remaining)) {
	if (tdefl_flush_block(d, flush) < 0)
	  return d->m_prev_return_status;
	d->m_finished = (flush == TDEFL_FINISH);
	if (flush == TDEFL_FULL_FLUSH) {
	  MZ_CLEAR_OBJ(d->m_hash);
	  MZ_CLEAR_OBJ(d->m_next);
	  d->m_dict_size = 0;
	}
  }

  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));
}

tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf,
								   size_t in_buf_size, tdefl_flush flush) {
  MZ_ASSERT(d->m_pPut_buf_func);
  return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);
}

tdefl_status tdefl_init(tdefl_compressor *d,
						tdefl_put_buf_func_ptr pPut_buf_func,
						void *pPut_buf_user, int flags) {
  d->m_pPut_buf_func = pPut_buf_func;
  d->m_pPut_buf_user = pPut_buf_user;
  d->m_flags = (mz_uint)(flags);
  d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3;
  d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;
  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;
  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG))
	MZ_CLEAR_OBJ(d->m_hash);
  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size =
	  d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;
  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished =
	  d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;
  d->m_pLZ_code_buf = d->m_lz_code_buf + 1;
  d->m_pLZ_flags = d->m_lz_code_buf;
  d->m_num_flags_left = 8;
  d->m_pOutput_buf = d->m_output_buf;
  d->m_pOutput_buf_end = d->m_output_buf;
  d->m_prev_return_status = TDEFL_STATUS_OKAY;
  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0;
  d->m_adler32 = 1;
  d->m_pIn_buf = NULL;
  d->m_pOut_buf = NULL;
  d->m_pIn_buf_size = NULL;
  d->m_pOut_buf_size = NULL;
  d->m_flush = TDEFL_NO_FLUSH;
  d->m_pSrc = NULL;
  d->m_src_buf_left = 0;
  d->m_out_buf_ofs = 0;
  memset(&d->m_huff_count[0][0], 0,
		 sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);
  memset(&d->m_huff_count[1][0], 0,
		 sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);
  return TDEFL_STATUS_OKAY;
}

tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d) {
  return d->m_prev_return_status;
}

mz_uint32 tdefl_get_adler32(tdefl_compressor *d) { return d->m_adler32; }

mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,
									 tdefl_put_buf_func_ptr pPut_buf_func,
									 void *pPut_buf_user, int flags) {
  tdefl_compressor *pComp;
  mz_bool succeeded;
  if (((buf_len) && (!pBuf)) || (!pPut_buf_func))
	return MZ_FALSE;
  pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
  if (!pComp)
	return MZ_FALSE;
  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) ==
			   TDEFL_STATUS_OKAY);
  succeeded =
	  succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) ==
					TDEFL_STATUS_DONE);
  MZ_FREE(pComp);
  return succeeded;
}

typedef struct {
  size_t m_size, m_capacity;
  mz_uint8 *m_pBuf;
  mz_bool m_expandable;
} tdefl_output_buffer;

static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len,
										  void *pUser) {
  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;
  size_t new_size = p->m_size + len;
  if (new_size > p->m_capacity) {
	size_t new_capacity = p->m_capacity;
	mz_uint8 *pNew_buf;
	if (!p->m_expandable)
	  return MZ_FALSE;
	do {
	  new_capacity = MZ_MAX(128U, new_capacity << 1U);
	} while (new_size > new_capacity);
	pNew_buf = (mz_uint8 *)MZ_REALLOC(p->m_pBuf, new_capacity);
	if (!pNew_buf)
	  return MZ_FALSE;
	p->m_pBuf = pNew_buf;
	p->m_capacity = new_capacity;
  }
  memcpy((mz_uint8 *)p->m_pBuf + p->m_size, pBuf, len);
  p->m_size = new_size;
  return MZ_TRUE;
}

void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len,
								 size_t *pOut_len, int flags) {
  tdefl_output_buffer out_buf;
  MZ_CLEAR_OBJ(out_buf);
  if (!pOut_len)
	return MZ_FALSE;
  else
	*pOut_len = 0;
  out_buf.m_expandable = MZ_TRUE;
  if (!tdefl_compress_mem_to_output(
		  pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
	return NULL;
  *pOut_len = out_buf.m_size;
  return out_buf.m_pBuf;
}

size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len,
								 const void *pSrc_buf, size_t src_buf_len,
								 int flags) {
  tdefl_output_buffer out_buf;
  MZ_CLEAR_OBJ(out_buf);
  if (!pOut_buf)
	return 0;
  out_buf.m_pBuf = (mz_uint8 *)pOut_buf;
  out_buf.m_capacity = out_buf_len;
  if (!tdefl_compress_mem_to_output(
		  pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags))
	return 0;
  return out_buf.m_size;
}

#ifndef MINIZ_NO_ZLIB_APIS
static const mz_uint s_tdefl_num_probes[11] = {0,   1,   6,   32,  16,  32,
											   128, 256, 512, 768, 1500};

// level may actually range from [0,10] (10 is a "hidden" max level, where we
// want a bit more compression and it's fine if throughput to fall off a cliff
// on some files).
mz_uint tdefl_create_comp_flags_from_zip_params(int level, int window_bits,
												int strategy) {
  mz_uint comp_flags =
	  s_tdefl_num_probes[(level >= 0) ? MZ_MIN(10, level) : MZ_DEFAULT_LEVEL] |
	  ((level <= 3) ? TDEFL_GREEDY_PARSING_FLAG : 0);
  if (window_bits > 0)
	comp_flags |= TDEFL_WRITE_ZLIB_HEADER;

  if (!level)
	comp_flags |= TDEFL_FORCE_ALL_RAW_BLOCKS;
  else if (strategy == MZ_FILTERED)
	comp_flags |= TDEFL_FILTER_MATCHES;
  else if (strategy == MZ_HUFFMAN_ONLY)
	comp_flags &= ~TDEFL_MAX_PROBES_MASK;
  else if (strategy == MZ_FIXED)
	comp_flags |= TDEFL_FORCE_ALL_STATIC_BLOCKS;
  else if (strategy == MZ_RLE)
	comp_flags |= TDEFL_RLE_MATCHES;

  return comp_flags;
}
#endif // MINIZ_NO_ZLIB_APIS

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4204) // nonstandard extension used : non-constant
								// aggregate initializer (also supported by GNU
								// C and C99, so no big deal)
#pragma warning(disable : 4244) // 'initializing': conversion from '__int64' to
								// 'int', possible loss of data
#pragma warning(disable : 4267) // 'argument': conversion from '__int64' to 'int',
								// possible loss of data
#pragma warning(disable : 4996) // 'strdup': The POSIX name for this item is
								// deprecated. Instead, use the ISO C and C++
								// conformant name: _strdup.
#endif

// Simple PNG writer function by Alex Evans, 2011. Released into the public
// domain: https://gist.github.com/908299, more context at
// http://altdevblogaday.org/2011/04/06/a-smaller-jpg-encoder/.
// This is actually a modification of Alex's original code so PNG files
// generated by this function pass pngcheck.
void *tdefl_write_image_to_png_file_in_memory_ex(const void *pImage, int w,
												 int h, int num_chans,
												 size_t *pLen_out,
												 mz_uint level, mz_bool flip) {
  // Using a local copy of this array here in case MINIZ_NO_ZLIB_APIS was
  // defined.
  static const mz_uint s_tdefl_png_num_probes[11] = {
	  0, 1, 6, 32, 16, 32, 128, 256, 512, 768, 1500};
  tdefl_compressor *pComp =
	  (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
  tdefl_output_buffer out_buf;
  int i, bpl = w * num_chans, y, z;
  mz_uint32 c;
  *pLen_out = 0;
  if (!pComp)
	return NULL;
  MZ_CLEAR_OBJ(out_buf);
  out_buf.m_expandable = MZ_TRUE;
  out_buf.m_capacity = 57 + MZ_MAX(64, (1 + bpl) * h);
  if (NULL == (out_buf.m_pBuf = (mz_uint8 *)MZ_MALLOC(out_buf.m_capacity))) {
	MZ_FREE(pComp);
	return NULL;
  }
  // write dummy header
  for (z = 41; z; --z)
	tdefl_output_buffer_putter(&z, 1, &out_buf);
  // compress image data
  tdefl_init(pComp, tdefl_output_buffer_putter, &out_buf,
			 s_tdefl_png_num_probes[MZ_MIN(10, level)] |
				 TDEFL_WRITE_ZLIB_HEADER);
  for (y = 0; y < h; ++y) {
	tdefl_compress_buffer(pComp, &z, 1, TDEFL_NO_FLUSH);
	tdefl_compress_buffer(pComp,
						  (mz_uint8 *)pImage + (flip ? (h - 1 - y) : y) * bpl,
						  bpl, TDEFL_NO_FLUSH);
  }
  if (tdefl_compress_buffer(pComp, NULL, 0, TDEFL_FINISH) !=
	  TDEFL_STATUS_DONE) {
	MZ_FREE(pComp);
	MZ_FREE(out_buf.m_pBuf);
	return NULL;
  }
  // write real header
  *pLen_out = out_buf.m_size - 41;
  {
	static const mz_uint8 chans[] = {0x00, 0x00, 0x04, 0x02, 0x06};
	mz_uint8 pnghdr[41] = {
		0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
		0x49, 0x48, 0x44, 0x52, 0, 0, (mz_uint8)(w >> 8), (mz_uint8)w, 0, 0,
		(mz_uint8)(h >> 8), (mz_uint8)h, 8, chans[num_chans], 0, 0, 0, 0, 0, 0,
		0, (mz_uint8)(*pLen_out >> 24), (mz_uint8)(*pLen_out >> 16),
		(mz_uint8)(*pLen_out >> 8), (mz_uint8)*pLen_out, 0x49, 0x44, 0x41,
		0x54};
	c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, pnghdr + 12, 17);
	for (i = 0; i < 4; ++i, c <<= 8)
	  ((mz_uint8 *)(pnghdr + 29))[i] = (mz_uint8)(c >> 24);
	memcpy(out_buf.m_pBuf, pnghdr, 41);
  }
  // write footer (IDAT CRC-32, followed by IEND chunk)
  if (!tdefl_output_buffer_putter(
		  "\0\0\0\0\0\0\0\0\x49\x45\x4e\x44\xae\x42\x60\x82", 16, &out_buf)) {
	*pLen_out = 0;
	MZ_FREE(pComp);
	MZ_FREE(out_buf.m_pBuf);
	return NULL;
  }
  c = (mz_uint32)mz_crc32(MZ_CRC32_INIT, out_buf.m_pBuf + 41 - 4,
						  *pLen_out + 4);
  for (i = 0; i < 4; ++i, c <<= 8)
	(out_buf.m_pBuf + out_buf.m_size - 16)[i] = (mz_uint8)(c >> 24);
  // compute final size of file, grab compressed data buffer and return
  *pLen_out += 57;
  MZ_FREE(pComp);
  return out_buf.m_pBuf;
}
void *tdefl_write_image_to_png_file_in_memory(const void *pImage, int w, int h,
											  int num_chans, size_t *pLen_out) {
  // Level 6 corresponds to TDEFL_DEFAULT_MAX_PROBES or MZ_DEFAULT_LEVEL (but we
  // can't depend on MZ_DEFAULT_LEVEL being available in case the zlib API's
  // where #defined out)
  return tdefl_write_image_to_png_file_in_memory_ex(pImage, w, h, num_chans,
													pLen_out, 6, MZ_FALSE);
}

// ------------------- .ZIP archive reading

#ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef MINIZ_NO_STDIO
#define MZ_FILE void *
#else
#include <stdio.h>
#include <sys/stat.h>

#if defined(_MSC_VER) || defined(__MINGW64__)
static FILE *mz_fopen(const char *pFilename, const char *pMode) {
  FILE *pFile = NULL;
  fopen_s(&pFile, pFilename, pMode);
  return pFile;
}
static FILE *mz_freopen(const char *pPath, const char *pMode, FILE *pStream) {
  FILE *pFile = NULL;
  if (freopen_s(&pFile, pPath, pMode, pStream))
	return NULL;
  return pFile;
}
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FILE FILE
#define MZ_FOPEN mz_fopen
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 _ftelli64
#define MZ_FSEEK64 _fseeki64
#define MZ_FILE_STAT_STRUCT _stat
#define MZ_FILE_STAT _stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN mz_freopen
#define MZ_DELETE_FILE remove
#elif defined(__MINGW32__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FILE FILE
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello64
#define MZ_FSEEK64 fseeko64
#define MZ_FILE_STAT_STRUCT _stat
#define MZ_FILE_STAT _stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove
#elif defined(__TINYC__)
#ifndef MINIZ_NO_TIME
#include <sys/utime.h>
#endif
#define MZ_FILE FILE
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftell
#define MZ_FSEEK64 fseek
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove
#elif defined(__GNUC__) && defined(_LARGEFILE64_SOURCE) && _LARGEFILE64_SOURCE
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FILE FILE
#define MZ_FOPEN(f, m) fopen64(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello64
#define MZ_FSEEK64 fseeko64
#define MZ_FILE_STAT_STRUCT stat64
#define MZ_FILE_STAT stat64
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(p, m, s) freopen64(p, m, s)
#define MZ_DELETE_FILE remove
#else
#ifndef MINIZ_NO_TIME
#include <utime.h>
#endif
#define MZ_FILE FILE
#define MZ_FOPEN(f, m) fopen(f, m)
#define MZ_FCLOSE fclose
#define MZ_FREAD fread
#define MZ_FWRITE fwrite
#define MZ_FTELL64 ftello
#define MZ_FSEEK64 fseeko
#define MZ_FILE_STAT_STRUCT stat
#define MZ_FILE_STAT stat
#define MZ_FFLUSH fflush
#define MZ_FREOPEN(f, m, s) freopen(f, m, s)
#define MZ_DELETE_FILE remove
#endif // #ifdef _MSC_VER
#endif // #ifdef MINIZ_NO_STDIO

#define MZ_TOLOWER(c) ((((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c))

// Various ZIP archive enums. To completely avoid cross platform compiler
// alignment and platform endian issues, miniz.c doesn't use structs for any of
// this stuff.
enum {
  // ZIP archive identifiers and record sizes
  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG = 0x06054b50,
  MZ_ZIP_CENTRAL_DIR_HEADER_SIG = 0x02014b50,
  MZ_ZIP_LOCAL_DIR_HEADER_SIG = 0x04034b50,
  MZ_ZIP_LOCAL_DIR_HEADER_SIZE = 30,
  MZ_ZIP_CENTRAL_DIR_HEADER_SIZE = 46,
  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE = 22,
  // Central directory header record offsets
  MZ_ZIP_CDH_SIG_OFS = 0,
  MZ_ZIP_CDH_VERSION_MADE_BY_OFS = 4,
  MZ_ZIP_CDH_VERSION_NEEDED_OFS = 6,
  MZ_ZIP_CDH_BIT_FLAG_OFS = 8,
  MZ_ZIP_CDH_METHOD_OFS = 10,
  MZ_ZIP_CDH_FILE_TIME_OFS = 12,
  MZ_ZIP_CDH_FILE_DATE_OFS = 14,
  MZ_ZIP_CDH_CRC32_OFS = 16,
  MZ_ZIP_CDH_COMPRESSED_SIZE_OFS = 20,
  MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS = 24,
  MZ_ZIP_CDH_FILENAME_LEN_OFS = 28,
  MZ_ZIP_CDH_EXTRA_LEN_OFS = 30,
  MZ_ZIP_CDH_COMMENT_LEN_OFS = 32,
  MZ_ZIP_CDH_DISK_START_OFS = 34,
  MZ_ZIP_CDH_INTERNAL_ATTR_OFS = 36,
  MZ_ZIP_CDH_EXTERNAL_ATTR_OFS = 38,
  MZ_ZIP_CDH_LOCAL_HEADER_OFS = 42,
  // Local directory header offsets
  MZ_ZIP_LDH_SIG_OFS = 0,
  MZ_ZIP_LDH_VERSION_NEEDED_OFS = 4,
  MZ_ZIP_LDH_BIT_FLAG_OFS = 6,
  MZ_ZIP_LDH_METHOD_OFS = 8,
  MZ_ZIP_LDH_FILE_TIME_OFS = 10,
  MZ_ZIP_LDH_FILE_DATE_OFS = 12,
  MZ_ZIP_LDH_CRC32_OFS = 14,
  MZ_ZIP_LDH_COMPRESSED_SIZE_OFS = 18,
  MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS = 22,
  MZ_ZIP_LDH_FILENAME_LEN_OFS = 26,
  MZ_ZIP_LDH_EXTRA_LEN_OFS = 28,
  // End of central directory offsets
  MZ_ZIP_ECDH_SIG_OFS = 0,
  MZ_ZIP_ECDH_NUM_THIS_DISK_OFS = 4,
  MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS = 6,
  MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS = 8,
  MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS = 10,
  MZ_ZIP_ECDH_CDIR_SIZE_OFS = 12,
  MZ_ZIP_ECDH_CDIR_OFS_OFS = 16,
  MZ_ZIP_ECDH_COMMENT_SIZE_OFS = 20,
};

typedef struct {
  void *m_p;
  size_t m_size, m_capacity;
  mz_uint m_element_size;
} mz_zip_array;

struct mz_zip_internal_state_tag {
  mz_zip_array m_central_dir;
  mz_zip_array m_central_dir_offsets;
  mz_zip_array m_sorted_central_dir_offsets;
  MZ_FILE *m_pFile;
  void *m_pMem;
  size_t m_mem_size;
  size_t m_mem_capacity;
};

#define MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(array_ptr, element_size)                 \
  (array_ptr)->m_element_size = element_size
#define MZ_ZIP_ARRAY_ELEMENT(array_ptr, element_type, index)                   \
  ((element_type *)((array_ptr)->m_p))[index]

static MZ_FORCEINLINE void mz_zip_array_clear(mz_zip_archive *pZip,
											  mz_zip_array *pArray) {
  pZip->m_pFree(pZip->m_pAlloc_opaque, pArray->m_p);
  memset(pArray, 0, sizeof(mz_zip_array));
}

static mz_bool mz_zip_array_ensure_capacity(mz_zip_archive *pZip,
											mz_zip_array *pArray,
											size_t min_new_capacity,
											mz_uint growing) {
  void *pNew_p;
  size_t new_capacity = min_new_capacity;
  MZ_ASSERT(pArray->m_element_size);
  if (pArray->m_capacity >= min_new_capacity)
	return MZ_TRUE;
  if (growing) {
	new_capacity = MZ_MAX(1, pArray->m_capacity);
	while (new_capacity < min_new_capacity)
	  new_capacity *= 2;
  }
  if (NULL == (pNew_p = pZip->m_pRealloc(pZip->m_pAlloc_opaque, pArray->m_p,
										 pArray->m_element_size, new_capacity)))
	return MZ_FALSE;
  pArray->m_p = pNew_p;
  pArray->m_capacity = new_capacity;
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool
mz_zip_array_reserve(mz_zip_archive *pZip, mz_zip_array *pArray,
					 size_t new_capacity, mz_uint growing) {
  if (new_capacity > pArray->m_capacity) {
	if (!mz_zip_array_ensure_capacity(pZip, pArray, new_capacity, growing))
	  return MZ_FALSE;
  }
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool
mz_zip_array_resize(mz_zip_archive *pZip, mz_zip_array *pArray, size_t new_size,
					mz_uint growing) {
  if (new_size > pArray->m_capacity) {
	if (!mz_zip_array_ensure_capacity(pZip, pArray, new_size, growing))
	  return MZ_FALSE;
  }
  pArray->m_size = new_size;
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool
mz_zip_array_ensure_room(mz_zip_archive *pZip, mz_zip_array *pArray, size_t n) {
  return mz_zip_array_reserve(pZip, pArray, pArray->m_size + n, MZ_TRUE);
}

static MZ_FORCEINLINE mz_bool
mz_zip_array_push_back(mz_zip_archive *pZip, mz_zip_array *pArray,
					   const void *pElements, size_t n) {
  size_t orig_size = pArray->m_size;
  if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))
	return MZ_FALSE;
  memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size,
		 pElements, n * pArray->m_element_size);
  return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static time_t mz_zip_dos_to_time_t(int dos_time, int dos_date) {
  struct tm tm;
  memset(&tm, 0, sizeof(tm));
  tm.tm_isdst = -1;
  tm.tm_year = ((dos_date >> 9) & 127) + 1980 - 1900;
  tm.tm_mon = ((dos_date >> 5) & 15) - 1;
  tm.tm_mday = dos_date & 31;
  tm.tm_hour = (dos_time >> 11) & 31;
  tm.tm_min = (dos_time >> 5) & 63;
  tm.tm_sec = (dos_time << 1) & 62;
  return mktime(&tm);
}

static void mz_zip_time_to_dos_time(time_t time, mz_uint16 *pDOS_time,
									mz_uint16 *pDOS_date) {
#ifdef _MSC_VER
  struct tm tm_struct;
  struct tm *tm = &tm_struct;
  errno_t err = localtime_s(tm, &time);
  if (err) {
	*pDOS_date = 0;
	*pDOS_time = 0;
	return;
  }
#else
  struct tm *tm = localtime(&time);
#endif
  *pDOS_time = (mz_uint16)(((tm->tm_hour) << 11) + ((tm->tm_min) << 5) +
						   ((tm->tm_sec) >> 1));
  *pDOS_date = (mz_uint16)(((tm->tm_year + 1900 - 1980) << 9) +
						   ((tm->tm_mon + 1) << 5) + tm->tm_mday);
}
#endif

#ifndef MINIZ_NO_STDIO
static mz_bool mz_zip_get_file_modified_time(const char *pFilename,
											 mz_uint16 *pDOS_time,
											 mz_uint16 *pDOS_date) {
#ifdef MINIZ_NO_TIME
  (void)pFilename;
  *pDOS_date = *pDOS_time = 0;
#else
  struct MZ_FILE_STAT_STRUCT file_stat;
  // On Linux with x86 glibc, this call will fail on large files (>= 0x80000000
  // bytes) unless you compiled with _LARGEFILE64_SOURCE. Argh.
  if (MZ_FILE_STAT(pFilename, &file_stat) != 0)
	return MZ_FALSE;
  mz_zip_time_to_dos_time(file_stat.st_mtime, pDOS_time, pDOS_date);
#endif // #ifdef MINIZ_NO_TIME
  return MZ_TRUE;
}

#ifndef MINIZ_NO_TIME
static mz_bool mz_zip_set_file_times(const char *pFilename, time_t access_time,
									 time_t modified_time) {
  struct utimbuf t;
  t.actime = access_time;
  t.modtime = modified_time;
  return !utime(pFilename, &t);
}
#endif // #ifndef MINIZ_NO_TIME
#endif // #ifndef MINIZ_NO_STDIO

static mz_bool mz_zip_reader_init_internal(mz_zip_archive *pZip,
										   mz_uint32 flags) {
  (void)flags;
  if ((!pZip) || (pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
	return MZ_FALSE;

  if (!pZip->m_pAlloc)
	pZip->m_pAlloc = def_alloc_func;
  if (!pZip->m_pFree)
	pZip->m_pFree = def_free_func;
  if (!pZip->m_pRealloc)
	pZip->m_pRealloc = def_realloc_func;

  pZip->m_zip_mode = MZ_ZIP_MODE_READING;
  pZip->m_archive_size = 0;
  pZip->m_central_directory_file_ofs = 0;
  pZip->m_total_files = 0;

  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(
				   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
	return MZ_FALSE;
  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,
								sizeof(mz_uint8));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,
								sizeof(mz_uint32));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,
								sizeof(mz_uint32));
  return MZ_TRUE;
}

static MZ_FORCEINLINE mz_bool
mz_zip_reader_filename_less(const mz_zip_array *pCentral_dir_array,
							const mz_zip_array *pCentral_dir_offsets,
							mz_uint l_index, mz_uint r_index) {
  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(
						   pCentral_dir_array, mz_uint8,
						   MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,
												l_index)),
				 *pE;
  const mz_uint8 *pR =
	  &MZ_ZIP_ARRAY_ELEMENT(
		  pCentral_dir_array, mz_uint8,
		  MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32, r_index));
  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS),
		  r_len = MZ_READ_LE16(pR + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  mz_uint8 l = 0, r = 0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pR += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pE = pL + MZ_MIN(l_len, r_len);
  while (pL < pE) {
	if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
	  break;
	pL++;
	pR++;
  }
  return (pL == pE) ? (l_len < r_len) : (l < r);
}

#define MZ_SWAP_UINT32(a, b)                                                   \
  do {                                                                         \
	mz_uint32 t = a;                                                           \
	a = b;                                                                     \
	b = t;                                                                     \
  }                                                                            \
  MZ_MACRO_END

// Heap sort of lowercased filenames, used to help accelerate plain central
// directory searches by mz_zip_reader_locate_file(). (Could also use qsort(),
// but it could allocate memory.)
static void
mz_zip_reader_sort_central_dir_offsets_by_filename(mz_zip_archive *pZip) {
  mz_zip_internal_state *pState = pZip->m_pState;
  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
  mz_uint32 *pIndices =
	  &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32,
							0);
  const int size = pZip->m_total_files;
  int start = (size - 2) >> 1, end;
  while (start >= 0) {
	int child, root = start;
	for (;;) {
	  if ((child = (root << 1) + 1) >= size)
		break;
	  child +=
		  (((child + 1) < size) &&
		   (mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
										pIndices[child], pIndices[child + 1])));
	  if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
									   pIndices[root], pIndices[child]))
		break;
	  MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
	  root = child;
	}
	start--;
  }

  end = size - 1;
  while (end > 0) {
	int child, root = 0;
	MZ_SWAP_UINT32(pIndices[end], pIndices[0]);
	for (;;) {
	  if ((child = (root << 1) + 1) >= end)
		break;
	  child +=
		  (((child + 1) < end) &&
		   mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
									   pIndices[child], pIndices[child + 1]));
	  if (!mz_zip_reader_filename_less(pCentral_dir, pCentral_dir_offsets,
									   pIndices[root], pIndices[child]))
		break;
	  MZ_SWAP_UINT32(pIndices[root], pIndices[child]);
	  root = child;
	}
	end--;
  }
}

static mz_bool mz_zip_reader_read_central_dir(mz_zip_archive *pZip,
											  mz_uint32 flags) {
  mz_uint cdir_size, num_this_disk, cdir_disk_index;
  mz_uint64 cdir_ofs;
  mz_int64 cur_file_ofs;
  const mz_uint8 *p;
  mz_uint32 buf_u32[4096 / sizeof(mz_uint32)];
  mz_uint8 *pBuf = (mz_uint8 *)buf_u32;
  mz_bool sort_central_dir =
	  ((flags & MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY) == 0);
  // Basic sanity checks - reject files which are too small, and check the first
  // 4 bytes of the file to make sure a local header is there.
  if (pZip->m_archive_size < MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
	return MZ_FALSE;
  // Find the end of central directory record by scanning the file from the end
  // towards the beginning.
  cur_file_ofs =
	  MZ_MAX((mz_int64)pZip->m_archive_size - (mz_int64)sizeof(buf_u32), 0);
  for (;;) {
	int i,
		n = (int)MZ_MIN(sizeof(buf_u32), pZip->m_archive_size - cur_file_ofs);
	if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf, n) != (mz_uint)n)
	  return MZ_FALSE;
	for (i = n - 4; i >= 0; --i)
	  if (MZ_READ_LE32(pBuf + i) == MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG)
		break;
	if (i >= 0) {
	  cur_file_ofs += i;
	  break;
	}
	if ((!cur_file_ofs) || ((pZip->m_archive_size - cur_file_ofs) >=
							(0xFFFF + MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)))
	  return MZ_FALSE;
	cur_file_ofs = MZ_MAX(cur_file_ofs - (sizeof(buf_u32) - 3), 0);
  }
  // Read and verify the end of central directory record.
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,
					MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) !=
	  MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE)
	return MZ_FALSE;
  if ((MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_SIG_OFS) !=
	   MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG) ||
	  ((pZip->m_total_files =
			MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS)) !=
	   MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS)))
	return MZ_FALSE;

  num_this_disk = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_THIS_DISK_OFS);
  cdir_disk_index = MZ_READ_LE16(pBuf + MZ_ZIP_ECDH_NUM_DISK_CDIR_OFS);
  if (((num_this_disk | cdir_disk_index) != 0) &&
	  ((num_this_disk != 1) || (cdir_disk_index != 1)))
	return MZ_FALSE;

  if ((cdir_size = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_SIZE_OFS)) <
	  pZip->m_total_files * MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)
	return MZ_FALSE;

  cdir_ofs = MZ_READ_LE32(pBuf + MZ_ZIP_ECDH_CDIR_OFS_OFS);
  if ((cdir_ofs + (mz_uint64)cdir_size) > pZip->m_archive_size)
	return MZ_FALSE;

  pZip->m_central_directory_file_ofs = cdir_ofs;

  if (pZip->m_total_files) {
	mz_uint i, n;

	// Read the entire central directory into a heap block, and allocate another
	// heap block to hold the unsorted central dir file record offsets, and
	// another to hold the sorted indices.
	if ((!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir, cdir_size,
							  MZ_FALSE)) ||
		(!mz_zip_array_resize(pZip, &pZip->m_pState->m_central_dir_offsets,
							  pZip->m_total_files, MZ_FALSE)))
	  return MZ_FALSE;

	if (sort_central_dir) {
	  if (!mz_zip_array_resize(pZip,
							   &pZip->m_pState->m_sorted_central_dir_offsets,
							   pZip->m_total_files, MZ_FALSE))
		return MZ_FALSE;
	}

	if (pZip->m_pRead(pZip->m_pIO_opaque, cdir_ofs,
					  pZip->m_pState->m_central_dir.m_p,
					  cdir_size) != cdir_size)
	  return MZ_FALSE;

	// Now create an index into the central directory file records, do some
	// basic sanity checking on each record, and check for zip64 entries (which
	// are not yet supported).
	p = (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p;
	for (n = cdir_size, i = 0; i < pZip->m_total_files; ++i) {
	  mz_uint total_header_size, comp_size, decomp_size, disk_index;
	  if ((n < MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) ||
		  (MZ_READ_LE32(p) != MZ_ZIP_CENTRAL_DIR_HEADER_SIG))
		return MZ_FALSE;
	  MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets, mz_uint32,
						   i) =
		  (mz_uint32)(p - (const mz_uint8 *)pZip->m_pState->m_central_dir.m_p);
	  if (sort_central_dir)
		MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_sorted_central_dir_offsets,
							 mz_uint32, i) = i;
	  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
	  decomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
	  if (((!MZ_READ_LE32(p + MZ_ZIP_CDH_METHOD_OFS)) &&
		   (decomp_size != comp_size)) ||
		  (decomp_size && !comp_size) || (decomp_size == 0xFFFFFFFF) ||
		  (comp_size == 0xFFFFFFFF))
		return MZ_FALSE;
	  disk_index = MZ_READ_LE16(p + MZ_ZIP_CDH_DISK_START_OFS);
	  if ((disk_index != num_this_disk) && (disk_index != 1))
		return MZ_FALSE;
	  if (((mz_uint64)MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS) +
		   MZ_ZIP_LOCAL_DIR_HEADER_SIZE + comp_size) > pZip->m_archive_size)
		return MZ_FALSE;
	  if ((total_header_size = MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
							   MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +
							   MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS) +
							   MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS)) >
		  n)
		return MZ_FALSE;
	  n -= total_header_size;
	  p += total_header_size;
	}
  }

  if (sort_central_dir)
	mz_zip_reader_sort_central_dir_offsets_by_filename(pZip);

  return MZ_TRUE;
}

mz_bool mz_zip_reader_init(mz_zip_archive *pZip, mz_uint64 size,
						   mz_uint32 flags) {
  if ((!pZip) || (!pZip->m_pRead))
	return MZ_FALSE;
  if (!mz_zip_reader_init_internal(pZip, flags))
	return MZ_FALSE;
  pZip->m_archive_size = size;
  if (!mz_zip_reader_read_central_dir(pZip, flags)) {
	mz_zip_reader_end(pZip);
	return MZ_FALSE;
  }
  return MZ_TRUE;
}

static size_t mz_zip_mem_read_func(void *pOpaque, mz_uint64 file_ofs,
								   void *pBuf, size_t n) {
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  size_t s = (file_ofs >= pZip->m_archive_size)
				 ? 0
				 : (size_t)MZ_MIN(pZip->m_archive_size - file_ofs, n);
  memcpy(pBuf, (const mz_uint8 *)pZip->m_pState->m_pMem + file_ofs, s);
  return s;
}

mz_bool mz_zip_reader_init_mem(mz_zip_archive *pZip, const void *pMem,
							   size_t size, mz_uint32 flags) {
  if (!mz_zip_reader_init_internal(pZip, flags))
	return MZ_FALSE;
  pZip->m_archive_size = size;
  pZip->m_pRead = mz_zip_mem_read_func;
  pZip->m_pIO_opaque = pZip;
#ifdef __cplusplus
  pZip->m_pState->m_pMem = const_cast<void *>(pMem);
#else
  pZip->m_pState->m_pMem = (void *)pMem;
#endif
  pZip->m_pState->m_mem_size = size;
  if (!mz_zip_reader_read_central_dir(pZip, flags)) {
	mz_zip_reader_end(pZip);
	return MZ_FALSE;
  }
  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_read_func(void *pOpaque, mz_uint64 file_ofs,
									void *pBuf, size_t n) {
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
  if (((mz_int64)file_ofs < 0) ||
	  (((cur_ofs != (mz_int64)file_ofs)) &&
	   (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
	return 0;
  return MZ_FREAD(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_reader_init_file(mz_zip_archive *pZip, const char *pFilename,
								mz_uint32 flags) {
  mz_uint64 file_size;
  MZ_FILE *pFile = MZ_FOPEN(pFilename, "rb");
  if (!pFile)
	return MZ_FALSE;
  if (MZ_FSEEK64(pFile, 0, SEEK_END)) {
	MZ_FCLOSE(pFile);
	return MZ_FALSE;
  }
  file_size = MZ_FTELL64(pFile);
  if (!mz_zip_reader_init_internal(pZip, flags)) {
	MZ_FCLOSE(pFile);
	return MZ_FALSE;
  }
  pZip->m_pRead = mz_zip_file_read_func;
  pZip->m_pIO_opaque = pZip;
  pZip->m_pState->m_pFile = pFile;
  pZip->m_archive_size = file_size;
  if (!mz_zip_reader_read_central_dir(pZip, flags)) {
	mz_zip_reader_end(pZip);
	return MZ_FALSE;
  }
  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_uint mz_zip_reader_get_num_files(mz_zip_archive *pZip) {
  return pZip ? pZip->m_total_files : 0;
}

static MZ_FORCEINLINE const mz_uint8 *
mz_zip_reader_get_cdh(mz_zip_archive *pZip, mz_uint file_index) {
  if ((!pZip) || (!pZip->m_pState) || (file_index >= pZip->m_total_files) ||
	  (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
	return NULL;
  return &MZ_ZIP_ARRAY_ELEMENT(
			 &pZip->m_pState->m_central_dir, mz_uint8,
			 MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets,
								  mz_uint32, file_index));
}

mz_bool mz_zip_reader_is_file_encrypted(mz_zip_archive *pZip,
										mz_uint file_index) {
  mz_uint m_bit_flag;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p)
	return MZ_FALSE;
  m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
  return (m_bit_flag & 1);
}

mz_bool mz_zip_reader_is_file_a_directory(mz_zip_archive *pZip,
										  mz_uint file_index) {
  mz_uint filename_len, external_attr;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p)
	return MZ_FALSE;

  // First see if the filename ends with a '/' character.
  filename_len = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  if (filename_len) {
	if (*(p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_len - 1) == '/')
	  return MZ_TRUE;
  }

  // Bugfix: This code was also checking if the internal attribute was non-zero,
  // which wasn't correct.
  // Most/all zip writers (hopefully) set DOS file/directory attributes in the
  // low 16-bits, so check for the DOS directory flag and ignore the source OS
  // ID in the created by field.
  // FIXME: Remove this check? Is it necessary - we already check the filename.
  external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
  if ((external_attr & 0x10) != 0)
	return MZ_TRUE;

  return MZ_FALSE;
}

mz_bool mz_zip_reader_file_stat(mz_zip_archive *pZip, mz_uint file_index,
								mz_zip_archive_file_stat *pStat) {
  mz_uint n;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if ((!p) || (!pStat))
	return MZ_FALSE;

  // Unpack the central directory record.
  pStat->m_file_index = file_index;
  pStat->m_central_dir_ofs = MZ_ZIP_ARRAY_ELEMENT(
	  &pZip->m_pState->m_central_dir_offsets, mz_uint32, file_index);
  pStat->m_version_made_by = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_MADE_BY_OFS);
  pStat->m_version_needed = MZ_READ_LE16(p + MZ_ZIP_CDH_VERSION_NEEDED_OFS);
  pStat->m_bit_flag = MZ_READ_LE16(p + MZ_ZIP_CDH_BIT_FLAG_OFS);
  pStat->m_method = MZ_READ_LE16(p + MZ_ZIP_CDH_METHOD_OFS);
#ifndef MINIZ_NO_TIME
  pStat->m_time =
	  mz_zip_dos_to_time_t(MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_TIME_OFS),
						   MZ_READ_LE16(p + MZ_ZIP_CDH_FILE_DATE_OFS));
#endif
  pStat->m_crc32 = MZ_READ_LE32(p + MZ_ZIP_CDH_CRC32_OFS);
  pStat->m_comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
  pStat->m_uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);
  pStat->m_internal_attr = MZ_READ_LE16(p + MZ_ZIP_CDH_INTERNAL_ATTR_OFS);
  pStat->m_external_attr = MZ_READ_LE32(p + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS);
  pStat->m_local_header_ofs = MZ_READ_LE32(p + MZ_ZIP_CDH_LOCAL_HEADER_OFS);

  // Copy as much of the filename and comment as possible.
  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILENAME_SIZE - 1);
  memcpy(pStat->m_filename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
  pStat->m_filename[n] = '\0';

  n = MZ_READ_LE16(p + MZ_ZIP_CDH_COMMENT_LEN_OFS);
  n = MZ_MIN(n, MZ_ZIP_MAX_ARCHIVE_FILE_COMMENT_SIZE - 1);
  pStat->m_comment_size = n;
  memcpy(pStat->m_comment, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
							   MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS) +
							   MZ_READ_LE16(p + MZ_ZIP_CDH_EXTRA_LEN_OFS),
		 n);
  pStat->m_comment[n] = '\0';

  return MZ_TRUE;
}

mz_uint mz_zip_reader_get_filename(mz_zip_archive *pZip, mz_uint file_index,
								   char *pFilename, mz_uint filename_buf_size) {
  mz_uint n;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  if (!p) {
	if (filename_buf_size)
	  pFilename[0] = '\0';
	return 0;
  }
  n = MZ_READ_LE16(p + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  if (filename_buf_size) {
	n = MZ_MIN(n, filename_buf_size - 1);
	memcpy(pFilename, p + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n);
	pFilename[n] = '\0';
  }
  return n + 1;
}

static MZ_FORCEINLINE mz_bool
mz_zip_reader_string_equal(const char *pA, const char *pB, mz_uint len,
						   mz_uint flags) {
  mz_uint i;
  if (flags & MZ_ZIP_FLAG_CASE_SENSITIVE)
	return 0 == memcmp(pA, pB, len);
  for (i = 0; i < len; ++i)
	if (MZ_TOLOWER(pA[i]) != MZ_TOLOWER(pB[i]))
	  return MZ_FALSE;
  return MZ_TRUE;
}

static MZ_FORCEINLINE int
mz_zip_reader_filename_compare(const mz_zip_array *pCentral_dir_array,
							   const mz_zip_array *pCentral_dir_offsets,
							   mz_uint l_index, const char *pR, mz_uint r_len) {
  const mz_uint8 *pL = &MZ_ZIP_ARRAY_ELEMENT(
						   pCentral_dir_array, mz_uint8,
						   MZ_ZIP_ARRAY_ELEMENT(pCentral_dir_offsets, mz_uint32,
												l_index)),
				 *pE;
  mz_uint l_len = MZ_READ_LE16(pL + MZ_ZIP_CDH_FILENAME_LEN_OFS);
  mz_uint8 l = 0, r = 0;
  pL += MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
  pE = pL + MZ_MIN(l_len, r_len);
  while (pL < pE) {
	if ((l = MZ_TOLOWER(*pL)) != (r = MZ_TOLOWER(*pR)))
	  break;
	pL++;
	pR++;
  }
  return (pL == pE) ? (int)(l_len - r_len) : (l - r);
}

static int mz_zip_reader_locate_file_binary_search(mz_zip_archive *pZip,
												   const char *pFilename) {
  mz_zip_internal_state *pState = pZip->m_pState;
  const mz_zip_array *pCentral_dir_offsets = &pState->m_central_dir_offsets;
  const mz_zip_array *pCentral_dir = &pState->m_central_dir;
  mz_uint32 *pIndices =
	  &MZ_ZIP_ARRAY_ELEMENT(&pState->m_sorted_central_dir_offsets, mz_uint32,
							0);
  const int size = pZip->m_total_files;
  const mz_uint filename_len = (mz_uint)strlen(pFilename);
  int l = 0, h = size - 1;
  while (l <= h) {
	int m = (l + h) >> 1, file_index = pIndices[m],
		comp =
			mz_zip_reader_filename_compare(pCentral_dir, pCentral_dir_offsets,
										   file_index, pFilename, filename_len);
	if (!comp)
	  return file_index;
	else if (comp < 0)
	  l = m + 1;
	else
	  h = m - 1;
  }
  return -1;
}

int mz_zip_reader_locate_file(mz_zip_archive *pZip, const char *pName,
							  const char *pComment, mz_uint flags) {
  mz_uint file_index;
  size_t name_len, comment_len;
  if ((!pZip) || (!pZip->m_pState) || (!pName) ||
	  (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
	return -1;
  if (((flags & (MZ_ZIP_FLAG_IGNORE_PATH | MZ_ZIP_FLAG_CASE_SENSITIVE)) == 0) &&
	  (!pComment) && (pZip->m_pState->m_sorted_central_dir_offsets.m_size))
	return mz_zip_reader_locate_file_binary_search(pZip, pName);
  name_len = strlen(pName);
  if (name_len > 0xFFFF)
	return -1;
  comment_len = pComment ? strlen(pComment) : 0;
  if (comment_len > 0xFFFF)
	return -1;
  for (file_index = 0; file_index < pZip->m_total_files; file_index++) {
	const mz_uint8 *pHeader =
		&MZ_ZIP_ARRAY_ELEMENT(
			&pZip->m_pState->m_central_dir, mz_uint8,
			MZ_ZIP_ARRAY_ELEMENT(&pZip->m_pState->m_central_dir_offsets,
								 mz_uint32, file_index));
	mz_uint filename_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_FILENAME_LEN_OFS);
	const char *pFilename =
		(const char *)pHeader + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE;
	if (filename_len < name_len)
	  continue;
	if (comment_len) {
	  mz_uint file_extra_len = MZ_READ_LE16(pHeader + MZ_ZIP_CDH_EXTRA_LEN_OFS),
			  file_comment_len =
				  MZ_READ_LE16(pHeader + MZ_ZIP_CDH_COMMENT_LEN_OFS);
	  const char *pFile_comment = pFilename + filename_len + file_extra_len;
	  if ((file_comment_len != comment_len) ||
		  (!mz_zip_reader_string_equal(pComment, pFile_comment,
									   file_comment_len, flags)))
		continue;
	}
	if ((flags & MZ_ZIP_FLAG_IGNORE_PATH) && (filename_len)) {
	  int ofs = filename_len - 1;
	  do {
		if ((pFilename[ofs] == '/') || (pFilename[ofs] == '\\') ||
			(pFilename[ofs] == ':'))
		  break;
	  } while (--ofs >= 0);
	  ofs++;
	  pFilename += ofs;
	  filename_len -= ofs;
	}
	if ((filename_len == name_len) &&
		(mz_zip_reader_string_equal(pName, pFilename, filename_len, flags)))
	  return file_index;
  }
  return -1;
}

mz_bool mz_zip_reader_extract_to_mem_no_alloc(mz_zip_archive *pZip,
											  mz_uint file_index, void *pBuf,
											  size_t buf_size, mz_uint flags,
											  void *pUser_read_buf,
											  size_t user_read_buf_size) {
  int status = TINFL_STATUS_DONE;
  mz_uint64 needed_size, cur_file_ofs, comp_remaining,
	  out_buf_ofs = 0, read_buf_size, read_buf_ofs = 0, read_buf_avail;
  mz_zip_archive_file_stat file_stat;
  void *pRead_buf;
  mz_uint32
	  local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /
					   sizeof(mz_uint32)];
  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
  tinfl_decompressor inflator;

  if ((buf_size) && (!pBuf))
	return MZ_FALSE;

  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
	return MZ_FALSE;

  // Empty file, or a directory (but not always a directory - I've seen odd zips
  // with directories that have compressed data which inflates to 0 bytes)
  if (!file_stat.m_comp_size)
	return MZ_TRUE;

  // Entry is a subdirectory (I've seen old zips with dir entries which have
  // compressed deflate data which inflates to 0 bytes, but these entries claim
  // to uncompress to 512 bytes in the headers).
  // I'm torn how to handle this case - should it fail instead?
  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
	return MZ_TRUE;

  // Encryption and patch files are not supported.
  if (file_stat.m_bit_flag & (1 | 32))
	return MZ_FALSE;

  // This function only supports stored and deflate.
  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&
	  (file_stat.m_method != MZ_DEFLATED))
	return MZ_FALSE;

  // Ensure supplied output buffer is large enough.
  needed_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? file_stat.m_comp_size
													  : file_stat.m_uncomp_size;
  if (buf_size < needed_size)
	return MZ_FALSE;

  // Read and parse the local directory entry.
  cur_file_ofs = file_stat.m_local_header_ofs;
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,
					MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
	  MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
	return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
	return MZ_FALSE;

  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +
				  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +
				  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
	return MZ_FALSE;

  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
	// The file is stored or the caller has requested the compressed data.
	if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pBuf,
					  (size_t)needed_size) != needed_size)
	  return MZ_FALSE;
	return ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) != 0) ||
		   (mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,
					 (size_t)file_stat.m_uncomp_size) == file_stat.m_crc32);
  }

  // Decompress the file either directly from memory or from a file input
  // buffer.
  tinfl_init(&inflator);

  if (pZip->m_pState->m_pMem) {
	// Read directly from the archive in memory.
	pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
	read_buf_size = read_buf_avail = file_stat.m_comp_size;
	comp_remaining = 0;
  } else if (pUser_read_buf) {
	// Use a user provided read buffer.
	if (!user_read_buf_size)
	  return MZ_FALSE;
	pRead_buf = (mz_uint8 *)pUser_read_buf;
	read_buf_size = user_read_buf_size;
	read_buf_avail = 0;
	comp_remaining = file_stat.m_comp_size;
  } else {
	// Temporarily allocate a read buffer.
	read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);
#ifdef _MSC_VER
	if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&
		(read_buf_size > 0x7FFFFFFF))
#else
	if (((sizeof(size_t) == sizeof(mz_uint32))) && (read_buf_size > 0x7FFFFFFF))
#endif
	  return MZ_FALSE;
	if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
											(size_t)read_buf_size)))
	  return MZ_FALSE;
	read_buf_avail = 0;
	comp_remaining = file_stat.m_comp_size;
  }

  do {
	size_t in_buf_size,
		out_buf_size = (size_t)(file_stat.m_uncomp_size - out_buf_ofs);
	if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
	  read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
	  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,
						(size_t)read_buf_avail) != read_buf_avail) {
		status = TINFL_STATUS_FAILED;
		break;
	  }
	  cur_file_ofs += read_buf_avail;
	  comp_remaining -= read_buf_avail;
	  read_buf_ofs = 0;
	}
	in_buf_size = (size_t)read_buf_avail;
	status = tinfl_decompress(
		&inflator, (mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,
		(mz_uint8 *)pBuf, (mz_uint8 *)pBuf + out_buf_ofs, &out_buf_size,
		TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF |
			(comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0));
	read_buf_avail -= in_buf_size;
	read_buf_ofs += in_buf_size;
	out_buf_ofs += out_buf_size;
  } while (status == TINFL_STATUS_NEEDS_MORE_INPUT);

  if (status == TINFL_STATUS_DONE) {
	// Make sure the entire file was decompressed, and check its CRC.
	if ((out_buf_ofs != file_stat.m_uncomp_size) ||
		(mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf,
				  (size_t)file_stat.m_uncomp_size) != file_stat.m_crc32))
	  status = TINFL_STATUS_FAILED;
  }

  if ((!pZip->m_pState->m_pMem) && (!pUser_read_buf))
	pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);

  return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_mem_no_alloc(
	mz_zip_archive *pZip, const char *pFilename, void *pBuf, size_t buf_size,
	mz_uint flags, void *pUser_read_buf, size_t user_read_buf_size) {
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
	return MZ_FALSE;
  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,
											   flags, pUser_read_buf,
											   user_read_buf_size);
}

mz_bool mz_zip_reader_extract_to_mem(mz_zip_archive *pZip, mz_uint file_index,
									 void *pBuf, size_t buf_size,
									 mz_uint flags) {
  return mz_zip_reader_extract_to_mem_no_alloc(pZip, file_index, pBuf, buf_size,
											   flags, NULL, 0);
}

mz_bool mz_zip_reader_extract_file_to_mem(mz_zip_archive *pZip,
										  const char *pFilename, void *pBuf,
										  size_t buf_size, mz_uint flags) {
  return mz_zip_reader_extract_file_to_mem_no_alloc(pZip, pFilename, pBuf,
													buf_size, flags, NULL, 0);
}

void *mz_zip_reader_extract_to_heap(mz_zip_archive *pZip, mz_uint file_index,
									size_t *pSize, mz_uint flags) {
  mz_uint64 comp_size, uncomp_size, alloc_size;
  const mz_uint8 *p = mz_zip_reader_get_cdh(pZip, file_index);
  void *pBuf;

  if (pSize)
	*pSize = 0;
  if (!p)
	return NULL;

  comp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);
  uncomp_size = MZ_READ_LE32(p + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS);

  alloc_size = (flags & MZ_ZIP_FLAG_COMPRESSED_DATA) ? comp_size : uncomp_size;
#ifdef _MSC_VER
  if (((0, sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
#else
  if (((sizeof(size_t) == sizeof(mz_uint32))) && (alloc_size > 0x7FFFFFFF))
#endif
	return NULL;
  if (NULL ==
	  (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, (size_t)alloc_size)))
	return NULL;

  if (!mz_zip_reader_extract_to_mem(pZip, file_index, pBuf, (size_t)alloc_size,
									flags)) {
	pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
	return NULL;
  }

  if (pSize)
	*pSize = (size_t)alloc_size;
  return pBuf;
}

void *mz_zip_reader_extract_file_to_heap(mz_zip_archive *pZip,
										 const char *pFilename, size_t *pSize,
										 mz_uint flags) {
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0) {
	if (pSize)
	  *pSize = 0;
	return MZ_FALSE;
  }
  return mz_zip_reader_extract_to_heap(pZip, file_index, pSize, flags);
}

mz_bool mz_zip_reader_extract_to_callback(mz_zip_archive *pZip,
										  mz_uint file_index,
										  mz_file_write_func pCallback,
										  void *pOpaque, mz_uint flags) {
  int status = TINFL_STATUS_DONE;
  mz_uint file_crc32 = MZ_CRC32_INIT;
  mz_uint64 read_buf_size, read_buf_ofs = 0, read_buf_avail, comp_remaining,
						   out_buf_ofs = 0, cur_file_ofs;
  mz_zip_archive_file_stat file_stat;
  void *pRead_buf = NULL;
  void *pWrite_buf = NULL;
  mz_uint32
	  local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /
					   sizeof(mz_uint32)];
  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;

  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
	return MZ_FALSE;

  // Empty file, or a directory (but not always a directory - I've seen odd zips
  // with directories that have compressed data which inflates to 0 bytes)
  if (!file_stat.m_comp_size)
	return MZ_TRUE;

  // Entry is a subdirectory (I've seen old zips with dir entries which have
  // compressed deflate data which inflates to 0 bytes, but these entries claim
  // to uncompress to 512 bytes in the headers).
  // I'm torn how to handle this case - should it fail instead?
  if (mz_zip_reader_is_file_a_directory(pZip, file_index))
	return MZ_TRUE;

  // Encryption and patch files are not supported.
  if (file_stat.m_bit_flag & (1 | 32))
	return MZ_FALSE;

  // This function only supports stored and deflate.
  if ((!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (file_stat.m_method != 0) &&
	  (file_stat.m_method != MZ_DEFLATED))
	return MZ_FALSE;

  // Read and parse the local directory entry.
  cur_file_ofs = file_stat.m_local_header_ofs;
  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pLocal_header,
					MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
	  MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
	return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
	return MZ_FALSE;

  cur_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE +
				  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +
				  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  if ((cur_file_ofs + file_stat.m_comp_size) > pZip->m_archive_size)
	return MZ_FALSE;

  // Decompress the file either directly from memory or from a file input
  // buffer.
  if (pZip->m_pState->m_pMem) {
	pRead_buf = (mz_uint8 *)pZip->m_pState->m_pMem + cur_file_ofs;
	read_buf_size = read_buf_avail = file_stat.m_comp_size;
	comp_remaining = 0;
  } else {
	read_buf_size = MZ_MIN(file_stat.m_comp_size, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);
	if (NULL == (pRead_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
											(size_t)read_buf_size)))
	  return MZ_FALSE;
	read_buf_avail = 0;
	comp_remaining = file_stat.m_comp_size;
  }

  if ((flags & MZ_ZIP_FLAG_COMPRESSED_DATA) || (!file_stat.m_method)) {
	// The file is stored or the caller has requested the compressed data.
	if (pZip->m_pState->m_pMem) {
#ifdef _MSC_VER
	  if (((0, sizeof(size_t) == sizeof(mz_uint32))) &&
		  (file_stat.m_comp_size > 0xFFFFFFFF))
#else
	  if (((sizeof(size_t) == sizeof(mz_uint32))) &&
		  (file_stat.m_comp_size > 0xFFFFFFFF))
#endif
		return MZ_FALSE;
	  if (pCallback(pOpaque, out_buf_ofs, pRead_buf,
					(size_t)file_stat.m_comp_size) != file_stat.m_comp_size)
		status = TINFL_STATUS_FAILED;
	  else if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
		file_crc32 =
			(mz_uint32)mz_crc32(file_crc32, (const mz_uint8 *)pRead_buf,
								(size_t)file_stat.m_comp_size);
	  cur_file_ofs += file_stat.m_comp_size;
	  out_buf_ofs += file_stat.m_comp_size;
	  comp_remaining = 0;
	} else {
	  while (comp_remaining) {
		read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
		if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,
						  (size_t)read_buf_avail) != read_buf_avail) {
		  status = TINFL_STATUS_FAILED;
		  break;
		}

		if (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))
		  file_crc32 = (mz_uint32)mz_crc32(
			  file_crc32, (const mz_uint8 *)pRead_buf, (size_t)read_buf_avail);

		if (pCallback(pOpaque, out_buf_ofs, pRead_buf,
					  (size_t)read_buf_avail) != read_buf_avail) {
		  status = TINFL_STATUS_FAILED;
		  break;
		}
		cur_file_ofs += read_buf_avail;
		out_buf_ofs += read_buf_avail;
		comp_remaining -= read_buf_avail;
	  }
	}
  } else {
	tinfl_decompressor inflator;
	tinfl_init(&inflator);

	if (NULL == (pWrite_buf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
											 TINFL_LZ_DICT_SIZE)))
	  status = TINFL_STATUS_FAILED;
	else {
	  do {
		mz_uint8 *pWrite_buf_cur =
			(mz_uint8 *)pWrite_buf + (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
		size_t in_buf_size,
			out_buf_size =
				TINFL_LZ_DICT_SIZE - (out_buf_ofs & (TINFL_LZ_DICT_SIZE - 1));
		if ((!read_buf_avail) && (!pZip->m_pState->m_pMem)) {
		  read_buf_avail = MZ_MIN(read_buf_size, comp_remaining);
		  if (pZip->m_pRead(pZip->m_pIO_opaque, cur_file_ofs, pRead_buf,
							(size_t)read_buf_avail) != read_buf_avail) {
			status = TINFL_STATUS_FAILED;
			break;
		  }
		  cur_file_ofs += read_buf_avail;
		  comp_remaining -= read_buf_avail;
		  read_buf_ofs = 0;
		}

		in_buf_size = (size_t)read_buf_avail;
		status = tinfl_decompress(
			&inflator, (const mz_uint8 *)pRead_buf + read_buf_ofs, &in_buf_size,
			(mz_uint8 *)pWrite_buf, pWrite_buf_cur, &out_buf_size,
			comp_remaining ? TINFL_FLAG_HAS_MORE_INPUT : 0);
		read_buf_avail -= in_buf_size;
		read_buf_ofs += in_buf_size;

		if (out_buf_size) {
		  if (pCallback(pOpaque, out_buf_ofs, pWrite_buf_cur, out_buf_size) !=
			  out_buf_size) {
			status = TINFL_STATUS_FAILED;
			break;
		  }
		  file_crc32 =
			  (mz_uint32)mz_crc32(file_crc32, pWrite_buf_cur, out_buf_size);
		  if ((out_buf_ofs += out_buf_size) > file_stat.m_uncomp_size) {
			status = TINFL_STATUS_FAILED;
			break;
		  }
		}
	  } while ((status == TINFL_STATUS_NEEDS_MORE_INPUT) ||
			   (status == TINFL_STATUS_HAS_MORE_OUTPUT));
	}
  }

  if ((status == TINFL_STATUS_DONE) &&
	  (!(flags & MZ_ZIP_FLAG_COMPRESSED_DATA))) {
	// Make sure the entire file was decompressed, and check its CRC.
	if ((out_buf_ofs != file_stat.m_uncomp_size) ||
		(file_crc32 != file_stat.m_crc32))
	  status = TINFL_STATUS_FAILED;
  }

  if (!pZip->m_pState->m_pMem)
	pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
  if (pWrite_buf)
	pZip->m_pFree(pZip->m_pAlloc_opaque, pWrite_buf);

  return status == TINFL_STATUS_DONE;
}

mz_bool mz_zip_reader_extract_file_to_callback(mz_zip_archive *pZip,
											   const char *pFilename,
											   mz_file_write_func pCallback,
											   void *pOpaque, mz_uint flags) {
  int file_index = mz_zip_reader_locate_file(pZip, pFilename, NULL, flags);
  if (file_index < 0)
	return MZ_FALSE;
  return mz_zip_reader_extract_to_callback(pZip, file_index, pCallback, pOpaque,
										   flags);
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_callback(void *pOpaque, mz_uint64 ofs,
										 const void *pBuf, size_t n) {
  (void)ofs;
  return MZ_FWRITE(pBuf, 1, n, (MZ_FILE *)pOpaque);
}

mz_bool mz_zip_reader_extract_to_file(mz_zip_archive *pZip, mz_uint file_index,
									  const char *pDst_filename,
									  mz_uint flags) {
  mz_bool status;
  mz_zip_archive_file_stat file_stat;
  MZ_FILE *pFile;
  if (!mz_zip_reader_file_stat(pZip, file_index, &file_stat))
	return MZ_FALSE;
  pFile = MZ_FOPEN(pDst_filename, "wb");
  if (!pFile)
	return MZ_FALSE;
  status = mz_zip_reader_extract_to_callback(
	  pZip, file_index, mz_zip_file_write_callback, pFile, flags);
  if (MZ_FCLOSE(pFile) == EOF)
	return MZ_FALSE;
#ifndef MINIZ_NO_TIME
  if (status)
	mz_zip_set_file_times(pDst_filename, file_stat.m_time, file_stat.m_time);
#endif
  return status;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_reader_end(mz_zip_archive *pZip) {
  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||
	  (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
	return MZ_FALSE;

  if (pZip->m_pState) {
	mz_zip_internal_state *pState = pZip->m_pState;
	pZip->m_pState = NULL;
	mz_zip_array_clear(pZip, &pState->m_central_dir);
	mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
	mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
	if (pState->m_pFile) {
	  MZ_FCLOSE(pState->m_pFile);
	  pState->m_pFile = NULL;
	}
#endif // #ifndef MINIZ_NO_STDIO

	pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
  }
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;

  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_reader_extract_file_to_file(mz_zip_archive *pZip,
										   const char *pArchive_filename,
										   const char *pDst_filename,
										   mz_uint flags) {
  int file_index =
	  mz_zip_reader_locate_file(pZip, pArchive_filename, NULL, flags);
  if (file_index < 0)
	return MZ_FALSE;
  return mz_zip_reader_extract_to_file(pZip, file_index, pDst_filename, flags);
}
#endif

// ------------------- .ZIP archive writing

#ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

static void mz_write_le16(mz_uint8 *p, mz_uint16 v) {
  p[0] = (mz_uint8)v;
  p[1] = (mz_uint8)(v >> 8);
}
static void mz_write_le32(mz_uint8 *p, mz_uint32 v) {
  p[0] = (mz_uint8)v;
  p[1] = (mz_uint8)(v >> 8);
  p[2] = (mz_uint8)(v >> 16);
  p[3] = (mz_uint8)(v >> 24);
}
#define MZ_WRITE_LE16(p, v) mz_write_le16((mz_uint8 *)(p), (mz_uint16)(v))
#define MZ_WRITE_LE32(p, v) mz_write_le32((mz_uint8 *)(p), (mz_uint32)(v))

mz_bool mz_zip_writer_init(mz_zip_archive *pZip, mz_uint64 existing_size) {
  if ((!pZip) || (pZip->m_pState) || (!pZip->m_pWrite) ||
	  (pZip->m_zip_mode != MZ_ZIP_MODE_INVALID))
	return MZ_FALSE;

  if (pZip->m_file_offset_alignment) {
	// Ensure user specified file offset alignment is a power of 2.
	if (pZip->m_file_offset_alignment & (pZip->m_file_offset_alignment - 1))
	  return MZ_FALSE;
  }

  if (!pZip->m_pAlloc)
	pZip->m_pAlloc = def_alloc_func;
  if (!pZip->m_pFree)
	pZip->m_pFree = def_free_func;
  if (!pZip->m_pRealloc)
	pZip->m_pRealloc = def_realloc_func;

  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  pZip->m_archive_size = existing_size;
  pZip->m_central_directory_file_ofs = 0;
  pZip->m_total_files = 0;

  if (NULL == (pZip->m_pState = (mz_zip_internal_state *)pZip->m_pAlloc(
				   pZip->m_pAlloc_opaque, 1, sizeof(mz_zip_internal_state))))
	return MZ_FALSE;
  memset(pZip->m_pState, 0, sizeof(mz_zip_internal_state));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir,
								sizeof(mz_uint8));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_central_dir_offsets,
								sizeof(mz_uint32));
  MZ_ZIP_ARRAY_SET_ELEMENT_SIZE(&pZip->m_pState->m_sorted_central_dir_offsets,
								sizeof(mz_uint32));
  return MZ_TRUE;
}

static size_t mz_zip_heap_write_func(void *pOpaque, mz_uint64 file_ofs,
									 const void *pBuf, size_t n) {
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_uint64 new_size = MZ_MAX(file_ofs + n, pState->m_mem_size);
#ifdef _MSC_VER
  if ((!n) ||
	  ((0, sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
#else
  if ((!n) ||
	  ((sizeof(size_t) == sizeof(mz_uint32)) && (new_size > 0x7FFFFFFF)))
#endif
	return 0;
  if (new_size > pState->m_mem_capacity) {
	void *pNew_block;
	size_t new_capacity = MZ_MAX(64, pState->m_mem_capacity);
	while (new_capacity < new_size)
	  new_capacity *= 2;
	if (NULL == (pNew_block = pZip->m_pRealloc(
					 pZip->m_pAlloc_opaque, pState->m_pMem, 1, new_capacity)))
	  return 0;
	pState->m_pMem = pNew_block;
	pState->m_mem_capacity = new_capacity;
  }
  memcpy((mz_uint8 *)pState->m_pMem + file_ofs, pBuf, n);
  pState->m_mem_size = (size_t)new_size;
  return n;
}

mz_bool mz_zip_writer_init_heap(mz_zip_archive *pZip,
								size_t size_to_reserve_at_beginning,
								size_t initial_allocation_size) {
  pZip->m_pWrite = mz_zip_heap_write_func;
  pZip->m_pIO_opaque = pZip;
  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
	return MZ_FALSE;
  if (0 != (initial_allocation_size = MZ_MAX(initial_allocation_size,
											 size_to_reserve_at_beginning))) {
	if (NULL == (pZip->m_pState->m_pMem = pZip->m_pAlloc(
					 pZip->m_pAlloc_opaque, 1, initial_allocation_size))) {
	  mz_zip_writer_end(pZip);
	  return MZ_FALSE;
	}
	pZip->m_pState->m_mem_capacity = initial_allocation_size;
  }
  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
static size_t mz_zip_file_write_func(void *pOpaque, mz_uint64 file_ofs,
									 const void *pBuf, size_t n) {
  mz_zip_archive *pZip = (mz_zip_archive *)pOpaque;
  mz_int64 cur_ofs = MZ_FTELL64(pZip->m_pState->m_pFile);
  if (((mz_int64)file_ofs < 0) ||
	  (((cur_ofs != (mz_int64)file_ofs)) &&
	   (MZ_FSEEK64(pZip->m_pState->m_pFile, (mz_int64)file_ofs, SEEK_SET))))
	return 0;
  return MZ_FWRITE(pBuf, 1, n, pZip->m_pState->m_pFile);
}

mz_bool mz_zip_writer_init_file(mz_zip_archive *pZip, const char *pFilename,
								mz_uint64 size_to_reserve_at_beginning) {
  MZ_FILE *pFile;
  pZip->m_pWrite = mz_zip_file_write_func;
  pZip->m_pIO_opaque = pZip;
  if (!mz_zip_writer_init(pZip, size_to_reserve_at_beginning))
	return MZ_FALSE;
  if (NULL == (pFile = MZ_FOPEN(pFilename, "wb"))) {
	mz_zip_writer_end(pZip);
	return MZ_FALSE;
  }
  pZip->m_pState->m_pFile = pFile;
  if (size_to_reserve_at_beginning) {
	mz_uint64 cur_ofs = 0;
	char buf[4096];
	MZ_CLEAR_OBJ(buf);
	do {
	  size_t n = (size_t)MZ_MIN(sizeof(buf), size_to_reserve_at_beginning);
	  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_ofs, buf, n) != n) {
		mz_zip_writer_end(pZip);
		return MZ_FALSE;
	  }
	  cur_ofs += n;
	  size_to_reserve_at_beginning -= n;
	} while (size_to_reserve_at_beginning);
  }
  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_writer_init_from_reader(mz_zip_archive *pZip,
									   const char *pFilename) {
  mz_zip_internal_state *pState;
  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_READING))
	return MZ_FALSE;
  // No sense in trying to write to an archive that's already at the support max
  // size
  if ((pZip->m_total_files == 0xFFFF) ||
	  ((pZip->m_archive_size + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
		MZ_ZIP_LOCAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
	return MZ_FALSE;

  pState = pZip->m_pState;

  if (pState->m_pFile) {
#ifdef MINIZ_NO_STDIO
	pFilename;
	return MZ_FALSE;
#else
	// Archive is being read from stdio - try to reopen as writable.
	if (pZip->m_pIO_opaque != pZip)
	  return MZ_FALSE;
	if (!pFilename)
	  return MZ_FALSE;
	pZip->m_pWrite = mz_zip_file_write_func;
	if (NULL ==
		(pState->m_pFile = MZ_FREOPEN(pFilename, "r+b", pState->m_pFile))) {
	  // The mz_zip_archive is now in a bogus state because pState->m_pFile is
	  // NULL, so just close it.
	  mz_zip_reader_end(pZip);
	  return MZ_FALSE;
	}
#endif // #ifdef MINIZ_NO_STDIO
  } else if (pState->m_pMem) {
	// Archive lives in a memory block. Assume it's from the heap that we can
	// resize using the realloc callback.
	if (pZip->m_pIO_opaque != pZip)
	  return MZ_FALSE;
	pState->m_mem_capacity = pState->m_mem_size;
	pZip->m_pWrite = mz_zip_heap_write_func;
  }
  // Archive is being read via a user provided read function - make sure the
  // user has specified a write function too.
  else if (!pZip->m_pWrite)
	return MZ_FALSE;

  // Start writing new files at the archive's current central directory
  // location.
  pZip->m_archive_size = pZip->m_central_directory_file_ofs;
  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING;
  pZip->m_central_directory_file_ofs = 0;

  return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem(mz_zip_archive *pZip, const char *pArchive_name,
							  const void *pBuf, size_t buf_size,
							  mz_uint level_and_flags) {
  return mz_zip_writer_add_mem_ex(pZip, pArchive_name, pBuf, buf_size, NULL, 0,
								  level_and_flags, 0, 0);
}

typedef struct {
  mz_zip_archive *m_pZip;
  mz_uint64 m_cur_archive_file_ofs;
  mz_uint64 m_comp_size;
} mz_zip_writer_add_state;

static mz_bool mz_zip_writer_add_put_buf_callback(const void *pBuf, int len,
												  void *pUser) {
  mz_zip_writer_add_state *pState = (mz_zip_writer_add_state *)pUser;
  if ((int)pState->m_pZip->m_pWrite(pState->m_pZip->m_pIO_opaque,
									pState->m_cur_archive_file_ofs, pBuf,
									len) != len)
	return MZ_FALSE;
  pState->m_cur_archive_file_ofs += len;
  pState->m_comp_size += len;
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_local_dir_header(
	mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,
	mz_uint16 extra_size, mz_uint64 uncomp_size, mz_uint64 comp_size,
	mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,
	mz_uint16 dos_time, mz_uint16 dos_date) {
  (void)pZip;
  memset(pDst, 0, MZ_ZIP_LOCAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_SIG_OFS, MZ_ZIP_LOCAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_VERSION_NEEDED_OFS, method ? 20 : 0);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_BIT_FLAG_OFS, bit_flags);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_METHOD_OFS, method);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_TIME_OFS, dos_time);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILE_DATE_OFS, dos_date);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_CRC32_OFS, uncomp_crc32);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_COMPRESSED_SIZE_OFS, comp_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_LDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_FILENAME_LEN_OFS, filename_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_LDH_EXTRA_LEN_OFS, extra_size);
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_create_central_dir_header(
	mz_zip_archive *pZip, mz_uint8 *pDst, mz_uint16 filename_size,
	mz_uint16 extra_size, mz_uint16 comment_size, mz_uint64 uncomp_size,
	mz_uint64 comp_size, mz_uint32 uncomp_crc32, mz_uint16 method,
	mz_uint16 bit_flags, mz_uint16 dos_time, mz_uint16 dos_date,
	mz_uint64 local_header_ofs, mz_uint32 ext_attributes) {
  (void)pZip;
  memset(pDst, 0, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_SIG_OFS, MZ_ZIP_CENTRAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_VERSION_NEEDED_OFS, method ? 20 : 0);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_BIT_FLAG_OFS, bit_flags);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_METHOD_OFS, method);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_TIME_OFS, dos_time);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILE_DATE_OFS, dos_date);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_CRC32_OFS, uncomp_crc32);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS, comp_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_DECOMPRESSED_SIZE_OFS, uncomp_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_FILENAME_LEN_OFS, filename_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_EXTRA_LEN_OFS, extra_size);
  MZ_WRITE_LE16(pDst + MZ_ZIP_CDH_COMMENT_LEN_OFS, comment_size);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_EXTERNAL_ATTR_OFS, ext_attributes);
  MZ_WRITE_LE32(pDst + MZ_ZIP_CDH_LOCAL_HEADER_OFS, local_header_ofs);
  return MZ_TRUE;
}

static mz_bool mz_zip_writer_add_to_central_dir(
	mz_zip_archive *pZip, const char *pFilename, mz_uint16 filename_size,
	const void *pExtra, mz_uint16 extra_size, const void *pComment,
	mz_uint16 comment_size, mz_uint64 uncomp_size, mz_uint64 comp_size,
	mz_uint32 uncomp_crc32, mz_uint16 method, mz_uint16 bit_flags,
	mz_uint16 dos_time, mz_uint16 dos_date, mz_uint64 local_header_ofs,
	mz_uint32 ext_attributes) {
  mz_zip_internal_state *pState = pZip->m_pState;
  mz_uint32 central_dir_ofs = (mz_uint32)pState->m_central_dir.m_size;
  size_t orig_central_dir_size = pState->m_central_dir.m_size;
  mz_uint8 central_dir_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];

  // No zip64 support yet
  if ((local_header_ofs > 0xFFFFFFFF) ||
	  (((mz_uint64)pState->m_central_dir.m_size +
		MZ_ZIP_CENTRAL_DIR_HEADER_SIZE + filename_size + extra_size +
		comment_size) > 0xFFFFFFFF))
	return MZ_FALSE;

  if (!mz_zip_writer_create_central_dir_header(
		  pZip, central_dir_header, filename_size, extra_size, comment_size,
		  uncomp_size, comp_size, uncomp_crc32, method, bit_flags, dos_time,
		  dos_date, local_header_ofs, ext_attributes))
	return MZ_FALSE;

  if ((!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_dir_header,
							   MZ_ZIP_CENTRAL_DIR_HEADER_SIZE)) ||
	  (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pFilename,
							   filename_size)) ||
	  (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pExtra,
							   extra_size)) ||
	  (!mz_zip_array_push_back(pZip, &pState->m_central_dir, pComment,
							   comment_size)) ||
	  (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets,
							   &central_dir_ofs, 1))) {
	// Try to push the central directory array back into its original state.
	mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,
						MZ_FALSE);
	return MZ_FALSE;
  }

  return MZ_TRUE;
}

static mz_bool mz_zip_writer_validate_archive_name(const char *pArchive_name) {
  // Basic ZIP archive filename validity checks: Valid filenames cannot start
  // with a forward slash, cannot contain a drive letter, and cannot use
  // DOS-style backward slashes.
  if (*pArchive_name == '/')
	return MZ_FALSE;
  while (*pArchive_name) {
	if ((*pArchive_name == '\\') || (*pArchive_name == ':'))
	  return MZ_FALSE;
	pArchive_name++;
  }
  return MZ_TRUE;
}

static mz_uint
mz_zip_writer_compute_padding_needed_for_file_alignment(mz_zip_archive *pZip) {
  mz_uint32 n;
  if (!pZip->m_file_offset_alignment)
	return 0;
  n = (mz_uint32)(pZip->m_archive_size & (pZip->m_file_offset_alignment - 1));
  return (pZip->m_file_offset_alignment - n) &
		 (pZip->m_file_offset_alignment - 1);
}

static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip,
										 mz_uint64 cur_file_ofs, mz_uint32 n) {
  char buf[4096];
  memset(buf, 0, MZ_MIN(sizeof(buf), n));
  while (n) {
	mz_uint32 s = MZ_MIN(sizeof(buf), n);
	if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
	  return MZ_FALSE;
	cur_file_ofs += s;
	n -= s;
  }
  return MZ_TRUE;
}

mz_bool mz_zip_writer_add_mem_ex(mz_zip_archive *pZip,
								 const char *pArchive_name, const void *pBuf,
								 size_t buf_size, const void *pComment,
								 mz_uint16 comment_size,
								 mz_uint level_and_flags, mz_uint64 uncomp_size,
								 mz_uint32 uncomp_crc32) {
  mz_uint16 method = 0, dos_time = 0, dos_date = 0;
  mz_uint level, ext_attributes = 0, num_alignment_padding_bytes;
  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,
			cur_archive_file_ofs = pZip->m_archive_size, comp_size = 0;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  tdefl_compressor *pComp = NULL;
  mz_bool store_data_uncompressed;
  mz_zip_internal_state *pState;

  if ((int)level_and_flags < 0)
	level_and_flags = MZ_DEFAULT_LEVEL;
  level = level_and_flags & 0xF;
  store_data_uncompressed =
	  ((!level) || (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA));

  if ((!pZip) || (!pZip->m_pState) ||
	  (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || ((buf_size) && (!pBuf)) ||
	  (!pArchive_name) || ((comment_size) && (!pComment)) ||
	  (pZip->m_total_files == 0xFFFF) || (level > MZ_UBER_COMPRESSION))
	return MZ_FALSE;

  pState = pZip->m_pState;

  if ((!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) && (uncomp_size))
	return MZ_FALSE;
  // No zip64 support yet
  if ((buf_size > 0xFFFFFFFF) || (uncomp_size > 0xFFFFFFFF))
	return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
	return MZ_FALSE;

#ifndef MINIZ_NO_TIME
  {
	time_t cur_time;
	time(&cur_time);
	mz_zip_time_to_dos_time(cur_time, &dos_time, &dos_date);
  }
#endif // #ifndef MINIZ_NO_TIME

  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > 0xFFFF)
	return MZ_FALSE;

  num_alignment_padding_bytes =
	  mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) ||
	  ((pZip->m_archive_size + num_alignment_padding_bytes +
		MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
		comment_size + archive_name_size) > 0xFFFFFFFF))
	return MZ_FALSE;

  if ((archive_name_size) && (pArchive_name[archive_name_size - 1] == '/')) {
	// Set DOS Subdirectory attribute bit.
	ext_attributes |= 0x10;
	// Subdirectories cannot contain data.
	if ((buf_size) || (uncomp_size))
	  return MZ_FALSE;
  }

  // Try to do any allocations before writing to the archive, so if an
  // allocation fails the file remains unmodified. (A good idea if we're doing
  // an in-place modification.)
  if ((!mz_zip_array_ensure_room(pZip, &pState->m_central_dir,
								 MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
									 archive_name_size + comment_size)) ||
	  (!mz_zip_array_ensure_room(pZip, &pState->m_central_dir_offsets, 1)))
	return MZ_FALSE;

  if ((!store_data_uncompressed) && (buf_size)) {
	if (NULL == (pComp = (tdefl_compressor *)pZip->m_pAlloc(
					 pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor))))
	  return MZ_FALSE;
  }

  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs,
								 num_alignment_padding_bytes +
									 sizeof(local_dir_header))) {
	pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
	return MZ_FALSE;
  }
  local_dir_header_ofs += num_alignment_padding_bytes;
  if (pZip->m_file_offset_alignment) {
	MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==
			  0);
  }
  cur_archive_file_ofs +=
	  num_alignment_padding_bytes + sizeof(local_dir_header);

  MZ_CLEAR_OBJ(local_dir_header);
  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,
					 archive_name_size) != archive_name_size) {
	pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
	return MZ_FALSE;
  }
  cur_archive_file_ofs += archive_name_size;

  if (!(level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)) {
	uncomp_crc32 =
		(mz_uint32)mz_crc32(MZ_CRC32_INIT, (const mz_uint8 *)pBuf, buf_size);
	uncomp_size = buf_size;
	if (uncomp_size <= 3) {
	  level = 0;
	  store_data_uncompressed = MZ_TRUE;
	}
  }

  if (store_data_uncompressed) {
	if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pBuf,
					   buf_size) != buf_size) {
	  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
	  return MZ_FALSE;
	}

	cur_archive_file_ofs += buf_size;
	comp_size = buf_size;

	if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
	  method = MZ_DEFLATED;
  } else if (buf_size) {
	mz_zip_writer_add_state state;

	state.m_pZip = pZip;
	state.m_cur_archive_file_ofs = cur_archive_file_ofs;
	state.m_comp_size = 0;

	if ((tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
					tdefl_create_comp_flags_from_zip_params(
						level, -15, MZ_DEFAULT_STRATEGY)) !=
		 TDEFL_STATUS_OKAY) ||
		(tdefl_compress_buffer(pComp, pBuf, buf_size, TDEFL_FINISH) !=
		 TDEFL_STATUS_DONE)) {
	  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
	  return MZ_FALSE;
	}

	comp_size = state.m_comp_size;
	cur_archive_file_ofs = state.m_cur_archive_file_ofs;

	method = MZ_DEFLATED;
  }

  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
  pComp = NULL;

  // no zip64 support yet
  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
	return MZ_FALSE;

  if (!mz_zip_writer_create_local_dir_header(
		  pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,
		  comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
	return MZ_FALSE;

  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,
					 sizeof(local_dir_header)) != sizeof(local_dir_header))
	return MZ_FALSE;

  if (!mz_zip_writer_add_to_central_dir(
		  pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,
		  comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,
		  dos_time, dos_date, local_dir_header_ofs, ext_attributes))
	return MZ_FALSE;

  pZip->m_total_files++;
  pZip->m_archive_size = cur_archive_file_ofs;

  return MZ_TRUE;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_writer_add_file(mz_zip_archive *pZip, const char *pArchive_name,
							   const char *pSrc_filename, const void *pComment,
							   mz_uint16 comment_size,
							   mz_uint level_and_flags) {
  mz_uint uncomp_crc32 = MZ_CRC32_INIT, level, num_alignment_padding_bytes;
  mz_uint16 method = 0, dos_time = 0, dos_date = 0, ext_attributes = 0;
  mz_uint64 local_dir_header_ofs = pZip->m_archive_size,
			cur_archive_file_ofs = pZip->m_archive_size, uncomp_size = 0,
			comp_size = 0;
  size_t archive_name_size;
  mz_uint8 local_dir_header[MZ_ZIP_LOCAL_DIR_HEADER_SIZE];
  MZ_FILE *pSrc_file = NULL;

  if ((int)level_and_flags < 0)
	level_and_flags = MZ_DEFAULT_LEVEL;
  level = level_and_flags & 0xF;

  if ((!pZip) || (!pZip->m_pState) ||
	  (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) || (!pArchive_name) ||
	  ((comment_size) && (!pComment)) || (level > MZ_UBER_COMPRESSION))
	return MZ_FALSE;
  if (level_and_flags & MZ_ZIP_FLAG_COMPRESSED_DATA)
	return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
	return MZ_FALSE;

  archive_name_size = strlen(pArchive_name);
  if (archive_name_size > 0xFFFF)
	return MZ_FALSE;

  num_alignment_padding_bytes =
	  mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) ||
	  ((pZip->m_archive_size + num_alignment_padding_bytes +
		MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE +
		comment_size + archive_name_size) > 0xFFFFFFFF))
	return MZ_FALSE;

  if (!mz_zip_get_file_modified_time(pSrc_filename, &dos_time, &dos_date))
	return MZ_FALSE;

  pSrc_file = MZ_FOPEN(pSrc_filename, "rb");
  if (!pSrc_file)
	return MZ_FALSE;
  MZ_FSEEK64(pSrc_file, 0, SEEK_END);
  uncomp_size = MZ_FTELL64(pSrc_file);
  MZ_FSEEK64(pSrc_file, 0, SEEK_SET);

  if (uncomp_size > 0xFFFFFFFF) {
	// No zip64 support yet
	MZ_FCLOSE(pSrc_file);
	return MZ_FALSE;
  }
  if (uncomp_size <= 3)
	level = 0;

  if (!mz_zip_writer_write_zeros(pZip, cur_archive_file_ofs,
								 num_alignment_padding_bytes +
									 sizeof(local_dir_header))) {
	MZ_FCLOSE(pSrc_file);
	return MZ_FALSE;
  }
  local_dir_header_ofs += num_alignment_padding_bytes;
  if (pZip->m_file_offset_alignment) {
	MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==
			  0);
  }
  cur_archive_file_ofs +=
	  num_alignment_padding_bytes + sizeof(local_dir_header);

  MZ_CLEAR_OBJ(local_dir_header);
  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pArchive_name,
					 archive_name_size) != archive_name_size) {
	MZ_FCLOSE(pSrc_file);
	return MZ_FALSE;
  }
  cur_archive_file_ofs += archive_name_size;

  if (uncomp_size) {
	mz_uint64 uncomp_remaining = uncomp_size;
	void *pRead_buf =
		pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1, MZ_ZIP_MAX_IO_BUF_SIZE);
	if (!pRead_buf) {
	  MZ_FCLOSE(pSrc_file);
	  return MZ_FALSE;
	}

	if (!level) {
	  while (uncomp_remaining) {
		mz_uint n = (mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, uncomp_remaining);
		if ((MZ_FREAD(pRead_buf, 1, n, pSrc_file) != n) ||
			(pZip->m_pWrite(pZip->m_pIO_opaque, cur_archive_file_ofs, pRead_buf,
							n) != n)) {
		  pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
		  MZ_FCLOSE(pSrc_file);
		  return MZ_FALSE;
		}
		uncomp_crc32 =
			(mz_uint32)mz_crc32(uncomp_crc32, (const mz_uint8 *)pRead_buf, n);
		uncomp_remaining -= n;
		cur_archive_file_ofs += n;
	  }
	  comp_size = uncomp_size;
	} else {
	  mz_bool result = MZ_FALSE;
	  mz_zip_writer_add_state state;
	  tdefl_compressor *pComp = (tdefl_compressor *)pZip->m_pAlloc(
		  pZip->m_pAlloc_opaque, 1, sizeof(tdefl_compressor));
	  if (!pComp) {
		pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
		MZ_FCLOSE(pSrc_file);
		return MZ_FALSE;
	  }

	  state.m_pZip = pZip;
	  state.m_cur_archive_file_ofs = cur_archive_file_ofs;
	  state.m_comp_size = 0;

	  if (tdefl_init(pComp, mz_zip_writer_add_put_buf_callback, &state,
					 tdefl_create_comp_flags_from_zip_params(
						 level, -15, MZ_DEFAULT_STRATEGY)) !=
		  TDEFL_STATUS_OKAY) {
		pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);
		pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
		MZ_FCLOSE(pSrc_file);
		return MZ_FALSE;
	  }

	  for (;;) {
		size_t in_buf_size =
			(mz_uint32)MZ_MIN(uncomp_remaining, (mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE);
		tdefl_status status;

		if (MZ_FREAD(pRead_buf, 1, in_buf_size, pSrc_file) != in_buf_size)
		  break;

		uncomp_crc32 = (mz_uint32)mz_crc32(
			uncomp_crc32, (const mz_uint8 *)pRead_buf, in_buf_size);
		uncomp_remaining -= in_buf_size;

		status = tdefl_compress_buffer(pComp, pRead_buf, in_buf_size,
									   uncomp_remaining ? TDEFL_NO_FLUSH
														: TDEFL_FINISH);
		if (status == TDEFL_STATUS_DONE) {
		  result = MZ_TRUE;
		  break;
		} else if (status != TDEFL_STATUS_OKAY)
		  break;
	  }

	  pZip->m_pFree(pZip->m_pAlloc_opaque, pComp);

	  if (!result) {
		pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
		MZ_FCLOSE(pSrc_file);
		return MZ_FALSE;
	  }

	  comp_size = state.m_comp_size;
	  cur_archive_file_ofs = state.m_cur_archive_file_ofs;

	  method = MZ_DEFLATED;
	}

	pZip->m_pFree(pZip->m_pAlloc_opaque, pRead_buf);
  }

  MZ_FCLOSE(pSrc_file);
  pSrc_file = NULL;

  // no zip64 support yet
  if ((comp_size > 0xFFFFFFFF) || (cur_archive_file_ofs > 0xFFFFFFFF))
	return MZ_FALSE;

  if (!mz_zip_writer_create_local_dir_header(
		  pZip, local_dir_header, (mz_uint16)archive_name_size, 0, uncomp_size,
		  comp_size, uncomp_crc32, method, 0, dos_time, dos_date))
	return MZ_FALSE;

  if (pZip->m_pWrite(pZip->m_pIO_opaque, local_dir_header_ofs, local_dir_header,
					 sizeof(local_dir_header)) != sizeof(local_dir_header))
	return MZ_FALSE;

  if (!mz_zip_writer_add_to_central_dir(
		  pZip, pArchive_name, (mz_uint16)archive_name_size, NULL, 0, pComment,
		  comment_size, uncomp_size, comp_size, uncomp_crc32, method, 0,
		  dos_time, dos_date, local_dir_header_ofs, ext_attributes))
	return MZ_FALSE;

  pZip->m_total_files++;
  pZip->m_archive_size = cur_archive_file_ofs;

  return MZ_TRUE;
}
#endif // #ifndef MINIZ_NO_STDIO

mz_bool mz_zip_writer_add_from_zip_reader(mz_zip_archive *pZip,
										  mz_zip_archive *pSource_zip,
										  mz_uint file_index) {
  mz_uint n, bit_flags, num_alignment_padding_bytes;
  mz_uint64 comp_bytes_remaining, local_dir_header_ofs;
  mz_uint64 cur_src_file_ofs, cur_dst_file_ofs;
  mz_uint32
	  local_header_u32[(MZ_ZIP_LOCAL_DIR_HEADER_SIZE + sizeof(mz_uint32) - 1) /
					   sizeof(mz_uint32)];
  mz_uint8 *pLocal_header = (mz_uint8 *)local_header_u32;
  mz_uint8 central_header[MZ_ZIP_CENTRAL_DIR_HEADER_SIZE];
  size_t orig_central_dir_size;
  mz_zip_internal_state *pState;
  void *pBuf;
  const mz_uint8 *pSrc_central_header;

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
	return MZ_FALSE;
  if (NULL ==
	  (pSrc_central_header = mz_zip_reader_get_cdh(pSource_zip, file_index)))
	return MZ_FALSE;
  pState = pZip->m_pState;

  num_alignment_padding_bytes =
	  mz_zip_writer_compute_padding_needed_for_file_alignment(pZip);

  // no zip64 support yet
  if ((pZip->m_total_files == 0xFFFF) ||
	  ((pZip->m_archive_size + num_alignment_padding_bytes +
		MZ_ZIP_LOCAL_DIR_HEADER_SIZE + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE) >
	   0xFFFFFFFF))
	return MZ_FALSE;

  cur_src_file_ofs =
	  MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS);
  cur_dst_file_ofs = pZip->m_archive_size;

  if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs,
						   pLocal_header, MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
	  MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
	return MZ_FALSE;
  if (MZ_READ_LE32(pLocal_header) != MZ_ZIP_LOCAL_DIR_HEADER_SIG)
	return MZ_FALSE;
  cur_src_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

  if (!mz_zip_writer_write_zeros(pZip, cur_dst_file_ofs,
								 num_alignment_padding_bytes))
	return MZ_FALSE;
  cur_dst_file_ofs += num_alignment_padding_bytes;
  local_dir_header_ofs = cur_dst_file_ofs;
  if (pZip->m_file_offset_alignment) {
	MZ_ASSERT((local_dir_header_ofs & (pZip->m_file_offset_alignment - 1)) ==
			  0);
  }

  if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pLocal_header,
					 MZ_ZIP_LOCAL_DIR_HEADER_SIZE) !=
	  MZ_ZIP_LOCAL_DIR_HEADER_SIZE)
	return MZ_FALSE;
  cur_dst_file_ofs += MZ_ZIP_LOCAL_DIR_HEADER_SIZE;

  n = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_FILENAME_LEN_OFS) +
	  MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_EXTRA_LEN_OFS);
  comp_bytes_remaining =
	  n + MZ_READ_LE32(pSrc_central_header + MZ_ZIP_CDH_COMPRESSED_SIZE_OFS);

  if (NULL ==
	  (pBuf = pZip->m_pAlloc(pZip->m_pAlloc_opaque, 1,
							 (size_t)MZ_MAX(sizeof(mz_uint32) * 4,
											MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE,
												   comp_bytes_remaining)))))
	return MZ_FALSE;

  while (comp_bytes_remaining) {
	n = (mz_uint)MZ_MIN((mz_uint)MZ_ZIP_MAX_IO_BUF_SIZE, comp_bytes_remaining);
	if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,
							 n) != n) {
	  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
	  return MZ_FALSE;
	}
	cur_src_file_ofs += n;

	if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
	  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
	  return MZ_FALSE;
	}
	cur_dst_file_ofs += n;

	comp_bytes_remaining -= n;
  }

  bit_flags = MZ_READ_LE16(pLocal_header + MZ_ZIP_LDH_BIT_FLAG_OFS);
  if (bit_flags & 8) {
	// Copy data descriptor
	if (pSource_zip->m_pRead(pSource_zip->m_pIO_opaque, cur_src_file_ofs, pBuf,
							 sizeof(mz_uint32) * 4) != sizeof(mz_uint32) * 4) {
	  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
	  return MZ_FALSE;
	}

	n = sizeof(mz_uint32) * ((MZ_READ_LE32(pBuf) == 0x08074b50) ? 4 : 3);
	if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_dst_file_ofs, pBuf, n) != n) {
	  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);
	  return MZ_FALSE;
	}

	cur_src_file_ofs += n;
	cur_dst_file_ofs += n;
  }
  pZip->m_pFree(pZip->m_pAlloc_opaque, pBuf);

  // no zip64 support yet
  if (cur_dst_file_ofs > 0xFFFFFFFF)
	return MZ_FALSE;

  orig_central_dir_size = pState->m_central_dir.m_size;

  memcpy(central_header, pSrc_central_header, MZ_ZIP_CENTRAL_DIR_HEADER_SIZE);
  MZ_WRITE_LE32(central_header + MZ_ZIP_CDH_LOCAL_HEADER_OFS,
				local_dir_header_ofs);
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir, central_header,
							  MZ_ZIP_CENTRAL_DIR_HEADER_SIZE))
	return MZ_FALSE;

  n = MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_FILENAME_LEN_OFS) +
	  MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_EXTRA_LEN_OFS) +
	  MZ_READ_LE16(pSrc_central_header + MZ_ZIP_CDH_COMMENT_LEN_OFS);
  if (!mz_zip_array_push_back(
		  pZip, &pState->m_central_dir,
		  pSrc_central_header + MZ_ZIP_CENTRAL_DIR_HEADER_SIZE, n)) {
	mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,
						MZ_FALSE);
	return MZ_FALSE;
  }

  if (pState->m_central_dir.m_size > 0xFFFFFFFF)
	return MZ_FALSE;
  n = (mz_uint32)orig_central_dir_size;
  if (!mz_zip_array_push_back(pZip, &pState->m_central_dir_offsets, &n, 1)) {
	mz_zip_array_resize(pZip, &pState->m_central_dir, orig_central_dir_size,
						MZ_FALSE);
	return MZ_FALSE;
  }

  pZip->m_total_files++;
  pZip->m_archive_size = cur_dst_file_ofs;

  return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_archive(mz_zip_archive *pZip) {
  mz_zip_internal_state *pState;
  mz_uint64 central_dir_ofs, central_dir_size;
  mz_uint8 hdr[MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE];

  if ((!pZip) || (!pZip->m_pState) || (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING))
	return MZ_FALSE;

  pState = pZip->m_pState;

  // no zip64 support yet
  if ((pZip->m_total_files > 0xFFFF) ||
	  ((pZip->m_archive_size + pState->m_central_dir.m_size +
		MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIZE) > 0xFFFFFFFF))
	return MZ_FALSE;

  central_dir_ofs = 0;
  central_dir_size = 0;
  if (pZip->m_total_files) {
	// Write central directory
	central_dir_ofs = pZip->m_archive_size;
	central_dir_size = pState->m_central_dir.m_size;
	pZip->m_central_directory_file_ofs = central_dir_ofs;
	if (pZip->m_pWrite(pZip->m_pIO_opaque, central_dir_ofs,
					   pState->m_central_dir.m_p,
					   (size_t)central_dir_size) != central_dir_size)
	  return MZ_FALSE;
	pZip->m_archive_size += central_dir_size;
  }

  // Write end of central directory record
  MZ_CLEAR_OBJ(hdr);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_SIG_OFS,
				MZ_ZIP_END_OF_CENTRAL_DIR_HEADER_SIG);
  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_NUM_ENTRIES_ON_DISK_OFS,
				pZip->m_total_files);
  MZ_WRITE_LE16(hdr + MZ_ZIP_ECDH_CDIR_TOTAL_ENTRIES_OFS, pZip->m_total_files);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_SIZE_OFS, central_dir_size);
  MZ_WRITE_LE32(hdr + MZ_ZIP_ECDH_CDIR_OFS_OFS, central_dir_ofs);

  if (pZip->m_pWrite(pZip->m_pIO_opaque, pZip->m_archive_size, hdr,
					 sizeof(hdr)) != sizeof(hdr))
	return MZ_FALSE;
#ifndef MINIZ_NO_STDIO
  if ((pState->m_pFile) && (MZ_FFLUSH(pState->m_pFile) == EOF))
	return MZ_FALSE;
#endif // #ifndef MINIZ_NO_STDIO

  pZip->m_archive_size += sizeof(hdr);

  pZip->m_zip_mode = MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED;
  return MZ_TRUE;
}

mz_bool mz_zip_writer_finalize_heap_archive(mz_zip_archive *pZip, void **pBuf,
											size_t *pSize) {
  if ((!pZip) || (!pZip->m_pState) || (!pBuf) || (!pSize))
	return MZ_FALSE;
  if (pZip->m_pWrite != mz_zip_heap_write_func)
	return MZ_FALSE;
  if (!mz_zip_writer_finalize_archive(pZip))
	return MZ_FALSE;

  *pBuf = pZip->m_pState->m_pMem;
  *pSize = pZip->m_pState->m_mem_size;
  pZip->m_pState->m_pMem = NULL;
  pZip->m_pState->m_mem_size = pZip->m_pState->m_mem_capacity = 0;
  return MZ_TRUE;
}

mz_bool mz_zip_writer_end(mz_zip_archive *pZip) {
  mz_zip_internal_state *pState;
  mz_bool status = MZ_TRUE;
  if ((!pZip) || (!pZip->m_pState) || (!pZip->m_pAlloc) || (!pZip->m_pFree) ||
	  ((pZip->m_zip_mode != MZ_ZIP_MODE_WRITING) &&
	   (pZip->m_zip_mode != MZ_ZIP_MODE_WRITING_HAS_BEEN_FINALIZED)))
	return MZ_FALSE;

  pState = pZip->m_pState;
  pZip->m_pState = NULL;
  mz_zip_array_clear(pZip, &pState->m_central_dir);
  mz_zip_array_clear(pZip, &pState->m_central_dir_offsets);
  mz_zip_array_clear(pZip, &pState->m_sorted_central_dir_offsets);

#ifndef MINIZ_NO_STDIO
  if (pState->m_pFile) {
	MZ_FCLOSE(pState->m_pFile);
	pState->m_pFile = NULL;
  }
#endif // #ifndef MINIZ_NO_STDIO

  if ((pZip->m_pWrite == mz_zip_heap_write_func) && (pState->m_pMem)) {
	pZip->m_pFree(pZip->m_pAlloc_opaque, pState->m_pMem);
	pState->m_pMem = NULL;
  }

  pZip->m_pFree(pZip->m_pAlloc_opaque, pState);
  pZip->m_zip_mode = MZ_ZIP_MODE_INVALID;
  return status;
}

#ifndef MINIZ_NO_STDIO
mz_bool mz_zip_add_mem_to_archive_file_in_place(
	const char *pZip_filename, const char *pArchive_name, const void *pBuf,
	size_t buf_size, const void *pComment, mz_uint16 comment_size,
	mz_uint level_and_flags) {
  mz_bool status, created_new_archive = MZ_FALSE;
  mz_zip_archive zip_archive;
  struct MZ_FILE_STAT_STRUCT file_stat;
  MZ_CLEAR_OBJ(zip_archive);
  if ((int)level_and_flags < 0)
	level_and_flags = MZ_DEFAULT_LEVEL;
  if ((!pZip_filename) || (!pArchive_name) || ((buf_size) && (!pBuf)) ||
	  ((comment_size) && (!pComment)) ||
	  ((level_and_flags & 0xF) > MZ_UBER_COMPRESSION))
	return MZ_FALSE;
  if (!mz_zip_writer_validate_archive_name(pArchive_name))
	return MZ_FALSE;
  if (MZ_FILE_STAT(pZip_filename, &file_stat) != 0) {
	// Create a new archive.
	if (!mz_zip_writer_init_file(&zip_archive, pZip_filename, 0))
	  return MZ_FALSE;
	created_new_archive = MZ_TRUE;
  } else {
	// Append to an existing archive.
	if (!mz_zip_reader_init_file(&zip_archive, pZip_filename,
								 level_and_flags |
									 MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
	  return MZ_FALSE;
	if (!mz_zip_writer_init_from_reader(&zip_archive, pZip_filename)) {
	  mz_zip_reader_end(&zip_archive);
	  return MZ_FALSE;
	}
  }
  status =
	  mz_zip_writer_add_mem_ex(&zip_archive, pArchive_name, pBuf, buf_size,
							   pComment, comment_size, level_and_flags, 0, 0);
  // Always finalize, even if adding failed for some reason, so we have a valid
  // central directory. (This may not always succeed, but we can try.)
  if (!mz_zip_writer_finalize_archive(&zip_archive))
	status = MZ_FALSE;
  if (!mz_zip_writer_end(&zip_archive))
	status = MZ_FALSE;
  if ((!status) && (created_new_archive)) {
	// It's a new archive and something went wrong, so just delete it.
	int ignoredStatus = MZ_DELETE_FILE(pZip_filename);
	(void)ignoredStatus;
  }
  return status;
}

void *mz_zip_extract_archive_file_to_heap(const char *pZip_filename,
										  const char *pArchive_name,
										  size_t *pSize, mz_uint flags) {
  int file_index;
  mz_zip_archive zip_archive;
  void *p = NULL;

  if (pSize)
	*pSize = 0;

  if ((!pZip_filename) || (!pArchive_name))
	return NULL;

  MZ_CLEAR_OBJ(zip_archive);
  if (!mz_zip_reader_init_file(&zip_archive, pZip_filename,
							   flags |
								   MZ_ZIP_FLAG_DO_NOT_SORT_CENTRAL_DIRECTORY))
	return NULL;

  if ((file_index = mz_zip_reader_locate_file(&zip_archive, pArchive_name, NULL,
											  flags)) >= 0)
	p = mz_zip_reader_extract_to_heap(&zip_archive, file_index, pSize, flags);

  mz_zip_reader_end(&zip_archive);
  return p;
}

#endif // #ifndef MINIZ_NO_STDIO

#endif // #ifndef MINIZ_NO_ARCHIVE_WRITING_APIS

#endif // #ifndef MINIZ_NO_ARCHIVE_APIS

#ifdef __cplusplus
}
#endif

#endif // MINIZ_HEADER_FILE_ONLY

/*
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>
*/

// ---------------------- end of miniz ----------------------------------------
}

bool IsBigEndian(void) {
  union {
	unsigned int i;
	char c[4];
  } bint = {0x01020304};

  return bint.c[0] == 1;
}

void swap2(unsigned short *val) {
  unsigned short tmp = *val;
  unsigned char *dst = (unsigned char *)val;
  unsigned char *src = (unsigned char *)&tmp;

  dst[0] = src[1];
  dst[1] = src[0];
}

void swap4(unsigned int *val) {
  unsigned int tmp = *val;
  unsigned char *dst = (unsigned char *)val;
  unsigned char *src = (unsigned char *)&tmp;

  dst[0] = src[3];
  dst[1] = src[2];
  dst[2] = src[1];
  dst[3] = src[0];
}

void swap8(unsigned long long *val) {
  unsigned long long tmp = (*val);
  unsigned char *dst = (unsigned char *)val;
  unsigned char *src = (unsigned char *)&tmp;

  dst[0] = src[7];
  dst[1] = src[6];
  dst[2] = src[5];
  dst[3] = src[4];
  dst[4] = src[3];
  dst[5] = src[2];
  dst[6] = src[1];
  dst[7] = src[0];
}

// https://gist.github.com/rygorous/2156668
// Reuse MINIZ_LITTLE_ENDIAN flag from miniz.
union FP32 {
  unsigned int u;
  float f;
  struct {
#if MINIZ_LITTLE_ENDIAN
	unsigned int Mantissa : 23;
	unsigned int Exponent : 8;
	unsigned int Sign : 1;
#else
	unsigned int Sign : 1;
	unsigned int Exponent : 8;
	unsigned int Mantissa : 23;
#endif
  } s;
};

union FP16 {
  unsigned short u;
  struct {
#if MINIZ_LITTLE_ENDIAN
	unsigned int Mantissa : 10;
	unsigned int Exponent : 5;
	unsigned int Sign : 1;
#else
	unsigned int Sign : 1;
	unsigned int Exponent : 5;
	unsigned int Mantissa : 10;
#endif
  } s;
};

FP32 half_to_float(FP16 h) {
  static const FP32 magic = {113 << 23};
  static const unsigned int shifted_exp = 0x7c00
										  << 13; // exponent mask after shift
  FP32 o;

  o.u = (h.u & 0x7fff) << 13;            // exponent/mantissa bits
  unsigned int exp_ = shifted_exp & o.u; // just the exponent
  o.u += (127 - 15) << 23;               // exponent adjust

  // handle exponent special cases
  if (exp_ == shifted_exp)   // Inf/NaN?
	o.u += (128 - 16) << 23; // extra exp adjust
  else if (exp_ == 0)        // Zero/Denormal?
  {
	o.u += 1 << 23; // extra exp adjust
	o.f -= magic.f; // renormalize
  }

  o.u |= (h.u & 0x8000) << 16; // sign bit
  return o;
}

FP16 float_to_half_full(FP32 f) {
  FP16 o = {0};

  // Based on ISPC reference code (with minor modifications)
  if (f.s.Exponent == 0) // Signed zero/denormal (which will underflow)
	o.s.Exponent = 0;
  else if (f.s.Exponent == 255) // Inf or NaN (all exponent bits set)
  {
	o.s.Exponent = 31;
	o.s.Mantissa = f.s.Mantissa ? 0x200 : 0; // NaN->qNaN and Inf->Inf
  } else                                     // Normalized number
  {
	// Exponent unbias the single, then bias the halfp
	int newexp = f.s.Exponent - 127 + 15;
	if (newexp >= 31) // Overflow, return signed infinity
	  o.s.Exponent = 31;
	else if (newexp <= 0) // Underflow
	{
	  if ((14 - newexp) <= 24) // Mantissa might be non-zero
	  {
		unsigned int mant = f.s.Mantissa | 0x800000; // Hidden 1 bit
		o.s.Mantissa = mant >> (14 - newexp);
		if ((mant >> (13 - newexp)) & 1) // Check for rounding
		  o.u++; // Round, might overflow into exp bit, but this is OK
	  }
	} else {
	  o.s.Exponent = newexp;
	  o.s.Mantissa = f.s.Mantissa >> 13;
	  if (f.s.Mantissa & 0x1000) // Check for rounding
		o.u++;                   // Round, might overflow to inf, this is OK
	}
  }

  o.s.Sign = f.s.Sign;
  return o;
}

// NOTE: From OpenEXR code
// #define IMF_INCREASING_Y  0
// #define IMF_DECREASING_Y  1
// #define IMF_RAMDOM_Y    2
//
// #define IMF_NO_COMPRESSION  0
// #define IMF_RLE_COMPRESSION 1
// #define IMF_ZIPS_COMPRESSION  2
// #define IMF_ZIP_COMPRESSION 3
// #define IMF_PIZ_COMPRESSION 4
// #define IMF_PXR24_COMPRESSION 5
// #define IMF_B44_COMPRESSION 6
// #define IMF_B44A_COMPRESSION  7

const char *ReadString(std::string &s, const char *ptr) {
  // Read untile NULL(\0).
  const char *p = ptr;
  const char *q = ptr;
  while ((*q) != 0)
	q++;

  s = std::string(p, q);

  return q + 1; // skip '\0'
}

const char *ReadAttribute(std::string &name, std::string &ty,
						  std::vector<unsigned char> &data, const char *ptr) {

  if ((*ptr) == 0) {
	// end of attribute.
	return NULL;
  }

  const char *p = ReadString(name, ptr);

  p = ReadString(ty, p);

  int dataLen;
  memcpy(&dataLen, p, sizeof(int));
  p += 4;

  if (IsBigEndian()) {
	swap4(reinterpret_cast<unsigned int *>(&dataLen));
  }

  data.resize(dataLen);
  memcpy(&data.at(0), p, dataLen);
  p += dataLen;

  return p;
}

void WriteAttribute(FILE *fp, const char *name, const char *type,
					const unsigned char *data, int len) {
  size_t n = fwrite(name, 1, strlen(name) + 1, fp);
  assert(n == strlen(name) + 1);

  n = fwrite(type, 1, strlen(type) + 1, fp);
  assert(n == strlen(type) + 1);

  int outLen = len;
  if (IsBigEndian()) {
	swap4(reinterpret_cast<unsigned int *>(&outLen));
  }
  n = fwrite(&outLen, 1, sizeof(int), fp);
  assert(n == sizeof(int));

  n = fwrite(data, 1, len, fp);
  assert(n == (size_t)len);

  (void)n;
}

void WriteAttributeToMemory(std::vector<unsigned char> &out, const char *name,
							const char *type, const unsigned char *data,
							int len) {
  out.insert(out.end(), name, name + strlen(name) + 1);
  out.insert(out.end(), type, type + strlen(type) + 1);

  int outLen = len;
  if (IsBigEndian()) {
	swap4(reinterpret_cast<unsigned int *>(&outLen));
  }
  out.insert(out.end(), reinterpret_cast<unsigned char *>(&outLen),
			 reinterpret_cast<unsigned char *>(&outLen) + sizeof(int));
  out.insert(out.end(), data, data + len);
}

typedef struct {
  std::string name; // less than 255 bytes long
  int pixelType;
  unsigned char pLinear;
  int xSampling;
  int ySampling;
} ChannelInfo;

void ReadChannelInfo(std::vector<ChannelInfo> &channels,
					 const std::vector<unsigned char> &data) {
  const char *p = reinterpret_cast<const char *>(&data.at(0));

  for (;;) {
	if ((*p) == 0) {
	  break;
	}
	ChannelInfo info;
	p = ReadString(info.name, p);

	memcpy(&info.pixelType, p, sizeof(int));
	p += 4;
	info.pLinear = p[0];                     // uchar
	p += 1 + 3;                              // reserved: uchar[3]
	memcpy(&info.xSampling, p, sizeof(int)); // int
	p += 4;
	memcpy(&info.ySampling, p, sizeof(int)); // int
	p += 4;

	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&info.pixelType));
	  swap4(reinterpret_cast<unsigned int *>(&info.xSampling));
	  swap4(reinterpret_cast<unsigned int *>(&info.ySampling));
	}

	channels.push_back(info);
  }
}

void WriteChannelInfo(std::vector<unsigned char> &data,
					  const std::vector<ChannelInfo> &channels) {

  size_t sz = 0;

  // Calculate total size.
  for (size_t c = 0; c < channels.size(); c++) {
	sz += strlen(channels[c].name.c_str()) + 1; // +1 for \0
	sz += 16;                                   // 4 * int
  }
  data.resize(sz + 1);

  unsigned char *p = &data.at(0);

  for (size_t c = 0; c < channels.size(); c++) {
	memcpy(p, channels[c].name.c_str(), strlen(channels[c].name.c_str()));
	p += strlen(channels[c].name.c_str());
	(*p) = '\0';
	p++;

	int pixelType = channels[c].pixelType;
	int xSampling = channels[c].xSampling;
	int ySampling = channels[c].ySampling;
	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&pixelType));
	  swap4(reinterpret_cast<unsigned int *>(&xSampling));
	  swap4(reinterpret_cast<unsigned int *>(&ySampling));
	}

	memcpy(p, &pixelType, sizeof(int));
	p += sizeof(int);

	(*p) = channels[c].pLinear;
	p += 4;

	memcpy(p, &xSampling, sizeof(int));
	p += sizeof(int);

	memcpy(p, &ySampling, sizeof(int));
	p += sizeof(int);
  }

  (*p) = '\0';
}

void CompressZip(unsigned char *dst, unsigned long long &compressedSize,
				 const unsigned char *src, unsigned long srcSize) {

  std::vector<unsigned char> tmpBuf(srcSize);

  //
  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's
  // ImfZipCompressor.cpp
  //

  //
  // Reorder the pixel data.
  //

  {
	char *t1 = (char *)&tmpBuf.at(0);
	char *t2 = (char *)&tmpBuf.at(0) + (srcSize + 1) / 2;
	const char *stop = (const char *)src + srcSize;

	for (;;) {
	  if ((const char *)src < stop)
		*(t1++) = *(src++);
	  else
		break;

	  if ((const char *)src < stop)
		*(t2++) = *(src++);
	  else
		break;
	}
  }

  //
  // Predictor.
  //

  {
	unsigned char *t = &tmpBuf.at(0) + 1;
	unsigned char *stop = &tmpBuf.at(0) + srcSize;
	int p = t[-1];

	while (t < stop) {
	  int d = int(t[0]) - p + (128 + 256);
	  p = t[0];
	  t[0] = d;
	  ++t;
	}
  }

  //
  // Compress the data using miniz
  //

  miniz::mz_ulong outSize = miniz::mz_compressBound(srcSize);
  int ret = miniz::mz_compress(dst, &outSize,
							   (const unsigned char *)&tmpBuf.at(0), srcSize);
  assert(ret == miniz::MZ_OK);
  (void)ret;

  compressedSize = outSize;
}

void DecompressZip(unsigned char *dst, unsigned long &uncompressedSize,
				   const unsigned char *src, unsigned long srcSize) {
  std::vector<unsigned char> tmpBuf(uncompressedSize);

  int ret =
	  miniz::mz_uncompress(&tmpBuf.at(0), &uncompressedSize, src, srcSize);
  assert(ret == miniz::MZ_OK);
  (void)ret;

  //
  // Apply EXR-specific? postprocess. Grabbed from OpenEXR's
  // ImfZipCompressor.cpp
  //

  // Predictor.
  {
	unsigned char *t = &tmpBuf.at(0) + 1;
	unsigned char *stop = &tmpBuf.at(0) + uncompressedSize;

	while (t < stop) {
	  int d = int(t[-1]) + int(t[0]) - 128;
	  t[0] = d;
	  ++t;
	}
  }

  // Reorder the pixel data.
  {
	const char *t1 = reinterpret_cast<const char *>(&tmpBuf.at(0));
	const char *t2 = reinterpret_cast<const char *>(&tmpBuf.at(0)) +
					 (uncompressedSize + 1) / 2;
	char *s = reinterpret_cast<char *>(dst);
	char *stop = s + uncompressedSize;

	for(;;) {
	  if (s < stop)
		*(s++) = *(t1++);
	  else
		break;

	  if (s < stop)
		*(s++) = *(t2++);
	  else
		break;
	}
  }
}

//
// PIZ compress/uncompress, based on OpenEXR's ImfPizCompressor.cpp
//
// -----------------------------------------------------------------
// Copyright (c) 2004, Industrial Light & Magic, a division of Lucas
// Digital Ltd. LLC)
// (3 clause BSD license)
//

struct PIZChannelData {
  unsigned short *start;
  unsigned short *end;
  int nx;
  int ny;
  int ys;
  int size;
};

//-----------------------------------------------------------------------------
//
//  16-bit Haar Wavelet encoding and decoding
//
//  The source code in this file is derived from the encoding
//  and decoding routines written by Christian Rouet for his
//  PIZ image file format.
//
//-----------------------------------------------------------------------------

//
// Wavelet basis functions without modulo arithmetic; they produce
// the best compression ratios when the wavelet-transformed data are
// Huffman-encoded, but the wavelet transform works only for 14-bit
// data (untransformed data values must be less than (1 << 14)).
//

inline void wenc14(unsigned short a, unsigned short b, unsigned short &l,
				   unsigned short &h) {
  short as = a;
  short bs = b;

  short ms = (as + bs) >> 1;
  short ds = as - bs;

  l = ms;
  h = ds;
}

inline void wdec14(unsigned short l, unsigned short h, unsigned short &a,
				   unsigned short &b) {
  short ls = l;
  short hs = h;

  int hi = hs;
  int ai = ls + (hi & 1) + (hi >> 1);

  short as = ai;
  short bs = ai - hi;

  a = as;
  b = bs;
}

//
// Wavelet basis functions with modulo arithmetic; they work with full
// 16-bit data, but Huffman-encoding the wavelet-transformed data doesn't
// compress the data quite as well.
//

const int NBITS = 16;
const int A_OFFSET = 1 << (NBITS - 1);
const int M_OFFSET = 1 << (NBITS - 1);
const int MOD_MASK = (1 << NBITS) - 1;

inline void wenc16(unsigned short a, unsigned short b, unsigned short &l,
				   unsigned short &h) {
  int ao = (a + A_OFFSET) & MOD_MASK;
  int m = ((ao + b) >> 1);
  int d = ao - b;

  if (d < 0)
	m = (m + M_OFFSET) & MOD_MASK;

  d &= MOD_MASK;

  l = m;
  h = d;
}

inline void wdec16(unsigned short l, unsigned short h, unsigned short &a,
				   unsigned short &b) {
  int m = l;
  int d = h;
  int bb = (m - (d >> 1)) & MOD_MASK;
  int aa = (d + bb - A_OFFSET) & MOD_MASK;
  b = bb;
  a = aa;
}

//
// 2D Wavelet encoding:
//

void wav2Encode(unsigned short *in, // io: values are transformed in place
				int nx,             // i : x size
				int ox,             // i : x offset
				int ny,             // i : y size
				int oy,             // i : y offset
				unsigned short mx)  // i : maximum in[x][y] value
{
  bool w14 = (mx < (1 << 14));
  int n = (nx > ny) ? ny : nx;
  int p = 1;  // == 1 <<  level
  int p2 = 2; // == 1 << (level+1)

  //
  // Hierachical loop on smaller dimension n
  //

  while (p2 <= n) {
	unsigned short *py = in;
	unsigned short *ey = in + oy * (ny - p2);
	int oy1 = oy * p;
	int oy2 = oy * p2;
	int ox1 = ox * p;
	int ox2 = ox * p2;
	unsigned short i00, i01, i10, i11;

	//
	// Y loop
	//

	for (; py <= ey; py += oy2) {
	  unsigned short *px = py;
	  unsigned short *ex = py + ox * (nx - p2);

	  //
	  // X loop
	  //

	  for (; px <= ex; px += ox2) {
		unsigned short *p01 = px + ox1;
		unsigned short *p10 = px + oy1;
		unsigned short *p11 = p10 + ox1;

		//
		// 2D wavelet encoding
		//

		if (w14) {
		  wenc14(*px, *p01, i00, i01);
		  wenc14(*p10, *p11, i10, i11);
		  wenc14(i00, i10, *px, *p10);
		  wenc14(i01, i11, *p01, *p11);
		} else {
		  wenc16(*px, *p01, i00, i01);
		  wenc16(*p10, *p11, i10, i11);
		  wenc16(i00, i10, *px, *p10);
		  wenc16(i01, i11, *p01, *p11);
		}
	  }

	  //
	  // Encode (1D) odd column (still in Y loop)
	  //

	  if (nx & p) {
		unsigned short *p10 = px + oy1;

		if (w14)
		  wenc14(*px, *p10, i00, *p10);
		else
		  wenc16(*px, *p10, i00, *p10);

		*px = i00;
	  }
	}

	//
	// Encode (1D) odd line (must loop in X)
	//

	if (ny & p) {
	  unsigned short *px = py;
	  unsigned short *ex = py + ox * (nx - p2);

	  for (; px <= ex; px += ox2) {
		unsigned short *p01 = px + ox1;

		if (w14)
		  wenc14(*px, *p01, i00, *p01);
		else
		  wenc16(*px, *p01, i00, *p01);

		*px = i00;
	  }
	}

	//
	// Next level
	//

	p = p2;
	p2 <<= 1;
  }
}

//
// 2D Wavelet decoding:
//

void wav2Decode(unsigned short *in, // io: values are transformed in place
				int nx,             // i : x size
				int ox,             // i : x offset
				int ny,             // i : y size
				int oy,             // i : y offset
				unsigned short mx)  // i : maximum in[x][y] value
{
  bool w14 = (mx < (1 << 14));
  int n = (nx > ny) ? ny : nx;
  int p = 1;
  int p2;

  //
  // Search max level
  //

  while (p <= n)
	p <<= 1;

  p >>= 1;
  p2 = p;
  p >>= 1;

  //
  // Hierarchical loop on smaller dimension n
  //

  while (p >= 1) {
	unsigned short *py = in;
	unsigned short *ey = in + oy * (ny - p2);
	int oy1 = oy * p;
	int oy2 = oy * p2;
	int ox1 = ox * p;
	int ox2 = ox * p2;
	unsigned short i00, i01, i10, i11;

	//
	// Y loop
	//

	for (; py <= ey; py += oy2) {
	  unsigned short *px = py;
	  unsigned short *ex = py + ox * (nx - p2);

	  //
	  // X loop
	  //

	  for (; px <= ex; px += ox2) {
		unsigned short *p01 = px + ox1;
		unsigned short *p10 = px + oy1;
		unsigned short *p11 = p10 + ox1;

		//
		// 2D wavelet decoding
		//

		if (w14) {
		  wdec14(*px, *p10, i00, i10);
		  wdec14(*p01, *p11, i01, i11);
		  wdec14(i00, i01, *px, *p01);
		  wdec14(i10, i11, *p10, *p11);
		} else {
		  wdec16(*px, *p10, i00, i10);
		  wdec16(*p01, *p11, i01, i11);
		  wdec16(i00, i01, *px, *p01);
		  wdec16(i10, i11, *p10, *p11);
		}
	  }

	  //
	  // Decode (1D) odd column (still in Y loop)
	  //

	  if (nx & p) {
		unsigned short *p10 = px + oy1;

		if (w14)
		  wdec14(*px, *p10, i00, *p10);
		else
		  wdec16(*px, *p10, i00, *p10);

		*px = i00;
	  }
	}

	//
	// Decode (1D) odd line (must loop in X)
	//

	if (ny & p) {
	  unsigned short *px = py;
	  unsigned short *ex = py + ox * (nx - p2);

	  for (; px <= ex; px += ox2) {
		unsigned short *p01 = px + ox1;

		if (w14)
		  wdec14(*px, *p01, i00, *p01);
		else
		  wdec16(*px, *p01, i00, *p01);

		*px = i00;
	  }
	}

	//
	// Next level
	//

	p2 = p;
	p >>= 1;
  }
}

//-----------------------------------------------------------------------------
//
//	16-bit Huffman compression and decompression.
//
//	The source code in this file is derived from the 8-bit
//	Huffman compression and decompression routines written
//	by Christian Rouet for his PIZ image file format.
//
//-----------------------------------------------------------------------------

// Adds some modification for tinyexr.

const int HUF_ENCBITS = 16; // literal (value) bit length
const int HUF_DECBITS = 14; // decoding bit size (>= 8)

const int HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size
const int HUF_DECSIZE = 1 << HUF_DECBITS;       // decoding table size
const int HUF_DECMASK = HUF_DECSIZE - 1;

struct HufDec { // short code		long code
  //-------------------------------
  int len : 8;  // code length		0
  int lit : 24; // lit			p size
  int *p;       // 0			lits
};

inline long long hufLength(long long code) { return code & 63; }

inline long long hufCode(long long code) { return code >> 6; }

inline void outputBits(int nBits, long long bits, long long &c, int &lc,
					   char *&out) {
  c <<= nBits;
  lc += nBits;

  c |= bits;

  while (lc >= 8)
	*out++ = (c >> (lc -= 8));
}

inline long long getBits(int nBits, long long &c, int &lc, const char *&in) {
  while (lc < nBits) {
	c = (c << 8) | *(unsigned char *)(in++);
	lc += 8;
  }

  lc -= nBits;
  return (c >> lc) & ((1 << nBits) - 1);
}

//
// ENCODING TABLE BUILDING & (UN)PACKING
//

//
// Build a "canonical" Huffman code table:
//	- for each (uncompressed) symbol, hcode contains the length
//	  of the corresponding code (in the compressed data)
//	- canonical codes are computed and stored in hcode
//	- the rules for constructing canonical codes are as follows:
//	  * shorter codes (if filled with zeroes to the right)
//	    have a numerically higher value than longer codes
//	  * for codes with the same length, numerical values
//	    increase with numerical symbol values
//	- because the canonical code table can be constructed from
//	  symbol lengths alone, the code table can be transmitted
//	  without sending the actual code values
//	- see http://www.compressconsult.com/huffman/
//

void hufCanonicalCodeTable(long long hcode[HUF_ENCSIZE]) {
  long long n[59];

  //
  // For each i from 0 through 58, count the
  // number of different codes of length i, and
  // store the count in n[i].
  //

  for (int i = 0; i <= 58; ++i)
	n[i] = 0;

  for (int i = 0; i < HUF_ENCSIZE; ++i)
	n[hcode[i]] += 1;

  //
  // For each i from 58 through 1, compute the
  // numerically lowest code with length i, and
  // store that code in n[i].
  //

  long long c = 0;

  for (int i = 58; i > 0; --i) {
	long long nc = ((c + n[i]) >> 1);
	n[i] = c;
	c = nc;
  }

  //
  // hcode[i] contains the length, l, of the
  // code for symbol i.  Assign the next available
  // code of length l to the symbol and store both
  // l and the code in hcode[i].
  //

  for (int i = 0; i < HUF_ENCSIZE; ++i) {
	int l = hcode[i];

	if (l > 0)
	  hcode[i] = l | (n[l]++ << 6);
  }
}

//
// Compute Huffman codes (based on frq input) and store them in frq:
//	- code structure is : [63:lsb - 6:msb] | [5-0: bit length];
//	- max code length is 58 bits;
//	- codes outside the range [im-iM] have a null length (unused values);
//	- original frequencies are destroyed;
//	- encoding tables are used by hufEncode() and hufBuildDecTable();
//

struct FHeapCompare {
  bool operator()(long long *a, long long *b) { return *a > *b; }
};

void hufBuildEncTable(
	long long *frq, // io: input frequencies [HUF_ENCSIZE], output table
	int *im,        //  o: min frq index
	int *iM)        //  o: max frq index
{
  //
  // This function assumes that when it is called, array frq
  // indicates the frequency of all possible symbols in the data
  // that are to be Huffman-encoded.  (frq[i] contains the number
  // of occurrences of symbol i in the data.)
  //
  // The loop below does three things:
  //
  // 1) Finds the minimum and maximum indices that point
  //    to non-zero entries in frq:
  //
  //     frq[im] != 0, and frq[i] == 0 for all i < im
  //     frq[iM] != 0, and frq[i] == 0 for all i > iM
  //
  // 2) Fills array fHeap with pointers to all non-zero
  //    entries in frq.
  //
  // 3) Initializes array hlink such that hlink[i] == i
  //    for all array entries.
  //

  int hlink[HUF_ENCSIZE];
  long long *fHeap[HUF_ENCSIZE];

  *im = 0;

  while (!frq[*im])
	(*im)++;

  int nf = 0;

  for (int i = *im; i < HUF_ENCSIZE; i++) {
	hlink[i] = i;

	if (frq[i]) {
	  fHeap[nf] = &frq[i];
	  nf++;
	  *iM = i;
	}
  }

  //
  // Add a pseudo-symbol, with a frequency count of 1, to frq;
  // adjust the fHeap and hlink array accordingly.  Function
  // hufEncode() uses the pseudo-symbol for run-length encoding.
  //

  (*iM)++;
  frq[*iM] = 1;
  fHeap[nf] = &frq[*iM];
  nf++;

  //
  // Build an array, scode, such that scode[i] contains the number
  // of bits assigned to symbol i.  Conceptually this is done by
  // constructing a tree whose leaves are the symbols with non-zero
  // frequency:
  //
  //     Make a heap that contains all symbols with a non-zero frequency,
  //     with the least frequent symbol on top.
  //
  //     Repeat until only one symbol is left on the heap:
  //
  //         Take the two least frequent symbols off the top of the heap.
  //         Create a new node that has first two nodes as children, and
  //         whose frequency is the sum of the frequencies of the first
  //         two nodes.  Put the new node back into the heap.
  //
  // The last node left on the heap is the root of the tree.  For each
  // leaf node, the distance between the root and the leaf is the length
  // of the code for the corresponding symbol.
  //
  // The loop below doesn't actually build the tree; instead we compute
  // the distances of the leaves from the root on the fly.  When a new
  // node is added to the heap, then that node's descendants are linked
  // into a single linear list that starts at the new node, and the code
  // lengths of the descendants (that is, their distance from the root
  // of the tree) are incremented by one.
  //

  std::make_heap(&fHeap[0], &fHeap[nf], FHeapCompare());

  long long scode[HUF_ENCSIZE];
  memset(scode, 0, sizeof(long long) * HUF_ENCSIZE);

  while (nf > 1) {
	//
	// Find the indices, mm and m, of the two smallest non-zero frq
	// values in fHeap, add the smallest frq to the second-smallest
	// frq, and remove the smallest frq value from fHeap.
	//

	int mm = fHeap[0] - frq;
	std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());
	--nf;

	int m = fHeap[0] - frq;
	std::pop_heap(&fHeap[0], &fHeap[nf], FHeapCompare());

	frq[m] += frq[mm];
	std::push_heap(&fHeap[0], &fHeap[nf], FHeapCompare());

	//
	// The entries in scode are linked into lists with the
	// entries in hlink serving as "next" pointers and with
	// the end of a list marked by hlink[j] == j.
	//
	// Traverse the lists that start at scode[m] and scode[mm].
	// For each element visited, increment the length of the
	// corresponding code by one bit. (If we visit scode[j]
	// during the traversal, then the code for symbol j becomes
	// one bit longer.)
	//
	// Merge the lists that start at scode[m] and scode[mm]
	// into a single list that starts at scode[m].
	//

	//
	// Add a bit to all codes in the first list.
	//

	for (int j = m; true; j = hlink[j]) {
	  scode[j]++;

	  assert(scode[j] <= 58);

	  if (hlink[j] == j) {
		//
		// Merge the two lists.
		//

		hlink[j] = mm;
		break;
	  }
	}

	//
	// Add a bit to all codes in the second list
	//

	for (int j = mm; true; j = hlink[j]) {
	  scode[j]++;

	  assert(scode[j] <= 58);

	  if (hlink[j] == j)
		break;
	}
  }

  //
  // Build a canonical Huffman code table, replacing the code
  // lengths in scode with (code, code length) pairs.  Copy the
  // code table from scode into frq.
  //

  hufCanonicalCodeTable(scode);
  memcpy(frq, scode, sizeof(long long) * HUF_ENCSIZE);
}

//
// Pack an encoding table:
//	- only code lengths, not actual codes, are stored
//	- runs of zeroes are compressed as follows:
//
//	  unpacked		packed
//	  --------------------------------
//	  1 zero		0	(6 bits)
//	  2 zeroes		59
//	  3 zeroes		60
//	  4 zeroes		61
//	  5 zeroes		62
//	  n zeroes (6 or more)	63 n-6	(6 + 8 bits)
//

const int SHORT_ZEROCODE_RUN = 59;
const int LONG_ZEROCODE_RUN = 63;
const int SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
const int LONGEST_LONG_RUN = 255 + SHORTEST_LONG_RUN;

void hufPackEncTable(const long long *hcode, // i : encoding table [HUF_ENCSIZE]
					 int im,                 // i : min hcode index
					 int iM,                 // i : max hcode index
					 char **pcode) //  o: ptr to packed table (updated)
{
  char *p = *pcode;
  long long c = 0;
  int lc = 0;

  for (; im <= iM; im++) {
	int l = hufLength(hcode[im]);

	if (l == 0) {
	  int zerun = 1;

	  while ((im < iM) && (zerun < LONGEST_LONG_RUN)) {
		if (hufLength(hcode[im + 1]) > 0)
		  break;
		im++;
		zerun++;
	  }

	  if (zerun >= 2) {
		if (zerun >= SHORTEST_LONG_RUN) {
		  outputBits(6, LONG_ZEROCODE_RUN, c, lc, p);
		  outputBits(8, zerun - SHORTEST_LONG_RUN, c, lc, p);
		} else {
		  outputBits(6, SHORT_ZEROCODE_RUN + zerun - 2, c, lc, p);
		}
		continue;
	  }
	}

	outputBits(6, l, c, lc, p);
  }

  if (lc > 0)
	*p++ = (unsigned char)(c << (8 - lc));

  *pcode = p;
}

//
// Unpack an encoding table packed by hufPackEncTable():
//

bool hufUnpackEncTable(const char **pcode, // io: ptr to packed table (updated)
					   int ni,             // i : input size (in bytes)
					   int im,             // i : min hcode index
					   int iM,             // i : max hcode index
					   long long *hcode)   //  o: encoding table [HUF_ENCSIZE]
{
  memset(hcode, 0, sizeof(long long) * HUF_ENCSIZE);

  const char *p = *pcode;
  long long c = 0;
  int lc = 0;

  for (; im <= iM; im++) {
	if (p - *pcode > ni) {
	  return false;
	}

	long long l = hcode[im] = getBits(6, c, lc, p); // code length

	if (l == (long long)LONG_ZEROCODE_RUN) {
	  if (p - *pcode > ni) {
		return false;
	  }

	  int zerun = getBits(8, c, lc, p) + SHORTEST_LONG_RUN;

	  if (im + zerun > iM + 1) {
		return false;
	  }

	  while (zerun--)
		hcode[im++] = 0;

	  im--;
	} else if (l >= (long long)SHORT_ZEROCODE_RUN) {
	  int zerun = l - SHORT_ZEROCODE_RUN + 2;

	  if (im + zerun > iM + 1) {
		return false;
	  }

	  while (zerun--)
		hcode[im++] = 0;

	  im--;
	}
  }

  *pcode = const_cast<char *>(p);

  hufCanonicalCodeTable(hcode);

  return true;
}

//
// DECODING TABLE BUILDING
//

//
// Clear a newly allocated decoding table so that it contains only zeroes.
//

void hufClearDecTable(HufDec *hdecod) // io: (allocated by caller)
									  //     decoding table [HUF_DECSIZE]
{
  for (int i = 0; i < HUF_DECSIZE; i++) {
	hdecod[i].len = 0;
	hdecod[i].lit = 0;
	hdecod[i].p = NULL;
  }
  // memset(hdecod, 0, sizeof(HufDec) * HUF_DECSIZE);
}

//
// Build a decoding hash table based on the encoding table hcode:
//	- short codes (<= HUF_DECBITS) are resolved with a single table access;
//	- long code entry allocations are not optimized, because long codes are
//	  unfrequent;
//	- decoding tables are used by hufDecode();
//

bool hufBuildDecTable(const long long *hcode, // i : encoding table
					  int im,                 // i : min index in hcode
					  int iM,                 // i : max index in hcode
					  HufDec *hdecod)         //  o: (allocated by caller)
//     decoding table [HUF_DECSIZE]
{
  //
  // Init hashtable & loop on all codes.
  // Assumes that hufClearDecTable(hdecod) has already been called.
  //

  for (; im <= iM; im++) {
	long long c = hufCode(hcode[im]);
	int l = hufLength(hcode[im]);

	if (c >> l) {
	  //
	  // Error: c is supposed to be an l-bit code,
	  // but c contains a value that is greater
	  // than the largest l-bit number.
	  //

	  // invalidTableEntry();
	  return false;
	}

	if (l > HUF_DECBITS) {
	  //
	  // Long code: add a secondary entry
	  //

	  HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));

	  if (pl->len) {
		//
		// Error: a short code has already
		// been stored in table entry *pl.
		//

		// invalidTableEntry();
		return false;
	  }

	  pl->lit++;

	  if (pl->p) {
		int *p = pl->p;
		pl->p = new int[pl->lit];

		for (int i = 0; i < pl->lit - 1; ++i)
		  pl->p[i] = p[i];

		delete[] p;
	  } else {
		pl->p = new int[1];
	  }

	  pl->p[pl->lit - 1] = im;
	} else if (l) {
	  //
	  // Short code: init all primary entries
	  //

	  HufDec *pl = hdecod + (c << (HUF_DECBITS - l));

	  for (long long i = 1 << (HUF_DECBITS - l); i > 0; i--, pl++) {
		if (pl->len || pl->p) {
		  //
		  // Error: a short code or a long code has
		  // already been stored in table entry *pl.
		  //

		  // invalidTableEntry();
		  return false;
		}

		pl->len = l;
		pl->lit = im;
	  }
	}
  }

  return true;
}

//
// Free the long code entries of a decoding table built by hufBuildDecTable()
//

void hufFreeDecTable(HufDec *hdecod) // io: Decoding table
{
  for (int i = 0; i < HUF_DECSIZE; i++) {
	if (hdecod[i].p) {
	  delete[] hdecod[i].p;
	  hdecod[i].p = 0;
	}
  }
}

//
// ENCODING
//

inline void outputCode(long long code, long long &c, int &lc, char *&out) {
  outputBits(hufLength(code), hufCode(code), c, lc, out);
}

inline void sendCode(long long sCode, int runCount, long long runCode,
					 long long &c, int &lc, char *&out) {
  //
  // Output a run of runCount instances of the symbol sCount.
  // Output the symbols explicitly, or if that is shorter, output
  // the sCode symbol once followed by a runCode symbol and runCount
  // expressed as an 8-bit number.
  //

  if (hufLength(sCode) + hufLength(runCode) + 8 < hufLength(sCode) * runCount) {
	outputCode(sCode, c, lc, out);
	outputCode(runCode, c, lc, out);
	outputBits(8, runCount, c, lc, out);
  } else {
	while (runCount-- >= 0)
	  outputCode(sCode, c, lc, out);
  }
}

//
// Encode (compress) ni values based on the Huffman encoding table hcode:
//

int hufEncode                  // return: output size (in bits)
	(const long long *hcode,   // i : encoding table
	 const unsigned short *in, // i : uncompressed input buffer
	 const int ni,             // i : input buffer size (in bytes)
	 int rlc,                  // i : rl code
	 char *out)                //  o: compressed output buffer
{
  char *outStart = out;
  long long c = 0; // bits not yet written to out
  int lc = 0;      // number of valid bits in c (LSB)
  int s = in[0];
  int cs = 0;

  //
  // Loop on input values
  //

  for (int i = 1; i < ni; i++) {
	//
	// Count same values or send code
	//

	if (s == in[i] && cs < 255) {
	  cs++;
	} else {
	  sendCode(hcode[s], cs, hcode[rlc], c, lc, out);
	  cs = 0;
	}

	s = in[i];
  }

  //
  // Send remaining code
  //

  sendCode(hcode[s], cs, hcode[rlc], c, lc, out);

  if (lc)
	*out = (c << (8 - lc)) & 0xff;

  return (out - outStart) * 8 + lc;
}

//
// DECODING
//

//
// In order to force the compiler to inline them,
// getChar() and getCode() are implemented as macros
// instead of "inline" functions.
//

#define getChar(c, lc, in)                                                     \
  {                                                                            \
	c = (c << 8) | *(unsigned char *)(in++);                                   \
	lc += 8;                                                                   \
  }

#define getCode(po, rlc, c, lc, in, out, oe)                                   \
  {                                                                            \
	if (po == rlc) {                                                           \
	  if (lc < 8)                                                              \
		getChar(c, lc, in);                                                    \
																			   \
	  lc -= 8;                                                                 \
																			   \
	  unsigned char cs = (c >> lc);                                            \
																			   \
	  if (out + cs > oe)                                                       \
		return false;                                                          \
																			   \
	  unsigned short s = out[-1];                                              \
																			   \
	  while (cs-- > 0)                                                         \
		*out++ = s;                                                            \
	} else if (out < oe) {                                                     \
	  *out++ = po;                                                             \
	} else {                                                                   \
	  return false;                                                            \
	}                                                                          \
  }

//
// Decode (uncompress) ni bits based on encoding & decoding tables:
//

bool hufDecode(const long long *hcode, // i : encoding table
			   const HufDec *hdecod,   // i : decoding table
			   const char *in,         // i : compressed input buffer
			   int ni,                 // i : input size (in bits)
			   int rlc,                // i : run-length code
			   int no,                 // i : expected output size (in bytes)
			   unsigned short *out)    //  o: uncompressed output buffer
{
  long long c = 0;
  int lc = 0;
  unsigned short *outb = out;
  unsigned short *oe = out + no;
  const char *ie = in + (ni + 7) / 8; // input byte size

  //
  // Loop on input bytes
  //

  while (in < ie) {
	getChar(c, lc, in);

	//
	// Access decoding table
	//

	while (lc >= HUF_DECBITS) {
	  const HufDec pl = hdecod[(c >> (lc - HUF_DECBITS)) & HUF_DECMASK];

	  if (pl.len) {
		//
		// Get short code
		//

		lc -= pl.len;
		getCode(pl.lit, rlc, c, lc, in, out, oe);
	  } else {
		if (!pl.p) {
		  return false;
		}
		// invalidCode(); // wrong code

		//
		// Search long code
		//

		int j;

		for (j = 0; j < pl.lit; j++) {
		  int l = hufLength(hcode[pl.p[j]]);

		  while (lc < l && in < ie) // get more bits
			getChar(c, lc, in);

		  if (lc >= l) {
			if (hufCode(hcode[pl.p[j]]) ==
				((c >> (lc - l)) & (((long long)(1) << l) - 1))) {
			  //
			  // Found : get long code
			  //

			  lc -= l;
			  getCode(pl.p[j], rlc, c, lc, in, out, oe);
			  break;
			}
		  }
		}

		if (j == pl.lit) {
		  return false;
		  // invalidCode(); // Not found
		}
	  }
	}
  }

  //
  // Get remaining (short) codes
  //

  int i = (8 - ni) & 7;
  c >>= i;
  lc -= i;

  while (lc > 0) {
	const HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];

	if (pl.len) {
	  lc -= pl.len;
	  getCode(pl.lit, rlc, c, lc, in, out, oe);
	} else {
	  return false;
	  // invalidCode(); // wrong (long) code
	}
  }

  if (out - outb != no) {
	return false;
  }
  // notEnoughData ();

  return true;
}

void countFrequencies(long long freq[HUF_ENCSIZE],
					  const unsigned short data[/*n*/], int n) {
  for (int i = 0; i < HUF_ENCSIZE; ++i)
	freq[i] = 0;

  for (int i = 0; i < n; ++i)
	++freq[data[i]];
}

void writeUInt(char buf[4], unsigned int i) {
  unsigned char *b = (unsigned char *)buf;

  b[0] = i;
  b[1] = i >> 8;
  b[2] = i >> 16;
  b[3] = i >> 24;
}

unsigned int readUInt(const char buf[4]) {
  const unsigned char *b = (const unsigned char *)buf;

  return (b[0] & 0x000000ff) | ((b[1] << 8) & 0x0000ff00) |
		 ((b[2] << 16) & 0x00ff0000) | ((b[3] << 24) & 0xff000000);
}

//
// EXTERNAL INTERFACE
//

int hufCompress(const unsigned short raw[], int nRaw, char compressed[]) {
  if (nRaw == 0)
	return 0;

  long long freq[HUF_ENCSIZE];

  countFrequencies(freq, raw, nRaw);

  int im = 0;
  int iM = 0;
  hufBuildEncTable(freq, &im, &iM);

  char *tableStart = compressed + 20;
  char *tableEnd = tableStart;
  hufPackEncTable(freq, im, iM, &tableEnd);
  int tableLength = tableEnd - tableStart;

  char *dataStart = tableEnd;
  int nBits = hufEncode(freq, raw, nRaw, iM, dataStart);
  int dataLength = (nBits + 7) / 8;

  writeUInt(compressed, im);
  writeUInt(compressed + 4, iM);
  writeUInt(compressed + 8, tableLength);
  writeUInt(compressed + 12, nBits);
  writeUInt(compressed + 16, 0); // room for future extensions

  return dataStart + dataLength - compressed;
}

bool hufUncompress(const char compressed[], int nCompressed,
				   unsigned short raw[], int nRaw) {
  if (nCompressed == 0) {
	if (nRaw != 0)
	  return false;

	return false;
  }

  int im = readUInt(compressed);
  int iM = readUInt(compressed + 4);
  // int tableLength = readUInt (compressed + 8);
  int nBits = readUInt(compressed + 12);

  if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)
	return false;

  const char *ptr = compressed + 20;

  //
  // Fast decoder needs at least 2x64-bits of compressed data, and
  // needs to be run-able on this platform. Otherwise, fall back
  // to the original decoder
  //

  // if (FastHufDecoder::enabled() && nBits > 128)
  //{
  //    FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);
  //    fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);
  //}
  // else
  {
	std::vector<long long> freq(HUF_ENCSIZE);
	std::vector<HufDec> hdec(HUF_DECSIZE);

	hufClearDecTable(&hdec.at(0));

	hufUnpackEncTable(&ptr, nCompressed - (ptr - compressed), im, iM,
					  &freq.at(0));

	{
	  if (nBits > 8 * (nCompressed - (ptr - compressed))) {
		return false;
	  }

	  hufBuildDecTable(&freq.at(0), im, iM, &hdec.at(0));
	  hufDecode(&freq.at(0), &hdec.at(0), ptr, nBits, iM, nRaw, raw);
	}
	// catch (...)
	//{
	//    hufFreeDecTable (hdec);
	//    throw;
	//}

	hufFreeDecTable(&hdec.at(0));
  }

  return true;
}

//
// Functions to compress the range of values in the pixel data
//

const int USHORT_RANGE = (1 << 16);
const int BITMAP_SIZE = (USHORT_RANGE >> 3);

void bitmapFromData(const unsigned short data[/*nData*/], int nData,
					unsigned char bitmap[BITMAP_SIZE],
					unsigned short &minNonZero, unsigned short &maxNonZero) {
  for (int i = 0; i < BITMAP_SIZE; ++i)
	bitmap[i] = 0;

  for (int i = 0; i < nData; ++i)
	bitmap[data[i] >> 3] |= (1 << (data[i] & 7));

  bitmap[0] &= ~1; // zero is not explicitly stored in
				   // the bitmap; we assume that the
				   // data always contain zeroes
  minNonZero = BITMAP_SIZE - 1;
  maxNonZero = 0;

  for (int i = 0; i < BITMAP_SIZE; ++i) {
	if (bitmap[i]) {
	  if (minNonZero > i)
		minNonZero = i;
	  if (maxNonZero < i)
		maxNonZero = i;
	}
  }
}

unsigned short forwardLutFromBitmap(const unsigned char bitmap[BITMAP_SIZE],
									unsigned short lut[USHORT_RANGE]) {
  int k = 0;

  for (int i = 0; i < USHORT_RANGE; ++i) {
	if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))
	  lut[i] = k++;
	else
	  lut[i] = 0;
  }

  return k - 1; // maximum value stored in lut[],
} // i.e. number of ones in bitmap minus 1

unsigned short reverseLutFromBitmap(const unsigned char bitmap[BITMAP_SIZE],
									unsigned short lut[USHORT_RANGE]) {
  int k = 0;

  for (int i = 0; i < USHORT_RANGE; ++i) {
	if ((i == 0) || (bitmap[i >> 3] & (1 << (i & 7))))
	  lut[k++] = i;
  }

  int n = k - 1;

  while (k < USHORT_RANGE)
	lut[k++] = 0;

  return n; // maximum k where lut[k] is non-zero,
} // i.e. number of ones in bitmap minus 1

void applyLut(const unsigned short lut[USHORT_RANGE],
			  unsigned short data[/*nData*/], int nData) {
  for (int i = 0; i < nData; ++i)
	data[i] = lut[data[i]];
}

bool CompressPiz(unsigned char *outPtr, unsigned int &outSize,
				 const unsigned char *inPtr, size_t inSize,
				 const std::vector<ChannelInfo> &channelInfo, int dataWidth,
				 int numLines) {
  unsigned char bitmap[BITMAP_SIZE];
  unsigned short minNonZero;
  unsigned short maxNonZero;

  if (IsBigEndian()) {
	// @todo { PIZ compression on BigEndian architecture. }
	assert(0);
	return false;
  }

  // Assume `inSize` is multiple of 2 or 4.
  std::vector<unsigned short> tmpBuffer(inSize / sizeof(unsigned short));

  std::vector<PIZChannelData> channelData(channelInfo.size());
  unsigned short *tmpBufferEnd = &tmpBuffer.at(0);

  int i = 0;
  for (size_t c = 0; c < channelData.size(); c++, i++) {
	PIZChannelData &cd = channelData[i];

	cd.start = tmpBufferEnd;
	cd.end = cd.start;

	cd.nx = dataWidth;
	cd.ny = numLines;
	// cd.ys = c.channel().ySampling;

	int pixelSize = sizeof(int); // UINT and FLOAT
	if (channelInfo[i].pixelType == TINYEXR_PIXELTYPE_HALF) {
	  pixelSize = sizeof(short);
	}

	cd.size = pixelSize / sizeof(short);

	tmpBufferEnd += cd.nx * cd.ny * cd.size;
  }

  const unsigned char *ptr = inPtr;
  for (int y = 0; y < numLines; ++y) {
	for (size_t i = 0; i < channelData.size(); ++i) {
	  PIZChannelData &cd = channelData[i];

	  // if (modp (y, cd.ys) != 0)
	  //    continue;

	  int n = cd.nx * cd.size;
	  memcpy(cd.end, ptr, n * sizeof(unsigned short));
	  ptr += n * sizeof(unsigned short);
	  cd.end += n;
	}
  }

  bitmapFromData(&tmpBuffer.at(0), tmpBuffer.size(), bitmap, minNonZero,
				 maxNonZero);

  unsigned short lut[USHORT_RANGE];
  unsigned short maxValue = forwardLutFromBitmap(bitmap, lut);
  applyLut(lut, &tmpBuffer.at(0), tmpBuffer.size());

  //
  // Store range compression info in _outBuffer
  //

  char *buf = reinterpret_cast<char *>(outPtr);

  memcpy(buf, &minNonZero, sizeof(unsigned short));
  buf += sizeof(unsigned short);
  memcpy(buf, &maxNonZero, sizeof(unsigned short));
  buf += sizeof(unsigned short);

  if (minNonZero <= maxNonZero) {
	memcpy(buf, (char *)&bitmap[0] + minNonZero, maxNonZero - minNonZero + 1);
	buf += maxNonZero - minNonZero + 1;
  }

  //
  // Apply wavelet encoding
  //

  for (size_t i = 0; i < channelData.size(); ++i) {
	PIZChannelData &cd = channelData[i];

	for (int j = 0; j < cd.size; ++j) {
	  wav2Encode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,
				 maxValue);
	}
  }

  //
  // Apply Huffman encoding; append the result to _outBuffer
  //

  // length header(4byte), then huff data. Initialize length header with zero,
  // then later fill it by `length`.
  char *lengthPtr = buf;
  int zero = 0;
  memcpy(buf, &zero, sizeof(int));
  buf += sizeof(int);

  int length = hufCompress(&tmpBuffer.at(0), tmpBuffer.size(), buf);
  memcpy(lengthPtr, &length, sizeof(int));

  outSize = (reinterpret_cast<unsigned char *>(buf) - outPtr) + length;
  return true;
}

bool DecompressPiz(unsigned char *outPtr, const unsigned char *inPtr, size_t tmpBufSize,
				   const std::vector<ChannelInfo> &channelInfo, int dataWidth,
				   int numLines) {
  unsigned char bitmap[BITMAP_SIZE];
  unsigned short minNonZero;
  unsigned short maxNonZero;

  if (IsBigEndian()) {
	// @todo { PIZ compression on BigEndian architecture. }
	assert(0);
	return false;
  }

  memset(bitmap, 0, BITMAP_SIZE);

  const unsigned char *ptr = inPtr;
  minNonZero = *(reinterpret_cast<const unsigned short *>(ptr));
  maxNonZero = *(reinterpret_cast<const unsigned short *>(ptr + 2));
  ptr += 4;

  if (maxNonZero >= BITMAP_SIZE) {
	return false;
  }

  if (minNonZero <= maxNonZero) {
	memcpy((char *)&bitmap[0] + minNonZero, ptr, maxNonZero - minNonZero + 1);
	ptr += maxNonZero - minNonZero + 1;
  }

  unsigned short lut[USHORT_RANGE];
  memset(lut, 0, sizeof(unsigned short) * USHORT_RANGE);
  unsigned short maxValue = reverseLutFromBitmap(bitmap, lut);

  //
  // Huffman decoding
  //

  int length;

  length = *(reinterpret_cast<const int *>(ptr));
  ptr += sizeof(int);

  std::vector<unsigned short> tmpBuffer(tmpBufSize);
  hufUncompress(reinterpret_cast<const char *>(ptr), length, &tmpBuffer.at(0),
				tmpBufSize);

  //
  // Wavelet decoding
  //

  std::vector<PIZChannelData> channelData(channelInfo.size());

  unsigned short *tmpBufferEnd = &tmpBuffer.at(0);

  for (size_t i = 0; i < channelInfo.size(); ++i) {
	const ChannelInfo &chan = channelInfo[i];

	int pixelSize = sizeof(int); // UINT and FLOAT
	if (chan.pixelType == TINYEXR_PIXELTYPE_HALF) {
	  pixelSize = sizeof(short);
	}

	channelData[i].start = tmpBufferEnd;
	channelData[i].end = channelData[i].start;
	channelData[i].nx = dataWidth;
	channelData[i].ny = numLines;
	// channelData[i].ys = 1;
	channelData[i].size = pixelSize / sizeof(short);

	tmpBufferEnd += channelData[i].nx * channelData[i].ny * channelData[i].size;
  }

  for (size_t i = 0; i < channelData.size(); ++i) {
	PIZChannelData &cd = channelData[i];

	for (int j = 0; j < cd.size; ++j) {
	  wav2Decode(cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size,
				 maxValue);
	}
  }

  //
  // Expand the pixel data to their original range
  //

  applyLut(lut, &tmpBuffer.at(0), tmpBufSize);

  for (int y = 0; y < numLines; y++) {
	for (size_t i = 0; i < channelData.size(); ++i) {
	  PIZChannelData &cd = channelData[i];

	  // if (modp (y, cd.ys) != 0)
	  //    continue;

	  int n = cd.nx * cd.size;
	  memcpy(outPtr, cd.end, n * sizeof(unsigned short));
	  outPtr += n * sizeof(unsigned short);
	  cd.end += n;
	}
  }

  return true;
}
//
// -----------------------------------------------------------------
//

} // namespace

int LoadEXR(float **out_rgba, int *width, int *height, const char *filename,
			const char **err) {

  if (out_rgba == NULL) {
	if (err) {
	  (*err) = "Invalid argument.\n";
	}
	return -1;
  }

  EXRImage exrImage;
  InitEXRImage(&exrImage);

  {
	int ret = ParseMultiChannelEXRHeaderFromFile(&exrImage, filename, err);
	if (ret != 0) {
	  return ret;
	}
  }

  // Read HALF channel as FLOAT.
  for (int i = 0; i < exrImage.num_channels; i++) {
	if (exrImage.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {
	  exrImage.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;
	}
  }

  {
	int ret = LoadMultiChannelEXRFromFile(&exrImage, filename, err);
	if (ret != 0) {
	  return ret;
	}
  }

  // RGBA
  int idxR = -1;
  int idxG = -1;
  int idxB = -1;
  int idxA = -1;
  for (int c = 0; c < exrImage.num_channels; c++) {
	if (strcmp(exrImage.channel_names[c], "R") == 0) {
	  idxR = c;
	} else if (strcmp(exrImage.channel_names[c], "G") == 0) {
	  idxG = c;
	} else if (strcmp(exrImage.channel_names[c], "B") == 0) {
	  idxB = c;
	} else if (strcmp(exrImage.channel_names[c], "A") == 0) {
	  idxA = c;
	}
  }

  if (idxR == -1) {
	if (err) {
	  (*err) = "R channel not found\n";
	}

	// @todo { free exrImage }
	return -1;
  }

  if (idxG == -1) {
	if (err) {
	  (*err) = "G channel not found\n";
	}
	// @todo { free exrImage }
	return -1;
  }

  if (idxB == -1) {
	if (err) {
	  (*err) = "B channel not found\n";
	}
	// @todo { free exrImage }
	return -1;
  }

  (*out_rgba) =
	  (float *)malloc(4 * sizeof(float) * exrImage.width * exrImage.height);
  for (int i = 0; i < exrImage.width * exrImage.height; i++) {
	(*out_rgba)[4 * i + 0] =
		reinterpret_cast<float **>(exrImage.images)[idxR][i];
	(*out_rgba)[4 * i + 1] =
		reinterpret_cast<float **>(exrImage.images)[idxG][i];
	(*out_rgba)[4 * i + 2] =
		reinterpret_cast<float **>(exrImage.images)[idxB][i];
	if (idxA != -1) {
	  (*out_rgba)[4 * i + 3] =
		  reinterpret_cast<float **>(exrImage.images)[idxA][i];
	} else {
	  (*out_rgba)[4 * i + 3] = 1.0;
	}
  }

  (*width) = exrImage.width;
  (*height) = exrImage.height;

  // @todo { free exrImage }
  return 0;
}

int ParseEXRHeaderFromMemory(EXRAttribute *customAttributes,
							 int *numCustomAttributes, int *width, int *height,
							 const unsigned char *memory) {

  if (memory == NULL) {
	// Invalid argument
	return -1;
  }

  const char *buf = reinterpret_cast<const char *>(memory);

  const char *marker = &buf[0];

  // Header check.
  {
	const char header[] = {0x76, 0x2f, 0x31, 0x01};

	if (memcmp(marker, header, 4) != 0) {
	  // if (err) {
	  //  (*err) = "Header mismatch.";
	  //}
	  return -3;
	}
	marker += 4;
  }

  // Version, scanline.
  {
	// must be [2, 0, 0, 0]
	if (marker[0] != 2 || marker[1] != 0 || marker[2] != 0 || marker[3] != 0) {
	  // if (err) {
	  //  (*err) = "Unsupported version or scanline.";
	  //}
	  return -4;
	}

	marker += 4;
  }

  int dx = -1;
  int dy = -1;
  int dw = -1;
  int dh = -1;
  int lineOrder = 0;                          // @fixme
  int displayWindow[4] = {-1, -1, -1, -1};    // @fixme
  float screenWindowCenter[2] = {0.0f, 0.0f}; // @fixme
  float screenWindowWidth = 1.0f;             // @fixme
  int numChannels = -1;
  float pixelAspectRatio = 1.0f; // @fixme
  std::vector<ChannelInfo> channels;
  std::vector<EXRAttribute> attribs;

  if (numCustomAttributes) {
	(*numCustomAttributes) = 0;
  }

  // Read attributes
  for (;;) {
	std::string attrName;
	std::string attrType;
	std::vector<unsigned char> data;
	const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
	if (marker_next == NULL) {
	  marker++; // skip '\0'
	  break;
	}

	if (attrName.compare("compression") == TINYEXR_COMPRESSIONTYPE_NONE) {
	  //	mwkm
	  //	0 : NO_COMPRESSION
	  //	1 : RLE
	  //	2 : ZIPS (Single scanline)
	  //	3 : ZIP (16-line block)
	  //	4 : PIZ (32-line block)
	  if (data[0] > TINYEXR_COMPRESSIONTYPE_PIZ) {
		// if (err) {
		//  (*err) = "Unsupported compression type.";
		//}
		return -5;
	  }

	} else if (attrName.compare("channels") == 0) {

	  // name: zero-terminated string, from 1 to 255 bytes long
	  // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
	  // pLinear: unsigned char, possible values are 0 and 1
	  // reserved: three chars, should be zero
	  // xSampling: int
	  // ySampling: int

	  ReadChannelInfo(channels, data);

	  numChannels = channels.size();

	  if (numChannels < 1) {
		// if (err) {
		//  (*err) = "Invalid channels format.";
		//}
		return -6;
	  }

	} else if (attrName.compare("dataWindow") == 0) {
	  memcpy(&dx, &data.at(0), sizeof(int));
	  memcpy(&dy, &data.at(4), sizeof(int));
	  memcpy(&dw, &data.at(8), sizeof(int));
	  memcpy(&dh, &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&dx));
		swap4(reinterpret_cast<unsigned int *>(&dy));
		swap4(reinterpret_cast<unsigned int *>(&dw));
		swap4(reinterpret_cast<unsigned int *>(&dh));
	  }
	} else if (attrName.compare("displayWindow") == 0) {
	  memcpy(&displayWindow[0], &data.at(0), sizeof(int));
	  memcpy(&displayWindow[1], &data.at(4), sizeof(int));
	  memcpy(&displayWindow[2], &data.at(8), sizeof(int));
	  memcpy(&displayWindow[3], &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[0]));
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[1]));
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[2]));
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[3]));
	  }
	} else if (attrName.compare("lineOrder") == 0) {
	  memcpy(&lineOrder, &data.at(0), sizeof(float));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&lineOrder));
	  }
	} else if (attrName.compare("pixelAspectRatio") == 0) {
	  memcpy(&pixelAspectRatio, &data.at(0), sizeof(float));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&pixelAspectRatio));
	  }
	} else if (attrName.compare("screenWindowCenter") == 0) {
	  memcpy(&screenWindowCenter[0], &data.at(0), sizeof(float));
	  memcpy(&screenWindowCenter[1], &data.at(4), sizeof(float));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[0]));
		swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[1]));
	  }
	} else if (attrName.compare("screenWindowWidth") == 0) {
	  memcpy(&screenWindowWidth, &data.at(0), sizeof(float));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&screenWindowWidth));
	  }

	} else {
	  // Custom attribute(up to TINYEXR_MAX_ATTRIBUTES)
	  if (numCustomAttributes &&
		  ((*numCustomAttributes) < TINYEXR_MAX_ATTRIBUTES)) {
		EXRAttribute attrib;
		attrib.name = strdup(attrName.c_str());
		attrib.type = strdup(attrType.c_str());
		attrib.size = data.size();
		attrib.value = (unsigned char *)malloc(data.size());
		memcpy((char *)attrib.value, &data.at(0), data.size());
		attribs.push_back(attrib);
	  }
	}

	marker = marker_next;
  }

  assert(dx >= 0);
  assert(dy >= 0);
  assert(dw >= 0);
  assert(dh >= 0);
  assert(numChannels >= 1);

  int dataWidth = dw - dx + 1;
  int dataHeight = dh - dy + 1;

  (*width) = dataWidth;
  (*height) = dataHeight;

  if (numCustomAttributes) {
	assert(attribs.size() < TINYEXR_MAX_ATTRIBUTES);
	(*numCustomAttributes) = attribs.size();

	// Assume the pointer to customAttributes has enough memory to store.
	for (int i = 0; i < (int)attribs.size(); i++) {
	  customAttributes[i] = attribs[i];
	}
  }

  return 0;
}

int LoadEXRFromMemory(float *out_rgba, const unsigned char *memory,
					  const char **err) {

  if (out_rgba == NULL || memory == NULL) {
	if (err) {
	  (*err) = "Invalid argument.\n";
	}
	return -1;
  }

  EXRImage exrImage;
  InitEXRImage(&exrImage);
  int ret = LoadMultiChannelEXRFromMemory(&exrImage, memory, err);
  if (ret != 0) {
	return ret;
  }

  // RGBA
  int idxR = -1;
  int idxG = -1;
  int idxB = -1;
  int idxA = -1;
  for (int c = 0; c < exrImage.num_channels; c++) {
	if (strcmp(exrImage.channel_names[c], "R") == 0) {
	  idxR = c;
	} else if (strcmp(exrImage.channel_names[c], "G") == 0) {
	  idxG = c;
	} else if (strcmp(exrImage.channel_names[c], "B") == 0) {
	  idxB = c;
	} else if (strcmp(exrImage.channel_names[c], "A") == 0) {
	  idxA = c;
	}
  }

  if (idxR == -1) {
	if (err) {
	  (*err) = "R channel not found\n";
	}

	// @todo { free exrImage }
	return -1;
  }

  if (idxG == -1) {
	if (err) {
	  (*err) = "G channel not found\n";
	}
	// @todo { free exrImage }
	return -1;
  }

  if (idxB == -1) {
	if (err) {
	  (*err) = "B channel not found\n";
	}
	// @todo { free exrImage }
	return -1;
  }

  // Assume `out_rgba` have enough memory allocated.
  for (int i = 0; i < exrImage.width * exrImage.height; i++) {
	out_rgba[4 * i + 0] = reinterpret_cast<float **>(exrImage.images)[idxR][i];
	out_rgba[4 * i + 1] = reinterpret_cast<float **>(exrImage.images)[idxG][i];
	out_rgba[4 * i + 2] = reinterpret_cast<float **>(exrImage.images)[idxB][i];
	if (idxA > 0) {
	  out_rgba[4 * i + 3] =
		  reinterpret_cast<float **>(exrImage.images)[idxA][i];
	} else {
	  out_rgba[4 * i + 3] = 1.0;
	}
  }

  return 0;
}

int LoadMultiChannelEXRFromFile(EXRImage *exrImage, const char *filename,
								const char **err) {
  if (exrImage == NULL) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  FILE *fp = fopen(filename, "rb");
  if (!fp) {
	if (err) {
	  (*err) = "Cannot read file.";
	}
	return -1;
  }

  size_t filesize;
  // Compute size
  fseek(fp, 0, SEEK_END);
  filesize = ftell(fp);
  fseek(fp, 0, SEEK_SET);

  std::vector<unsigned char> buf(filesize); // @todo { use mmap }
  {
	size_t ret;
	ret = fread(&buf[0], 1, filesize, fp);
	assert(ret == filesize);
	fclose(fp);
	(void)ret;
  }

  return LoadMultiChannelEXRFromMemory(exrImage, &buf.at(0), err);
}

int LoadMultiChannelEXRFromMemory(EXRImage *exrImage,
								  const unsigned char *memory,
								  const char **err) {
  if (exrImage == NULL || memory == NULL) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  const char *buf = reinterpret_cast<const char *>(memory);

  const char *head = &buf[0];
  const char *marker = &buf[0];

  // Header check.
  {
	const char header[] = {0x76, 0x2f, 0x31, 0x01};

	if (memcmp(marker, header, 4) != 0) {
	  if (err) {
		(*err) = "Header mismatch.";
	  }
	  return -3;
	}
	marker += 4;
  }

  // Version, scanline.
  {
	// must be [2, 0, 0, 0]
	if (marker[0] != 2 || marker[1] != 0 || marker[2] != 0 || marker[3] != 0) {
	  if (err) {
		(*err) = "Unsupported version or scanline.";
	  }
	  return -4;
	}

	marker += 4;
  }

  int dx = -1;
  int dy = -1;
  int dw = -1;
  int dh = -1;
  int numScanlineBlocks = 1; // 16 for ZIP compression.
  int compressionType = -1;
  int numChannels = -1;
  unsigned char lineOrder = 0; // 0 -> increasing y; 1 -> decreasing
  std::vector<ChannelInfo> channels;

  // Read attributes
  for (;;) {
	std::string attrName;
	std::string attrType;
	std::vector<unsigned char> data;
	const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
	if (marker_next == NULL) {
	  marker++; // skip '\0'
	  break;
	}

	if (attrName.compare("compression") == 0) {
	  //	mwkm
	  //	0 : NO_COMPRESSION
	  //	1 : RLE
	  //	2 : ZIPS (Single scanline)
	  //	3 : ZIP (16-line block)
	  //	4 : PIZ (32-line block)
	  if (data[0] != TINYEXR_COMPRESSIONTYPE_NONE &&
		  data[0] != TINYEXR_COMPRESSIONTYPE_ZIPS &&
		  data[0] != TINYEXR_COMPRESSIONTYPE_ZIP &&
		  data[0] != TINYEXR_COMPRESSIONTYPE_PIZ) {

		if (err) {
		  (*err) = "Unsupported compression type.";
		}
		return -5;
	  }

	  compressionType = data[0];

	  if (compressionType == TINYEXR_COMPRESSIONTYPE_ZIP) {
		numScanlineBlocks = 16;
	  } else if (compressionType == TINYEXR_COMPRESSIONTYPE_PIZ) {
		numScanlineBlocks = 32;
	  }

	} else if (attrName.compare("channels") == 0) {

	  // name: zero-terminated string, from 1 to 255 bytes long
	  // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
	  // pLinear: unsigned char, possible values are 0 and 1
	  // reserved: three chars, should be zero
	  // xSampling: int
	  // ySampling: int

	  ReadChannelInfo(channels, data);

	  numChannels = channels.size();

	  if (numChannels < 1) {
		if (err) {
		  (*err) = "Invalid channels format.";
		}
		return -6;
	  }

	} else if (attrName.compare("dataWindow") == 0) {
	  memcpy(&dx, &data.at(0), sizeof(int));
	  memcpy(&dy, &data.at(4), sizeof(int));
	  memcpy(&dw, &data.at(8), sizeof(int));
	  memcpy(&dh, &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&dx));
		swap4(reinterpret_cast<unsigned int *>(&dy));
		swap4(reinterpret_cast<unsigned int *>(&dw));
		swap4(reinterpret_cast<unsigned int *>(&dh));
	  }
	} else if (attrName.compare("displayWindow") == 0) {
	  int x, y, w, h;
	  memcpy(&x, &data.at(0), sizeof(int));
	  memcpy(&y, &data.at(4), sizeof(int));
	  memcpy(&w, &data.at(8), sizeof(int));
	  memcpy(&h, &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&x));
		swap4(reinterpret_cast<unsigned int *>(&y));
		swap4(reinterpret_cast<unsigned int *>(&w));
		swap4(reinterpret_cast<unsigned int *>(&h));
	  }
	} else if (attrName.compare("lineOrder") == 0) {
	  memcpy(&lineOrder, &data.at(0), sizeof(lineOrder));
	}

	marker = marker_next;
  }

  assert(dx >= 0);
  assert(dy >= 0);
  assert(dw >= 0);
  assert(dh >= 0);
  assert(numChannels >= 1);

  int dataWidth = dw - dx + 1;
  int dataHeight = dh - dy + 1;

  // Read offset tables.
  int numBlocks = dataHeight / numScanlineBlocks;
  if (numBlocks * numScanlineBlocks < dataHeight) {
	numBlocks++;
  }

  std::vector<long long> offsets(numBlocks);

  for (int y = 0; y < numBlocks; y++) {
	long long offset;
	memcpy(&offset, marker, sizeof(long long));
	if (IsBigEndian()) {
	  swap8(reinterpret_cast<unsigned long long *>(&offset));
	}
	marker += sizeof(long long); // = 8
	offsets[y] = offset;
  }

  exrImage->images = reinterpret_cast<unsigned char **>(
	  (float **)malloc(sizeof(float *) * numChannels));

  std::vector<size_t> channelOffsetList(numChannels);
  int pixelDataSize = 0;
  size_t channelOffset = 0;
  for (int c = 0; c < numChannels; c++) {
	channelOffsetList[c] = channelOffset;
	if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {
	  pixelDataSize += sizeof(unsigned short);
	  channelOffset += sizeof(unsigned short);
	  // Alloc internal image for half type.
	  if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
		exrImage->images[c] =
			reinterpret_cast<unsigned char *>((unsigned short *)malloc(
				sizeof(unsigned short) * dataWidth * dataHeight));
	  } else if (exrImage->requested_pixel_types[c] ==
				 TINYEXR_PIXELTYPE_FLOAT) {
		exrImage->images[c] = reinterpret_cast<unsigned char *>(
			(float *)malloc(sizeof(float) * dataWidth * dataHeight));
	  } else {
		assert(0);
	  }
	} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {
	  pixelDataSize += sizeof(float);
	  channelOffset += sizeof(float);
	  exrImage->images[c] = reinterpret_cast<unsigned char *>(
		  (float *)malloc(sizeof(float) * dataWidth * dataHeight));
	} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {
	  pixelDataSize += sizeof(unsigned int);
	  channelOffset += sizeof(unsigned int);
	  exrImage->images[c] = reinterpret_cast<unsigned char *>((
		  unsigned int *)malloc(sizeof(unsigned int) * dataWidth * dataHeight));
	} else {
	  assert(0);
	}
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for (int y = 0; y < numBlocks; y++) {
	const unsigned char *dataPtr =
		reinterpret_cast<const unsigned char *>(head + offsets[y]);
	// 4 byte: scan line
	// 4 byte: data size
	// ~     : pixel data(uncompressed or compressed)
	int lineNo;
	memcpy(&lineNo, dataPtr, sizeof(int));
	int dataLen;
	memcpy(&dataLen, dataPtr + 4, sizeof(int));
	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&lineNo));
	  swap4(reinterpret_cast<unsigned int *>(&dataLen));
	}

	int endLineNo = (std::min)(lineNo + numScanlineBlocks, dataHeight);

	int numLines = endLineNo - lineNo;

	if (compressionType == 4) { // PIZ
	  // Allocate original data size.
	  std::vector<unsigned char> outBuf(dataWidth * numLines * pixelDataSize);
	  size_t tmpBufLen = dataWidth * numLines * pixelDataSize;

	  DecompressPiz(reinterpret_cast<unsigned char *>(&outBuf.at(0)),
					dataPtr + 8, tmpBufLen, channels, dataWidth, numLines);

	  bool isBigEndian = IsBigEndian();

	  // For ZIP_COMPRESSION:
	  //   pixel sample data for channel 0 for scanline 0
	  //   pixel sample data for channel 1 for scanline 0
	  //   pixel sample data for channel ... for scanline 0
	  //   pixel sample data for channel n for scanline 0
	  //   pixel sample data for channel 0 for scanline 1
	  //   pixel sample data for channel 1 for scanline 1
	  //   pixel sample data for channel ... for scanline 1
	  //   pixel sample data for channel n for scanline 1
	  //   ...
	  for (int c = 0; c < numChannels; c++) {

		if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {
		  for (int v = 0; v < numLines; v++) {
			const unsigned short *linePtr = reinterpret_cast<unsigned short *>(
				&outBuf.at(v * pixelDataSize * dataWidth +
						   channelOffsetList[c] * dataWidth));
			for (int u = 0; u < dataWidth; u++) {
			  FP16 hf;

			  hf.u = linePtr[u];

			  if (isBigEndian) {
				swap2(reinterpret_cast<unsigned short *>(&hf.u));
			  }

			  if (exrImage->requested_pixel_types[c] ==
				  TINYEXR_PIXELTYPE_HALF) {
				unsigned short *image =
					reinterpret_cast<unsigned short **>(exrImage->images)[c];
				if (lineOrder == 0) {
				  image += (lineNo + v) * dataWidth + u;
				} else {
				  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
				}
				*image = hf.u;
			  } else { // HALF -> FLOAT
				FP32 f32 = half_to_float(hf);
				float *image = reinterpret_cast<float **>(exrImage->images)[c];
				if (lineOrder == 0) {
				  image += (lineNo + v) * dataWidth + u;
				} else {
				  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
				}
				*image = f32.f;
			  }
			}
		  }
		} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {

		  assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);

		  for (int v = 0; v < numLines; v++) {
			const unsigned int *linePtr = reinterpret_cast<unsigned int *>(
				&outBuf.at(v * pixelDataSize * dataWidth +
						   channelOffsetList[c] * dataWidth));
			for (int u = 0; u < dataWidth; u++) {

			  unsigned int val = linePtr[u];

			  if (isBigEndian) {
				swap4(&val);
			  }

			  unsigned int *image =
				  reinterpret_cast<unsigned int **>(exrImage->images)[c];
			  if (lineOrder == 0) {
				image += (lineNo + v) * dataWidth + u;
			  } else {
				image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
			  }
			  *image = val;
			}
		  }
		} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {
		  assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);
		  for (int v = 0; v < numLines; v++) {
			const float *linePtr = reinterpret_cast<float *>(
				&outBuf.at(v * pixelDataSize * dataWidth +
						   channelOffsetList[c] * dataWidth));
			for (int u = 0; u < dataWidth; u++) {

			  float val = linePtr[u];

			  if (isBigEndian) {
				swap4(reinterpret_cast<unsigned int *>(&val));
			  }

			  float *image = reinterpret_cast<float **>(exrImage->images)[c];
			  if (lineOrder == 0) {
				image += (lineNo + v) * dataWidth + u;
			  } else {
				image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
			  }
			  *image = val;
			}
		  }
		} else {
		  assert(0);
		}
	  }

	  //	mwkm, ZIPS or ZIP both good to go
	} else if (compressionType == 2 || compressionType == 3) { // ZIP

	  // Allocate original data size.
	  std::vector<unsigned char> outBuf(dataWidth * numLines * pixelDataSize);

	  unsigned long dstLen = outBuf.size();
	  DecompressZip(reinterpret_cast<unsigned char *>(&outBuf.at(0)), dstLen,
					dataPtr + 8, dataLen);

	  bool isBigEndian = IsBigEndian();

	  // For ZIP_COMPRESSION:
	  //   pixel sample data for channel 0 for scanline 0
	  //   pixel sample data for channel 1 for scanline 0
	  //   pixel sample data for channel ... for scanline 0
	  //   pixel sample data for channel n for scanline 0
	  //   pixel sample data for channel 0 for scanline 1
	  //   pixel sample data for channel 1 for scanline 1
	  //   pixel sample data for channel ... for scanline 1
	  //   pixel sample data for channel n for scanline 1
	  //   ...
	  for (int c = 0; c < numChannels; c++) {

		if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {
		  for (int v = 0; v < numLines; v++) {
			const unsigned short *linePtr = reinterpret_cast<unsigned short *>(
				&outBuf.at(v * pixelDataSize * dataWidth +
						   channelOffsetList[c] * dataWidth));
			for (int u = 0; u < dataWidth; u++) {
			  FP16 hf;

			  hf.u = linePtr[u];

			  if (isBigEndian) {
				swap2(reinterpret_cast<unsigned short *>(&hf.u));
			  }

			  if (exrImage->requested_pixel_types[c] ==
				  TINYEXR_PIXELTYPE_HALF) {
				unsigned short *image =
					reinterpret_cast<unsigned short **>(exrImage->images)[c];
				if (lineOrder == 0) {
				  image += (lineNo + v) * dataWidth + u;
				} else {
				  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
				}
				*image = hf.u;
			  } else { // HALF -> FLOAT
				FP32 f32 = half_to_float(hf);
				float *image = reinterpret_cast<float **>(exrImage->images)[c];
				if (lineOrder == 0) {
				  image += (lineNo + v) * dataWidth + u;
				} else {
				  image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
				}
				*image = f32.f;
			  }
			}
		  }
		} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {

		  assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT);

		  for (int v = 0; v < numLines; v++) {
			const unsigned int *linePtr = reinterpret_cast<unsigned int *>(
				&outBuf.at(v * pixelDataSize * dataWidth +
						   channelOffsetList[c] * dataWidth));
			for (int u = 0; u < dataWidth; u++) {

			  unsigned int val = linePtr[u];

			  if (isBigEndian) {
				swap4(&val);
			  }

			  unsigned int *image =
				  reinterpret_cast<unsigned int **>(exrImage->images)[c];
			  if (lineOrder == 0) {
				image += (lineNo + v) * dataWidth + u;
			  } else {
				image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
			  }
			  *image = val;
			}
		  }
		} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {
		  assert(exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT);
		  for (int v = 0; v < numLines; v++) {
			const float *linePtr = reinterpret_cast<float *>(
				&outBuf.at(v * pixelDataSize * dataWidth +
						   channelOffsetList[c] * dataWidth));
			for (int u = 0; u < dataWidth; u++) {

			  float val = linePtr[u];

			  if (isBigEndian) {
				swap4(reinterpret_cast<unsigned int *>(&val));
			  }

			  float *image = reinterpret_cast<float **>(exrImage->images)[c];
			  if (lineOrder == 0) {
				image += (lineNo + v) * dataWidth + u;
			  } else {
				image += (dataHeight - 1 - (lineNo + v)) * dataWidth + u;
			  }
			  *image = val;
			}
		  }
		} else {
		  assert(0);
		}
	  }

	} else if (compressionType == 0) { // No compression

	  bool isBigEndian = IsBigEndian();

	  for (int c = 0; c < numChannels; c++) {

		if (channels[c].pixelType == TINYEXR_PIXELTYPE_HALF) {

		  const unsigned short *linePtr =
			  reinterpret_cast<const unsigned short *>(
				  dataPtr + 8 + c * dataWidth * sizeof(unsigned short));

		  if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
			unsigned short *outLine =
				reinterpret_cast<unsigned short *>(exrImage->images[c]);
			if (lineOrder == 0) {
			  outLine += y * dataWidth;
			} else {
			  outLine += (dataHeight - 1 - y) * dataWidth;
			}

			for (int u = 0; u < dataWidth; u++) {
			  FP16 hf;

			  hf.u = linePtr[u];

			  if (isBigEndian) {
				swap2(reinterpret_cast<unsigned short *>(&hf.u));
			  }

			  outLine[u] = hf.u;
			}
		  } else if (exrImage->requested_pixel_types[c] ==
					 TINYEXR_PIXELTYPE_FLOAT) {
			float *outLine = reinterpret_cast<float *>(exrImage->images[c]);
			if (lineOrder == 0) {
			  outLine += y * dataWidth;
			} else {
			  outLine += (dataHeight - 1 - y) * dataWidth;
			}

			for (int u = 0; u < dataWidth; u++) {
			  FP16 hf;

			  hf.u = linePtr[u];

			  if (isBigEndian) {
				swap2(reinterpret_cast<unsigned short *>(&hf.u));
			  }

			  FP32 f32 = half_to_float(hf);

			  outLine[u] = f32.f;
			}
		  } else {
			assert(0);
		  }
		} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_FLOAT) {

		  const float *linePtr = reinterpret_cast<const float *>(
			  dataPtr + 8 + c * dataWidth * sizeof(float));

		  float *outLine = reinterpret_cast<float *>(exrImage->images[c]);
		  if (lineOrder == 0) {
			outLine += y * dataWidth;
		  } else {
			outLine += (dataHeight - 1 - y) * dataWidth;
		  }

		  for (int u = 0; u < dataWidth; u++) {
			float val = linePtr[u];

			if (isBigEndian) {
			  swap4(reinterpret_cast<unsigned int *>(&val));
			}

			outLine[u] = val;
		  }
		} else if (channels[c].pixelType == TINYEXR_PIXELTYPE_UINT) {

		  const unsigned int *linePtr = reinterpret_cast<const unsigned int *>(
			  dataPtr + 8 + c * dataWidth * sizeof(unsigned int));

		  unsigned int *outLine =
			  reinterpret_cast<unsigned int *>(exrImage->images[c]);
		  if (lineOrder == 0) {
			outLine += y * dataWidth;
		  } else {
			outLine += (dataHeight - 1 - y) * dataWidth;
		  }

		  for (int u = 0; u < dataWidth; u++) {
			unsigned int val = linePtr[u];

			if (isBigEndian) {
			  swap4(reinterpret_cast<unsigned int *>(&val));
			}

			outLine[u] = val;
		  }
		}
	  }
	}
  } // omp parallel

  {
	exrImage->channel_names =
		(const char **)malloc(sizeof(const char *) * numChannels);
	for (int c = 0; c < numChannels; c++) {
#ifdef _WIN32
	  exrImage->channel_names[c] = _strdup(channels[c].name.c_str());
#else
	  exrImage->channel_names[c] = strdup(channels[c].name.c_str());
#endif
	}
	exrImage->num_channels = numChannels;

	exrImage->width = dataWidth;
	exrImage->height = dataHeight;

	// Fill with requested_pixel_types.
	exrImage->pixel_types = (int *)malloc(sizeof(int *) * numChannels);
	for (int c = 0; c < numChannels; c++) {
	  exrImage->pixel_types[c] = exrImage->requested_pixel_types[c];
	}
  }

  return 0; // OK
}

// @deprecated
#if 0
int SaveEXR(const float *in_rgba, int width, int height, const char *filename,
			const char **err) {
  if (in_rgba == NULL || filename == NULL) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  FILE *fp = fopen(filename, "wb");
  if (!fp) {
	if (err) {
	  (*err) = "Cannot write a file.";
	}
	return -1;
  }

  // Header
  {
	const char header[] = {0x76, 0x2f, 0x31, 0x01};
	size_t n = fwrite(header, 1, 4, fp);
	assert(n == 4);
  }

  // Version, scanline.
  {
	const char marker[] = {2, 0, 0, 0};
	size_t n = fwrite(marker, 1, 4, fp);
	assert(n == 4);
  }

  int numScanlineBlocks = 16; // 16 for ZIP compression.

  // Write attributes.
  {
	unsigned char data[] = {
		'A', 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0,   0,   'B',
		0,   1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,   'G', 0,
		1,   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 'R', 0,   1,
		0,   0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0}; // last 0 =
														   // terminator.

	WriteAttribute(fp, "channels", "chlist", data, 18 * 4 + 1); // +1 = null
  }

  {
	int compressionType = 3; // ZIP compression
	WriteAttribute(fp, "compression", "compression",
				   reinterpret_cast<const unsigned char *>(&compressionType),
				   1);
  }

  {
	int data[4] = {0, 0, width - 1, height - 1};
	WriteAttribute(fp, "dataWindow", "box2i",
				   reinterpret_cast<const unsigned char *>(data),
				   sizeof(int) * 4);
	WriteAttribute(fp, "displayWindow", "box2i",
				   reinterpret_cast<const unsigned char *>(data),
				   sizeof(int) * 4);
  }

  {
	unsigned char lineOrder = 0; // increasingY
	WriteAttribute(fp, "lineOrder", "lineOrder", &lineOrder, 1);
  }

  {
	float aspectRatio = 1.0f;
	WriteAttribute(fp, "pixelAspectRatio", "float",
				   reinterpret_cast<const unsigned char *>(&aspectRatio),
				   sizeof(float));
  }

  {
	float center[2] = {0.0f, 0.0f};
	WriteAttribute(fp, "screenWindowCenter", "v2f",
				   reinterpret_cast<const unsigned char *>(center),
				   2 * sizeof(float));
  }

  {
	float w = (float)width;
	WriteAttribute(fp, "screenWindowWidth", "float",
				   reinterpret_cast<const unsigned char *>(&w), sizeof(float));
  }

  { // end of header
	unsigned char e = 0;
	fwrite(&e, 1, 1, fp);
  }

  int numBlocks = height / numScanlineBlocks;
  if (numBlocks * numScanlineBlocks < height) {
	numBlocks++;
  }

  std::vector<long long> offsets(numBlocks);

  size_t headerSize = ftell(fp); // sizeof(header)
  long long offset =
	  headerSize +
	  numBlocks * sizeof(long long); // sizeof(header) + sizeof(offsetTable)

  std::vector<unsigned char> data;

  for (int i = 0; i < numBlocks; i++) {
	int startY = numScanlineBlocks * i;
	int endY = (std::min)(numScanlineBlocks * (i + 1), height);
	int h = endY - startY;

	std::vector<unsigned short> buf(4 * width * h);

	for (int y = 0; y < h; y++) {
	  for (int x = 0; x < width; x++) {
		FP32 r, g, b, a;
		r.f = in_rgba[4 * ((y + startY) * width + x) + 0];
		g.f = in_rgba[4 * ((y + startY) * width + x) + 1];
		b.f = in_rgba[4 * ((y + startY) * width + x) + 2];
		a.f = in_rgba[4 * ((y + startY) * width + x) + 3];

		FP16 hr, hg, hb, ha;
		hr = float_to_half_full(r);
		hg = float_to_half_full(g);
		hb = float_to_half_full(b);
		ha = float_to_half_full(a);

		// Assume increasing Y
		buf[4 * y * width + 3 * width + x] = hr.u;
		buf[4 * y * width + 2 * width + x] = hg.u;
		buf[4 * y * width + 1 * width + x] = hb.u;
		buf[4 * y * width + 0 * width + x] = ha.u;
	  }
	}

	int bound = miniz::mz_compressBound(buf.size() * sizeof(unsigned short));

	std::vector<unsigned char> block(
		miniz::mz_compressBound(buf.size() * sizeof(unsigned short)));
	unsigned long long outSize = block.size();

	CompressZip(&block.at(0), outSize,
				reinterpret_cast<const unsigned char *>(&buf.at(0)),
				buf.size() * sizeof(unsigned short));

	// 4 byte: scan line
	// 4 byte: data size
	// ~     : pixel data(compressed)
	std::vector<unsigned char> header(8);
	unsigned int dataLen = outSize; // truncate
	memcpy(&header.at(0), &startY, sizeof(int));
	memcpy(&header.at(4), &dataLen, sizeof(unsigned int));

	data.insert(data.end(), header.begin(), header.end());
	data.insert(data.end(), block.begin(), block.begin() + dataLen);

	offsets[i] = offset;
	offset += dataLen + 8; // 8 = sizeof(blockHeader)
  }

  fwrite(&offsets.at(0), 1, sizeof(unsigned long long) * numBlocks, fp);

  fwrite(&data.at(0), 1, data.size(), fp);

  fclose(fp);

  return 0; // OK
}
#endif

size_t SaveMultiChannelEXRToMemory(const EXRImage *exrImage,
								   unsigned char **memory_out,
								   const char **err) {
  if (exrImage == NULL || memory_out == NULL || exrImage->compression < 0 ||
	  exrImage->compression > TINYEXR_COMPRESSIONTYPE_PIZ) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return 0;
  }

  std::vector<unsigned char> memory;

  // Header
  {
	const char header[] = {0x76, 0x2f, 0x31, 0x01};
	memory.insert(memory.end(), header, header + 4);
  }

  // Version, scanline.
  {
	const char marker[] = {2, 0, 0, 0};
	memory.insert(memory.end(), marker, marker + 4);
  }

  int numScanlines = 1;
  if (exrImage->compression == TINYEXR_COMPRESSIONTYPE_ZIP) {
	numScanlines = 16;
  } else if (exrImage->compression == TINYEXR_COMPRESSIONTYPE_PIZ) {
	numScanlines = 32;
  }

  // Write attributes.
  std::vector<ChannelInfo> channels;
  {
	std::vector<unsigned char> data;

	for (int c = 0; c < exrImage->num_channels; c++) {
	  ChannelInfo info;
	  info.pLinear = 0;
	  info.pixelType = exrImage->requested_pixel_types[c];
	  info.xSampling = 1;
	  info.ySampling = 1;
	  info.name = std::string(exrImage->channel_names[c]);
	  channels.push_back(info);
	}

	WriteChannelInfo(data, channels);

	WriteAttributeToMemory(memory, "channels", "chlist", &data.at(0),
						   data.size()); // +1 = null
  }

  {
	int comp = exrImage->compression;
	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&comp));
	}
	WriteAttributeToMemory(memory, "compression", "compression",
						   reinterpret_cast<const unsigned char *>(&comp), 1);
  }

  {
	int data[4] = {0, 0, exrImage->width - 1, exrImage->height - 1};
	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&data[0]));
	  swap4(reinterpret_cast<unsigned int *>(&data[1]));
	  swap4(reinterpret_cast<unsigned int *>(&data[2]));
	  swap4(reinterpret_cast<unsigned int *>(&data[3]));
	}
	WriteAttributeToMemory(memory, "dataWindow", "box2i",
						   reinterpret_cast<const unsigned char *>(data),
						   sizeof(int) * 4);
	WriteAttributeToMemory(memory, "displayWindow", "box2i",
						   reinterpret_cast<const unsigned char *>(data),
						   sizeof(int) * 4);
  }

  {
	unsigned char lineOrder = 0; // increasingY
	WriteAttributeToMemory(memory, "lineOrder", "lineOrder", &lineOrder, 1);
  }

  {
	float aspectRatio = 1.0f;
	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&aspectRatio));
	}
	WriteAttributeToMemory(
		memory, "pixelAspectRatio", "float",
		reinterpret_cast<const unsigned char *>(&aspectRatio), sizeof(float));
  }

  {
	float center[2] = {0.0f, 0.0f};
	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&center[0]));
	  swap4(reinterpret_cast<unsigned int *>(&center[1]));
	}
	WriteAttributeToMemory(memory, "screenWindowCenter", "v2f",
						   reinterpret_cast<const unsigned char *>(center),
						   2 * sizeof(float));
  }

  {
	float w = (float)exrImage->width;
	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&w));
	}
	WriteAttributeToMemory(memory, "screenWindowWidth", "float",
						   reinterpret_cast<const unsigned char *>(&w),
						   sizeof(float));
  }

  // Custom attributes
  if (exrImage->num_custom_attributes > 0) {
	// @todo { endian }
	for (int i = 0; i < exrImage->num_custom_attributes; i++) {
	  WriteAttributeToMemory(memory, exrImage->custom_attributes[i].name,
							 exrImage->custom_attributes[i].type,
							 reinterpret_cast<const unsigned char *>(
								 &exrImage->custom_attributes[i].value),
							 exrImage->custom_attributes[i].size);
	}
  }

  { // end of header
	unsigned char e = 0;
	memory.push_back(e);
  }

  int numBlocks = exrImage->height / numScanlines;
  if (numBlocks * numScanlines < exrImage->height) {
	numBlocks++;
  }

  std::vector<long long> offsets(numBlocks);

  size_t headerSize = memory.size();
  long long offset =
	  headerSize +
	  numBlocks * sizeof(long long); // sizeof(header) + sizeof(offsetTable)

  std::vector<unsigned char> data;

  bool isBigEndian = IsBigEndian();

  std::vector<std::vector<unsigned char> > dataList(numBlocks);
  std::vector<size_t> channelOffsetList(exrImage->num_channels);

  int pixelDataSize = 0;
  size_t channelOffset = 0;
  for (int c = 0; c < exrImage->num_channels; c++) {
	channelOffsetList[c] = channelOffset;
	if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
	  pixelDataSize += sizeof(unsigned short);
	  channelOffset += sizeof(unsigned short);
	} else if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {
	  pixelDataSize += sizeof(float);
	  channelOffset += sizeof(float);
	} else if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {
	  pixelDataSize += sizeof(unsigned int);
	  channelOffset += sizeof(unsigned int);
	} else {
	  assert(0);
	}
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for (int i = 0; i < numBlocks; i++) {
	int startY = numScanlines * i;
	int endY = (std::min)(numScanlines * (i + 1), exrImage->height);
	int h = endY - startY;

	std::vector<unsigned char> buf(exrImage->width * h * pixelDataSize);

	for (int c = 0; c < exrImage->num_channels; c++) {
	  if (exrImage->pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {

		if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {
		  for (int y = 0; y < h; y++) {
			for (int x = 0; x < exrImage->width; x++) {
			  FP16 h16;
			  h16.u = reinterpret_cast<unsigned short **>(
				  exrImage->images)[c][(y + startY) * exrImage->width + x];

			  FP32 f32 = half_to_float(h16);

			  if (isBigEndian) {
				swap4(reinterpret_cast<unsigned int *>(&f32.f));
			  }

			  // Assume increasing Y
			  float *linePtr = reinterpret_cast<float *>(
				  &buf.at(pixelDataSize * y * exrImage->width +
						  channelOffsetList[c] * exrImage->width));
			  linePtr[x] = f32.f;
			}
		  }
		} else if (exrImage->requested_pixel_types[c] ==
				   TINYEXR_PIXELTYPE_HALF) {
		  for (int y = 0; y < h; y++) {
			for (int x = 0; x < exrImage->width; x++) {
			  unsigned short val = reinterpret_cast<unsigned short **>(
				  exrImage->images)[c][(y + startY) * exrImage->width + x];

			  if (isBigEndian) {
				swap2(&val);
			  }

			  // Assume increasing Y
			  unsigned short *linePtr = reinterpret_cast<unsigned short *>(
				  &buf.at(pixelDataSize * y * exrImage->width +
						  channelOffsetList[c] * exrImage->width));
			  linePtr[x] = val;
			}
		  }
		} else {
		  assert(0);
		}

	  } else if (exrImage->pixel_types[c] == TINYEXR_PIXELTYPE_FLOAT) {

		if (exrImage->requested_pixel_types[c] == TINYEXR_PIXELTYPE_HALF) {
		  for (int y = 0; y < h; y++) {
			for (int x = 0; x < exrImage->width; x++) {
			  FP32 f32;
			  f32.f = reinterpret_cast<float **>(
				  exrImage->images)[c][(y + startY) * exrImage->width + x];

			  FP16 h16;
			  h16 = float_to_half_full(f32);

			  if (isBigEndian) {
				swap2(reinterpret_cast<unsigned short *>(&h16.u));
			  }

			  // Assume increasing Y
			  unsigned short *linePtr = reinterpret_cast<unsigned short *>(
				  &buf.at(pixelDataSize * y * exrImage->width +
						  channelOffsetList[c] * exrImage->width));
			  linePtr[x] = h16.u;
			}
		  }
		} else if (exrImage->requested_pixel_types[c] ==
				   TINYEXR_PIXELTYPE_FLOAT) {
		  for (int y = 0; y < h; y++) {
			for (int x = 0; x < exrImage->width; x++) {
			  float val = reinterpret_cast<float **>(
				  exrImage->images)[c][(y + startY) * exrImage->width + x];

			  if (isBigEndian) {
				swap4(reinterpret_cast<unsigned int *>(&val));
			  }

			  // Assume increasing Y
			  float *linePtr = reinterpret_cast<float *>(
				  &buf.at(pixelDataSize * y * exrImage->width +
						  channelOffsetList[c] * exrImage->width));
			  linePtr[x] = val;
			}
		  }
		} else {
		  assert(0);
		}
	  } else if (exrImage->pixel_types[c] == TINYEXR_PIXELTYPE_UINT) {

		for (int y = 0; y < h; y++) {
		  for (int x = 0; x < exrImage->width; x++) {
			unsigned int val = reinterpret_cast<unsigned int **>(
				exrImage->images)[c][(y + startY) * exrImage->width + x];

			if (isBigEndian) {
			  swap4(&val);
			}

			// Assume increasing Y
			unsigned int *linePtr = reinterpret_cast<unsigned int *>(
				&buf.at(pixelDataSize * y * exrImage->width +
						channelOffsetList[c] * exrImage->width));
			linePtr[x] = val;
		  }
		}
	  }
	}

	if (exrImage->compression == TINYEXR_COMPRESSIONTYPE_NONE) {

	  // 4 byte: scan line
	  // 4 byte: data size
	  // ~     : pixel data(uncompressed)
	  std::vector<unsigned char> header(8);
	  unsigned int dataLen = (unsigned int)buf.size();
	  memcpy(&header.at(0), &startY, sizeof(int));
	  memcpy(&header.at(4), &dataLen, sizeof(unsigned int));

	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&header.at(0)));
		swap4(reinterpret_cast<unsigned int *>(&header.at(4)));
	  }

	  dataList[i].insert(dataList[i].end(), header.begin(), header.end());
	  dataList[i].insert(dataList[i].end(), buf.begin(), buf.begin() + dataLen);

	} else if ((exrImage->compression == TINYEXR_COMPRESSIONTYPE_ZIPS) ||
			   (exrImage->compression == TINYEXR_COMPRESSIONTYPE_ZIP)) {

	  std::vector<unsigned char> block(miniz::mz_compressBound(buf.size()));
	  unsigned long long outSize = block.size();

	  CompressZip(&block.at(0), outSize,
				  reinterpret_cast<const unsigned char *>(&buf.at(0)),
				  buf.size());

	  // 4 byte: scan line
	  // 4 byte: data size
	  // ~     : pixel data(compressed)
	  std::vector<unsigned char> header(8);
	  unsigned int dataLen = outSize; // truncate
	  memcpy(&header.at(0), &startY, sizeof(int));
	  memcpy(&header.at(4), &dataLen, sizeof(unsigned int));

	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&header.at(0)));
		swap4(reinterpret_cast<unsigned int *>(&header.at(4)));
	  }

	  dataList[i].insert(dataList[i].end(), header.begin(), header.end());
	  dataList[i].insert(dataList[i].end(), block.begin(),
						 block.begin() + dataLen);

	} else if (exrImage->compression == TINYEXR_COMPRESSIONTYPE_PIZ) {
	  unsigned int bufLen =
		  1024 +
		  1.2 * (unsigned int)buf.size(); // @fixme { compute good bound. }
	  std::vector<unsigned char> block(bufLen);
	  unsigned int outSize = static_cast<unsigned int>(block.size());

	  CompressPiz(&block.at(0), outSize,
				  reinterpret_cast<const unsigned char *>(&buf.at(0)),
				  buf.size(), channels, exrImage->width, h);

	  // 4 byte: scan line
	  // 4 byte: data size
	  // ~     : pixel data(compressed)
	  std::vector<unsigned char> header(8);
	  unsigned int dataLen = outSize;
	  memcpy(&header.at(0), &startY, sizeof(int));
	  memcpy(&header.at(4), &dataLen, sizeof(unsigned int));

	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&header.at(0)));
		swap4(reinterpret_cast<unsigned int *>(&header.at(4)));
	  }

	  dataList[i].insert(dataList[i].end(), header.begin(), header.end());
	  dataList[i].insert(dataList[i].end(), block.begin(),
						 block.begin() + dataLen);

	} else {
	  assert(0);
	}

  } // omp parallel

  for (int i = 0; i < numBlocks; i++) {

	data.insert(data.end(), dataList[i].begin(), dataList[i].end());

	offsets[i] = offset;
	if (IsBigEndian()) {
	  swap8(reinterpret_cast<unsigned long long *>(&offsets[i]));
	}
	offset += dataList[i].size();
  }

  {
	memory.insert(memory.end(),
				  reinterpret_cast<unsigned char *>(&offsets.at(0)),
				  reinterpret_cast<unsigned char *>(&offsets.at(0)) +
					  sizeof(unsigned long long) * numBlocks);
  }

  { memory.insert(memory.end(), data.begin(), data.end()); }

  assert(memory.size() > 0);

  (*memory_out) = (unsigned char *)malloc(memory.size());
  memcpy((*memory_out), &memory.at(0), memory.size());

  return memory.size(); // OK
}

int SaveMultiChannelEXRToFile(const EXRImage *exrImage, const char *filename,
							  const char **err) {
  if (exrImage == NULL || filename == NULL || exrImage->compression < 0 ||
	  exrImage->compression > TINYEXR_COMPRESSIONTYPE_PIZ) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  FILE *fp = fopen(filename, "wb");
  if (!fp) {
	if (err) {
	  (*err) = "Cannot write a file.";
	}
	return -1;
  }

  unsigned char *mem = NULL;
  size_t mem_size = SaveMultiChannelEXRToMemory(exrImage, &mem, err);

  if ((mem_size > 0) && mem) {

	fwrite(mem, 1, mem_size, fp);
  }
  free(mem);

  fclose(fp);

  return 0; // OK
}

int LoadDeepEXR(DeepImage *deepImage, const char *filename, const char **err) {
  if (deepImage == NULL) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  FILE *fp = fopen(filename, "rb");
  if (!fp) {
	if (err) {
	  (*err) = "Cannot read file.";
	}
	return -1;
  }

  size_t filesize;
  // Compute size
  fseek(fp, 0, SEEK_END);
  filesize = ftell(fp);
  fseek(fp, 0, SEEK_SET);

  if (filesize == 0) {
	fclose(fp);
	if (err) {
	  (*err) = "File size is zero.";
	}
	return -1;
  }

  std::vector<char> buf(filesize); // @todo { use mmap }
  {
	size_t ret;
	ret = fread(&buf[0], 1, filesize, fp);
	assert(ret == filesize);
	(void)ret;
  }
  fclose(fp);

  const char *head = &buf[0];
  const char *marker = &buf[0];

  // Header check.
  {
	const char header[] = {0x76, 0x2f, 0x31, 0x01};

	if (memcmp(marker, header, 4) != 0) {
	  if (err) {
		(*err) = "Header mismatch.";
	  }
	  return -3;
	}
	marker += 4;
  }

  // Version, scanline.
  {
	// ver 2.0, scanline, deep bit on(0x800)
	// must be [2, 0, 0, 0]
	if (marker[0] != 2 || marker[1] != 8 || marker[2] != 0 || marker[3] != 0) {
	  if (err) {
		(*err) = "Unsupported version or scanline.";
	  }
	  return -4;
	}

	marker += 4;
  }

  int dx = -1;
  int dy = -1;
  int dw = -1;
  int dh = -1;
  int numScanlineBlocks = 1; // 16 for ZIP compression.
  int compressionType = -1;
  int numChannels = -1;
  std::vector<ChannelInfo> channels;

  // Read attributes
  for (;;) {
	std::string attrName;
	std::string attrType;
	std::vector<unsigned char> data;
	const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
	if (marker_next == NULL) {
	  marker++; // skip '\0'
	  break;
	}

	if (attrName.compare("compression") == 0) {
	  // must be 0:No compression, 1: RLE, 2: ZIPs or 3: ZIP
	  if (data[0] > 3) {
		if (err) {
		  (*err) = "Unsupported compression type.";
		}
		return -5;
	  }

	  compressionType = data[0];

	  if (compressionType == 3) { // ZIP
		numScanlineBlocks = 16;
	  }

	} else if (attrName.compare("channels") == 0) {

	  // name: zero-terminated string, from 1 to 255 bytes long
	  // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
	  // pLinear: unsigned char, possible values are 0 and 1
	  // reserved: three chars, should be zero
	  // xSampling: int
	  // ySampling: int

	  ReadChannelInfo(channels, data);

	  numChannels = channels.size();

	  if (numChannels < 1) {
		if (err) {
		  (*err) = "Invalid channels format.";
		}
		return -6;
	  }

	} else if (attrName.compare("dataWindow") == 0) {
	  memcpy(&dx, &data.at(0), sizeof(int));
	  memcpy(&dy, &data.at(4), sizeof(int));
	  memcpy(&dw, &data.at(8), sizeof(int));
	  memcpy(&dh, &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&dx));
		swap4(reinterpret_cast<unsigned int *>(&dy));
		swap4(reinterpret_cast<unsigned int *>(&dw));
		swap4(reinterpret_cast<unsigned int *>(&dh));
	  }

	} else if (attrName.compare("displayWindow") == 0) {
	  int x;
	  int y;
	  int w;
	  int h;
	  memcpy(&x, &data.at(0), sizeof(int));
	  memcpy(&y, &data.at(4), sizeof(int));
	  memcpy(&w, &data.at(8), sizeof(int));
	  memcpy(&h, &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&x));
		swap4(reinterpret_cast<unsigned int *>(&y));
		swap4(reinterpret_cast<unsigned int *>(&w));
		swap4(reinterpret_cast<unsigned int *>(&h));
	  }
	}

	marker = marker_next;
  }

  assert(dx >= 0);
  assert(dy >= 0);
  assert(dw >= 0);
  assert(dh >= 0);
  assert(numChannels >= 1);

  int dataWidth = dw - dx + 1;
  int dataHeight = dh - dy + 1;

  std::vector<float> image(dataWidth * dataHeight * 4); // 4 = RGBA

  // Read offset tables.
  int numBlocks = dataHeight / numScanlineBlocks;
  if (numBlocks * numScanlineBlocks < dataHeight) {
	numBlocks++;
  }

  std::vector<long long> offsets(numBlocks);

  for (int y = 0; y < numBlocks; y++) {
	long long offset;
	memcpy(&offset, marker, sizeof(long long));
	if (IsBigEndian()) {
	  swap8(reinterpret_cast<unsigned long long *>(&offset));
	}
	marker += sizeof(long long); // = 8
	offsets[y] = offset;
  }

  if (compressionType != 0 && compressionType != 2 && compressionType != 3) {
	if (err) {
	  (*err) = "Unsupported format.";
	}
	return -10;
  }

  deepImage->image = (float ***)malloc(sizeof(float **) * numChannels);
  for (int c = 0; c < numChannels; c++) {
	deepImage->image[c] = (float **)malloc(sizeof(float *) * dataHeight);
	for (int y = 0; y < dataHeight; y++) {
	}
  }

  deepImage->offset_table = (int **)malloc(sizeof(int *) * dataHeight);
  for (int y = 0; y < dataHeight; y++) {
	deepImage->offset_table[y] = (int *)malloc(sizeof(int) * dataWidth);
  }

  for (int y = 0; y < numBlocks; y++) {
	const unsigned char *dataPtr =
		reinterpret_cast<const unsigned char *>(head + offsets[y]);

	// int: y coordinate
	// int64: packed size of pixel offset table
	// int64: packed size of sample data
	// int64: unpacked size of sample data
	// compressed pixel offset table
	// compressed sample data
	int lineNo;
	long long packedOffsetTableSize;
	long long packedSampleDataSize;
	long long unpackedSampleDataSize;
	memcpy(&lineNo, dataPtr, sizeof(int));
	memcpy(&packedOffsetTableSize, dataPtr + 4, sizeof(long long));
	memcpy(&packedSampleDataSize, dataPtr + 12, sizeof(long long));
	memcpy(&unpackedSampleDataSize, dataPtr + 20, sizeof(long long));

	if (IsBigEndian()) {
	  swap4(reinterpret_cast<unsigned int *>(&lineNo));
	  swap8(reinterpret_cast<unsigned long long *>(&packedOffsetTableSize));
	  swap8(reinterpret_cast<unsigned long long *>(&packedSampleDataSize));
	  swap8(reinterpret_cast<unsigned long long *>(&unpackedSampleDataSize));
	}

	std::vector<int> pixelOffsetTable(dataWidth);

	// decode pixel offset table.
	{
	  unsigned long dstLen = pixelOffsetTable.size() * sizeof(int);
	  DecompressZip(reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),
					dstLen, dataPtr + 28, packedOffsetTableSize);

	  assert(dstLen == pixelOffsetTable.size() * sizeof(int));
	  for (int i = 0; i < dataWidth; i++) {
		deepImage->offset_table[y][i] = pixelOffsetTable[i];
	  }
	}

	std::vector<unsigned char> sampleData(unpackedSampleDataSize);

	// decode sample data.
	{
	  unsigned long dstLen = unpackedSampleDataSize;
	  DecompressZip(reinterpret_cast<unsigned char *>(&sampleData.at(0)),
					dstLen, dataPtr + 28 + packedOffsetTableSize,
					packedSampleDataSize);
	  assert(dstLen == (unsigned long)unpackedSampleDataSize);
	}

	// decode sample
	int sampleSize = -1;
	std::vector<int> channelOffsetList(numChannels);
	{
	  int channelOffset = 0;
	  for (int i = 0; i < numChannels; i++) {
		channelOffsetList[i] = channelOffset;
		if (channels[i].pixelType == TINYEXR_PIXELTYPE_UINT) { // UINT
		  channelOffset += 4;
		} else if (channels[i].pixelType == TINYEXR_PIXELTYPE_HALF) { // half
		  channelOffset += 2;
		} else if (channels[i].pixelType == TINYEXR_PIXELTYPE_FLOAT) { // float
		  channelOffset += 4;
		} else {
		  assert(0);
		}
	  }
	  sampleSize = channelOffset;
	}
	assert(sampleSize >= 2);

	assert((size_t)(pixelOffsetTable[dataWidth - 1] * sampleSize) ==
		   sampleData.size());
	int samplesPerLine = sampleData.size() / sampleSize;

	//
	// Alloc memory
	//

	//
	// pixel data is stored as image[channels][pixel_samples]
	//
	{
	  unsigned long long dataOffset = 0;
	  for (int c = 0; c < numChannels; c++) {

		deepImage->image[c][y] =
			(float *)malloc(sizeof(float) * samplesPerLine);

		if (channels[c].pixelType == 0) { // UINT
		  for (int x = 0; x < samplesPerLine; x++) {
			unsigned int ui = *reinterpret_cast<unsigned int *>(
								  &sampleData.at(dataOffset + x * sizeof(int)));
			deepImage->image[c][y][x] = (float)ui; // @fixme
		  }
		  dataOffset += sizeof(unsigned int) * samplesPerLine;
		} else if (channels[c].pixelType == 1) { // half
		  for (int x = 0; x < samplesPerLine; x++) {
			FP16 f16;
			f16.u = *reinterpret_cast<unsigned short *>(
						&sampleData.at(dataOffset + x * sizeof(short)));
			FP32 f32 = half_to_float(f16);
			deepImage->image[c][y][x] = f32.f;
		  }
		  dataOffset += sizeof(short) * samplesPerLine;
		} else { // float
		  for (int x = 0; x < samplesPerLine; x++) {
			float f = *reinterpret_cast<float *>(
						  &sampleData.at(dataOffset + x * sizeof(float)));
			deepImage->image[c][y][x] = f;
		  }
		  dataOffset += sizeof(float) * samplesPerLine;
		}
	  }
	}

  } // y

  deepImage->width = dataWidth;
  deepImage->height = dataHeight;

  deepImage->channel_names =
	  (const char **)malloc(sizeof(const char *) * numChannels);
  for (int c = 0; c < numChannels; c++) {
#ifdef _WIN32
	deepImage->channel_names[c] = _strdup(channels[c].name.c_str());
#else
	deepImage->channel_names[c] = strdup(channels[c].name.c_str());
#endif
  }
  deepImage->num_channels = numChannels;

  return 0; // OK
}

int SaveDeepEXR(const DeepImage *deepImage, const char *filename,
				const char **err) {
  if (deepImage == NULL || filename == NULL) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  FILE *fp = fopen(filename, "rb");
  if (!fp) {
	if (err) {
	  (*err) = "Cannot write file.";
	}
	return -1;
  }

  // Write header check.
  {
	const char header[] = {0x76, 0x2f, 0x31, 0x01};
	size_t n = fwrite(header, 1, 4, fp);
	if (n != 4) {
	  if (err) {
		(*err) = "Header write failed.";
	  }
	  fclose(fp);
	  return -3;
	}
  }

  // Version, scanline.
  {
	// ver 2.0, scanline, deep bit on(0x800)
	const char data[] = {2, 8, 0, 0};
	size_t n = fwrite(data, 1, 4, fp);
	if (n != 4) {
	  if (err) {
		(*err) = "Flag write failed.";
	  }
	  fclose(fp);
	  return -3;
	}
  }

  // Write attributes.
  {
	int data = 2; // ZIPS
	WriteAttribute(fp, "compression", "compression",
				   reinterpret_cast<const unsigned char *>(&data), sizeof(int));
  }

  {
	int data[4] = {0, 0, deepImage->width - 1, deepImage->height - 1};
	WriteAttribute(fp, "dataWindow", "box2i",
				   reinterpret_cast<const unsigned char *>(data),
				   sizeof(int) * 4);
	WriteAttribute(fp, "displayWindow", "box2i",
				   reinterpret_cast<const unsigned char *>(data),
				   sizeof(int) * 4);
  }

  int numScanlineBlocks = 1;
  // Write offset tables.
  int numBlocks = deepImage->height / numScanlineBlocks;
  if (numBlocks * numScanlineBlocks < deepImage->height) {
	numBlocks++;
  }

#if 0 // @todo
  std::vector<long long> offsets(numBlocks);

  //std::vector<int> pixelOffsetTable(dataWidth);

  // compress pixel offset table.
  {
	  unsigned long dstLen = pixelOffsetTable.size() * sizeof(int);
	  Compresses(reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),
					dstLen, dataPtr + 28, packedOffsetTableSize);

	  assert(dstLen == pixelOffsetTable.size() * sizeof(int));
	  //      int ret =
	  //          miniz::mz_uncompress(reinterpret_cast<unsigned char
	  //          *>(&pixelOffsetTable.at(0)), &dstLen, dataPtr + 28,
	  //          packedOffsetTableSize);
	  //      printf("ret = %d, dstLen = %d\n", ret, (int)dstLen);
	  //
	  for (int i = 0; i < dataWidth; i++) {
		// printf("offt[%d] = %d\n", i, pixelOffsetTable[i]);
		deepImage->offset_table[y][i] = pixelOffsetTable[i];
	  }
	}

  for (int y = 0; y < numBlocks; y++) {
	//long long offset = *(reinterpret_cast<const long long *>(marker));
	// printf("offset[%d] = %lld\n", y, offset);
	//marker += sizeof(long long); // = 8
	offsets[y] = offset;
  }

  // Write offset table.
  fwrite(&offsets.at(0), sizeof(long long), numBlocks, fp);

  for (int y = 0; y < numBlocks; y++) {
	const unsigned char *dataPtr =
		reinterpret_cast<const unsigned char *>(head + offsets[y]);

	// int: y coordinate
	// int64: packed size of pixel offset table
	// int64: packed size of sample data
	// int64: unpacked size of sample data
	// compressed pixel offset table
	// compressed sample data
	int lineNo = *reinterpret_cast<const int *>(dataPtr);
	long long packedOffsetTableSize =
		*reinterpret_cast<const long long *>(dataPtr + 4);
	long long packedSampleDataSize =
		*reinterpret_cast<const long long *>(dataPtr + 12);
	long long unpackedSampleDataSize =
		*reinterpret_cast<const long long *>(dataPtr + 20);
	// printf("line: %d, %lld/%lld/%lld\n", lineNo, packedOffsetTableSize,
	// packedSampleDataSize, unpackedSampleDataSize);

	int endLineNo = (std::min)(lineNo + numScanlineBlocks, dataHeight);

	int numLines = endLineNo - lineNo;
	// printf("numLines: %d\n", numLines);

	std::vector<int> pixelOffsetTable(dataWidth);

	// decode pixel offset table.
	{
	  unsigned long dstLen = pixelOffsetTable.size() * sizeof(int);
	  DecompressZip(reinterpret_cast<unsigned char *>(&pixelOffsetTable.at(0)),
					dstLen, dataPtr + 28, packedOffsetTableSize);

	  assert(dstLen == pixelOffsetTable.size() * sizeof(int));
	  //      int ret =
	  //          miniz::mz_uncompress(reinterpret_cast<unsigned char
	  //          *>(&pixelOffsetTable.at(0)), &dstLen, dataPtr + 28,
	  //          packedOffsetTableSize);
	  //      printf("ret = %d, dstLen = %d\n", ret, (int)dstLen);
	  //
	  for (int i = 0; i < dataWidth; i++) {
		// printf("offt[%d] = %d\n", i, pixelOffsetTable[i]);
		deepImage->offset_table[y][i] = pixelOffsetTable[i];
	  }
	}

	std::vector<unsigned char> sampleData(unpackedSampleDataSize);

	// decode sample data.
	{
	  unsigned long dstLen = unpackedSampleDataSize;
	  // printf("dstLen = %d\n", dstLen);
	  // printf("srcLen = %d\n", packedSampleDataSize);
	  DecompressZip(reinterpret_cast<unsigned char *>(&sampleData.at(0)),
					dstLen, dataPtr + 28 + packedOffsetTableSize,
					packedSampleDataSize);
	  assert(dstLen == unpackedSampleDataSize);
	}

	// decode sample
	int sampleSize = -1;
	std::vector<int> channelOffsetList(numChannels);
	{
	  int channelOffset = 0;
	  for (int i = 0; i < numChannels; i++) {
		// printf("offt[%d] = %d\n", i, channelOffset);
		channelOffsetList[i] = channelOffset;
		if (channels[i].pixelType == 0) { // UINT
		  channelOffset += 4;
		} else if (channels[i].pixelType == 1) { // half
		  channelOffset += 2;
		} else if (channels[i].pixelType == 2) { // float
		  channelOffset += 4;
		} else {
		  assert(0);
		}
	  }
	  sampleSize = channelOffset;
	}
	assert(sampleSize >= 2);

	assert(pixelOffsetTable[dataWidth - 1] * sampleSize == sampleData.size());
	int samplesPerLine = sampleData.size() / sampleSize;

	//
	// Alloc memory
	//

	//
	// pixel data is stored as image[channels][pixel_samples]
	//
	{
	  unsigned long long dataOffset = 0;
	  for (int c = 0; c < numChannels; c++) {

		deepImage->image[c][y] =
			(float *)malloc(sizeof(float) * samplesPerLine);

		// unsigned int channelOffset = channelOffsetList[c];
		// unsigned int i = channelOffset;
		// printf("channel = %d. name = %s. ty = %d\n", c,
		// channels[c].name.c_str(), channels[c].pixelType);

		// printf("dataOffset = %d\n", (int)dataOffset);

		if (channels[c].pixelType == 0) { // UINT
		  for (int x = 0; x < samplesPerLine; x++) {
			unsigned int ui = *reinterpret_cast<unsigned int *>(
								  &sampleData.at(dataOffset + x * sizeof(int)));
			deepImage->image[c][y][x] = (float)ui; // @fixme
		  }
		  dataOffset += sizeof(unsigned int) * samplesPerLine;
		} else if (channels[c].pixelType == 1) { // half
		  for (int x = 0; x < samplesPerLine; x++) {
			FP16 f16;
			f16.u = *reinterpret_cast<unsigned short *>(
						&sampleData.at(dataOffset + x * sizeof(short)));
			FP32 f32 = half_to_float(f16);
			deepImage->image[c][y][x] = f32.f;
			// printf("c[%d]  f(half) = %f (0x%08x)\n", c, f32.f, f16.u);
		  }
		  dataOffset += sizeof(short) * samplesPerLine;
		} else { // float
		  for (int x = 0; x < samplesPerLine; x++) {
			float f = *reinterpret_cast<float *>(
						  &sampleData.at(dataOffset + x * sizeof(float)));
			// printf("  f = %f(0x%08x)\n", f, *((unsigned int *)&f));
			deepImage->image[c][y][x] = f;
		  }
		  dataOffset += sizeof(float) * samplesPerLine;
		}
	  }
	  // printf("total: %d\n", dataOffset);
	}

  } // y
#endif
  fclose(fp);

  return 0; // OK
}

void InitEXRImage(EXRImage *exrImage) {
  if (exrImage == NULL) {
	return;
  }

  exrImage->num_custom_attributes = 0;
  exrImage->num_channels = 0;
  exrImage->channel_names = NULL;
  exrImage->images = NULL;
  exrImage->pixel_types = NULL;
  exrImage->requested_pixel_types = NULL;
  exrImage->compression = TINYEXR_COMPRESSIONTYPE_ZIP;
}

int FreeEXRImage(EXRImage *exrImage) {

  if (exrImage == NULL) {
	return -1; // Err
  }

  for (int i = 0; i < exrImage->num_channels; i++) {

	if (exrImage->channel_names && exrImage->channel_names[i]) {
	  free((char *)exrImage->channel_names[i]); // remove const
	}

	if (exrImage->images && exrImage->images[i]) {
	  free(exrImage->images[i]);
	}
  }

  if (exrImage->channel_names) {
	free(exrImage->channel_names);
  }

  if (exrImage->images) {
	free(exrImage->images);
  }

  if (exrImage->pixel_types) {
	free(exrImage->pixel_types);
  }

  if (exrImage->requested_pixel_types) {
	free(exrImage->requested_pixel_types);
  }

  for (int i = 0; i < exrImage->num_custom_attributes; i++) {
	if (exrImage->custom_attributes[i].name) {
	  free(exrImage->custom_attributes[i].name);
	}
	if (exrImage->custom_attributes[i].type) {
	  free(exrImage->custom_attributes[i].type);
	}
	if (exrImage->custom_attributes[i].value) {
	  free(exrImage->custom_attributes[i].value);
	}
  }

  return 0;
}

int ParseMultiChannelEXRHeaderFromFile(EXRImage *exrImage, const char *filename,
									   const char **err) {
  if (exrImage == NULL) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  FILE *fp = fopen(filename, "rb");
  if (!fp) {
	if (err) {
	  (*err) = "Cannot read file.";
	}
	return -1;
  }

  size_t filesize;
  // Compute size
  fseek(fp, 0, SEEK_END);
  filesize = ftell(fp);
  fseek(fp, 0, SEEK_SET);

  std::vector<unsigned char> buf(filesize); // @todo { use mmap }
  {
	size_t ret;
	ret = fread(&buf[0], 1, filesize, fp);
	assert(ret == filesize);
	fclose(fp);
	(void)ret;
  }

  return ParseMultiChannelEXRHeaderFromMemory(exrImage, &buf.at(0), err);
}

int ParseMultiChannelEXRHeaderFromMemory(EXRImage *exrImage,
										 const unsigned char *memory,
										 const char **err) {
  if (exrImage == NULL || memory == NULL) {
	if (err) {
	  (*err) = "Invalid argument.";
	}
	return -1;
  }

  const char *buf = reinterpret_cast<const char *>(memory);

  const char *marker = &buf[0];

  // Header check.
  {
	const char header[] = {0x76, 0x2f, 0x31, 0x01};

	if (memcmp(marker, header, 4) != 0) {
	  if (err) {
		(*err) = "Header mismatch.";
	  }
	  return -3;
	}
	marker += 4;
  }

  // Version, scanline.
  {
	// must be [2, 0, 0, 0]
	if (marker[0] != 2 || marker[1] != 0 || marker[2] != 0 || marker[3] != 0) {
	  if (err) {
		(*err) = "Unsupported version or scanline.";
	  }
	  return -4;
	}

	marker += 4;
  }

  int dx = -1;
  int dy = -1;
  int dw = -1;
  int dh = -1;
  int numChannels = -1;
  int displayWindow[4] = {-1, -1, -1, -1};    // @fixme.
  float screenWindowCenter[2] = {0.0f, 0.0f}; // @fixme
  float screenWindowWidth = 1.0f;             // @fixme
  float pixelAspectRatio = 1.0f;
  unsigned char lineOrder = 0; // 0 -> increasing y; 1 -> decreasing
  std::vector<ChannelInfo> channels;
  int compressionType = 0; // @fixme

  int numCustomAttributes = 0;
  std::vector<EXRAttribute> customAttribs;

  // Read attributes
  for (;;) {
	std::string attrName;
	std::string attrType;
	std::vector<unsigned char> data;
	const char *marker_next = ReadAttribute(attrName, attrType, data, marker);
	if (marker_next == NULL) {
	  marker++; // skip '\0'
	  break;
	}

	if (attrName.compare("compression") == 0) {
	  // must be 0:No compression, 1: RLE, 2: ZIPs, 3: ZIP or 4: PIZ
	  if (data[0] > TINYEXR_COMPRESSIONTYPE_PIZ) {
		if (err) {
		  (*err) = "Unsupported compression type.";
		}
		return -5;
	  }

	  compressionType = data[0];

	} else if (attrName.compare("channels") == 0) {

	  // name: zero-terminated string, from 1 to 255 bytes long
	  // pixel type: int, possible values are: UINT = 0 HALF = 1 FLOAT = 2
	  // pLinear: unsigned char, possible values are 0 and 1
	  // reserved: three chars, should be zero
	  // xSampling: int
	  // ySampling: int

	  ReadChannelInfo(channels, data);

	  numChannels = channels.size();

	  if (numChannels < 1) {
		if (err) {
		  (*err) = "Invalid channels format.";
		}
		return -6;
	  }

	} else if (attrName.compare("dataWindow") == 0) {
	  memcpy(&dx, &data.at(0), sizeof(int));
	  memcpy(&dy, &data.at(4), sizeof(int));
	  memcpy(&dw, &data.at(8), sizeof(int));
	  memcpy(&dh, &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&dx));
		swap4(reinterpret_cast<unsigned int *>(&dy));
		swap4(reinterpret_cast<unsigned int *>(&dw));
		swap4(reinterpret_cast<unsigned int *>(&dh));
	  }
	} else if (attrName.compare("displayWindow") == 0) {
	  memcpy(&displayWindow[0], &data.at(0), sizeof(int));
	  memcpy(&displayWindow[1], &data.at(4), sizeof(int));
	  memcpy(&displayWindow[2], &data.at(8), sizeof(int));
	  memcpy(&displayWindow[3], &data.at(12), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[0]));
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[1]));
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[2]));
		swap4(reinterpret_cast<unsigned int *>(&displayWindow[3]));
	  }
	} else if (attrName.compare("lineOrder") == 0) {
	  int order;
	  memcpy(&order, &data.at(0), sizeof(int));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&order));
	  }
	  lineOrder = (unsigned char)order;
	} else if (attrName.compare("pixelAspectRatio") == 0) {
	  memcpy(&pixelAspectRatio, &data.at(0), sizeof(float));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&pixelAspectRatio));
	  }
	} else if (attrName.compare("screenWindowCenter") == 0) {
	  memcpy(&screenWindowCenter[0], &data.at(0), sizeof(float));
	  memcpy(&screenWindowCenter[1], &data.at(4), sizeof(float));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[0]));
		swap4(reinterpret_cast<unsigned int *>(&screenWindowCenter[1]));
	  }
	} else if (attrName.compare("screenWindowWidth") == 0) {
	  memcpy(&screenWindowWidth, &data.at(0), sizeof(float));
	  if (IsBigEndian()) {
		swap4(reinterpret_cast<unsigned int *>(&screenWindowWidth));
	  }
	} else {
	  // Custom attribute(up to TINYEXR_MAX_ATTRIBUTES)
	  if (numCustomAttributes < TINYEXR_MAX_ATTRIBUTES) {
		EXRAttribute attrib;
		attrib.name = strdup(attrName.c_str());
		attrib.type = strdup(attrType.c_str());
		attrib.size = data.size();
		attrib.value = (unsigned char *)malloc(data.size());
		memcpy((char *)attrib.value, &data.at(0), data.size());
		customAttribs.push_back(attrib);
	  }
	}

	marker = marker_next;
  }

  assert(dx >= 0);
  assert(dy >= 0);
  assert(dw >= 0);
  assert(dh >= 0);
  assert(numChannels >= 1);

  int dataWidth = dw - dx + 1;
  int dataHeight = dh - dy + 1;

  {
	exrImage->channel_names =
		(const char **)malloc(sizeof(const char *) * numChannels);
	for (int c = 0; c < numChannels; c++) {
#ifdef _WIN32
	  exrImage->channel_names[c] = _strdup(channels[c].name.c_str());
#else
	  exrImage->channel_names[c] = strdup(channels[c].name.c_str());
#endif
	}
	exrImage->num_channels = numChannels;

	exrImage->width = dataWidth;
	exrImage->height = dataHeight;
	exrImage->pixel_aspect_ratio = pixelAspectRatio;
	exrImage->screen_window_center[0] = screenWindowCenter[0];
	exrImage->screen_window_center[1] = screenWindowCenter[1];
	exrImage->screen_window_width = screenWindowWidth;
	exrImage->display_window[0] = displayWindow[0];
	exrImage->display_window[1] = displayWindow[1];
	exrImage->display_window[2] = displayWindow[2];
	exrImage->display_window[3] = displayWindow[3];
	exrImage->data_window[0] = dx;
	exrImage->data_window[1] = dy;
	exrImage->data_window[2] = dw;
	exrImage->data_window[3] = dh;
	exrImage->line_order = lineOrder;
	exrImage->compression = compressionType;

	exrImage->pixel_types = (int *)malloc(sizeof(int) * numChannels);
	for (int c = 0; c < numChannels; c++) {
	  exrImage->pixel_types[c] = channels[c].pixelType;
	}

	// Initially fill with values of `pixel-types`
	exrImage->requested_pixel_types = (int *)malloc(sizeof(int) * numChannels);
	for (int c = 0; c < numChannels; c++) {
	  exrImage->requested_pixel_types[c] = channels[c].pixelType;
	}
  }

  if (numCustomAttributes > 0) {
	assert(customAttribs.size() < TINYEXR_MAX_ATTRIBUTES);
	exrImage->num_custom_attributes = numCustomAttributes;

	for (int i = 0; i < (int)customAttribs.size(); i++) {
	  exrImage->custom_attributes[i] = customAttribs[i];
	}
  }

  return 0; // OK
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif

#endif // __TINYEXR_H__



//#line 1 "flif_dec.h"
#ifndef FLIF_INTERFACE_DEC_H
#define FLIF_INTERFACE_DEC_H

/*
FLIF - Free Lossless Image Format

Copyright 2010-2016, Jon Sneyers & Pieter Wuille

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


//#line 1 "flif_common.h"
#ifndef FLIF_INTERFACE_COMMON_H
#define FLIF_INTERFACE_COMMON_H

/*
FLIF - Free Lossless Image Format

Copyright 2010-2016, Jon Sneyers & Pieter Wuille

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <stdint.h>
#include <stddef.h>

#ifdef _MSC_VER
#define FLIF_API __cdecl
 #ifdef FLIF_BUILD_DLL
  #define FLIF_DLLIMPORT __declspec(dllexport)
 #elif FLIF_USE_DLL
  #define FLIF_DLLIMPORT __declspec(dllimport)
 #endif
#else
#define FLIF_API
#endif

#ifndef FLIF_DLLIMPORT
#define FLIF_DLLIMPORT
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

	typedef struct FLIF_IMAGE FLIF_IMAGE;

	FLIF_DLLIMPORT FLIF_IMAGE* FLIF_API flif_create_image(uint32_t width, uint32_t height);
	FLIF_DLLIMPORT void FLIF_API flif_destroy_image(FLIF_IMAGE* image);

	FLIF_DLLIMPORT uint32_t FLIF_API flif_image_get_width(FLIF_IMAGE* image);
	FLIF_DLLIMPORT uint32_t FLIF_API flif_image_get_height(FLIF_IMAGE* image);
	FLIF_DLLIMPORT uint8_t  FLIF_API flif_image_get_nb_channels(FLIF_IMAGE* image);
	FLIF_DLLIMPORT uint32_t FLIF_API flif_image_get_frame_delay(FLIF_IMAGE* image);

	FLIF_DLLIMPORT void FLIF_API flif_image_write_row_RGBA8(FLIF_IMAGE* image, uint32_t row, const void* buffer, size_t buffer_size_bytes);
	FLIF_DLLIMPORT void FLIF_API flif_image_read_row_RGBA8(FLIF_IMAGE* image, uint32_t row, void* buffer, size_t buffer_size_bytes);

	FLIF_DLLIMPORT void FLIF_API flif_free_memory(void* buffer);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // FLIF_INTERFACE_COMMON_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

	typedef struct FLIF_DECODER FLIF_DECODER;

	FLIF_DLLIMPORT FLIF_DECODER* FLIF_API flif_create_decoder();
	FLIF_DLLIMPORT int32_t FLIF_API flif_abort_decoder(FLIF_DECODER* decoder);
	FLIF_DLLIMPORT void FLIF_API flif_destroy_decoder(FLIF_DECODER* decoder);

	FLIF_DLLIMPORT void FLIF_API flif_decoder_set_quality(FLIF_DECODER* decoder, int32_t quality); // valid quality: 0-100
	FLIF_DLLIMPORT void FLIF_API flif_decoder_set_scale(FLIF_DECODER* decoder, uint32_t scale); // valid scales: 1,2,4,8,16,...
	FLIF_DLLIMPORT void FLIF_API flif_decoder_set_resize(FLIF_DECODER* decoder, uint32_t width, uint32_t height);
	FLIF_DLLIMPORT void FLIF_API flif_decoder_set_callback(FLIF_DECODER* decoder, uint32_t (*callback)(int32_t quality, int64_t bytes_read));
	FLIF_DLLIMPORT void FLIF_API flif_decoder_set_first_callback_quality(FLIF_DECODER* decoder, int32_t quality); // valid quality: 0-10000

	FLIF_DLLIMPORT int32_t FLIF_API flif_decoder_decode_file(FLIF_DECODER* decoder, const char* filename);
	FLIF_DLLIMPORT int32_t FLIF_API flif_decoder_decode_memory(FLIF_DECODER* decoder, const void* buffer, size_t buffer_size_bytes);
	FLIF_DLLIMPORT size_t FLIF_API flif_decoder_num_images(FLIF_DECODER* decoder);
	FLIF_DLLIMPORT int32_t FLIF_API flif_decoder_num_loops(FLIF_DECODER* decoder);
	FLIF_DLLIMPORT FLIF_IMAGE* FLIF_API flif_decoder_get_image(FLIF_DECODER* decoder, size_t index);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // FLIF_INTERFACE_DEC_H


//#line 1 "io.cpp"
#include <stdio.h>
#include <stdarg.h>


//#line 1 "io.hpp"
#ifndef FLIF_IO_HPP
#define FLIF_IO_HPP

void e_printf(const char *format, ...);
void v_printf(const int v, const char *format, ...);

void increase_verbosity(int how_much=1);
int get_verbosity();

template<class IO>
bool ioget_int_8bit (IO& io, int* result)
{
	int c = io.getc();
	if (c == io.EOS) {
		e_printf ("Unexpected EOS");
		return false;
	}

	*result = c;
	return true;
}

template<class IO>
bool ioget_int_16bit_bigendian (IO& io, int* result)
{
	int c1;
	int c2;
	if (!(ioget_int_8bit (io, &c1) &&
		  ioget_int_8bit (io, &c2)))
		return false;

	*result = (c1 << 8) + c2;
	return true;
}

#endif

void e_printf(const char *format, ...) {
	va_list args;
	va_start(args, format);
	vfprintf(stderr, format, args);
	fflush(stderr);
	va_end(args);
}

static int verbosity = 1;
void increase_verbosity(int how_much) {
	verbosity += how_much;
}

int get_verbosity() {
	return verbosity;
}

void v_printf(const int v, const char *format, ...) {
	if (verbosity < v) return;
	va_list args;
	va_start(args, format);
	vfprintf(stdout, format, args);
	fflush(stdout);
	va_end(args);
}


//#line 1 "bit.cpp"
#ifdef _MSC_VER

#include <intrin.h>
int __builtin_clz(unsigned int value)
{
	unsigned long r;
	_BitScanReverse(&r, value);
	return (31 - r);
}

#endif


//#line 1 "chance.cpp"
#include <string.h>
#include <stdint.h>


//#line 1 "chance.hpp"
#ifndef FLIF_CHANCE_HPP
#define FLIF_CHANCE_HPP

#include <vector>
#include <math.h>
#include <stdint.h>
#include <string>
#include <sstream>

struct Log4kTable {
	uint16_t data[4097];
	int scale;

	Log4kTable();
};

extern const Log4kTable log4k;

void extern build_table(uint16_t *zero_state, uint16_t *one_state, size_t size, uint32_t factor, unsigned int max_p);

class SimpleBitChanceTable
{
public:
	uint16_t next[2][4096]; // stored as 12-bit numbers
	uint32_t alpha;

	void init(int cut, int alpha_) {
		alpha = alpha_;
		build_table(next[0], next[1], 4096, alpha_, 4096-cut);
	}

	SimpleBitChanceTable(int cut = 2, int alpha = 0xFFFFFFFF / 19) {
		init(cut, alpha);
	}
};

#ifdef STATS
struct BitChanceStats
{
	double weight;
	double sum;
	double factor;

	BitChanceStats() : weight(0), sum(0), factor(1.0) {}

	void add(bool bit, unsigned int alpha) {
		weight += factor;
		if (bit) {
			sum += factor;
		}
		factor *= (1.0 - alpha / 4294967296.0);
	}

	BitChanceStats& operator+=(const BitChanceStats& stats) {
		weight += stats.weight;
		sum += stats.sum;
		return *this;
	}

	std::string format() const {
		std::stringstream ss;
		ss << sum << ',' << weight;
		return ss.str();
	}
};
#endif

class SimpleBitChance
{
protected:
	uint16_t chance; // stored as a 12-bit number
#ifdef STATS
	BitChanceStats stats_;
#endif

public:
	typedef SimpleBitChanceTable Table;

	SimpleBitChance() {
		chance = 0x800;
	}

	uint16_t inline get_12bit() const {
		return chance;
	}
	void set_12bit(uint16_t chance) {
		this->chance = chance;
	}
	void inline put(bool bit, const Table &table) {
#ifdef STATS
		stats_.add(bit, table.alpha);
#endif
		chance = table.next[bit][chance];
	}

	void estim(bool bit, uint64_t &total) const {
		total += log4k.data[bit ? chance : 4096-chance];
	}

	int scale() const {
		return log4k.scale;
	}

#ifdef STATS
	const BitChanceStats& stats() const {
		return stats_;
	}
#endif
};

#ifndef FAST_BUT_WORSE_COMPRESSION

static const uint32_t MULTISCALE_ALPHAS[] = {
													 21590903, 66728412, 214748365, 7413105, 106514140, 10478104,
													 //41729744, 5081644, 154536134, 53610361, 14808157, 83024800,
													 //31468986, 3483142, 8675949, 6333940,128332124,12654046,75606698,47300557,203951463,58885392,35675766,94047111,3071053,4623799,17881424,26067561,9534590,5584795,8146883,6960985,11514860,116922432,71030141,50357314,180327910,62685268,88366071,3950501,245135590,33506680,140836325,4924204,15769017,23724167,37984644,5244115,5947593,44428377,19649020,100089021,9239337,29554783,80475310,8407260,57072137,13475351,7183492,3169265,2794299,164387337,7650051,4341711,109877739,48805148,285518438,22990693,120609957,223623543,3709472,136540575,64675496,4771639,16792101,26898887,25261851,10153668,34574286,40442237,6536419,91162830,20923221,6137730,78003381,55314351,191784837,68845961,73283013,32471914,103252233,60755844,149830100,45842100,51958541,85654236,36812186,43058031,19041256,2623791,332276342,97021591,113346113,10812893,30496923,5411776,174853162,260577854,14349874,132373756,2975884,4480536,124412038,28641651,3594527,11882728,3375207,185970177,216869333,6745365,4207184,39194272,7894563,230582101,145264850,5763342,22279836,2707704,3828091,159387120,410190395,9839267,197776890,8953217,2883663,13905751,11158365,3270616,169541181,12262333,303407934,276959225,210313815,24480974,4076824,27756639,585189062,13058253,363764189,15281050,2542478,18452249,237750805,20276138,16272536,294332358,252742534,2130583863,462185550,268647915,17328222,386315419,352964365,312752266,2313344,874357947,505177649,342471031,435457062,374878495,322372603,2463684,1348207122,696492758,535880669,2172176,398083245,476120461,1061088123,638637072,1903342123,759025196,2039621,422645434,2241650,551873246,2387331,448634113,977298116,490448053,1690401179,1181956121,2038126651,716804021,620344619,803443341,520318678,676701158,568306117,924600596,1493527858,1816328538,1120194691,1004588004,2104856,850135566,1279659514,1947720708,602531930,657419257,737644875,1976407,899176673,1649701506,1090312381,1383509600,780954783,826500455,950638308,1032515596,1992655788,1246411823,1570275450,1419498079,2084110791,1150740857,1859538985,1213845117,1915153,1773726365,1456171521,1313590710,1609656898,1531563934,1731746439
											};

template<int N, typename BitChance> class MultiscaleBitChanceTable {
public:
	typedef typename BitChance::Table SubTable;
	SubTable subTable[N];

	MultiscaleBitChanceTable(int cut = 8) {
		for (int i= 0; i<N; i++) {
			subTable[i].init(cut, MULTISCALE_ALPHAS[i]);
		}
	}
};

template<int N, typename BitChance> class MultiscaleBitChance
{
protected:
	BitChance chances[N];
	uint32_t quality[N];
	uint8_t best;
#ifdef STATS
	BitChanceStats stats_;
#endif

public:
	typedef MultiscaleBitChanceTable<N,BitChance> Table;

	MultiscaleBitChance() {
		set_12bit(0x800);
	}

	void set_12bit(uint16_t chanceIn) {
		for (int i = 0; i<N; i++) {
			chances[i].set(chanceIn);
			quality[i] = 0;
		}
		best = 0;
	}

	uint16_t get_12bit() const {
		return chances[best].get();
	}

	void put(bool bit, const Table &table) {
#ifdef STATS
		stats_.add(bit, table.subTable[best].alpha);
#endif
		for (int i=0; i<N; i++) { // for each scale
			uint64_t sbits = 0;
			chances[i].estim(bit, sbits); // number of bits if this scale was used
			uint64_t oqual=quality[i]; // previous estimate of bits used for this scale
// update quality estimate -- gradually forget the past
//            quality[i] = (oqual*4095 + sbits*65537+2048)/4096; // update bits estimate (([0-2**32-1]*4095+[0..2**16-1]*65537+2048)/4096 = [0..2**32-1])
//            quality[i] = (oqual*2047 + sbits*32769+1024)/2048;
//            quality[i] = (oqual*511 + sbits*8193 + 256)>>9;
			quality[i] = (oqual*255 + sbits*4097 + 128)>>8;
//            quality[i] = (oqual*127 + sbits*2049 + 64)>>7;
//            if (quality[i] < quality[best]) best=i;
			chances[i].put(bit, table.subTable[i]);
		}

		for (int i=0; i<N; i++) if (quality[i] < quality[best]) best=i;
	}

	void estim(bool bit, uint64_t &total) const {
		chances[best].estim(bit, total);
	}

	int scale() const {
		return chances[0].scale();
	}

#ifdef STATS
	const BitChanceStats& stats() const {
		return stats_;
	}
#endif
};

#endif

#endif


//#line 1 "bit.hpp"
#ifndef FLIF_BIT_HPP
#define FLIF_BIT_HPP

#ifdef _MSC_VER

int __builtin_clz(unsigned int value);

#endif

#endif

void build_table(uint16_t *zero_state, uint16_t *one_state, size_t size, uint32_t factor, unsigned int max_p)
{
	const int64_t one = 1LL << 32;
	int64_t p;
	unsigned int last_p8, p8;
	unsigned int i;

	memset(zero_state,0,sizeof(uint16_t) * size);
	memset(one_state,0,sizeof(uint16_t) * size);

	last_p8 = 0;
	p = one / 2;
	for (i = 0; i < size / 2; i++) {
		p8 = (size * p + one / 2) >> 32; //FIXME try without the one
		if (p8 <= last_p8) p8 = last_p8 + 1;
		if (last_p8 && last_p8 < size && p8 <= max_p) one_state[last_p8] = p8;

		p += ((one - p) * factor + one / 2) >> 32;
		last_p8 = p8;
	}

	for (i = size - max_p; i <= max_p; i++) {
		if (one_state[i]) continue;

		p = (i * one + size / 2) / size;
		p += ((one - p) * factor + one / 2) >> 32;
		p8 = (size * p + one / 2) >> 32; //FIXME try without the one
		if (p8 <= i) p8 = i + 1;
		if (p8 > max_p) p8 = max_p;
		one_state[i] = p8;
	}

	for (i = 1; i < size; i++)
		zero_state[i] = size - one_state[size - i];
}

/** Computes an approximation of log(4096 / x) / log(2) * base */
static uint32_t log4kf(int x, uint32_t base) {
	int bits = 8 * sizeof(int) - __builtin_clz(x);
	uint64_t y = ((uint64_t)x) << (32 - bits);
	uint32_t res = base * (13 - bits);
	uint32_t add = base;
	while ((add > 1) && ((y & 0x7FFFFFFF) != 0)) {
		y = (((uint64_t)y) * y + 0x40000000) >> 31;
		add >>= 1;
		if ((y >> 32) != 0) {
			res -= add;
			y >>= 1;
		}
	}
	return res;
}

Log4kTable::Log4kTable() {
	data[0] = 0;
	for (int i = 1; i <= 4096; i++) {
		data[i] = (log4kf(i, (65535UL << 16) / 12) + (1 << 15)) >> 16;
	}
	scale = 65535 / 12;
}

const Log4kTable log4k;


//#line 1 "flif-interface_dec.cpp"

//#line 1 "flif-interface-private_dec.hpp"
#ifndef FLIF_INTERFACE_PRIVATE_DEC_HPP
#define FLIF_INTERFACE_PRIVATE_DEC_HPP


//#line 1 "flif-interface-private_common.hpp"
#ifndef FLIF_INTERFACE_PRIVATE_COMMON_HPP
#define FLIF_INTERFACE_PRIVATE_COMMON_HPP


//#line 1 "image.hpp"
#ifndef FLIF_IMAGE_IMAGE_HPP
#define FLIF_IMAGE_IMAGE_HPP

#include <vector>
#include <assert.h>
#include <stdint.h>
#include <valarray>
#include <memory>

//#line 1 "crc32k.hpp"
#ifndef FLIF_IMAGE_CRC32K_HPP
#define FLIF_IMAGE_CRC32K_HPP

#include <stdint.h>

struct CRC32KTable {
	CRC32KTable();
	uint_fast32_t tab[256];
};

extern const CRC32KTable crc32k;

inline void crc32k_transform(uint_fast32_t& crc, const uint8_t byte) {
  crc = ((crc) << 8) ^ crc32k.tab[(((crc) >> 24) ^ (byte)) & 0xFF];
}

#endif



//#line 1 "config.h"
#ifndef FLIF_CONFIG_H
#define FLIF_CONFIG_H

/*****************************************/
/* OPTIONS TO DISABLE SOME FUNCTIONALITY */
/*****************************************/

// define this flag if you want support for > 8 bit per channel
#define SUPPORT_HDR 1

// include encoder related functionality in build. Disable when only interested in decoder
#ifndef DECODER_ONLY
#define HAS_ENCODER  1
#endif

// during decode, check for unexpected file end and interpolate from there
#define CHECK_FOR_BROKENFILES 1

/*************************************************/
/* OPTIONS TO CHANGE DEFAULT ENCODING PARAMETERS */
/*************************************************/

// more repeats makes encoding more expensive, but results in better trees (smaller files)
#define TREE_LEARN_REPEATS 3

// 5 byte improvement needed before splitting a MANIAC leaf node
#define CONTEXT_TREE_SPLIT_THRESHOLD 5461*8*5

#define CONTEXT_TREE_COUNT_DIV 30
#define CONTEXT_TREE_MIN_SUBTREE_SIZE 50

/**************************************************/
/* DANGER ZONE: OPTIONS THAT CHANGE THE BITSTREAM */
/* If you modify these, the bitstream format      */
/* changes, so it is no longer compatible!        */
/**************************************************/

// output the first K zoomlevels without building trees (too little data anyway to learn much from it)
#define NB_NOLEARN_ZOOMS 12
// this is enough to get a reasonable thumbnail/icon before the tree gets built/transmitted (at most 64x64 pixels)

// faster decoding, less compression (disable multi-scale bitchances, use 24-bit rac)
#define FAST_BUT_WORSE_COMPRESSION 1

// bounds for node counters
#define CONTEXT_TREE_MIN_COUNT 1
#define CONTEXT_TREE_MAX_COUNT 512

#endif


//#line 1 "compiler-specific.hpp"
#ifndef FLIF_COMPILER_SPECIFIC_HPP
#define FLIF_COMPILER_SPECIFIC_HPP

#ifdef _MSC_VER
#define ATTRIBUTE_HOT
#else
#define ATTRIBUTE_HOT __attribute__ ((hot))
#endif

#endif

typedef int32_t ColorVal;  // used in computations

typedef uint8_t ColorVal_intern_8;
typedef uint16_t ColorVal_intern_16u;
typedef int16_t ColorVal_intern_16;
typedef int32_t ColorVal_intern_32;

// It's a part of C++14. Following impl was taken from GotW#102
// (http://herbsutter.com/gotw/_102/).
// It should go into some common header one day.
template <typename T, typename... Args>
std::unique_ptr<T> make_unique(Args &&... args)
{
	return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

class GeneralPlane {
public:
	virtual void set(const uint32_t r, const uint32_t c, const ColorVal x) =0;
	virtual ColorVal get(const uint32_t r, const uint32_t c) const =0;
	virtual bool is_constant() const { return false; }
	virtual ~GeneralPlane() { }
};

template <typename pixel_t> class Plane final : public GeneralPlane {
	std::valarray<pixel_t> data;
	const uint32_t width, height;
public:
	Plane(uint32_t w, uint32_t h, ColorVal color=0) : data(color, w*h), width(w), height(h) { }
	void clear() {
		data.clear();
	}
	void set(const uint32_t r, const uint32_t c, const ColorVal x) {
		assert(r<height); assert(c<width);
		data[r*width + c] = x;
	}
	ColorVal get(const uint32_t r, const uint32_t c) const ATTRIBUTE_HOT {
//        if (r >= height || r < 0 || c >= width || c < 0) {printf("OUT OF RANGE!\n"); return 0;}
		assert(r<height); assert(c<width);
		return data[r*width + c];
	}
};

class ConstantPlane final : public GeneralPlane {
	ColorVal color;
public:
	ConstantPlane(ColorVal c) : color(c) {}
	void set(const uint32_t r, const uint32_t c, const ColorVal x) {
		assert(x == color);
	}
	ColorVal get(const uint32_t r, const uint32_t c) const {
		return color;
	}
	bool is_constant() const { return true; }
};

#define SCALED(x) (((x-1)>>scale)+1)
class Image {
	std::unique_ptr<GeneralPlane> planes[5];
	uint32_t width, height;
	ColorVal minval,maxval;
	int num;
	int scale;
#ifdef SUPPORT_HDR
	int depth;
#else
	const int depth=8;
#endif

	Image(const Image& other) {
	  // reuse implementation from assignment operator
	  operator=(other);
	}

	Image& operator=(const Image& other) {
	  width = other.width;
	  height = other.height;
	  minval = other.minval;
	  maxval = other.maxval;
	  num = other.num;
	  scale = other.scale;
#ifdef SUPPORT_HDR
	  depth = other.depth;
#endif
	  palette = other.palette;
	  frame_delay = other.frame_delay;
	  col_begin = other.col_begin;
	  col_end = other.col_end;
	  seen_before = other.seen_before;
	  clear();
	  {
	  int p=num;
	  if (depth <= 8) {
		if (p>0) planes[0] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height)); // R,Y
		if (p>1) planes[1] = make_unique<Plane<ColorVal_intern_16>>(SCALED(width), SCALED(height)); // G,I
		if (p>2) planes[2] = make_unique<Plane<ColorVal_intern_16>>(SCALED(width), SCALED(height)); // B,Q
		if (p>3) planes[3] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height)); // A
#ifdef SUPPORT_HDR
	  } else {
		if (p>0) planes[0] = make_unique<Plane<ColorVal_intern_16u>>(SCALED(width), SCALED(height)); // R,Y
		if (p>1) planes[1] = make_unique<Plane<ColorVal_intern_32>>(SCALED(width), SCALED(height)); // G,I
		if (p>2) planes[2] = make_unique<Plane<ColorVal_intern_32>>(SCALED(width), SCALED(height)); // B,Q
		if (p>3) planes[3] = make_unique<Plane<ColorVal_intern_16u>>(SCALED(width), SCALED(height)); // A
#endif
	  }
	  if (p>4) planes[4] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height)); // FRA
	  }
	  for(int p=0; p<num; p++)
		  for (uint32_t r=0; r<height; r++)
			 for (uint32_t c=0; c<width; c++)
				 set(p,r,c,other.operator()(p,r,c));

	  return *this;
	}

public:
	bool palette;
	int frame_delay;
	bool alpha_zero_special;
	std::vector<uint32_t> col_begin;
	std::vector<uint32_t> col_end;
	int seen_before;

	Image(uint32_t width, uint32_t height, ColorVal min, ColorVal max, int planes, int s=0) : scale(s) {
		init(width, height, min, max, planes);
	}

	Image(int s=0) : scale(s) {
	  width = height = 0;
	  minval = maxval = 0;
	  num = 0;
	  frame_delay = 0;
#ifdef SUPPORT_HDR
	  depth = 0;
#endif
	  palette = false;
	  alpha_zero_special = true;
	  seen_before = 0;
	}

	// move constructor
	Image(Image&& other) {
	  // reuse implementation from assignment operator
	  operator=(std::move(other));
	}
	Image& operator=(Image&& other) {
	  width = other.width;
	  height = other.height;
	  minval = other.minval;
	  maxval = other.maxval;
	  num = other.num;
	  scale = other.scale;
	  for (int p=0; p<num; p++) planes[p] = std::move(other.planes[p]);
	  frame_delay = other.frame_delay;
#ifdef SUPPORT_HDR
	  depth = other.depth;
	  other.depth = 0;
#endif

	  other.width = other.height = 0;
	  other.minval = other.maxval = 0;
	  other.num = 0;
	  other.frame_delay = 0;

	  palette = other.palette;
	  alpha_zero_special = other.alpha_zero_special;
	  col_begin = std::move(other.col_begin);
	  col_end = std::move(other.col_end);
	  seen_before = other.seen_before;

	  other.palette = false;
	  other.alpha_zero_special = true;
	  other.seen_before = 0;
	  return *this;
	}

	bool init(uint32_t w, uint32_t h, ColorVal min, ColorVal max, int p) {
	  width = w;
	  height = h;
	  minval = min;
	  maxval = max;
	  col_begin.clear();
	  col_begin.resize(height,0);
	  col_end.clear();
	  col_end.resize(height,width);
	  num = p;
	  seen_before = -1;
#ifdef SUPPORT_HDR
	  if (max < 256) depth=8; else depth=16;
#else
	  assert(max<256);
#endif
	  frame_delay=0;
	  palette=false;
	  alpha_zero_special=true;
	  assert(min == 0);
	  assert(max < (1<<depth));
	  assert(p <= 4);

	  clear();
	  try {
	  if (depth <= 8) {
		if (p>0) planes[0] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height)); // R,Y
		if (p>1) planes[1] = make_unique<Plane<ColorVal_intern_16>>(SCALED(width), SCALED(height)); // G,I
		if (p>2) planes[2] = make_unique<Plane<ColorVal_intern_16>>(SCALED(width), SCALED(height)); // B,Q
		if (p>3) planes[3] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height)); // A
#ifdef SUPPORT_HDR
	  } else {
		if (p>0) planes[0] = make_unique<Plane<ColorVal_intern_16u>>(SCALED(width), SCALED(height)); // R,Y
		if (p>1) planes[1] = make_unique<Plane<ColorVal_intern_32>>(SCALED(width), SCALED(height)); // G,I
		if (p>2) planes[2] = make_unique<Plane<ColorVal_intern_32>>(SCALED(width), SCALED(height)); // B,Q
		if (p>3) planes[3] = make_unique<Plane<ColorVal_intern_16u>>(SCALED(width), SCALED(height)); // A
#endif
	  }
	  if (p>4) planes[4] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height)); // FRA
	  }
	  catch (std::bad_alloc& ba) {
		e_printf("Error: could not allocate enough memory for image data.\n");
		return false;
	  }
	  return true;
	}

	// Copy constructor is private to avoid mistakes.
	// This function can be used if copies are necessary.
	Image clone()
	{
	  return *this;
	}
	void normalize_scale() {
//      v_printf(3,"%ix%i -> ",width,height);
	  width = SCALED(width);
	  height = SCALED(height);
	  scale = 0;
//      v_printf(3,"%ix%i\n",width,height);
	  col_begin.clear();
	  col_begin.resize(height,0);
	  col_end.clear();
	  col_end.resize(height,width);
	}

	void clear() {
		for (int p=0; p<5; p++) planes[p].reset(nullptr);
	}
	void reset() {
		clear();
		init(0,0,0,0,0);
	}
	bool uses_alpha() const {
		assert(depth == 8 || depth == 16);
		if (num<4) return false;
		for (uint32_t r=0; r<height; r++)
		   for (uint32_t c=0; c<width; c++)
			  if (operator()(3,r,c) < (1<<depth)-1) return true;
		return false; // alpha plane is completely opaque, so it is useless
	}
	bool uses_color() const {
		assert(depth == 8 || depth == 16);
		if (num<3) return false;
		for (uint32_t r=0; r<height; r++)
		   for (uint32_t c=0; c<width; c++)
			  if (operator()(0,r,c) != operator()(1,r,c) || operator()(0,r,c) != operator()(2,r,c)) return true;
		return false; // R=G=B for all pixels, so image is grayscale
	}
	void drop_alpha() {
		if (num<4) return;
		assert(num==4);
		planes[3].reset(nullptr);
		num=3;
	}
	void make_invisible_rgb_black() {
		if (num<4) return;
		for (uint32_t r=0; r<height; r++)
		   for (uint32_t c=0; c<width; c++)
			  if (operator()(3,r,c) == 0) {
				set(0,r,c,0);
				set(1,r,c,0);
				set(2,r,c,0);
			  }
	}
	void drop_color() {
		if (num<2) return;
		assert(num==3);
		planes[1].reset(nullptr);
		planes[2].reset(nullptr);
		num=1;
	}
	void drop_frame_lookbacks() {
		assert(num==5);
		planes[4].reset(nullptr);
		num=4;
	}
	void make_constant_plane(const int p, const ColorVal val) {
	  if (p>3 || p<0) return;
	  planes[p].reset(nullptr);
	  planes[p] = make_unique<ConstantPlane>(val);
	}
	void undo_make_constant_plane(const int p) {
	  if (p>3 || p<0) return;
	  if (!planes[p]->is_constant()) return;
	  ColorVal val = operator()(p,0,0);
	  planes[p].reset(nullptr);
	  if (depth <= 8) {
		if (p==0) planes[0] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height), val); // R,Y
		if (p==1) planes[1] = make_unique<Plane<ColorVal_intern_16>>(SCALED(width), SCALED(height), val); // G,I
		if (p==2) planes[2] = make_unique<Plane<ColorVal_intern_16>>(SCALED(width), SCALED(height), val); // B,Q
		if (p==3) planes[3] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height), val); // A
#ifdef SUPPORT_HDR
	  } else {
		if (p==0) planes[0] = make_unique<Plane<ColorVal_intern_16u>>(SCALED(width), SCALED(height), val); // R,Y
		if (p==1) planes[1] = make_unique<Plane<ColorVal_intern_32>>(SCALED(width), SCALED(height), val); // G,I
		if (p==2) planes[2] = make_unique<Plane<ColorVal_intern_32>>(SCALED(width), SCALED(height), val); // B,Q
		if (p==3) planes[3] = make_unique<Plane<ColorVal_intern_16u>>(SCALED(width), SCALED(height), val); // A
#endif
	  }
	}
	void ensure_chroma() {
		switch(num) {
			case 1:
			  make_constant_plane(1,((1<<depth)-1));
			case 2:
			  make_constant_plane(2,((1<<depth)-1));
			  num=3;
			default:
			  assert(num>=3);
		}
	}
	void ensure_alpha() {
		ensure_chroma();
		switch(num) {
			case 3:
			  make_constant_plane(3,255);
			  num=4;
			default:
			  assert(num>=4);
		}
	}
	void ensure_frame_lookbacks() {
		if (num < 5) {
			ensure_alpha();
			planes[4] = make_unique<Plane<ColorVal_intern_8>>(SCALED(width), SCALED(height));
			num=5;
		}
	}

#ifdef HAS_ENCODER
	bool load(const char *name);
#endif
	bool save(const char *name) const;

	// access pixel by coordinate
	ColorVal operator()(const int p, const uint32_t r, const uint32_t c) const ATTRIBUTE_HOT {
	  assert(p>=0);
	  assert(p<num);
	  return planes[p]->get(r>>scale,c>>scale);
	}
	void set(int p, uint32_t r, uint32_t c, ColorVal x) {
	  assert(p>=0);
	  assert(p<num);
	  planes[p]->set(r>>scale,c>>scale,x);
	}

	int numPlanes() const { return num; }
	ColorVal min(int) const { return minval; }
	ColorVal max(int) const { return maxval; }
	uint32_t rows() const { return height; }
	uint32_t cols() const { return width; }

	// access pixel by zoomlevel coordinate
	uint32_t zoom_rowpixelsize(int zoomlevel) const {
		return 1<<((zoomlevel+1)/2);
	}
	uint32_t zoom_colpixelsize(int zoomlevel) const {
		return 1<<((zoomlevel)/2);
	}

	uint32_t rows(int zoomlevel) const {
		return 1+(rows()-1)/zoom_rowpixelsize(zoomlevel);
	}
	uint32_t cols(int zoomlevel) const {
		return 1+(cols()-1)/zoom_colpixelsize(zoomlevel);
	}
	int zooms() const {
		int z = 0;
		while (zoom_rowpixelsize(z) < rows() || zoom_colpixelsize(z) < cols()) z++;
		return z;
	}
	ColorVal operator()(int p, int z, uint32_t rz, uint32_t cz) const ATTRIBUTE_HOT {
		uint32_t r = rz*zoom_rowpixelsize(z);
		uint32_t c = cz*zoom_colpixelsize(z);
		return operator()(p,r,c);
	}
	void set(int p, int z, uint32_t rz, uint32_t cz, ColorVal x) {
		uint32_t r = rz*zoom_rowpixelsize(z);
		uint32_t c = cz*zoom_colpixelsize(z);
		set(p,r,c,x);
	}

	uint32_t checksum() {
		  uint_fast32_t crc=0;
		  crc32k_transform(crc,width & 255);
		  crc32k_transform(crc,width / 256);
		  crc32k_transform(crc,height & 255);
		  crc32k_transform(crc,height / 256);

		  for(int p=0; p<num; p++)
			for (uint32_t r=0; r<height; r++)
			   for (uint32_t c=0; c<width; c++) {
				  ColorVal d = operator()(p,r,c);
				  crc32k_transform(crc, d & 255);
				  crc32k_transform(crc, (d >> 8) & 255);
			   }
//          printf("Computed checksum: %X\n", (~crc & 0xFFFFFFFF));
		  return (~crc & 0xFFFFFFFF);
	}
	void abort_decoding() {
		width = 0; // this is used to signal the decoder to stop
	}

};

typedef std::vector<Image>    Images;

#endif


//#line 1 "fileio.hpp"
#ifndef FLIF_FILEIO_HPP
#define FLIF_FILEIO_HPP

#include <stdio.h>
#include <string.h>

class FileIO
{
private:
	FILE *file;
	const char *name;

	// prevent copy
	FileIO(const FileIO&) {}
	void operator=(const FileIO&) {}
	// prevent move, for now
	FileIO(FileIO&&) {}
	void operator=(FileIO&&) {}
public:
	const int EOS = EOF;

	FileIO(FILE* fil, const char *aname) : file(fil), name(aname) { }
	~FileIO() {
		if (file) fclose(file);
	}
	void flush() {
		fflush(file);
	}
	bool isEOF() {
	  return feof(file);
	}
	long ftell() {
	  return ::ftell(file);
	}
	int getc() {
	  return fgetc(file);
	}
	char * gets(char *buf, int n) {
	  return fgets(buf, n, file);
	}
	int fputs(const char *s) {
	  return ::fputs(s, file);
	}
	int fputc(int c) {
	  return ::fputc(c, file);
	}
	void fseek(long offset, int where) {
	  ::fseek(file, offset,where);
	}
	const char* getName() {
	  return name;
	}
};

/*!
 * Read-only IO interface for a constant memory block
 */
class BlobReader
{
private:
	const uint8_t* data;
	size_t data_array_size;
	size_t seek_pos;
public:
	const int EOS = -1;

	BlobReader(const uint8_t* _data, size_t _data_array_size)
	: data(_data)
	, data_array_size(_data_array_size)
	, seek_pos(0)
	{
	}

	bool isEOF() const {
		return seek_pos >= data_array_size;
	}
	long ftell() const {
		return seek_pos;
	}
	int getc() {
		if(seek_pos >= data_array_size)
			return EOS;
		return data[seek_pos++];
	}
	char * gets(char *buf, int n) {
		int i = 0;
		const int max_write = n-1;
		while(seek_pos < data_array_size && i < max_write)
			buf[i++] = data[seek_pos++];
		buf[n-1] = '\0';

		if(i < max_write)
			return 0;
		else
			return buf;
	}
	int fputc(int c) {
	  // cannot write on const memory
	  return EOS;
	}
	void fseek(long offset, int where) {
		switch(where) {
		case SEEK_SET:
			seek_pos = offset;
			break;
		case SEEK_CUR:
			seek_pos += offset;
			break;
		case SEEK_END:
			seek_pos = long(data_array_size) + offset;
			break;
		}
	}
	static const char* getName() {
		return "BlobReader";
	}
};

/*!
 * IO interface for a growable memory block
 */
class BlobIO
{
private:
	uint8_t* data;
	// keeps track how large the array really is
	// HINT: should only be used in the grow() function
	size_t data_array_size;
	// keeps track how many bytes were written
	size_t bytes_used;
	size_t seek_pos;

	void grow(size_t necessary_size) {
		if(necessary_size < data_array_size)
			return;

		size_t new_size = necessary_size;
		// start with reasonably large array
		if(new_size < 4096)
			new_size = 4096;

		if(new_size < data_array_size * 3 / 2)
			new_size = data_array_size * 3 / 2;
		uint8_t* new_data = new uint8_t[new_size];

		memcpy(new_data, data, bytes_used);
		// if seek_pos has been moved beyond the written bytes,
		// fill the empty space with zeroes
		for(size_t i = bytes_used; i < seek_pos; ++i)
			new_data[i] = 0;
		delete [] data;
		data = new_data;
		std::swap(data_array_size, new_size);
	}
public:
	const int EOS = -1;

	BlobIO()
	: data(0)
	, data_array_size(0)
	, bytes_used(0)
	, seek_pos(0)
	{
	}

	~BlobIO() {
		delete [] data;
	}

	uint8_t* release(size_t* array_size)
	{
		uint8_t* ptr = data;
		*array_size = bytes_used;

		data = 0;
		data_array_size = 0;
		bytes_used = 0;
		seek_pos = 0;
		return ptr;
	}

	static void flush() {
		// nothing to do
	}
	bool isEOF() const {
		return seek_pos >= bytes_used;
	}
	int ftell() const {
		return seek_pos;
	}
	int getc() {
		if(seek_pos >= bytes_used)
			return EOS;
		return data[seek_pos++];
	}
	char * gets(char *buf, int n) {
		int i = 0;
		const int max_write = n-1;
		while(seek_pos < bytes_used && i < max_write)
			buf[i++] = data[seek_pos++];
		buf[n-1] = '\0';

		if(i < max_write)
			return 0;
		else
			return buf;
	}
	int fputs(const char *s) {
		size_t i = 0;
		// null-terminated string
		while(s[i])
		{
			grow(seek_pos + 1);
			data[seek_pos++] = s[i++];
			if(bytes_used < seek_pos)
				bytes_used = seek_pos+1;
		}
		return 0;
	}
	int fputc(int c) {
		grow(seek_pos + 1);

		data[seek_pos++] = static_cast<uint8_t>(c);
		if(bytes_used < seek_pos)
			bytes_used = seek_pos+1;
		return c;
	}
	void fseek(long offset, int where) {
		switch(where) {
		case SEEK_SET:
			seek_pos = offset;
			break;
		case SEEK_CUR:
			seek_pos += offset;
			break;
		case SEEK_END:
			seek_pos = long(bytes_used) + offset;
			break;
		}
	}
	static const char* getName() {
		return "BlobIO";
	}
};

#endif

#ifdef _MSC_VER
 #ifdef FLIF_BUILD_DLL
  #define FLIF_DLLEXPORT __declspec(dllexport)
 #else
  #define FLIF_DLLEXPORT
 #endif
#else
#define FLIF_DLLEXPORT __attribute__ ((visibility ("default")))
#endif

struct FLIF_IMAGE
{
	FLIF_IMAGE();

	void write_row_RGBA8(uint32_t row, const void* buffer, size_t buffer_size_bytes);
	void read_row_RGBA8(uint32_t row, void* buffer, size_t buffer_size_bytes);

	Image image;
};

#endif


//#line 1 "flif-dec.hpp"
#ifndef FLIF_FLIF_DEC_HPP
#define FLIF_FLIF_DEC_HPP

template <typename IO>
bool flif_decode(IO& io, Images &images, int quality, int scale, uint32_t (*callback)(int32_t,int64_t), int, Images &partial_images, int rw=0, int rh=0);

template <typename IO>
bool flif_decode(IO& io, Images &images, int quality = 100, int scale = 1, int rw=0, int rh=0) {return flif_decode(io, images, quality, scale, NULL, 0, images, rw, rh);}

#endif

struct FLIF_DECODER
{
	FLIF_DECODER();

	int32_t decode_file(const char* filename);
	int32_t decode_memory(const void* buffer, size_t buffer_size_bytes);
	int32_t abort();
	size_t num_images();
	int32_t num_loops();
	FLIF_IMAGE* get_image(size_t index);

	int32_t quality;
	uint32_t scale;
	void* callback;
	int32_t first_quality;
	uint32_t rw;
	uint32_t rh;

private:
	Images internal_images;
	Images images;
	std::vector<std::unique_ptr<FLIF_IMAGE>> requested_images;
	bool working;
};

#endif


//#line 1 "flif-interface_common.cpp"
//#pragma once

FLIF_IMAGE::FLIF_IMAGE() { }

#pragma pack(push,1)
struct FLIF_RGBA {
	uint8_t r,g,b,a;
};
#pragma pack(pop)

void FLIF_IMAGE::write_row_RGBA8(uint32_t row, const void* buffer, size_t buffer_size_bytes) {
	if(buffer_size_bytes < image.cols() * sizeof(FLIF_RGBA))
		return;

	const FLIF_RGBA* buffer_rgba = reinterpret_cast<const FLIF_RGBA*>(buffer);

	if(image.numPlanes() >= 3) {
		for (size_t c = 0; c < (size_t) image.cols(); c++) {
			image.set(0, row, c, buffer_rgba[c].r);
			image.set(1, row, c, buffer_rgba[c].g);
			image.set(2, row, c, buffer_rgba[c].b);
		}
	}
	if(image.numPlanes() >= 4) {
		for (size_t c = 0; c < (size_t) image.cols(); c++) {
			image.set(3, row, c, buffer_rgba[c].a);
		}
	}
}

void FLIF_IMAGE::read_row_RGBA8(uint32_t row, void* buffer, size_t buffer_size_bytes) {
	if(buffer_size_bytes < image.cols() * sizeof(FLIF_RGBA))
		return;

	FLIF_RGBA* buffer_rgba = reinterpret_cast<FLIF_RGBA*>(buffer);
	int rshift = 0;
	int lshift = 1;
	ColorVal m=image.max(0);
	while (m > 255) { rshift++; m = m >> 1; } // in case the image has bit depth higher than 8
	while (m * ((1 << lshift)-1) < 255) { lshift++; } // in case the image has bit depth lower than 8

	if(image.numPlanes() >= 3) {
		// color
		for (size_t c = 0; c < (size_t) image.cols(); c++) {
			buffer_rgba[c].r = ((image(0, row, c) >> rshift) * ((1<<lshift)-1)) & 0xFF;
			buffer_rgba[c].g = ((image(1, row, c) >> rshift) * ((1<<lshift)-1)) & 0xFF;
			buffer_rgba[c].b = ((image(2, row, c) >> rshift) * ((1<<lshift)-1)) & 0xFF;
		}
	} else {
		// grayscale
		for (size_t c = 0; c < (size_t) image.cols(); c++) {
			buffer_rgba[c].r =
			buffer_rgba[c].g =
			buffer_rgba[c].b = ((image(0, row, c) >> rshift) * ((1<<lshift)-1)) & 0xFF;
		}
	}
	if(image.numPlanes() >= 4) {
		for (size_t c = 0; c < (size_t) image.cols(); c++) {
			buffer_rgba[c].a = ((image(3, row, c) >> rshift) * ((1<<lshift)-1)) & 0xFF;
		}
	} else {
		for (size_t c = 0; c < (size_t) image.cols(); c++) {
			buffer_rgba[c].a = 0xFF;  // fully opaque
		}
	}
}

/*!
Notes about the C interface:

Only use types known to C.
Use types that are unambiguous across all compilers, like uint32_t.
Each function must have it's call convention set.
Exceptions must be caught no matter what.

*/

extern "C" {

FLIF_DLLEXPORT FLIF_IMAGE* FLIF_API flif_create_image(uint32_t width, uint32_t height) {
	try
	{
		std::unique_ptr<FLIF_IMAGE> image(new FLIF_IMAGE());
		image->image.init(width, height, 0, 255, 4);
		return image.release();
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT void FLIF_API flif_destroy_image(FLIF_IMAGE* image) {
	// delete should never let exceptions out
	delete image;
}

FLIF_DLLEXPORT uint32_t FLIF_API flif_image_get_width(FLIF_IMAGE* image) {
	try
	{
		return image->image.cols();
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT uint32_t FLIF_API flif_image_get_height(FLIF_IMAGE* image) {
	try
	{
		return image->image.rows();
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT uint8_t FLIF_API flif_image_get_nb_channels(FLIF_IMAGE* image) {
	try
	{
		int nb = image->image.numPlanes();
		if (nb > 4) nb = 4; // there could be an extra plane for FRA
		return nb;
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT uint32_t FLIF_API flif_image_get_frame_delay(FLIF_IMAGE* image) {
	try
	{
		return image->image.frame_delay;
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT void FLIF_API flif_image_write_row_RGBA8(FLIF_IMAGE* image, uint32_t row, const void* buffer, size_t buffer_size_bytes) {
	try
	{
		image->write_row_RGBA8(row, buffer, buffer_size_bytes);
	}
	catch(...) {}
}

FLIF_DLLEXPORT void FLIF_API flif_image_read_row_RGBA8(FLIF_IMAGE* image, uint32_t row, void* buffer, size_t buffer_size_bytes) {
	try
	{
		image->read_row_RGBA8(row, buffer, buffer_size_bytes);
	}
	catch(...) {}
}

FLIF_DLLEXPORT void FLIF_API flif_free_memory(void* buffer) {
	delete [] reinterpret_cast<uint8_t*>(buffer);
}

} // extern "C"

FLIF_DECODER::FLIF_DECODER()
: quality(100)
, scale(1)
, callback(NULL)
, first_quality(0)
, rw(0)
, rh(0)
, working(false)
{ }

int32_t FLIF_DECODER::decode_file(const char* filename) {
	internal_images.clear();
	images.clear();

	FILE *file = fopen(filename,"rb");
	if(!file)
		return 0;
	FileIO fio(file, filename);

	working = true;
	if(!flif_decode(fio, internal_images, quality, scale, reinterpret_cast<uint32_t (*)(int32_t,int64_t)>(callback), first_quality, images, rw, rh))
		{ working = false; return 0; }
	working = false;

	images.clear();
	for (Image& image : internal_images) images.emplace_back(std::move(image));

	return 1;
}

int32_t FLIF_DECODER::decode_memory(const void* buffer, size_t buffer_size_bytes) {
	internal_images.clear();
	images.clear();

	BlobReader reader(reinterpret_cast<const uint8_t*>(buffer), buffer_size_bytes);

	working = true;
	if(!flif_decode(reader, internal_images, quality, scale, reinterpret_cast<uint32_t (*)(int32_t,int64_t)>(callback), first_quality, images, rw, rh))
		{ working = false; return 0; }
	working = false;

	images.clear();
	for (Image& image : internal_images) images.emplace_back(std::move(image));
	return 1;
}

int32_t FLIF_DECODER::abort() {
	  if (working) {
		if (images.size() > 0) images[0].abort_decoding();
		return 1;
	  } else return 0;
}

size_t FLIF_DECODER::num_images() {
	return images.size();
}

int32_t FLIF_DECODER::num_loops() {
	return 0; // TODO: return actual loop count of the animation
}

FLIF_IMAGE* FLIF_DECODER::get_image(size_t index) {
	if(index >= images.size())
		return 0;
	if(index >= requested_images.size()) requested_images.resize(images.size());
	if (!requested_images[index].get()) requested_images[index].reset( new FLIF_IMAGE());
	if (images[index].rows()) {
		requested_images[index]->image = std::move(images[index]); // moves and invalidates images[index]
	}
	return requested_images[index].get();
}

/*!
Notes about the C interface:

Only use types known to C.
Use types that are unambiguous across all compilers, like uint32_t.
Each function must have it's call convention set.
Exceptions must be caught no matter what.

*/

extern "C" {

FLIF_DLLEXPORT FLIF_DECODER* FLIF_API flif_create_decoder() {
	try
	{
		std::unique_ptr<FLIF_DECODER> decoder(new FLIF_DECODER());
		return decoder.release();
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT int32_t FLIF_API flif_abort_decoder(FLIF_DECODER* decoder) {
	try {
	  return decoder->abort();
	} catch(...) {}
	return 0;
}
FLIF_DLLEXPORT void FLIF_API flif_destroy_decoder(FLIF_DECODER* decoder) {
	// delete should never let exceptions out
	delete decoder;
	decoder = NULL;
}

FLIF_DLLEXPORT void FLIF_API flif_decoder_set_quality(FLIF_DECODER* decoder, int32_t quality) {
	try
	{
		decoder->quality = quality;
	}
	catch(...) {}
}

FLIF_DLLEXPORT void FLIF_API flif_decoder_set_scale(FLIF_DECODER* decoder, uint32_t scale) {
	try
	{
		decoder->scale = scale;
	}
	catch(...) {}
}

FLIF_DLLEXPORT void FLIF_API flif_decoder_set_resize(FLIF_DECODER* decoder, uint32_t rw, uint32_t rh) {
	try
	{
		decoder->rw = rw;
		decoder->rh = rh;
	}
	catch(...) {}
}

FLIF_DLLEXPORT void FLIF_API flif_decoder_set_callback(FLIF_DECODER* decoder, uint32_t (*callback)(int32_t quality, int64_t bytes_read)) {
	try
	{
		decoder->callback = (void*) callback;
	}
	catch(...) {}
}

FLIF_DLLEXPORT void FLIF_API flif_decoder_set_first_callback_quality(FLIF_DECODER* decoder, int32_t quality) {
	try
	{
		decoder->first_quality = quality;
	}
	catch(...) {}
}

/*!
* \return non-zero if the function succeeded
*/
FLIF_DLLEXPORT int32_t FLIF_API flif_decoder_decode_file(FLIF_DECODER* decoder, const char* filename) {
	try
	{
		return decoder->decode_file(filename);
	}
	catch(...) {}
	return 0;
}

/*!
* \return non-zero if the function succeeded
*/
FLIF_DLLEXPORT int32_t FLIF_API flif_decoder_decode_memory(FLIF_DECODER* decoder, const void* buffer, size_t buffer_size_bytes) {
	try
	{
		return decoder->decode_memory(buffer, buffer_size_bytes);
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT size_t FLIF_API flif_decoder_num_images(FLIF_DECODER* decoder) {
	try
	{
		return decoder->num_images();
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT int32_t FLIF_API flif_decoder_num_loops(FLIF_DECODER* decoder) {
	try
	{
		return decoder->num_loops();
	}
	catch(...) {}
	return 0;
}

FLIF_DLLEXPORT FLIF_IMAGE* FLIF_API flif_decoder_get_image(FLIF_DECODER* decoder, size_t index) {
	try
	{
		return decoder->get_image(index);
	}
	catch(...) {}
	return 0;
}

} // extern "C"


//#line 1 "crc32k.cpp"
CRC32KTable::CRC32KTable() {
	uint32_t x[8];
	x[0] = 0x741b8cd7;
	for (int i = 1; i < 8; i++) {
		x[i] = (x[i - 1] << 1) ^ ((x[i - 1] >> 31) * x[0]);
	}
	for (int j = 0; j < 256; j++) {
		tab[j] = 0;
		for (int i = 0; i < 8; i++) {
			if ((j >> i) & 1) {
				tab[j] ^= x[i];
			}
		}
	}
}

const CRC32KTable crc32k;


//#line 1 "color_range.cpp"

//#line 1 "color_range.hpp"
#ifndef FLIF_IMAGE_COLOR_RANGE_HPP
#define FLIF_IMAGE_COLOR_RANGE_HPP

#include <vector>

typedef std::vector<ColorVal> prevPlanes;

class ColorRanges
{
public:
	virtual ~ColorRanges() {};
	virtual int numPlanes() const =0;
	virtual ColorVal min(int p) const =0;
	virtual ColorVal max(int p) const =0;
	virtual void minmax(const int p, const prevPlanes &, ColorVal &minv, ColorVal &maxv) const { minv=min(p); maxv=max(p); }
	virtual void snap(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv, ColorVal &v) const {
		minmax(p,pp,minv,maxv);
		assert(minv <= maxv);
		if(v>maxv) v=maxv;
		if(v<minv) v=minv;
		assert(v <= maxv);
		assert(v >= minv);
	}
	virtual bool isStatic() const { return true; }
};

typedef std::vector<std::pair<ColorVal, ColorVal> > StaticColorRangeList;

class StaticColorRanges : public ColorRanges
{
protected:
	const StaticColorRangeList ranges;

public:
	StaticColorRanges(StaticColorRangeList r) : ranges(r) {}
	int numPlanes() const { return ranges.size(); }
	ColorVal min(int p) const { if (p >= numPlanes()) return 0; assert(p<numPlanes()); return ranges[p].first; }
	ColorVal max(int p) const { if (p >= numPlanes()) return 0; assert(p<numPlanes()); return ranges[p].second; }
};

const ColorRanges *getRanges(const Image &image);

class DupColorRanges : public ColorRanges {
protected:
	const ColorRanges *ranges;
public:
	DupColorRanges(const ColorRanges *rangesIn) : ranges(rangesIn) {}

	int numPlanes() const { return ranges->numPlanes(); }
	ColorVal min(int p) const { return ranges->min(p); }
	ColorVal max(int p) const { return ranges->max(p); }
	void minmax(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv) const { ranges->minmax(p,pp,minv,maxv); }
	bool isStatic() const { return ranges->isStatic(); }
};

const ColorRanges *dupRanges(const ColorRanges *ranges);

#endif

const ColorRanges *getRanges(const Image &image) {
	StaticColorRangeList ranges;
	for (int p = 0; p < image.numPlanes(); p++) {
		ranges.push_back(std::make_pair(image.min(p), image.max(p)));
	}
	return new StaticColorRanges(ranges);
}

const ColorRanges *getRanges(const ColorRanges *ranges) {
	return new DupColorRanges(ranges);
}


//#line 1 "flif-dec.cpp"
#include <string>
#include <string.h>


//#line 1 "rac.hpp"
#ifndef FLIF_RAC_HPP
#define FLIF_RAC_HPP

#ifdef STATS
#include <stdio.h>
#endif

#include <stdint.h>
#include <assert.h>

/* RAC configuration for 24-bit RAC */
class RacConfig24 {
public:
	typedef uint32_t data_t;
	static const data_t MAX_RANGE_BITS = 24;
	static const data_t MIN_RANGE_BITS = 16;
	static const data_t MIN_RANGE = (1UL << MIN_RANGE_BITS);
	static const data_t BASE_RANGE = (1UL << MAX_RANGE_BITS);

	static inline data_t chance_12bit_chance(int b12, data_t range) {
		assert(b12 > 0);
		assert((b12 >> 12) == 0);
		// We want to compute (range * b12 + 0x800) >> 12.
		// Unfortunately, this can overflow the 32-bit data type, so split range
		// in its lower and upper 12 bits, and compute separately.
		return ((((range & 0xFFF) * b12 + 0x800) >> 12) + ((range >> 12) * b12));
	}
};

template <typename Config, typename IO> class RacInput {
public:
	typedef typename Config::data_t rac_t;
protected:
	IO& io;
private:
#ifdef STATS
	uint64_t samples;
#endif
	rac_t range;
	rac_t low;
private:
	int read_catch_eof() {
		int c = io.getc();
		if(c == io.EOS) return 0;
		return c;
	}
	void inline input() {
		if (range <= Config::MIN_RANGE) {
			low <<= 8;
			range <<= 8;
			low |= read_catch_eof();
		}
		if (range <= Config::MIN_RANGE) {
			low <<= 8;
			range <<= 8;
			low |= read_catch_eof();
		}
	}
	bool inline get(rac_t chance) {
#ifdef STATS
		samples++;
#endif
		assert(chance > 0);
		assert(chance < range);
		if (low >= range - chance) {
			low -= range - chance;
			range = chance;
			input();
			return 1;
		} else {
			range -= chance;
			input();
			return 0;
		}
	}
public:
	RacInput(IO& ioin) : io(ioin), range(Config::BASE_RANGE), low(0) {
#ifdef STATS
		samples = 0;
#endif
		rac_t r = Config::BASE_RANGE;
		while (r > 1) {
			low <<= 8;
			low |= read_catch_eof();
			r >>= 8;
		}
	}

#ifdef STATS
	~RacInput() {
		fprintf(stdout, "Total samples read from range coder: %llu\n", (unsigned long long)samples);
	}
#endif

	bool inline read_12bit_chance(uint16_t b12) ATTRIBUTE_HOT {
		return get(Config::chance_12bit_chance(b12, range));
	}

	bool inline read_bit() {
		return get(range >> 1);
	}
};

template <typename IO> class RacInput24 : public RacInput<RacConfig24, IO> {
public:
	RacInput24(IO& io) : RacInput<RacConfig24, IO>(io) { }
};

#ifdef HAS_ENCODER

//#line 1 "rac_enc.hpp"
#ifndef FLIF_RAC_ENC_HPP
#define FLIF_RAC_ENC_HPP

template <class Config, typename IO> class RacOutput {
public:
	typedef typename Config::data_t rac_t;
protected:
	IO& io;
private:
	rac_t range;
	rac_t low;
	int delayed_byte;
	int delayed_count;

	void inline output() {
		while (range <= Config::MIN_RANGE) {
			int byte = low >> Config::MIN_RANGE_BITS;
			if (delayed_byte < 0) { // first generated byte
				delayed_byte = byte;
			} else if (((low + range) >> 8) < Config::MIN_RANGE) { // definitely no overflow
				io.fputc(delayed_byte);
				while (delayed_count) {
					io.fputc(0xFF);
					delayed_count--;
				}
				delayed_byte = byte;
			} else if ((low >> 8) >= Config::MIN_RANGE) { // definitely overflow
				io.fputc(delayed_byte + 1);
				while (delayed_count) {
					io.fputc(0);
					delayed_count--;
				}
				delayed_byte = byte & 0xFF;
			} else {
				delayed_count++;
			}
			low = (low & (Config::MIN_RANGE - 1)) << 8;
			range <<= 8;
		}
	}
	void inline put(rac_t chance, bool bit) {
		assert(chance > 0);
		assert(chance < range);
		if (bit) {
			low += range - chance;
			range = chance;
		} else {
			range -= chance;
		}
		output();
	}
public:
	RacOutput(IO& ioin) : io(ioin), range(Config::BASE_RANGE), low(0), delayed_byte(-1), delayed_count(0) { }

	void inline write_12bit_chance(uint16_t b12, bool bit) {
		put(Config::chance_12bit_chance(b12, range), bit);
	}

	void inline write_bit(bool bit) {
		put(range >> 1, bit);
	}

	void inline flush() {
		low += (Config::MIN_RANGE - 1);
		// is this the correct way to reliably flush?
		  range = Config::MIN_RANGE - 1;
		  output();
		  range = Config::MIN_RANGE - 1;
		  output();
		  range = Config::MIN_RANGE - 1;
		  output();
		  range = Config::MIN_RANGE - 1;
		  output();
		io.flush();
	}
};

class RacDummy {
public:
	static void inline write_12bit_chance(uint16_t b12, bool) { }
	static void inline write_bit(bool) { }
	static void inline flush() { }
};

template <typename IO> class RacOutput24 : public RacOutput<RacConfig24, IO> {
public:
	RacOutput24(IO& io) : RacOutput<RacConfig24, IO>(io) { }
};

#endif


#endif

#endif


//#line 1 "compound.hpp"
#ifndef FLIF_COMPOUND_HPP
#define FLIF_COMPOUND_HPP

#include <vector>
#include <math.h>
#include <stdint.h>

//#line 1 "symbol.hpp"
#ifndef FLIF_SYMBOL_HPP
#define FLIF_SYMBOL_HPP

#include <vector>
#include <assert.h>

//#line 1 "util.hpp"
#ifndef FLIF_UTIL_HPP
#define FLIF_UTIL_HPP

#include <cstdint>

namespace maniac {
namespace util {

static inline int ilog2(uint32_t l) {
	if (l == 0) { return 0; }
//    return sizeof(unsigned int) * 8 - __builtin_clz(l) - 1;
	return sizeof(unsigned int) * 8 - 1 - __builtin_clz(l);
}

void indent(int n);

} // namespace util
} // namespace maniac

#endif


template <typename RAC> class UniformSymbolCoder {
private:
	RAC &rac;

public:
	UniformSymbolCoder(RAC &racIn) : rac(racIn) { }

#ifdef HAS_ENCODER
	void write_int(int min, int max, int val);
#endif
	int read_int(int min, int max) {
		assert(max >= min);
		if (min != 0) {
			max -= min;
		}
		if (max == 0) return min;

		// split in [0..med] [med+1..max]
		int med = max/2;
		bool bit = rac.read_bit();
		if (bit) {
			return read_int(min+med+1, min+max);
		} else {
			return read_int(min, min+med);
		}
	}
};

typedef enum {
	BIT_ZERO,
	BIT_SIGN,
	BIT_EXP,
	BIT_MANT,
//    BIT_EXTRA
} SymbolChanceBitType;

//static const char *SymbolChanceBitName[] = {"zero", "sign", "expo", "mant"};

static const uint16_t EXP_CHANCES[] = {1000, 1200, 1500, 1750, 2000, 2300, 2800, 2400, 2300,
									   2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048};
static const uint16_t MANT_CHANCES[] = {1900, 1850, 1800, 1750, 1650, 1600, 1600, 2048, 2048,
										2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048};
static const uint16_t ZERO_CHANCE = 1000;
static const uint16_t SIGN_CHANCE = 2048;
/*
static const uint16_t EXP_CHANCES[] = {1200, 1600, 1800, 1900, 2050, 2300, 2500, 2300, 2048,
									   2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048};
static const uint16_t MANT_CHANCES[] = {1750, 1730, 1710, 1670, 1650, 1700, 1800, 1800, 2048,
										2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048, 2048};
static const uint16_t ZERO_CHANCE = 1600;
static const uint16_t SIGN_CHANCE = 2048;
*/
#ifdef STATS
struct SymbolChanceStats {
	BitChanceStats stats_zero;
	BitChanceStats stats_sign;
	BitChanceStats stats_exp[17];
	BitChanceStats stats_mant[18];

	std::string format() const;
	~SymbolChanceStats();
};

extern SymbolChanceStats global_symbol_stats;
#endif

template <typename BitChance, int bits> class SymbolChance {
	BitChance bit_zero;
	BitChance bit_sign;
	BitChance bit_exp[bits-1];
	BitChance bit_mant[bits];

public:

	BitChance inline &bitZero()      {
		return bit_zero;
	}

	BitChance inline &bitSign()      {
		return bit_sign;
	}

	// all exp bits 0         -> int(log2(val)) == 0  [ val == 1 ]
	// exp bits up to i are 1 -> int(log2(val)) == i+1
	BitChance inline &bitExp(int i)  {
		assert(i >= 0 && i < bits-1);
		return bit_exp[i];
	}
	BitChance inline &bitMant(int i) {
		assert(i >= 0 && i < bits);
		return bit_mant[i];
	}

	BitChance inline &bit(SymbolChanceBitType typ, int i = 0) {
		switch (typ) {
		default:
		case BIT_ZERO:
			return bitZero();
		case BIT_SIGN:
			return bitSign();
		case BIT_EXP:
			return bitExp(i);
		case BIT_MANT:
			return bitMant(i);
		}
	}
	SymbolChance() { // : bit_exp(bitsin-1), bit_mant(bitsin) {
		bitZero().set_12bit(ZERO_CHANCE);
		bitSign().set_12bit(SIGN_CHANCE);
//        printf("bits: %i\n",bits);
		for (int i=0; i<bits-1; i++) {
			bitExp(i).set_12bit(EXP_CHANCES[i]);
		}
		for (int i=0; i<bits; i++) {
			bitMant(i).set_12bit(MANT_CHANCES[i]);
		}
	}

	int scale() const {
		return bitZero().scale();
	}

#ifdef STATS
	~SymbolChance() {
		global_symbol_stats.stats_zero += bit_zero.stats();
		global_symbol_stats.stats_sign += bit_sign.stats();
		for (int i = 0; i < bits - 1 && i < 17; i++) {
			global_symbol_stats.stats_exp[i] += bit_exp[i].stats();
		}
		for (int i = 0; i < bits && i < 18; i++) {
			global_symbol_stats.stats_mant[i] += bit_mant[i].stats();
		}
	}
#endif
};

template <typename SymbolCoder> int reader(SymbolCoder& coder, int bits) {
  int pos=0;
  int value=0;
  int b=1;
  while (pos++ < bits) {
	if (coder.read(BIT_MANT, pos)) value += b;
	b *= 2;
  }
  return value;
}

template <int bits, typename SymbolCoder> int reader(SymbolCoder& coder, int min, int max) ATTRIBUTE_HOT;

template <int bits, typename SymbolCoder> int reader(SymbolCoder& coder, int min, int max) {
	assert(min<=max);
	if (min == max) return min;

	bool sign;
	if (max >= 0 && min <= 0) {
	  if (coder.read(BIT_ZERO)) return 0;
	  if (min < 0) {
		if (max > 0) {
				sign = coder.read(BIT_SIGN);
				if (sign) min = 1; else max = -1;
		} else {sign = false; max=-1;}
	  } else {sign = true; min=1;}
	} else {
		if (min<0) sign = false;
		else sign = true;
	}

	const int amin = (sign? min : -max);
	const int amax = (sign? max : -min);

	const int emax = maniac::util::ilog2(amax);
	int e = maniac::util::ilog2(amin);

	for (; e < emax; e++) {
		// if exponent >e is impossible, we are done
		if ((1 << (e+1)) > amax) break;
		if (coder.read(BIT_EXP,e)) break;
	}

	int have = (1 << e);
	int left = have-1;
	for (int pos = e; pos>0;) {
		int bit = 1;
		left ^= (1 << (--pos));
		int minabs1 = have | (1<<pos);
		int maxabs0 = have | left;
		if (minabs1 > amax) { // 1-bit is impossible
			bit = 0;
		} else if (maxabs0 >= amin) { // 0-bit and 1-bit are both possible
			bit = coder.read(BIT_MANT,pos);
		}
		have |= (bit << pos);
	}
	return (sign ? have : -have);
}

template <typename BitChance, typename RAC> class SimpleBitCoder {
	typedef typename BitChance::Table Table;

private:
	const Table table;
	BitChance ctx;
	RAC &rac;

public:
	SimpleBitCoder(RAC &racIn, int cut = 2, int alpha = 0xFFFFFFFF / 19) : rac(racIn), table(cut,alpha) {}

	void set(uint16_t chance) {
		ctx.set(chance);
	}
#ifdef HAS_ENCODER
	void write(bool bit);
#endif
	bool read() {
		bool bit = rac.read(ctx.get());
		ctx.put(bit, table);
		return bit;
	}
};

template <typename BitChance, typename RAC, int bits> class SimpleSymbolBitCoder {
	typedef typename BitChance::Table Table;

private:
	const Table &table;
	SymbolChance<BitChance,bits> &ctx;
	RAC &rac;

public:
	SimpleSymbolBitCoder(const Table &tableIn, SymbolChance<BitChance,bits> &ctxIn, RAC &racIn) : table(tableIn), ctx(ctxIn), rac(racIn) {}

#ifdef HAS_ENCODER
	void write(bool bit, SymbolChanceBitType typ, int i = 0);
#endif

	bool read(SymbolChanceBitType typ, int i = 0) {
		BitChance& bch = ctx.bit(typ, i);
		bool bit = rac.read_12bit_chance(bch.get_12bit());
		bch.put(bit, table);
		return bit;
	}
};

template <typename BitChance, typename RAC, int bits> class SimpleSymbolCoder {
	typedef typename BitChance::Table Table;

private:
	SymbolChance<BitChance,bits> ctx;
	const Table table;
	RAC &rac;

public:
	SimpleSymbolCoder(RAC& racIn, int cut = 2, int alpha = 0xFFFFFFFF / 19) :  table(cut,alpha), rac(racIn) {
	}

#ifdef HAS_ENCODER
	void write_int(int min, int max, int value);
	void write_int(int nbits, int value);
#endif

	int read_int(int min, int max) {
		SimpleSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, ctx, rac);
		return reader<bits, SimpleSymbolBitCoder<BitChance, RAC, bits>>(bitCoder, min, max);
	}
	int read_int(int nbits) {
		assert (nbits <= bits);
		SimpleSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, ctx, rac);
		return reader(bitCoder, nbits);
	}
};

#ifdef HAS_ENCODER

//#line 1 "symbol_enc.hpp"
#ifndef FLIF_SYMBOL_ENC_HPP
#define FLIF_SYMBOL_ENC_HPP

template <typename RAC>
void UniformSymbolCoder<RAC>::write_int(int min, int max, int val) {
		assert(max >= min);
		if (min != 0) {
			max -= min;
			val -= min;
		}
		if (max == 0) return;

		// split in [0..med] [med+1..max]
		int med = max/2;
		if (val > med) {
			rac.write_bit(true);
			write_int(med+1, max, val);
		} else {
			rac.write_bit(false);
			write_int(0, med, val);
		}
		return;
}

template <typename SymbolCoder> void writer(SymbolCoder& coder, int bits, int value) {
  int pos=0;
  while (pos++ < bits) {
	coder.write(value&1, BIT_MANT, pos);
	value >>= 1;
  }
}

template <int bits, typename SymbolCoder> void writer(SymbolCoder& coder, int min, int max, int value) {
	assert(min<=max);
	assert(value>=min);
	assert(value<=max);

	// avoid doing anything if the value is already known
	if (min == max) return;

	if (value == 0) { // value is zero
		coder.write(true, BIT_ZERO);
		return;
	}

	// only output zero bit if value could also have been zero
	if (max >= 0 && min <= 0) coder.write(false,BIT_ZERO);
	int sign = (value > 0 ? 1 : 0);
	if (max > 0 && min < 0) {
		// only output sign bit if value can be both pos and neg
		if (min < 0 && max > 0) coder.write(sign,BIT_SIGN);
	}
	if (sign && min <= 0) min = 1;
	if (!sign && max >= 0) max = -1;
	const int a = abs(value);
	const int e = maniac::util::ilog2(a);
	int amin = sign ? abs(min) : abs(max);
	int amax = sign ? abs(max) : abs(min);

	int emax = maniac::util::ilog2(amax);
	int i = maniac::util::ilog2(amin);

	while (i < emax) {
		// if exponent >i is impossible, we are done
		if ((1 << (i+1)) > amax) break;
		// if exponent i is possible, output the exponent bit
		coder.write(i==e, BIT_EXP, i);
		if (i==e) break;
		i++;
	}
//  e_printf("exp=%i\n",e);
	int have = (1 << e);
	int left = have-1;
	for (int pos = e; pos>0;) {
		int bit = 1;
		left ^= (1 << (--pos));
		int minabs1 = have | (1<<pos);
		// int maxabs1 = have | left | (1<<pos);
		// int minabs0 = have;
		int maxabs0 = have | left;
		if (minabs1 > amax) { // 1-bit is impossible
			bit = 0;
		} else if (maxabs0 >= amin) { // 0-bit and 1-bit are both possible
			bit = (a >> pos) & 1;
			coder.write(bit, BIT_MANT, pos);
		}
		have |= (bit << pos);
	}
}

template <typename BitChance, typename RAC>
void SimpleBitCoder<BitChance,RAC>::write(bool bit) {
		rac.write(ctx.get(), bit);
		ctx.put(bit, table);
}

template <typename BitChance, typename RAC, int bits>
void SimpleSymbolBitCoder<BitChance,RAC,bits>::write(bool bit, SymbolChanceBitType typ, int i) {
		BitChance& bch = ctx.bit(typ, i);
		rac.write_12bit_chance(bch.get_12bit(), bit);
		bch.put(bit, table);
}

template <typename BitChance, typename RAC, int bits>
void SimpleSymbolCoder<BitChance,RAC,bits>::write_int(int min, int max, int value) {
		SimpleSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, ctx, rac);
		writer<bits, SimpleSymbolBitCoder<BitChance, RAC, bits> >(bitCoder, min, max, value);
}
template <typename BitChance, typename RAC, int bits>
void SimpleSymbolCoder<BitChance,RAC,bits>::write_int(int nbits, int value) {
		assert (nbits <= bits);
		SimpleSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, ctx, rac);
		writer(bitCoder, nbits, value);
}

#endif


#endif

#endif


typedef  ColorVal  PropertyVal;
typedef  std::vector<std::pair<PropertyVal,PropertyVal> > Ranges;
typedef  std::vector<PropertyVal> Properties;

// inner nodes
class PropertyDecisionNode {
public:
	int8_t property;         // -1 : leaf node, childID unused
	// 0..nb_properties-1 : childID refers to left branch  (in inner_node)
	//                      childID+1 refers to right branch
	int16_t count;
	PropertyVal splitval;
	uint32_t childID;
	uint32_t leafID;
	PropertyDecisionNode(int p=-1, int s=0, int c=0) : property(p), count(0), splitval(s), childID(c), leafID(0) {}
};

class Tree : public std::vector<PropertyDecisionNode> {
public:
	Tree() : std::vector<PropertyDecisionNode>(1, PropertyDecisionNode()) {}
};

// leaf nodes when tree is known
template <typename BitChance, int bits> class FinalCompoundSymbolChances {
public:
	SymbolChance<BitChance, bits> realChances;

	FinalCompoundSymbolChances() { }

	const SymbolChance<BitChance, bits> &chances() const { return realChances; }
};

template <typename BitChance, typename RAC, int bits> class FinalCompoundSymbolBitCoder {
public:
	typedef typename BitChance::Table Table;

private:
	const Table &table;
	RAC &rac;
	FinalCompoundSymbolChances<BitChance, bits> &chances;

	void inline updateChances(const SymbolChanceBitType type, const int i, bool bit) {
		BitChance& real = chances.realChances.bit(type,i);
		real.put(bit, table);
	}

public:
	FinalCompoundSymbolBitCoder(const Table &tableIn, RAC &racIn, FinalCompoundSymbolChances<BitChance, bits> &chancesIn) : table(tableIn), rac(racIn), chances(chancesIn) {}

	bool inline read(const SymbolChanceBitType type, const int i = 0) {
		BitChance& ch = chances.realChances.bit(type, i);
		bool bit = rac.read_12bit_chance(ch.get_12bit());
		updateChances(type, i, bit);
		return bit;
	}

#ifdef HAS_ENCODER
	void inline write(const bool bit, const SymbolChanceBitType type, const int i = 0);
#endif
};

template <typename BitChance, typename RAC, int bits> class FinalCompoundSymbolCoder {
private:
	typedef typename FinalCompoundSymbolBitCoder<BitChance, RAC, bits>::Table Table;
	RAC &rac;
	const Table table;

public:

	FinalCompoundSymbolCoder(RAC& racIn, int cut = 2, int alpha = 0xFFFFFFFF / 19) : rac(racIn), table(cut,alpha) {}

	int read_int(FinalCompoundSymbolChances<BitChance, bits> &chancesIn, int min, int max) {
		FinalCompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn);
		int val = reader<bits>(bitCoder, min, max);
		return val;
	}
	int read_int(FinalCompoundSymbolChances<BitChance, bits> &chancesIn, int nbits) {
		FinalCompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn);
		int val = reader(bitCoder, nbits);
		return val;
	}

#ifdef HAS_ENCODER
	void write_int(FinalCompoundSymbolChances<BitChance, bits>& chancesIn, int min, int max, int val);
	void write_int(FinalCompoundSymbolChances<BitChance, bits>& chancesIn, int nbits, int val);
#endif
};

template <typename BitChance, typename RAC, int bits> class FinalPropertySymbolCoder {
private:
	FinalCompoundSymbolCoder<BitChance, RAC, bits> coder;
	//Ranges range;
	unsigned int nb_properties;
	std::vector<FinalCompoundSymbolChances<BitChance,bits> > leaf_node;
	Tree &inner_node;

	FinalCompoundSymbolChances<BitChance,bits> inline &find_leaf(const Properties &properties) ATTRIBUTE_HOT {
		Tree::size_type pos = 0;
		while(inner_node[pos].property != -1) {
			if (inner_node[pos].count < 0) {
				if (properties[inner_node[pos].property] > inner_node[pos].splitval) {
				  pos = inner_node[pos].childID;
				} else {
				  pos = inner_node[pos].childID+1;
				}
			} else if (inner_node[pos].count > 0) {
				assert(inner_node[pos].leafID >= 0);
				assert((unsigned int)inner_node[pos].leafID < leaf_node.size());
				inner_node[pos].count--;
				break;
			} else if (inner_node[pos].count == 0) {
				inner_node[pos].count--;
				FinalCompoundSymbolChances<BitChance,bits> &result = leaf_node[inner_node[pos].leafID];
				uint32_t old_leaf = inner_node[pos].leafID;
				uint32_t new_leaf = leaf_node.size();
				FinalCompoundSymbolChances<BitChance,bits> resultCopy = result;
				leaf_node.push_back(resultCopy);
				inner_node[inner_node[pos].childID].leafID = old_leaf;
				inner_node[inner_node[pos].childID+1].leafID = new_leaf;
				if (properties[inner_node[pos].property] > inner_node[pos].splitval) {
				  return leaf_node[old_leaf];
				} else {
				  return leaf_node[new_leaf];
				}
			}
		}
		return leaf_node[inner_node[pos].leafID];
	}

public:
	FinalPropertySymbolCoder(RAC& racIn, Ranges &rangeIn, Tree &treeIn, int ignored_split_threshold = 0, int cut = 4, int alpha = 0xFFFFFFFF / 20) :
		coder(racIn, cut, alpha),
//        range(rangeIn),
		nb_properties(rangeIn.size()),
		leaf_node(1,FinalCompoundSymbolChances<BitChance,bits>()),
		inner_node(treeIn)
	{
		inner_node[0].leafID = 0;
	}

	int read_int(const Properties &properties, int min, int max) ATTRIBUTE_HOT {
		if (min == max) { return min; }
		assert(properties.size() == nb_properties);
		FinalCompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		return coder.read_int(chances, min, max);
	}

	int read_int(const Properties &properties, int nbits) {
		assert(properties.size() == nb_properties);
		FinalCompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		return coder.read_int(chances, nbits);
	}

#ifdef HAS_ENCODER
	void write_int(const Properties &properties, int min, int max, int val);
	void write_int(const Properties &properties, int nbits, int val);
#endif

	static void simplify(int divisor=CONTEXT_TREE_COUNT_DIV, int min_size=CONTEXT_TREE_MIN_SUBTREE_SIZE) {}
};

template <typename BitChance, typename RAC> class MetaPropertySymbolCoder {
public:
	typedef SimpleSymbolCoder<BitChance, RAC, 18> Coder;
private:
	Coder coder;
	const Ranges range;
	unsigned int nb_properties;

public:
	MetaPropertySymbolCoder(RAC &racIn, const Ranges &rangesIn, int cut = 2, int alpha = 0xFFFFFFFF / 19) :
		coder(racIn, cut, alpha),
		range(rangesIn),
		nb_properties(rangesIn.size())
	{
		for (unsigned int i=0; i<nb_properties; i++) {
		   assert(range[i].first <= range[i].second);
		}
	}

#ifdef HAS_ENCODER
	void write_subtree(int pos, Ranges &subrange, const Tree &tree);
	void write_tree(const Tree &tree);
#endif

	bool read_subtree(int pos, Ranges &subrange, Tree &tree) {
		PropertyDecisionNode &n = tree[pos];
		int p = n.property = coder.read_int(0,nb_properties)-1;

		if (p != -1) {
			int oldmin = subrange[p].first;
			int oldmax = subrange[p].second;
			if (oldmin >= oldmax) {
			  e_printf( "Invalid tree. Aborting tree decoding.\n");
			  return false;
			}
			n.count = coder.read_int(CONTEXT_TREE_MIN_COUNT, CONTEXT_TREE_MAX_COUNT); // * CONTEXT_TREE_COUNT_QUANTIZATION;
			assert(oldmin < oldmax);
			int splitval = n.splitval = coder.read_int(oldmin, oldmax-1);
			int childID = n.childID = tree.size();
//            e_printf( "Pos %i: prop %i splitval %i in [%i..%i]\n", pos, n.property, splitval, oldmin, oldmax-1);
			tree.push_back(PropertyDecisionNode());
			tree.push_back(PropertyDecisionNode());
			// > splitval
			subrange[p].first = splitval+1;
			if (!read_subtree(childID, subrange, tree)) return false;

			// <= splitval
			subrange[p].first = oldmin;
			subrange[p].second = splitval;
			if (!read_subtree(childID+1, subrange, tree)) return false;

			subrange[p].second = oldmax;
		}
		return true;
	}
	bool read_tree(Tree &tree) {
		  Ranges rootrange(range);
		  tree.clear();
		  tree.push_back(PropertyDecisionNode());
		  return read_subtree(0, rootrange, tree);
	}
};

#ifdef HAS_ENCODER

//#line 1 "compound_enc.hpp"
#ifndef FLIF_COMPOUND_ENC_HPP
#define FLIF_COMPOUND_ENC_HPP

// leaf nodes during tree construction phase
template <typename BitChance, int bits> class CompoundSymbolChances final : public FinalCompoundSymbolChances<BitChance, bits> {
public:
	std::vector<std::pair<SymbolChance<BitChance, bits>,SymbolChance<BitChance, bits> > > virtChances;
	uint64_t realSize;
	std::vector<uint64_t> virtSize;
	std::vector<int64_t> virtPropSum;
	int32_t count;
	int8_t best_property;

	void resetCounters() {
		best_property = -1;
		realSize = 0;
		count = 0;
		virtPropSum.assign(virtPropSum.size(),0);
		virtSize.assign(virtSize.size(),0);
	}

	CompoundSymbolChances(int nProp) :
		FinalCompoundSymbolChances<BitChance, bits>(),
		virtChances(nProp,std::make_pair(SymbolChance<BitChance, bits>(), SymbolChance<BitChance,bits>())),
		realSize(0),
		virtSize(nProp),
		virtPropSum(nProp),
		count(0),
		best_property(-1)
	{ }

};

template <typename BitChance, typename RAC, int bits>
void inline FinalCompoundSymbolBitCoder<BitChance,RAC,bits>::write(const bool bit, const SymbolChanceBitType type, const int i) {
		BitChance& ch = chances.realChances.bit(type, i);
		rac.write_12bit_chance(ch.get_12bit(), bit);
		updateChances(type, i, bit);
	}

template <typename BitChance, typename RAC, int bits> class CompoundSymbolBitCoder {
public:
	typedef typename BitChance::Table Table;

private:
	const Table &table;
	RAC &rac;
	CompoundSymbolChances<BitChance, bits> &chances;
	std::vector<bool> &select;

	void inline updateChances(SymbolChanceBitType type, int i, bool bit) {
		BitChance& real = chances.realChances.bit(type,i);
		real.estim(bit, chances.realSize);
		real.put(bit, table);

		int8_t best_property = -1;
		uint64_t best_size = chances.realSize;
		for (unsigned int j=0; j<chances.virtChances.size(); j++) {
			BitChance& virt = (select)[j] ? chances.virtChances[j].first.bit(type,i)
							  : chances.virtChances[j].second.bit(type,i);
			virt.estim(bit, chances.virtSize[j]);
			virt.put(bit, table);
			if (chances.virtSize[j] < best_size) {
				best_size = chances.virtSize[j];
				best_property = j;
			}
		}
		chances.best_property = best_property;
	}
	BitChance inline & bestChance(SymbolChanceBitType type, int i = 0) {
		signed short int p = chances.best_property;
		return (p == -1 ? chances.realChances.bit(type,i)
				: ((select)[p] ? chances.virtChances[p].first.bit(type,i)
				   : chances.virtChances[p].second.bit(type,i) ));
	}

public:
	CompoundSymbolBitCoder(const Table &tableIn, RAC &racIn, CompoundSymbolChances<BitChance, bits> &chancesIn, std::vector<bool> &selectIn) : table(tableIn), rac(racIn), chances(chancesIn), select(selectIn) {}

	bool read(SymbolChanceBitType type, int i = 0) {
		BitChance& ch = bestChance(type, i);
		bool bit = rac.read_12bit_chance(ch.get_12bit());
		updateChances(type, i, bit);
		return bit;
	}

	void write(bool bit, SymbolChanceBitType type, int i = 0) {
		BitChance& ch = bestChance(type, i);
		rac.write_12bit_chance(ch.get_12bit(), bit);
		updateChances(type, i, bit);
	}
};

template <typename BitChance, typename RAC, int bits>
void FinalCompoundSymbolCoder<BitChance,RAC,bits>::write_int(FinalCompoundSymbolChances<BitChance, bits>& chancesIn, int min, int max, int val) {
		FinalCompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn);
		writer<bits>(bitCoder, min, max, val);
	}

template <typename BitChance, typename RAC, int bits>
void FinalCompoundSymbolCoder<BitChance,RAC,bits>::write_int(FinalCompoundSymbolChances<BitChance, bits>& chancesIn, int nbits, int val) {
		FinalCompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn);
		writer(bitCoder, nbits, val);
	}

template <typename BitChance, typename RAC, int bits> class CompoundSymbolCoder {
private:
	typedef typename CompoundSymbolBitCoder<BitChance, RAC, bits>::Table Table;
	RAC &rac;
	const Table table;

public:

	CompoundSymbolCoder(RAC& racIn, int cut = 2, int alpha = 0xFFFFFFFF / 19) : rac(racIn), table(cut,alpha) {}

	int read_int(CompoundSymbolChances<BitChance, bits> &chancesIn, std::vector<bool> &selectIn, int min, int max) {
		if (min == max) { return min; }
		CompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn, selectIn);
		return reader<bits>(bitCoder, min, max);
	}

	void write_int(CompoundSymbolChances<BitChance, bits>& chancesIn, std::vector<bool> &selectIn, int min, int max, int val) {
		if (min == max) { assert(val==min); return; }
		CompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn, selectIn);
		writer<bits>(bitCoder, min, max, val);
	}

	int read_int(CompoundSymbolChances<BitChance, bits> &chancesIn, std::vector<bool> &selectIn, int nbits) {
		CompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn, selectIn);
		return reader(bitCoder, nbits);
	}

	void write_int(CompoundSymbolChances<BitChance, bits>& chancesIn, std::vector<bool> &selectIn, int nbits, int val) {
		CompoundSymbolBitCoder<BitChance, RAC, bits> bitCoder(table, rac, chancesIn, selectIn);
		writer(bitCoder, nbits, val);
	}
};

template <typename BitChance, typename RAC, int bits>
void FinalPropertySymbolCoder<BitChance,RAC,bits>::write_int(const Properties &properties, int min, int max, int val) {
		if (min == max) { assert(val==min); return; }
		assert(properties.size() == nb_properties);
		FinalCompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		coder.write_int(chances, min, max, val);
	}

template <typename BitChance, typename RAC, int bits>
void FinalPropertySymbolCoder<BitChance,RAC,bits>::write_int(const Properties &properties, int nbits, int val) {
		assert(properties.size() == nb_properties);
		FinalCompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		coder.write_int(chances, nbits, val);
	}

template <typename BitChance, typename RAC, int bits> class PropertySymbolCoder {
public:
	typedef CompoundSymbolCoder<BitChance, RAC, bits> Coder;
private:
	RAC &rac;
	Coder coder;
	const Ranges range;
	unsigned int nb_properties;
	std::vector<CompoundSymbolChances<BitChance,bits> > leaf_node;
	Tree &inner_node;
	std::vector<bool> selection;
	int split_threshold;

	inline PropertyVal div_down(int64_t sum, int32_t count) const {
		assert(count > 0);
		if (sum >= 0) return sum/count;
		else return -((-sum + count-1)/count);
	}

	CompoundSymbolChances<BitChance,bits> inline &find_leaf(const Properties &properties) {
		uint32_t pos = 0;
		Ranges current_ranges = range;
		while(inner_node[pos].property != -1) {
//        e_printf("Checking property %i (val=%i, splitval=%i)\n",inner_node[pos].property,properties[inner_node[pos].property],inner_node[pos].splitval);
			if (properties[inner_node[pos].property] > inner_node[pos].splitval) {
				current_ranges[inner_node[pos].property].first = inner_node[pos].splitval + 1;
				pos = inner_node[pos].childID;
			} else {
				current_ranges[inner_node[pos].property].second = inner_node[pos].splitval;
				pos = inner_node[pos].childID+1;
			}
		}
//    fprintf(stdout,"Returning leaf node %i\n", inner_node[pos].childID);
		CompoundSymbolChances<BitChance,bits> &result = leaf_node[inner_node[pos].leafID];

		// split leaf node if some virtual context is performing (significantly) better
		if(result.best_property != -1
		   && result.realSize > result.virtSize[result.best_property] + split_threshold
		   && current_ranges[result.best_property].first < current_ranges[result.best_property].second) {

		  int8_t p = result.best_property;
		  PropertyVal splitval = div_down(result.virtPropSum[p],result.count);
		  if (splitval >= current_ranges[result.best_property].second)
			 splitval = current_ranges[result.best_property].second-1; // == does happen because of rounding and running average

		  uint32_t new_inner = inner_node.size();
		  inner_node.push_back(inner_node[pos]);
		  inner_node.push_back(inner_node[pos]);
		  inner_node[pos].splitval = splitval;
//            fprintf(stdout,"Splitting on property %i, splitval=%i (count=%i)\n",p,inner_node[pos].splitval, (int)result.count);
		  inner_node[pos].property = p;
		  if (result.count < INT16_MAX) inner_node[pos].count = result.count;
		  else inner_node[pos].count = INT16_MAX;
		  uint32_t new_leaf = leaf_node.size();
		  result.resetCounters();
		  leaf_node.push_back(CompoundSymbolChances<BitChance,bits>(result));
		  uint32_t old_leaf = inner_node[pos].leafID;
		  inner_node[pos].childID = new_inner;
		  inner_node[new_inner].leafID = old_leaf;
		  inner_node[new_inner+1].leafID = new_leaf;
		  if (properties[p] > inner_node[pos].splitval) {
				return leaf_node[old_leaf];
		  } else {
				return leaf_node[new_leaf];
		  }
		}
		return result;
	}

	void inline set_selection_and_update_property_sums(const Properties &properties, CompoundSymbolChances<BitChance,bits> &chances) {
		chances.count++;
		for(unsigned int i=0; i<nb_properties; i++) {
			assert(properties[i] >= range[i].first);
			assert(properties[i] <= range[i].second);
			chances.virtPropSum[i] += properties[i];
			PropertyVal splitval = div_down(chances.virtPropSum[i],chances.count);
			selection[i] = (properties[i] > splitval);
		}
	}

public:
	PropertySymbolCoder(RAC& racIn, Ranges &rangeIn, Tree &treeIn, int st=CONTEXT_TREE_SPLIT_THRESHOLD, int cut = 2, int alpha = 0xFFFFFFFF / 19) :
		rac(racIn),
		coder(racIn, cut, alpha),
		range(rangeIn),
		nb_properties(range.size()),
		leaf_node(1,CompoundSymbolChances<BitChance,bits>(nb_properties)),
		inner_node(treeIn),
		selection(nb_properties,false),
		split_threshold(st) {
	}

	int read_int(Properties &properties, int min, int max) {
		CompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		set_selection_and_update_property_sums(properties,chances);
		CompoundSymbolChances<BitChance,bits> &chances2 = find_leaf(properties);
		return coder.read_int(chances2, selection, min, max);
	}

	void write_int(Properties &properties, int min, int max, int val) {
		CompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		set_selection_and_update_property_sums(properties,chances);
		CompoundSymbolChances<BitChance,bits> &chances2 = find_leaf(properties);
		coder.write_int(chances2, selection, min, max, val);
	}

	int read_int(Properties &properties, int nbits) {
		CompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		set_selection_and_update_property_sums(properties,chances);
		CompoundSymbolChances<BitChance,bits> &chances2 = find_leaf(properties);
		return coder.read_int(chances2, selection, nbits);
	}

	void write_int(Properties &properties, int nbits, int val) {
		CompoundSymbolChances<BitChance,bits> &chances = find_leaf(properties);
		set_selection_and_update_property_sums(properties,chances);
		CompoundSymbolChances<BitChance,bits> &chances2 = find_leaf(properties);
		coder.write_int(chances2, selection, nbits, val);
	}

	// destructive simplification procedure, prunes subtrees with too low counts
	long long int simplify_subtree(int pos, int divisor, int min_size, int indent) {
		PropertyDecisionNode &n = inner_node[pos];
		if (n.property == -1) {
			for (int i=0;i<indent;i++) v_printf(10,"  ");
			v_printf(10,"* leaf: count=%lli, size=%llu bits, bits per int: %f\n", (long long int)leaf_node[n.leafID].count, (unsigned long long int)leaf_node[n.leafID].realSize/5461, (leaf_node[n.leafID].count > 0 ? leaf_node[n.leafID].realSize/leaf_node[n.leafID].count*1.0/5461 : -1));
			if (leaf_node[n.leafID].count == 0) return -100; // avoid empty leafs by giving them an extra penalty
			return leaf_node[n.leafID].count;
		} else {
			for (int i=0;i<indent;i++) v_printf(10,"  ");
			v_printf(10,"* test: property %i, value > %i ?  (after %lli steps)\n", n.property, n.splitval, (long long int)n.count);
			long long int subtree_size = 0;
			subtree_size += simplify_subtree(n.childID, divisor, min_size, indent+1);
			subtree_size += simplify_subtree(n.childID+1, divisor, min_size, indent+1);
			n.count /= divisor;
			if (n.count > CONTEXT_TREE_MAX_COUNT) {
			   n.count = CONTEXT_TREE_MAX_COUNT;
			}
			if (n.count < CONTEXT_TREE_MIN_COUNT) n.count=CONTEXT_TREE_MIN_COUNT;
			if (n.count > 0xf) n.count &= 0xfff8; // remove some lsb entropy
//            printf("%li COUNT\n",n.count);
			if (subtree_size < min_size) {
//                printf("  PRUNING THE ABOVE SUBTREE\n");
				n.property = -1; // procedure is destructive because the leafID is not set
			}
			return subtree_size;
		}
	}
	void simplify(int divisor=CONTEXT_TREE_COUNT_DIV, int min_size=CONTEXT_TREE_MIN_SUBTREE_SIZE) {
		v_printf(10,"TREE BEFORE SIMPLIFICATION:\n");
		simplify_subtree(0, divisor, min_size, 0);
	}
};

template <typename BitChance, typename RAC>
void MetaPropertySymbolCoder<BitChance,RAC>::write_subtree(int pos, Ranges &subrange, const Tree &tree) {
		const PropertyDecisionNode &n = tree[pos];
		int p = n.property;
		coder.write_int(0,nb_properties,p+1);
		if (p != -1) {
			coder.write_int(CONTEXT_TREE_MIN_COUNT, CONTEXT_TREE_MAX_COUNT, n.count);
//            printf("From properties 0..%i, split node at PROPERTY %i\n",nb_properties-1,p);
			int oldmin = subrange[p].first;
			int oldmax = subrange[p].second;
			assert(oldmin < oldmax);
			coder.write_int(oldmin, oldmax-1, n.splitval);
//            e_printf( "Pos %i: prop %i splitval %i in [%i..%i]\n", pos, n.property, n.splitval, oldmin, oldmax-1);
			// > splitval
			subrange[p].first = n.splitval+1;
			write_subtree(n.childID, subrange, tree);

			// <= splitval
			subrange[p].first = oldmin;
			subrange[p].second = n.splitval;
			write_subtree(n.childID+1, subrange, tree);

			subrange[p].second = oldmax;
		}
	}
template <typename BitChance, typename RAC>
void MetaPropertySymbolCoder<BitChance,RAC>::write_tree(const Tree &tree) {
		  //fprintf(stdout,"Saving tree with %lu nodes.\n",tree.size());
		  Ranges rootrange(range);
		  write_subtree(0, rootrange, tree);
	}

#endif


#endif

#endif


//#line 1 "factory.hpp"
#ifndef FLIF_FACTORY_HPP
#define FLIF_FACTORY_HPP


//#line 1 "transform.hpp"
#ifndef FLIF_TRANSFORM_HPP
#define FLIF_TRANSFORM_HPP


//#line 1 "flif_config.h"
#ifndef FLIF_FLIF_CONFIG_H
#define FLIF_FLIF_CONFIG_H

template <typename IO> using RacIn = RacInput24<IO>;

#ifdef HAS_ENCODER
template <typename IO> using RacOut = RacOutput24<IO>;
#endif

#ifdef FAST_BUT_WORSE_COMPRESSION
typedef SimpleBitChance  FLIFBitChanceMeta;
#else
typedef MultiscaleBitChance<6,SimpleBitChance>  FLIFBitChanceMeta;
#endif

#endif

template <typename IO>
class Transform {
protected:

public:
	virtual ~Transform() {};

	// On encode: init, process, save, meta, data, <encoding>
	// On decode: init,          load, meta,       <decoding>, invData           ( + optional configure anywhere)
	// Progressive decode: init, load, meta,       <decoding>, invData, <render>, data,
	//                                             <decoding>, invData, <render>, data,
	//                                             ...
	//                                             <decoding>, invData

	bool virtual init(const ColorRanges *) { return true; }
	bool virtual undo_redo_during_decode() { return true; }
	void virtual configure(const int) { }
	bool virtual load(const ColorRanges *, RacIn<IO> &) { return true; };
#ifdef HAS_ENCODER
	bool virtual process(const ColorRanges *, const Images &) { return true; };
	void virtual save(const ColorRanges *, RacOut<IO> &) const {};
	void virtual data(Images&) const {}
#endif
	const ColorRanges virtual *meta(Images&, const ColorRanges *srcRanges) { return new DupColorRanges(srcRanges); }
	void virtual invData(Images&) const {}

};

#endif

#include <string>

template <typename IO>
Transform<IO> *create_transform(std::string desc);

#endif

//#line 1 "common.hpp"
#ifndef FLIF_COMMON_HPP
#define FLIF_COMMON_HPP

#include <memory>
#include <string>
#include <string.h>

enum class Optional : uint8_t {
  undefined = 0
};

enum class flifEncoding : uint8_t {
  nonInterlaced = 1,
  interlaced = 2
};

extern int64_t pixels_todo;
extern int64_t pixels_done;
extern int progressive_qual_target;
extern int progressive_qual_shown;

#define MAX_TRANSFORM 15

extern const std::vector<std::string> transforms;

typedef SimpleBitChance                         FLIFBitChancePass1;

// faster:
#ifdef FAST_BUT_WORSE_COMPRESSION
typedef SimpleBitChance                         FLIFBitChancePass2;
typedef SimpleBitChance                         FLIFBitChanceTree;
#else
// better compression:
typedef MultiscaleBitChance<6,SimpleBitChance>  FLIFBitChancePass2;
typedef MultiscaleBitChance<6,SimpleBitChance>  FLIFBitChanceTree;
#endif

extern const int NB_PROPERTIES[];
extern const int NB_PROPERTIESA[];

extern const int NB_PROPERTIES_scanlines[];
extern const int NB_PROPERTIES_scanlinesA[];

extern const int PLANE_ORDERING[];

void initPropRanges_scanlines(Ranges &propRanges, const ColorRanges &ranges, int p);

ColorVal predict_and_calcProps_scanlines(Properties &properties, const ColorRanges *ranges, const Image &image, const int p, const uint32_t r, const uint32_t c, ColorVal &min, ColorVal &max, const ColorVal fallback);

void initPropRanges(Ranges &propRanges, const ColorRanges &ranges, int p);

template<typename I> I inline median3(I a, I b, I c) {
	if (a < b) {
		if (b < c) {
		  return b;
		} else {
		  return a < c ? c : a;
		}
	} else {
	   if (a < c) {
		  return a;
	   } else {
		  return b < c ? c : b;
	   }
	}
}

// Prediction used for interpolation / alpha=0 pixels. Does not have to be the same as the guess used for encoding/decoding.
inline ColorVal predictScanlines(const Image &image, int p, uint32_t r, uint32_t c, ColorVal grey) {
	ColorVal left = (c>0 ? image(p,r,c-1) : (r > 0 ? image(p, r-1, c) : grey));
	ColorVal top = (r>0 ? image(p,r-1,c) : left);
	ColorVal topleft = (r>0 && c>0 ? image(p,r-1,c-1) : top);
	ColorVal gradientTL = left + top - topleft;
	return median3(gradientTL, left, top);
}

// Prediction used for interpolation / alpha=0 pixels. Does not have to be the same as the guess used for encoding/decoding.
inline ColorVal predict(const Image &image, int z, int p, uint32_t r, uint32_t c) {
	if (p==4) return 0;
	if (z%2 == 0) { // filling horizontal lines
	  ColorVal top = image(p,z,r-1,c);
	  ColorVal bottom = (r+1 < image.rows(z) ? image(p,z,r+1,c) : top ); // (c > 0 ? image(p, z, r, c - 1) : top));
	  ColorVal avg = (top + bottom)>>1;
	  return avg;
	} else { // filling vertical lines
	  ColorVal left = image(p,z,r,c-1);
	  ColorVal right = (c+1 < image.cols(z) ? image(p,z,r,c+1) : left ); //(r > 0 ? image(p, z, r-1, c) : left));
	  ColorVal avg = (left + right)>>1;
	  return avg;
	}
}

// Actual prediction. Also sets properties. Property vector should already have the right size before calling this.
ColorVal predict_and_calcProps(Properties &properties, const ColorRanges *ranges, const Image &image, const int z, const int p, const uint32_t r, const uint32_t c, ColorVal &min, ColorVal &max);

int plane_zoomlevels(const Image &image, const int beginZL, const int endZL);

std::pair<int, int> plane_zoomlevel(const Image &image, const int beginZL, const int endZL, int i);

inline std::vector<ColorVal> computeGreys(const ColorRanges *ranges) {
	std::vector<ColorVal> greys; // a pixel with values in the middle of the bounds
	for (int p = 0; p < ranges->numPlanes(); p++) greys.push_back((ranges->min(p)+ranges->max(p))/2);
	return greys;
}

#endif

using namespace maniac::util;

template<typename RAC> std::string static read_name(RAC& rac) {
	UniformSymbolCoder<RAC> coder(rac);
	int nb = coder.read_int(0, MAX_TRANSFORM);
	if (nb>MAX_TRANSFORM) nb=MAX_TRANSFORM;
	return transforms[nb];
}

template<typename IO, typename Rac, typename Coder>
bool flif_decode_scanlines_inner(IO &io, Rac &rac, std::vector<Coder> &coders, Images &images, const ColorRanges *ranges, int quality,
								 std::vector<Transform<IO>*> &transforms, uint32_t (*callback)(int32_t,int64_t), Images &partial_images) {
	ColorVal min,max;
	const int nump = images[0].numPlanes();
	const bool alphazero = images[0].alpha_zero_special;
	const bool FRA = (nump == 5);
	if (callback || quality<100) {
		 // initialize planes to grey
		 for (int p=0; p<nump; p++) {
		   if (ranges->min(p) < ranges->max(p))
		   for (int fr=0; fr< (int)images.size(); fr++) {
			for (uint32_t r=0; r<images[fr].rows(); r++) {
			  for (uint32_t c=0; c<images[fr].cols(); c++) {
				images[fr].set(p,r,c,(ranges->min(p)+ranges->max(p))/2);
			  }
			}
		   }
		 }
	}

	const std::vector<ColorVal> greys = computeGreys(ranges);

	for (int k=0,i=0; k < 5; k++) {
		int p=PLANE_ORDERING[k];
		if (p>=nump) continue;
		i++;
		Properties properties((nump>3?NB_PROPERTIES_scanlinesA[p]:NB_PROPERTIES_scanlines[p]));
		if ((100*pixels_done > quality*pixels_todo)) {
		  v_printf(5,"%lu subpixels done, %lu subpixels todo, quality target %i%% reached (%i%%)\n",(long unsigned)pixels_done,(long unsigned)pixels_todo,(int)quality,(int)(100*pixels_done/pixels_todo));
		  return false;
		}
		if (ranges->min(p) < ranges->max(p)) {
		  const ColorVal minP = ranges->min(p);
		  v_printf(2,"\r%i%% done [%i/%i] DEC[%ux%u]    ",(int)(100*pixels_done/pixels_todo),i,nump,images[0].cols(),images[0].rows());
		  v_printf(4,"\n");
		  pixels_done += images[0].cols()*images[0].rows();
		  for (uint32_t r = 0; r < images[0].rows(); r++) {
			if (images[0].cols() == 0) return false; // decode aborted
			for (int fr=0; fr< (int)images.size(); fr++) {
			  Image& image = images[fr];
			  uint32_t begin=image.col_begin[r], end=image.col_end[r];
			  if (image.seen_before >= 0) { for(uint32_t c=0; c<image.cols(); c++) image.set(p,r,c,images[image.seen_before](p,r,c)); continue; }
			  if (fr>0) {
				for (uint32_t c = 0; c < begin; c++)
				   if (alphazero && p<3 && image(3,r,c) == 0) image.set(p,r,c,predictScanlines(image,p,r,c, greys[p]));
				   else if (p !=4 ) image.set(p,r,c,images[fr-1](p,r,c));
			  } else if (nump>3 && p<3) { begin=0; end=image.cols(); }
			  for (uint32_t c = begin; c < end; c++) {
				if (alphazero && p<3 && image(3,r,c) == 0) {image.set(p,r,c,predictScanlines(image,p,r,c, greys[p])); continue;}
				if (FRA && p<4 && image(4,r,c) > 0) {assert(fr >= image(4,r,c)); image.set(p,r,c,images[fr-image(4,r,c)](p,r,c)); continue;}
				ColorVal guess = predict_and_calcProps_scanlines(properties,ranges,image,p,r,c,min,max, minP);
				if (FRA && p==4 && max > fr) max = fr;
				ColorVal curr = coders[p].read_int(properties, min - guess, max - guess) + guess;
				image.set(p,r,c, curr);
			  }
			  if (fr>0) {
				for (uint32_t c = end; c < image.cols(); c++)
				   if (alphazero && p<3 && image(3,r,c) == 0) image.set(p,r,c,predictScanlines(image,p,r,c, greys[p]));
				   else if (p !=4 ) image.set(p,r,c,images[fr-1](p,r,c));
			  }
			}
		  }
		  int qual = 10000*pixels_done/pixels_todo;
		  if (callback && p != 4 && qual >= progressive_qual_target) {
			for (unsigned int n=0; n < images.size(); n++) partial_images[n] = images[n].clone(); // make a copy to work with
			for (int i=transforms.size()-1; i>=0; i--) if (transforms[i]->undo_redo_during_decode()) transforms[i]->invData(partial_images);
			progressive_qual_shown = qual;
			progressive_qual_target = callback(qual,io.ftell());
			if (qual >= progressive_qual_target) return false;
		  }
		}
	}
	return true;
}

template<typename IO, typename Rac, typename Coder>
bool flif_decode_scanlines_pass(IO& io, Rac &rac, Images &images, const ColorRanges *ranges, std::vector<Tree> &forest, int quality,
								std::vector<Transform<IO>*> &transforms, uint32_t (*callback)(int32_t,int64_t), Images &partial_images,
								int cutoff = 2, int alpha = 0xFFFFFFFF / 19) {
	std::vector<Coder> coders;
	coders.reserve(images[0].numPlanes());
	for (int p = 0; p < images[0].numPlanes(); p++) {
		Ranges propRanges;
		initPropRanges_scanlines(propRanges, *ranges, p);
		coders.emplace_back(rac, propRanges, forest[p], 0, cutoff, alpha);
	}
	return flif_decode_scanlines_inner<IO,Rac,Coder>(io, rac, coders, images, ranges, quality, transforms, callback, partial_images);
}

// interpolate rest of the image
// used when decoding lossy
void flif_decode_FLIF2_inner_interpol(Images &images, const ColorRanges *ranges, const int I,
									  const int beginZL, const int endZL, const int32_t R, const int scale) {
	for (int i = I; i < plane_zoomlevels(images[0], beginZL, endZL); i++) {
	  if (i<0) continue;
	  std::pair<int, int> pzl = plane_zoomlevel(images[0], beginZL, endZL, i);
	  int p = pzl.first;
	  int z = pzl.second;
	  if (ranges->min(p) >= ranges->max(p)) continue;
	  if ( p == 4 ) continue; // don't interpolate FRA lookback channel
	  if ( 1<<(z/2) < scale) continue;
	  pixels_done += images[0].cols(z)*images[0].rows(z)/2;
	  v_printf(2,"\r%i%% done [%i/%i] INTERPOLATE[%i,%ux%u]                 ",(int)(100*pixels_done/pixels_todo),i,plane_zoomlevels(images[0], beginZL, endZL)-1,p,images[0].cols(z),images[0].rows(z));
	  v_printf(5,"\n");

	  if (z % 2 == 0) {
		// horizontal: scan the odd rows
		  for (uint32_t r = (I==i && R>=0 ? R : 1); r < images[0].rows(z); r += 2) {
			for (Image& image : images) {
			  if (image.palette == false) {
			   for (uint32_t c = 0; c < image.cols(z); c++) {
				 image.set(p,z,r,c, predict(image,z,p,r,c));    // normal method: use predict() for interpolation
			   }
			  } else {
			   for (uint32_t c = 0; c < image.cols(z); c++) {
				 image.set(p,z,r,c, image(p,z,r-1,c));          // paletted image: no interpolation
			   }
			  }
			}
		  }
	  } else {
		// vertical: scan the odd columns
		  for (uint32_t r = (I==i && R>=0 ? R : 0); r < images[0].rows(z); r++) {
			for (Image& image : images) {
			  if (image.palette == false) {
			   for (uint32_t c = 1; c < image.cols(z); c += 2) {
				image.set(p,z,r,c, predict(image,z,p,r,c));
			   }
			  } else {
			   for (uint32_t c = 1; c < image.cols(z); c += 2) {
				image.set(p,z,r,c, image(p,z,r,c-1));
			   }
			  }
			}
		  }
	  }
	}
	v_printf(2,"\n");
}

template<typename IO, typename Rac, typename Coder>
bool flif_decode_FLIF2_inner(IO& io, Rac &rac, std::vector<Coder> &coders, Images &images, const ColorRanges *ranges,
							 const int beginZL, const int endZL, int quality, int scale, std::vector<Transform<IO>*> &transforms,
							 uint32_t (*callback)(int32_t,int64_t), Images &partial_images) {
	ColorVal min,max;
	const int nump = images[0].numPlanes();
	const bool alphazero = images[0].alpha_zero_special;
	const bool FRA = (nump == 5);
	// flif_decode
	for (int i = 0; i < plane_zoomlevels(images[0], beginZL, endZL); i++) {
	  std::pair<int, int> pzl = plane_zoomlevel(images[0], beginZL, endZL, i);
	  int p = pzl.first;
	  int z = pzl.second;
	  if ((100*pixels_done > quality*pixels_todo)) {
			  v_printf(5,"%lu subpixels done, %lu subpixels todo, quality target %i%% reached (%i%%)\n",(long unsigned)pixels_done,(long unsigned)pixels_todo,(int)quality,(int)(100*pixels_done/pixels_todo));
			  flif_decode_FLIF2_inner_interpol(images, ranges, i, beginZL, endZL, (z%2 == 0 ?1:0), scale);
			  return false;
	  }
	  if (ranges->min(p) < ranges->max(p)) {
		if (1<<(z/2) < scale) {
			  v_printf(5,"%lu subpixels done (out of %lu subpixels at this scale), scale target 1:%i reached\n",(long unsigned)pixels_done,(long unsigned)pixels_todo,(int)scale);
			  flif_decode_FLIF2_inner_interpol(images, ranges, i, beginZL, endZL, (z%2 == 0 ?1:0), scale);
			  return false;
		}
		if (endZL == 0) v_printf(2,"\r%i%% done [%i/%i] DEC[%i,%ux%u]  ",(int)(100*pixels_done/pixels_todo),i,plane_zoomlevels(images[0], beginZL, endZL)-1,p,images[0].cols(z),images[0].rows(z));
		ColorVal curr;
		Properties properties((nump>3?NB_PROPERTIESA[p]:NB_PROPERTIES[p]));
		if (z % 2 == 0) {
		  for (uint32_t r = 1; r < images[0].rows(z); r += 2) {
			if (images[0].cols() == 0) return false; // decode aborted
			pixels_done += images[0].cols(z);
			if (endZL == 0 && (r & 65)==65) v_printf(3,"\r%i%% done [%i/%i] DEC[%i,%ux%u]  ",(int)(100*pixels_done/pixels_todo),i,plane_zoomlevels(images[0], beginZL, endZL)-1,p,images[0].cols(z),images[0].rows(z));
#ifdef CHECK_FOR_BROKENFILES
			if (io.isEOF()) {
			  v_printf(1,"Row %i: Unexpected file end. Interpolation from now on.\n",r);
			  flif_decode_FLIF2_inner_interpol(images, ranges, i, beginZL, endZL, (r>1?r-2:r), scale);
			  return false;
			}
#endif
			for (int fr=0; fr<(int)images.size(); fr++) {
			  Image& image = images[fr];
			  if (image.seen_before >= 0) { for (uint32_t c=0; c<image.cols(z); c++) image.set(p,z,r,c,images[image.seen_before](p,z,r,c)); continue; }
			  uint32_t begin=image.col_begin[r*image.zoom_rowpixelsize(z)]/image.zoom_colpixelsize(z), end=1+(image.col_end[r*image.zoom_rowpixelsize(z)]-1)/image.zoom_colpixelsize(z);
			  if (fr>0) {
				for (uint32_t c = 0; c < begin; c++)
							if (alphazero && p<3 && image(3,z,r,c) == 0) image.set(p,z,r,c, predict(image,z,p,r,c));
							else if (p !=4 ) image.set(p,z,r,c,images[fr-1](p,z,r,c));
				for (uint32_t c = end; c < image.cols(z); c++)
							if (alphazero && p<3 && image(3,z,r,c) == 0) image.set(p,z,r,c, predict(image,z,p,r,c));
							else if (p !=4 ) image.set(p,z,r,c,images[fr-1](p,z,r,c));
			  } else {
				if (nump>3 && p<3) {begin=0; end=image.cols(z);}
			  }
			  for (uint32_t c = begin; c < end; c++) {
					 if (alphazero && p<3 && image(3,z,r,c) == 0) { image.set(p,z,r,c,predict(image,z,p,r,c)); continue;}
					 if (FRA && p<4 && image(4,z,r,c) > 0) { image.set(p,z,r,c,images[fr-image(4,z,r,c)](p,z,r,c)); continue;}
					 ColorVal guess = predict_and_calcProps(properties,ranges,image,z,p,r,c,min,max);
					 if (FRA && p==4 && max > fr) max = fr;
					 curr = coders[p].read_int(properties, min - guess, max - guess) + guess;
					 image.set(p,z,r,c, curr);
			  }
			}
		  }
		} else {
		  for (uint32_t r = 0; r < images[0].rows(z); r++) {
			if (images[0].cols() == 0) return false; // decode aborted
			pixels_done += images[0].cols(z)/2;
			if (endZL == 0 && (r&129)==129) v_printf(3,"\r%i%% done [%i/%i] DEC[%i,%ux%u]  ",(int)(100*pixels_done/pixels_todo),i,plane_zoomlevels(images[0], beginZL, endZL)-1,p,images[0].cols(z),images[0].rows(z));
#ifdef CHECK_FOR_BROKENFILES
			if (io.isEOF()) {
			  v_printf(1,"Row %i: Unexpected file end. Interpolation from now on.\n", r);
			  flif_decode_FLIF2_inner_interpol(images, ranges, i, beginZL, endZL, (r>0?r-1:r), scale);
			  return false;
			}
#endif
			for (int fr=0; fr<(int)images.size(); fr++) {
			  Image& image = images[fr];
			  if (image.seen_before >= 0) { for (uint32_t c=1; c<image.cols(z); c+=2) image.set(p,z,r,c,images[image.seen_before](p,z,r,c)); continue; }
			  uint32_t begin=(image.col_begin[r*image.zoom_rowpixelsize(z)]/image.zoom_colpixelsize(z)),
			  end=(1+(image.col_end[r*image.zoom_rowpixelsize(z)]-1)/image.zoom_colpixelsize(z))|1;
			  if (begin>1 && ((begin&1) ==0)) begin--;
			  if (begin==0) begin=1;
			  if (fr>0) {
				for (uint32_t c = 1; c < begin; c+=2)
							if (alphazero && p<3 && image(3,z,r,c) == 0) image.set(p,z,r,c, predict(image,z,p,r,c));
							else if (p !=4 ) image.set(p,z,r,c,images[fr-1](p,z,r,c));
				for (uint32_t c = end; c < image.cols(z); c+=2)
							if (alphazero && p<3 && image(3,z,r,c) == 0) image.set(p,z,r,c, predict(image,z,p,r,c));
							else if (p !=4 ) image.set(p,z,r,c,images[fr-1](p,z,r,c));
			  } else {
				if (nump>3 && p<3) {begin=1; end=image.cols(z);}
			  }
			  for (uint32_t c = begin; c < end; c+=2) {
					 if (alphazero && p<3 && image(3,z,r,c) == 0) { image.set(p,z,r,c,predict(image,z,p,r,c)); continue;}
					 if (FRA && p<4 && image(4,z,r,c) > 0) { image.set(p,z,r,c,images[fr-image(4,z,r,c)](p,z,r,c)); continue;}
					 ColorVal guess = predict_and_calcProps(properties,ranges,image,z,p,r,c,min,max);
					 if (FRA && p==4 && max > fr) max = fr;
					 curr = coders[p].read_int(properties, min - guess, max - guess) + guess;
					 image.set(p,z,r,c, curr);
			  }
			}
		  }
		}
		if (endZL==0) {
		  v_printf(3,"    read %li bytes   ", io.ftell());
		  v_printf(5,"\n");
		}
		int qual = 10000*pixels_done/pixels_todo;
		if (callback && p<4 && (endZL==0 || i+1 == plane_zoomlevels(images[0], beginZL, endZL)) && qual >= progressive_qual_target) {
		  for (unsigned int n=0; n < images.size(); n++) partial_images[n] = images[n].clone(); // make a copy to work with
		  int64_t pixels_really_done = pixels_done;
		  flif_decode_FLIF2_inner_interpol(partial_images, ranges, i+1, beginZL, endZL, -1, scale);
		  if (endZL>0) flif_decode_FLIF2_inner_interpol(partial_images, ranges, 0, endZL-1, 0, -1, scale);
		  pixels_done = pixels_really_done;
		  for (Image& image : partial_images) image.normalize_scale();
		  for (int i=transforms.size()-1; i>=0; i--) if (transforms[i]->undo_redo_during_decode()) transforms[i]->invData(partial_images);
		  progressive_qual_shown = qual;
		  progressive_qual_target = callback(qual,io.ftell());
		  if (qual >= progressive_qual_target) return false;
		}
	  }
	}
	return true;
}

template<typename IO, typename Rac, typename Coder>
bool flif_decode_FLIF2_pass(IO &io, Rac &rac, Images &images, const ColorRanges *ranges, std::vector<Tree> &forest,
							const int beginZL, const int endZL, int quality, int scale, std::vector<Transform<IO>*> &transforms,
							uint32_t (*callback)(int32_t,int64_t), Images &partial_images, int cutoff = 2, int alpha = 0xFFFFFFFF / 19) {
	std::vector<Coder> coders;
	coders.reserve(images[0].numPlanes());
	for (int p = 0; p < images[0].numPlanes(); p++) {
		Ranges propRanges;
		initPropRanges(propRanges, *ranges, p);
		coders.emplace_back(rac, propRanges, forest[p], 0, cutoff, alpha);
	}

	if (beginZL == images[0].zooms() && endZL > 0) {
	  // special case: very left top pixel must be read first to get it all started
	  // SimpleSymbolCoder<FLIFBitChanceMeta, Rac, 24> metaCoder(rac);
	  UniformSymbolCoder<Rac> metaCoder(rac);
	  for (int p = 0; p < images[0].numPlanes(); p++) {
		if (ranges->min(p) < ranges->max(p)) {
		  for (Image& image : images) image.set(p,0,0, metaCoder.read_int(ranges->min(p), ranges->max(p)));
		  pixels_done++;
		}
	  }
	}
	return flif_decode_FLIF2_inner<IO,Rac,Coder>(io, rac, coders, images, ranges, beginZL, endZL, quality, scale, transforms, callback, partial_images);
}

template<typename IO, typename BitChance, typename Rac> bool flif_decode_tree(IO& io, Rac &rac, const ColorRanges *ranges, std::vector<Tree> &forest, const int encoding)
{
	try {
	  for (int p = 0; p < ranges->numPlanes(); p++) {
		Ranges propRanges;
		if (encoding==1) initPropRanges_scanlines(propRanges, *ranges, p);
		else initPropRanges(propRanges, *ranges, p);
		MetaPropertySymbolCoder<BitChance, Rac> metacoder(rac, propRanges);
		if (ranges->min(p)<ranges->max(p))
		if (!metacoder.read_tree(forest[p])) {return false;}
//        forest[p].print(stdout);
	  }
	} catch (std::bad_alloc& ba) {
		e_printf("Error: could not allocate enough memory for MANIAC trees.\n");
		return false;
	  }
	return true;
}

template <int bits, typename IO>
bool flif_decode_main(RacIn<IO>& rac, IO& io, Images &images, const ColorRanges *ranges,
		std::vector<Transform<IO>*> &transforms, int quality, int scale, uint32_t (*callback)(int32_t,int64_t), Images &partial_images, int encoding, int cutoff = 2, int alpha = 0xFFFFFFFF / 19) {

	std::vector<Tree> forest(ranges->numPlanes(), Tree());
	int roughZL = 0;
	if (encoding == 2) {
	  roughZL = images[0].zooms() - NB_NOLEARN_ZOOMS-1;
	  if (roughZL < 0) roughZL = 0;
//      v_printf(2,"Decoding rough data\n");
	  if (!flif_decode_FLIF2_pass<IO, RacIn<IO>, FinalPropertySymbolCoder<FLIFBitChancePass2, RacIn<IO>, bits> >(io, rac, images, ranges, forest, images[0].zooms(), roughZL+1, 100, scale, transforms, callback, partial_images, cutoff, alpha)) return false;
	}
	if (encoding == 2 && (quality <= 0 || pixels_done >= pixels_todo)) {
	  v_printf(3,"Not decoding MANIAC tree\n");
	  return false;
	} else {
	  v_printf(3,"Decoded header + rough data. Decoding MANIAC tree.\n");
	  if (!flif_decode_tree<IO, FLIFBitChanceTree, RacIn<IO>>(io, rac, ranges, forest, encoding)) return false;
	}

	switch(encoding) {
		case 1: v_printf(3,"Decoding data (scanlines)\n");
				return flif_decode_scanlines_pass<IO, RacIn<IO>, FinalPropertySymbolCoder<FLIFBitChancePass2, RacIn<IO>, bits> >(io, rac, images, ranges, forest, quality, transforms, callback, partial_images, cutoff, alpha);
				break;
		case 2: v_printf(3,"Decoding data (interlaced)\n");
				return flif_decode_FLIF2_pass<IO, RacIn<IO>, FinalPropertySymbolCoder<FLIFBitChancePass2, RacIn<IO>, bits> >(io, rac, images, ranges, forest, roughZL, 0, quality, scale, transforms, callback, partial_images, cutoff, alpha);
				break;
	}
	return false;
}

template <typename IO>
bool flif_decode(IO& io, Images &images, int quality, int scale, uint32_t (*callback)(int32_t,int64_t), int first_callback_quality, Images &partial_images, int rw, int rh) {
	bool just_identify = false;
	if (scale == -1) just_identify=true;
	else if (scale != 1 && scale != 2 && scale != 4 && scale != 8 && scale != 16 && scale != 32 && scale != 64 && scale != 128) {
				e_printf("Invalid scale down factor: %i\n", scale);
				return false;
	}

	char buff[5];
	if (!io.gets(buff,5)) { e_printf("Could not read header from file: %s\n",io.getName()); return false; }
	if (!strcmp(buff,"!<ar")) {
	   // FLIF file in an archive, try to find find the main image
	   if (!io.gets(buff,5)) return false;
	   if (strcmp(buff,"ch>\n")) return false;
	   char ar_header[61];
	   while (true) {
		  if (!io.gets(ar_header,61)) { e_printf("Archive does not contain a FLIF image\n"); return false; }
		  if (!strncmp(ar_header,"__image.flif/",13)) {
			if (!io.gets(buff,5)) { e_printf("Corrupt archive?\n"); return false; }
			break;
		  }
		  else {
			long skip = strtol(&ar_header[48],NULL,10);
			if (skip < 0) return false;
			if (skip & 1) skip++;
			io.fseek(skip,SEEK_CUR);
		  }
	   }
	}
	if (strcmp(buff,"FLIF")) { e_printf("%s is not a FLIF file\n",io.getName()); return false; }
	int c;
	if (!ioget_int_8bit (io, &c))
		return false;
	if (c < ' ' || c > ' '+32+15+32) { e_printf("Invalid or unknown FLIF format byte\n"); return false;}
	c -= ' ';
	int numFrames=1;
	if (c > 47) {
		c -= 32;
		if (!ioget_int_8bit (io, &numFrames))
			return false;
		if (numFrames < 2 || numFrames >= 256) return false;
		if (numFrames == 0xff) {
		  if (!ioget_int_16bit_bigendian (io, &numFrames))
			return false;
		  if (numFrames < 2) return false;
		}
	}
	const int encoding=c/16;
	if (encoding < 1 || encoding > 2) { e_printf("Invalid or unknown FLIF encoding method\n"); return false;}
	if (scale != 1 && encoding==1 && !just_identify) { e_printf("Cannot decode non-interlaced FLIF file at lower scale!\n"); return false; }
	if (quality < 100 && encoding==1) { v_printf(1,"Cannot decode non-interlaced FLIF file at lower quality! Ignoring quality...\n");}
	int numPlanes=c%16;
	if (numPlanes < 1 || numPlanes > 4 || numPlanes == 2) {e_printf("Invalid FLIF header (unsupported color channels)\n"); return false;}
	if (!ioget_int_8bit (io, &c))
		return false;
	if (c < '0' || c > '2')  {e_printf("Invalid FLIF header (unsupported color depth)\n"); return false;}

	int width;
	int height;
	if (!ioget_int_16bit_bigendian (io, &width))
		return false;
	if (!ioget_int_16bit_bigendian (io, &height))
		return false;
	if (width < 1 || height < 1) {e_printf("Invalid FLIF header\n"); return false;}

	RacIn<IO> rac(io);
	SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> metaCoder(rac);

//    image.init(width, height, 0, 0, 0);
	v_printf(3,"Decoding %ux%u image, channels:",width,height);
	int maxmax=0;
	for (int p = 0; p < numPlanes; p++) {
//        int min = 0;
		int max = 255;
		if (c=='2') max=65535;
		else if (c=='0') max=(1 << metaCoder.read_int(1, 16)) - 1;
		if (max>maxmax) maxmax=max;
//        image.add_plane(min, max);
//        v_printf(2," [%i] %i bpp (%i..%i)",p,ilog2(image.max(p)+1),image.min(p), image.max(p));
		if (c=='0') v_printf(3," [%i] %i bpp",p,ilog2(max+1));
	}
	if (c=='1') v_printf(3," %i, depth: 8 bit",numPlanes);
	if (c=='2') v_printf(3," %i, depth: 16 bit",numPlanes);
	if (numFrames>1) v_printf(3,", frames: %i",numFrames);
	bool alphazero=false;
	if (numPlanes>3) {
		alphazero=metaCoder.read_int(0, 1);
		if (!alphazero) v_printf(3, ", store RGB at A=0");
	}
	v_printf(3,"\n");
	if (just_identify) {
		v_printf(1,"%s: ",io.getName());
		if (numFrames == 1) v_printf(1,"FLIF image");
		else v_printf(1,"FLIF animation, %i frames",numFrames);
		v_printf(1,", %ux%u, ", width, height);
		if (c=='1') v_printf(1,"8-bit ");
		else if (c=='2') v_printf(1,"16-bit ");
		else if (c=='0') v_printf(1,"%i-bit ", ilog2(maxmax+1));
		if (numPlanes == 1) v_printf(1,"grayscale");
		else if (numPlanes == 3) v_printf(1,"RGB");
		else if (numPlanes == 4) v_printf(1,"RGBA");
		if (encoding == 1) v_printf(1,", non-interlaced");
		else if (encoding == 2) v_printf(1,", interlaced");
		v_printf(1,"\n");
		return true;
	}
	if (numFrames>1) {
		// ignored for now (assuming loop forever)
		metaCoder.read_int(0, 100); // repeats (0=infinite)
	}
	if (rw || rh) {
	  if (scale > 1) e_printf("Don't use -s and (-r or -f) at the same time! Ignoring -s...\n");
	  scale = 1;
	  if (rw < 0 || rh < 0) { e_printf("Negative target dimension? Really?\n"); return false; }
	  while ( (rw && (((width-1)/scale)+1) > rw)   || (rh && (((height-1)/scale)+1) > rh) ) scale *= 2;
	}
	if (scale != 1 && encoding==1) { v_printf(1,"Cannot decode non-interlaced FLIF file at lower scale! Ignoring resize target...\n"); scale = 1;}

	int scale_shift = ilog2(scale);
	if (scale_shift>0) v_printf(3,"Decoding downscaled image at scale 1:%i (%ix%i -> %ix%i)\n", scale, width, height, ((width-1)/scale)+1, ((height-1)/scale)+1);
	for (int i=0; i<numFrames; i++) {
	  images.push_back(Image(scale_shift));
	  if (!images[i].init(width,height,0,maxmax,numPlanes)) return false;
	  images[i].alpha_zero_special = alphazero;
	  if (numFrames>1) images[i].frame_delay = metaCoder.read_int(0, 60000); // time in ms between frames
	  if (callback) partial_images.push_back(Image(scale_shift));
	  //if (numFrames>1) partial_images[i].frame_delay = images[i].frame_delay;
	}

	int cutoff = 2;
	int alpha = 0xFFFFFFFF / 19;
	if (metaCoder.read_int(0,1)) {
	  cutoff = metaCoder.read_int(1,128);
	  alpha = 0xFFFFFFFF / metaCoder.read_int(2,128);
	  if (metaCoder.read_int(0,1)) {
		e_printf("Not yet implemented: non-default bitchance initialization\n");
		return false;
	  }
	}
	std::vector<const ColorRanges*> rangesList;
	std::vector<Transform<IO>*> transforms;
	rangesList.push_back(getRanges(images[0]));
	v_printf(4,"Transforms: ");
	int tcount=0;

	while (rac.read_bit()) {
		std::string desc = read_name(rac);
		Transform<IO> *trans = create_transform<IO>(desc);
		if (!trans) {
			e_printf("\nUnknown transformation '%s'\nTry upgrading your FLIF decoder?\n", desc.c_str());
			return false;
		}
		if (!trans->init(rangesList.back())) {
			e_printf("Transformation '%s' failed\nTry upgrading your FLIF decoder?\n", desc.c_str());
			return false;
		}
		if (tcount++ > 0) v_printf(4,", ");
		v_printf(4,"%s", desc.c_str());
		if (desc == "Frame_Lookback") {
				if (images.size()<2) return false;
				trans->configure(images.size());
		}
		if (desc == "Frame_Shape") {
				if (images.size()<2) return false;
				int unique_frames=images.size()-1; // not considering first frame
				for (Image& i : images) if (i.seen_before >= 0) unique_frames--;
				if (unique_frames < 1) {return false;}
				trans->configure(unique_frames*images[0].rows()); trans->configure(images[0].cols()); }
		if (desc == "Duplicate_Frame") { if (images.size()<2) return false; else trans->configure(images.size()); }
		if (desc == "Palette_Alpha") { trans->configure(images[0].alpha_zero_special); }
		if (!trans->load(rangesList.back(), rac)) return false;
		rangesList.push_back(trans->meta(images, rangesList.back()));
		transforms.push_back(trans);
	}
	if (tcount==0) v_printf(4,"none\n"); else v_printf(4,"\n");
	const ColorRanges* ranges = rangesList.back();

	int realnumplanes = 0;
	for (int i=0; i<ranges->numPlanes(); i++) if (ranges->min(i)<ranges->max(i)) realnumplanes++;
	pixels_todo = (int64_t)width*height*realnumplanes/scale/scale;
	pixels_done = 0;
	if (pixels_todo == 0) pixels_todo = pixels_done = 1;
	progressive_qual_target = first_callback_quality;
	progressive_qual_shown = -1;
	v_printf(9,"%lu subpixels done, %lu subpixels todo, quality target %i%%\n",(long unsigned)pixels_done,(long unsigned)pixels_todo,(int)quality);

	for (int p = 0; p < ranges->numPlanes(); p++) {
	  v_printf(10,"Plane %i: %i..%i\n",p,ranges->min(p),ranges->max(p));
	}

	for (int p = 0; p < ranges->numPlanes(); p++) {
		if (ranges->min(p) >= ranges->max(p)) {
			v_printf(6,"Constant plane %i at color value %i\n",p,ranges->min(p));
			for (int fr = 0; fr < numFrames; fr++)
				images[fr].make_constant_plane(p,ranges->min(p));
		}
	}
	int mbits = 0;
	for (int p = 0; p < ranges->numPlanes(); p++) {
		if (ranges->max(p) > ranges->min(p)) {
		  int nBits = ilog2((ranges->max(p) - ranges->min(p))*2-1)+1;
		  if (nBits > mbits) mbits = nBits;
		}
	}
	int bits = 10;
#ifdef SUPPORT_HDR
	if (mbits >10) bits=18;
	if (mbits > bits) { e_printf("FLIF cannot decode >16 bit per channel. How did this happen?\n"); return false;}
#else
	if (mbits > bits) { e_printf("This FLIF cannot decode >8 bit per channel. Please compile with SUPPORT_HDR.\n"); return false;}
#endif
	bool fully_decoded;
	if (bits == 10) {
	   fully_decoded = flif_decode_main<10>(rac, io, images, ranges, transforms, quality, scale, callback, partial_images, encoding, cutoff, alpha);
#ifdef SUPPORT_HDR
	} else {
	   fully_decoded = flif_decode_main<18>(rac, io, images, ranges, transforms, quality, scale, callback, partial_images, encoding, cutoff, alpha);
#endif
	}

   if (numFrames==1)
	  v_printf(2,"\rDecoding done, %li bytes for %ux%u pixels (%.4fbpp)   \n",io.ftell(), images[0].cols()/scale, images[0].rows()/scale, 8.0*io.ftell()/images[0].rows()*scale*scale/images[0].cols());
	else
	  v_printf(2,"\rDecoding done, %li bytes for %i frames of %ux%u pixels (%.4fbpp)   \n",io.ftell(), numFrames, images[0].cols()/scale, images[0].rows()/scale, 8.0*io.ftell()/numFrames/images[0].rows()*scale*scale/images[0].cols());

	for (Image& i : images) i.normalize_scale();

	for (int i=(int)transforms.size()-1; i>=0; i--) {
		transforms[i]->invData(images);
		delete transforms[i];
	}
	transforms.clear();
	for (unsigned int i=0; i<rangesList.size(); i++) {
		delete rangesList[i];
	}
	rangesList.clear();

	if (alphazero) for (Image& image : images) image.make_invisible_rgb_black();

	if (quality>=100 && scale==1 && fully_decoded) {
	  bool contains_checksum = metaCoder.read_int(0,1);
	  if (contains_checksum) {
		const uint32_t checksum = images[0].checksum();
		v_printf(8,"Computed checksum: %X\n", checksum);
		uint32_t checksum2 = metaCoder.read_int(16);
		checksum2 *= 0x10000;
		checksum2 += metaCoder.read_int(16);
		v_printf(8,"Read checksum: %X\n", checksum2);
		if (checksum != checksum2) {
		  v_printf(1,"\nCORRUPTION DETECTED: checksums don't match (computed: %x v/s read: %x)! (partial file?)\n\n", checksum, checksum2);
		} else {
		  v_printf(2,"Image decoded, checksum verified.\n");
		}
	  } else {
		v_printf(2,"Image decoded, does not contain a checksum.\n");
	  }
	} else if (quality < 100 || scale > 1) {
	  v_printf(2,"Not checking checksum, lossy partial decoding was chosen.\n");
	} else {
	  v_printf(1,"File ended prematurely or decoding was interrupted.\n");
	}

	// ensure that the callback gets called even if the image is completely constant
	if (progressive_qual_target > 10000) progressive_qual_target = 10000;
	if (callback && progressive_qual_target > progressive_qual_shown) {
		for (unsigned int n=0; n < images.size(); n++) partial_images[n] = images[n].clone(); // make a copy to work with
		callback(10000*pixels_done/pixels_todo,io.ftell());
	}

	return true;
}

template bool flif_decode(FileIO& io, Images &images, int quality, int scale, uint32_t (*callback)(int32_t,int64_t), int, Images &partial_images, int, int);
template bool flif_decode(BlobReader& io, Images &images, int quality, int scale, uint32_t (*callback)(int32_t,int64_t), int, Images &partial_images, int, int);


//#line 1 "common.cpp"
const std::vector<std::string> transforms = {"Channel_Compact", "YCoCg", "Bounds",
											 "Palette_Alpha", "Palette", "?? Palette_Chroma ??", "Color_Buckets",
											 "Duplicate_Frame", "Frame_Shape", "Frame_Lookback",
											 "?? YCbCr ??", "?? DCT ??", "?? DWT ??", "?? Quantization ??",
											 "?? Reserved ??", "?? Other ??" };
// Plenty of room for future extensions: transform "Other" can be used to encode identifiers of arbitrary many other transforms

int64_t pixels_todo = 0;
int64_t pixels_done = 0;
int progressive_qual_target = 0;
int progressive_qual_shown = -1;

const int PLANE_ORDERING[] = {4,3,0,1,2}; // FRA, A, Y, I, Q

const int NB_PROPERTIES_scanlines[] = {7,8,9,7,7};
const int NB_PROPERTIES_scanlinesA[] = {8,9,10,7,7};

void initPropRanges_scanlines(Ranges &propRanges, const ColorRanges &ranges, int p) {
	propRanges.clear();
	int min = ranges.min(p);
	int max = ranges.max(p);
	int mind = min - max, maxd = max - min;

	if (p < 3) {
	  for (int pp = 0; pp < p; pp++) {
		propRanges.push_back(std::make_pair(ranges.min(pp), ranges.max(pp)));  // pixels on previous planes
	  }
	  if (ranges.numPlanes()>3) propRanges.push_back(std::make_pair(ranges.min(3), ranges.max(3)));  // pixel on alpha plane
	}
	propRanges.push_back(std::make_pair(min,max));   // guess (median of 3)
	propRanges.push_back(std::make_pair(0,2));       // which predictor was it
	propRanges.push_back(std::make_pair(mind,maxd));
	propRanges.push_back(std::make_pair(mind,maxd));
	propRanges.push_back(std::make_pair(mind,maxd));
	propRanges.push_back(std::make_pair(mind,maxd));
	propRanges.push_back(std::make_pair(mind,maxd));
}

ColorVal predict_and_calcProps_scanlines(Properties &properties, const ColorRanges *ranges, const Image &image, const int p, const uint32_t r, const uint32_t c, ColorVal &min, ColorVal &max, const ColorVal fallback) {
	ColorVal guess;
	int which = 0;
	int index=0;
	if (p < 3) {
	  for (int pp = 0; pp < p; pp++) {
		properties[index++] = image(pp,r,c);
	  }
	  if (image.numPlanes()>3) properties[index++] = image(3,r,c);
	}
	ColorVal left = (c>0 ? image(p,r,c-1) : (r > 0 ? image(p, r-1, c) : fallback));
	ColorVal top = (r>0 ? image(p,r-1,c) : left);
	ColorVal topleft = (r>0 && c>0 ? image(p,r-1,c-1) : (r > 0 ? top : left));
	ColorVal gradientTL = left + top - topleft;
	guess = median3(gradientTL, left, top);
	ranges->snap(p,properties,min,max,guess);
	assert(min >= ranges->min(p));
	assert(max <= ranges->max(p));
	assert(guess >= min);
	assert(guess <= max);
	if (guess == gradientTL) which = 0;
	else if (guess == left) which = 1;
	else if (guess == top) which = 2;

	properties[index++] = guess;
	properties[index++] = which;

	if (c > 0 && r > 0) { properties[index++] = left - topleft; properties[index++] = topleft - top; }
				 else   { properties[index++] = 0; properties[index++] = 0;  }

	if (c+1 < image.cols() && r > 0) properties[index++] = top - image(p,r-1,c+1); // top - topright
				 else   properties[index++] = 0;
	if (r > 1) properties[index++] = image(p,r-2,c)-top;    // toptop - top
		 else properties[index++] = 0;
	if (c > 1) properties[index++] = image(p,r,c-2)-left;    // leftleft - left
		 else properties[index++] = 0;
	return guess;
}

const int NB_PROPERTIES[] = {8,9,8,8,8};
const int NB_PROPERTIESA[] = {9,10,9,8,8};

void initPropRanges(Ranges &propRanges, const ColorRanges &ranges, int p) {
	propRanges.clear();
	int min = ranges.min(p);
	int max = ranges.max(p);
	int mind = min - max, maxd = max - min;
	if (p < 3) {       // alpha channel first
	  for (int pp = 0; pp < p; pp++) {
		propRanges.push_back(std::make_pair(ranges.min(pp), ranges.max(pp)));  // pixels on previous planes
	  }
	  if (ranges.numPlanes()>3) propRanges.push_back(std::make_pair(ranges.min(3), ranges.max(3)));  // pixel on alpha plane
	}
	propRanges.push_back(std::make_pair(mind,maxd)); // neighbor A - neighbor B   (top-bottom or left-right)
	propRanges.push_back(std::make_pair(min,max));   // guess (median of 3)
	propRanges.push_back(std::make_pair(0,2));       // which predictor was it
	propRanges.push_back(std::make_pair(mind,maxd));
	propRanges.push_back(std::make_pair(mind,maxd));
	propRanges.push_back(std::make_pair(mind,maxd));

	if (p < 2 || p >= 3) {
	  propRanges.push_back(std::make_pair(mind,maxd));
	  propRanges.push_back(std::make_pair(mind,maxd));
	}
}

// Actual prediction. Also sets properties. Property vector should already have the right size before calling this.
ColorVal predict_and_calcProps(Properties &properties, const ColorRanges *ranges, const Image &image, const int z, const int p, const uint32_t r, const uint32_t c, ColorVal &min, ColorVal &max) ATTRIBUTE_HOT;
ColorVal predict_and_calcProps(Properties &properties, const ColorRanges *ranges, const Image &image, const int z, const int p, const uint32_t r, const uint32_t c, ColorVal &min, ColorVal &max) {
	ColorVal guess;
	int which = 0;
	int index = 0;

	if (p < 3) {
	  for (int pp = 0; pp < p; pp++) {
		properties[index++] = image(pp,z,r,c);
	  }
	  if (image.numPlanes()>3) properties[index++] = image(3,z,r,c);
	}
	ColorVal left;
	ColorVal top;
	ColorVal topleft;
	ColorVal topright;
	if (z%2 == 0) { // filling horizontal lines
	  top = image(p,z,r-1,c);
	  left = (c>0 ? image(p,z,r,c-1) : top);
	  topleft = (c>0 ? image(p,z,r-1,c-1) : top);
	  topright = (c+1 < image.cols(z) ? image(p,z,r-1,c+1) : top);
	  const ColorVal gradientTL = left + top - topleft;
	  const bool bottomPresent = r+1 < image.rows(z);
	  const ColorVal bottom = (bottomPresent ? image(p,z,r+1,c) : left);
	  const ColorVal bottomleft = (bottomPresent && c>0 ? image(p,z,r+1,c-1) : bottom);
	  const ColorVal gradientBL = left + bottom - bottomleft;
	  const ColorVal avg = (top + bottom)>>1;
	  guess = median3(gradientTL, gradientBL, avg);
	  ranges->snap(p,properties,min,max,guess);
	  if (guess == avg) which = 0;
	  else if (guess == gradientTL) which = 1;
	  else if (guess == gradientBL) which = 2;
	  properties[index++] = top-bottom;
	} else { // filling vertical lines
	  left = image(p,z,r,c-1);
	  top = (r>0 ? image(p,z,r-1,c) : left);
	  topleft = (r>0 ? image(p,z,r-1,c-1) : left);
	  const bool rightPresent = c+1 < image.cols(z);
	  const ColorVal right = (rightPresent ? image(p,z,r,c+1) : top);
	  topright = (r>0 && rightPresent ? image(p,z,r-1,c+1) : right);
	  const ColorVal gradientTL = left + top - topleft;
	  const ColorVal gradientTR = right + top - topright;
	  ColorVal avg = (left + right)>>1;
	  guess = median3(gradientTL, gradientTR, avg);
	  ranges->snap(p,properties,min,max,guess);
	  if (guess == avg) which = 0;
	  else if (guess == gradientTL) which = 1;
	  else if (guess == gradientTR) which = 2;
	  properties[index++] = left-right;
	}
	properties[index++]=guess;
	properties[index++]=which;

	if (c > 0 && r > 0) { properties[index++]=left - topleft; properties[index++]=topleft - top; }
				 else   { properties[index++]=0; properties[index++]=0; }

	if (c+1 < image.cols(z) && r > 0) properties[index++]=top - topright;
				 else   properties[index++]=0;

	if (p < 2 || p >= 3) {
	 if (r > 1) properties[index++]=image(p,z,r-2,c)-top;    // toptop - top
		 else properties[index++]=0;
	 if (c > 1) properties[index++]=image(p,z,r,c-2)-left;    // leftleft - left
		 else properties[index++]=0;
	}
	return guess;
}

int plane_zoomlevels(const Image &image, const int beginZL, const int endZL) {
	return image.numPlanes() * (beginZL - endZL + 1);
}

std::pair<int, int> plane_zoomlevel(const Image &image, const int beginZL, const int endZL, int i) {
	assert(i >= 0);
	assert(i < plane_zoomlevels(image, beginZL, endZL));
	// simple order: interleave planes, zoom in
//    int p = i % image.numPlanes();
//    int zl = beginZL - (i / image.numPlanes());

	// more advanced order: give priority to more important plane(s)
	// assumption: plane 0 is Y, plane 1 is I, plane 2 is Q, plane 3 is perhaps alpha, plane 4 are frame lookbacks (FRA transform, animation only)
	const int max_behind[] = {0, 2, 4, 0, 0};
	int np = image.numPlanes();
	if (np>5) {
	  // too many planes, do something simple
	  int p = i % image.numPlanes();
	  int zl = beginZL - (i / image.numPlanes());
	  return std::pair<int, int>(p,zl);
	}
	std::vector<int> czl(np);
	for (int &pzl : czl) pzl = beginZL+1;
	int highest_priority_plane = 0;
	if (np >= 4) highest_priority_plane = 3; // alpha first
	if (np >= 5) highest_priority_plane = 4; // lookbacks first
	int nextp = highest_priority_plane;
	while (i >= 0) {
	  czl[nextp]--;
	  i--;
	  if (i<0) break;
	  nextp=highest_priority_plane;
	  for (int p=0; p<np; p++) {
		if (czl[p] > czl[highest_priority_plane] + max_behind[p]) {
		  nextp = p; //break;
		}
	  }
	  // ensure that nextp is not at the most detailed zoomlevel yet
	  while (czl[nextp] <= endZL) nextp = (nextp+1)%np;
	}
	int p = nextp;
	int zl = czl[p];

	return std::pair<int, int>(p,zl);
}


//#line 1 "symbol.cpp"
#include <sstream>

#ifdef STATS
std::string SymbolChanceStats::format() const {
	std::stringstream ss;
	ss << "zero," << stats_zero.format() << ", ";
	ss << "sign," << stats_sign.format() << ", ";
	for (int i = 0; i < 17; i++) {
		ss << "e" << i << "," << stats_exp[i].format() << ", ";
	}
	for (int i = 0; i < 18; i++) {
		ss << "m" << i << "," << stats_mant[i].format() << ", ";
	}
	return ss.str();
}

SymbolChanceStats::~SymbolChanceStats() {
	fprintf(stderr, "STATS: %s\n", format().c_str());
}

SymbolChanceStats global_symbol_stats;
#endif


//#line 1 "factory.cpp"
#include <string>


//#line 1 "ycocg.hpp"
#ifndef FLIF_YCOCG_HPP
#define FLIF_YCOCG_HPP

#include <algorithm>

#define clip(x,l,u)   if ((x) < (l)) {(x)=(l);} else if ((x) > (u)) {(x)=(u);}

/*
	Explanation of lossless YCoCg:

	 Y = Luminance (near* weighted average of RGB in 1:2:1).
	 C = Chroma.
	Co = Amount of [o]range chrome. Max = orange, 0 = gray, min = blue.
	Cg = Amount of [g]reen chrome. Max = green, 0 = gray, min = purple.

	RGB -> YCoCg
	------------
	Co = R - B          <1> | This makes sense, if R = B, then we are gray.
							| If maximally orange, B = 0, R = max.
							| If maximally blue, B = max, R = 0.

	 p = (R + B)/2          | [P]urple, is the average of red/blue, truncated.
	 p = (2B + R - B)/2     | All these steps should be obviously
	 p = B + (R - B)/2      | equal, losslessly.
	 p = B + Co/2       <2>

	Cg = G - p          <3> | Again, makes sense, green vs. purple.

	 Y = p + Cg/2       <4> | Near* weighted average of RGB in 1:2:1.
	 Y = p + (G - p)/2
	 Y ~= p + G/2 - p/2     | *These steps are not lossless (they can be off by
	 Y ~= p/2 + G/2         | 1 or perhaps 2), but illustrate that Y is a near
	 Y ~= (R + B)/4 + G/2   | weighted average of RGB in 1:2:1.

	YCoCg -> RGB
	------------
	p = Y - Cg/2       <4>
	G = Cg + p         <3>
	B = p - Co/2       <2>
	R = Co + B         <1>
*/

ColorVal static inline get_min_y(int) {
	return 0;
}

ColorVal static inline get_max_y(int par) {
	return par*4-1;
}

ColorVal static inline get_min_co(int par, ColorVal y) {
	assert(y >= get_min_y(par));
	assert(y <= get_max_y(par));

	if (y<par-1) {
	  return -3-4*y;
	} else if (y>=3*par) {
	  return 4*(1+y-4*par);
	} else {
	  return -4*par+1;
	}
}

ColorVal static inline get_max_co(int par, ColorVal y) {
	assert(y >= get_min_y(par));
	assert(y <= get_max_y(par));

	if (y<par-1) {
	  return 3+4*y;
	} else if (y>=3*par) {
	  return 4*par-4*(1+y-3*par);
	} else {
	  return 4*par-1;
	}
}

ColorVal static inline get_min_cg(int par, ColorVal y, ColorVal co) {
	assert(y >= get_min_y(par));
	assert(y <= get_max_y(par));
	if (co < get_min_co(par,y)) return 8*par; //invalid value
	if (co > get_max_co(par,y)) return 8*par; //invalid value
	// assert(i >= get_min_co(par,y));
	// assert(i <= get_max_co(par,y));

	if (y<par-1) {
	  return -(2*y+1);
	} else if (y>=3*par) {
	  return -(2*(4*par-1-y)-((1+abs(co))/2)*2);
	} else {
	  return -std::min(2*par-1+(y-par+1)*2, 2*par+(3*par-1-y)*2-((1+abs(co))/2)*2);
	}
}

ColorVal static inline get_max_cg(int par, ColorVal y, ColorVal co) {
	assert(y >= get_min_y(par));
	assert(y <= get_max_y(par));

	if (co < get_min_co(par,y)) return -8*par; //invalid value
	if (co > get_max_co(par,y)) return -8*par; //invalid value
	// assert(i >= get_min_co(par,y));
	// assert(i <= get_max_co(par,y));

	if (y<par-1) {
	  return 1+2*y-(abs(co)/2)*2;
	} else if (y>=3*par) {
	  return 2*(4*par-1-y);
	} else {
	  return -std::max(-4*par + (1+y-2*par)*2, -2*par-(y-par)*2-1+(abs(co)/2)*2);
	}

}

class ColorRangesYCoCg final : public ColorRanges {
protected:
//    const int par=64; // range: [0..4*par-1]
	const int par;
	const ColorRanges *ranges;
public:
	ColorRangesYCoCg(int parIn, const ColorRanges *rangesIn)
			: par(parIn), ranges(rangesIn) {
	//        if (parIn != par) printf("OOPS: using YCoCg transform on something other than rgb888 ?\n");
	}
	bool isStatic() const { return false; }
	int numPlanes() const { return ranges->numPlanes(); }

	ColorVal min(int p) const {
	  switch(p) {
		case 0: return 0;
		case 1: return -4*par+1;
		case 2: return -4*par+1;
		default: return ranges->min(p);
	  };
	}
	ColorVal max(int p) const {
	  switch(p) {
		case 0: return 4*par-1;
		case 1: return 4*par-1;
		case 2: return 4*par-1;
		default: return ranges->max(p);
	  };
	}

	void minmax(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv) const {
		 if (p==1) { minv=get_min_co(par, pp[0]); maxv=get_max_co(par, pp[0]); return; }
		 else if (p==2) { minv=get_min_cg(par, pp[0], pp[1]); maxv=get_max_cg(par, pp[0], pp[1]); return; }
		 else if (p==0) { minv=0; maxv=get_max_y(par); return;}
		 else ranges->minmax(p,pp,minv,maxv);
	}
};

template <typename IO>
class TransformYCoCg : public Transform<IO> {
protected:
	int par;
	const ColorRanges *ranges;

public:
	bool virtual init(const ColorRanges *srcRanges) {
		if (srcRanges->numPlanes() < 3) return false;
		if (srcRanges->min(0) < 0 || srcRanges->min(1) < 0 || srcRanges->min(2) < 0) return false;
		if (srcRanges->min(0) == srcRanges->max(0) || srcRanges->min(1) == srcRanges->max(1) || srcRanges->min(2) == srcRanges->max(2)) return false;
		int max = std::max(std::max(srcRanges->max(0), srcRanges->max(1)), srcRanges->max(2));
		par = max/4+1;
		ranges = srcRanges;
		return true;
	}

	const ColorRanges *meta(Images&, const ColorRanges *srcRanges) {
		return new ColorRangesYCoCg(par, srcRanges);
	}

#ifdef HAS_ENCODER
	void data(Images& images) const {
//        printf("TransformYCoCg::data: par=%i\n", par);
		ColorVal R,G,B,Y,Co,Cg;
		for (Image& image : images)
		for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				R=image(0,r,c);
				G=image(1,r,c);
				B=image(2,r,c);

				Y = (((R + B)>>1) + G)>>1;
				Co = R - B;
				Cg = G - ((R + B)>>1);
/* alternative: (not exactly the same!)
				Co = R - B;
				ColorVal p = B + Co/2;
				Cg = G - p;
				Y = p + Cg/2;
*/
				image.set(0,r,c, Y);
				image.set(1,r,c, Co);
				image.set(2,r,c, Cg);
			}
		}
	}
#endif
	void invData(Images& images) const {
		ColorVal R,G,B,Y,Co,Cg;
		const ColorVal max[3] = {ranges->max(0), ranges->max(1), ranges->max(2)};
		for (Image& image : images) {
		  image.undo_make_constant_plane(0);
		  image.undo_make_constant_plane(1);
		  image.undo_make_constant_plane(2);
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				Y=image(0,r,c);
				Co=image(1,r,c);
				Cg=image(2,r,c);

				// the >> is assumed to be an arithmetic right shift, i.e. >>1 is dividing by two ROUNDED DOWN (not rounding towards zero)
				// this is strictly speaking not guaranteed behavior on signed ints, so to be sure we'll check it at compile time
#if (((-1)>>1) == -1)
				// R = Y + ((1-Cg)>>1) + ((Co+1)>>1);
				G = Y - ((-Cg)>>1);
				B = Y + ((1-Cg)>>1) - (Co>>1);
				R = Co + B;
#else
				Intentional syntax error: bitshift (>>) is not behaving as expected on negative integers
#endif

/* alternative (not exactly the same!)
				ColorVal p = Y - Cg/2;
				G = Cg + p;
				B = p - Co/2;
				R = Co + B;
*/

				clip(R, 0, max[0]); // clipping only needed in case of lossy/partial decoding
				clip(G, 0, max[1]);
				clip(B, 0, max[2]);

				image.set(0,r,c, R);
				image.set(1,r,c, G);
				image.set(2,r,c, B);
			}
		  }
		}
	}
};

#endif

//#include "yc1c2.hpp"

//#line 1 "bounds.hpp"
#ifndef FLIF_BOUNDS_HPP
#define FLIF_BOUNDS_HPP

#include <vector>

class ColorRangesBounds final : public ColorRanges {
protected:
	const std::vector<std::pair<ColorVal, ColorVal> > bounds;
	const ColorRanges *ranges;
public:
	ColorRangesBounds(const std::vector<std::pair<ColorVal, ColorVal> > &boundsIn, const ColorRanges *rangesIn) : bounds(boundsIn), ranges(rangesIn) {}
	bool isStatic() const { return false; }
	int numPlanes() const { return bounds.size(); }
	ColorVal min(int p) const { assert(p<numPlanes()); return std::max(ranges->min(p), bounds[p].first); }
	ColorVal max(int p) const { assert(p<numPlanes()); return std::min(ranges->max(p), bounds[p].second); }
	void snap(const int p, const prevPlanes &pp, ColorVal &min, ColorVal &max, ColorVal &v) const {
		if (p==0 || p==3) { min=bounds[p].first; max=bounds[p].second; } // optimization for special case
		else ranges->snap(p,pp,min,max,v);
		if (min < bounds[p].first) min=bounds[p].first;
		if (max > bounds[p].second) max=bounds[p].second;
		if (min>max) {
		   // should happen only if alpha=0 interpolation produces YI combination for which Q range from ColorRangesYIQ is outside bounds
		   min=bounds[p].first;
		   max=bounds[p].second;
		}
		if(v>max) v=max;
		if(v<min) v=min;
	}
	void minmax(const int p, const prevPlanes &pp, ColorVal &min, ColorVal &max) const {
		assert(p<numPlanes());
		if (p==0 || p==3) { min=bounds[p].first; max=bounds[p].second; return; } // optimization for special case
		ranges->minmax(p, pp, min, max);
		if (min < bounds[p].first) min=bounds[p].first;
		if (max > bounds[p].second) max=bounds[p].second;
		if (min>max) {
		   // should happen only if alpha=0 interpolation produces YI combination for which Q range from ColorRangesYIQ is outside bounds
		   min=bounds[p].first;
		   max=bounds[p].second;
		}
		assert(min <= max);
	}
};

template <typename IO>
class TransformBounds : public Transform<IO> {
protected:
	std::vector<std::pair<ColorVal, ColorVal> > bounds;

	bool undo_redo_during_decode() { return false; }

	const ColorRanges *meta(Images&, const ColorRanges *srcRanges) {
		if (srcRanges->isStatic()) {
			return new StaticColorRanges(bounds);
		} else {
			return new ColorRangesBounds(bounds, srcRanges);
		}
	}

	bool load(const ColorRanges *srcRanges, RacIn<IO> &rac) {
		SimpleSymbolCoder<SimpleBitChance, RacIn<IO>, 18> coder(rac);
		bounds.clear();
		for (int p=0; p<srcRanges->numPlanes(); p++) {
//            ColorVal min = coder.read_int(0, srcRanges->max(p) - srcRanges->min(p)) + srcRanges->min(p);
//            ColorVal max = coder.read_int(0, srcRanges->max(p) - min) + min;
			ColorVal min = coder.read_int(srcRanges->min(p), srcRanges->max(p));
			ColorVal max = coder.read_int(min, srcRanges->max(p));
			if (min > max) return false;
			if (min < srcRanges->min(p)) return false;
			if (max > srcRanges->max(p)) return false;
			bounds.push_back(std::make_pair(min,max));
			v_printf(5,"[%i:%i..%i]",p,min,max);
		}
		return true;
	}

#ifdef HAS_ENCODER
	void save(const ColorRanges *srcRanges, RacOut<IO> &rac) const {
		SimpleSymbolCoder<SimpleBitChance, RacOut<IO>, 18> coder(rac);
		for (int p=0; p<srcRanges->numPlanes(); p++) {
			ColorVal min = bounds[p].first;
			ColorVal max = bounds[p].second;
//            coder.write_int(0, srcRanges->max(p) - srcRanges->min(p), min - srcRanges->min(p));
//            coder.write_int(0, srcRanges->max(p) - min, max - min);
			coder.write_int(srcRanges->min(p), srcRanges->max(p), min);
			coder.write_int(min, srcRanges->max(p), max);
			v_printf(5,"[%i:%i..%i]",p,min,max);
		}
	}

	bool process(const ColorRanges *srcRanges, const Images &images) {
		bounds.clear();
		bool trivialbounds=true;
		int nump=srcRanges->numPlanes();
		for (int p=0; p<nump; p++) {
			ColorVal min = srcRanges->max(p);
			ColorVal max = srcRanges->min(p);
			for (const Image& image : images)
			for (uint32_t r=0; r<image.rows(); r++) {
				for (uint32_t c=0; c<image.cols(); c++) {
					if (image.alpha_zero_special && nump>3 && p<3 && image(3,r,c)==0) continue; // don't take fully transparent pixels into account
					ColorVal v = image(p,r,c);
					if (v < min) min = v;
					if (v > max) max = v;
					assert(v <= srcRanges->max(p));
					assert(v >= srcRanges->min(p));
				}
			}
			if (min > max) min = max = (min+max)/2; // this can happen if the image is fully transparent
			bounds.push_back(std::make_pair(min,max));
			if (min > srcRanges->min(p)) trivialbounds=false;
			if (max < srcRanges->max(p)) trivialbounds=false;
		}
		return !trivialbounds;
	}
#endif
};

#endif



//#line 1 "colorbuckets.hpp"
#ifndef FLIF_COLORBUCKETS_HPP
#define FLIF_COLORBUCKETS_HPP

#include <vector>

#define MAX_PER_BUCKET_0 255
#define MAX_PER_BUCKET_1 510
// if bucket0 and bucket1 are big enough to be exact (and no simplification happens!), then we don't need the bit to check for empty buckets
//#define MAX_PER_BUCKET_1 20

#define MAX_PER_BUCKET_2 5
#define MAX_PER_BUCKET_3 255
const unsigned int max_per_colorbucket[] = {MAX_PER_BUCKET_0, MAX_PER_BUCKET_1, MAX_PER_BUCKET_2, MAX_PER_BUCKET_3};

// quantization constants
#define CB0a 1
#define CB0b 1
#define CB1 4

static int totaldiscretecolors=0;
static int totalcontinuousbuckets=0;

class ColorBucket {
public:
	ColorVal min;
	ColorVal max;
	std::vector<ColorVal> values;
	bool discrete;
	std::vector<ColorVal> snapvalues;

	ColorBucket() {
		min = 10000;  // +infinity
		max = -10000; // -infinity    (set to empty interval to start with)
		discrete = true;
	}
	void addColor(const ColorVal c, const unsigned int max_per_bucket) {
		if (c<min) min=c;
		if (c>max) max=c;
		if (discrete) {
		  unsigned int pos=0;
		  for(; pos < values.size(); pos++) {
				if (c == values[pos]) return;
				if (values[pos] > c) break;
		  }
		  if (values.size() < max_per_bucket) {
				values.insert(values.begin()+pos, c);
				totaldiscretecolors++;
		  } else {
				totaldiscretecolors -= max_per_bucket;
				values.clear();
				discrete=false;
				totalcontinuousbuckets++;
		  }
		}
	}

	void removeColor(const ColorVal c) {
		if (discrete) {
		  unsigned int pos=0;
		  for(; pos < values.size(); pos++) {
				if (c == values[pos]) {
				   values.erase(values.begin()+pos);
				   break;
				}
		  }
		  if (c==min) min = values[0];
		  if (c==max) max = values[values.size()-1];
		} else {
		  if (c==min) min++;
		  if (c==max) max--;
		  if (c>max) return;
		  if (c<min) return;
		  discrete=true;
		  values.clear();
		  for (ColorVal x=min; x <= max; x++) {
			if (x != c) values.push_back(x);
		  }
		}
	}

	bool empty() const {
	   return (min>max);
	}
	ColorVal snapColor_slow(const ColorVal c) const {
		if (c <= min) return min;
		if (c >= max) return max;
		if (discrete) {
		  ColorVal mindiff = abs(c-min);
		  unsigned int best = 0;
		  for(unsigned int i=1; i < values.size(); i++) {
				if (c == values[i]) return c;
				ColorVal diff = abs(c-values[i]);
				if (diff < mindiff) {best = i; mindiff = diff;}
				if (values[i] > c) break; // can safely skip the rest, values is sorted
		  }
		  return values[best];
		}
		return c;
	}
	void prepare_snapvalues() {
		if (discrete) {
				snapvalues.clear();
				for (ColorVal c=min; c<max; c++) {
						snapvalues.push_back(snapColor_slow(c));
				}
		}
	}
	void simplify_lossless() {
		if (discrete) {
				if ((int)values.size() == max-min+1) {
						discrete=false;  // bucket actually contains a continuous range
						totaldiscretecolors -= values.size();
						totalcontinuousbuckets++;
						values.clear();
				}
		}
	}
	void simplify(int percent) {
		if (empty()) return;
		simplify_lossless();
		if (discrete) {
				// heuristic: turn discrete bucket into a continuous one if it is dense enough
				if ((int)values.size()-2 > (max-min-1)*percent/100) {
						discrete=false; // more than <percent> of the ]min,max[ values are present
						totaldiscretecolors -= values.size();
						totalcontinuousbuckets++;
						values.clear();
				}
		}
	}

	ColorVal snapColor(const ColorVal c) const {
		if (c <= min) return min;
		if (c >= max) return max;
		if (discrete) {
		  assert((ColorVal)snapvalues.size() > c-min);
		  return snapvalues[c-min];
		}
		return c;
	}
	void print() const {
		if (min>max) printf("E ");
		else if (min==max) printf("S%i ",min);
		else {
				if (discrete) {
						printf("D[");
						for (ColorVal c : values) printf("%i%c",c,(c<max?',':']'));
						printf(" ");
				} else {
						printf("C%i..%i ",min,max);
				}
		}
	}
	void printshort() const {
		if (min>max) printf(".");
		else if (min==max) printf("1");
		else {
				if (discrete) {
						if (values.size()>9) printf("+"); else printf("%u",(unsigned int) values.size());
				} else {
						printf("C");
				}
		}
	}
};

class ColorBuckets {
public:
	ColorBucket bucket0;
	int min0, min1;
	std::vector<ColorBucket> bucket1;
	std::vector<std::vector<ColorBucket> > bucket2;
	ColorBucket bucket3;
	const ColorRanges *ranges;
	ColorBuckets(const ColorRanges *r) : bucket0(), min0(r->min(0)), min1(r->min(1)),
										 bucket1((r->max(0) - min0)/CB0a +1),
										 bucket2((r->max(0) - min0)/CB0b +1, std::vector<ColorBucket>((r->max(1) - min1)/CB1 +1)),
										 bucket3(),
										 ranges(r) {}
	ColorBucket& findBucket(const int p, const prevPlanes &pp) {
		assert(p>=0); assert(p<4);
		if (p==0) return bucket0;
		if (p==1) return bucket1[(pp[0]-min0)/CB0a];
		if (p==2) return bucket2[(pp[0]-min0)/CB0b][(pp[1]-min1)/CB1];
		else return bucket3;
	}
	const ColorBucket& findBucket(const int p, const prevPlanes &pp) const {
		assert(p>=0); assert(p<4);
		if (p==0) return bucket0;
		if (p==1) return bucket1[(pp[0]-min0)/CB0a];
		if (p==2) return bucket2[(pp[0]-min0)/CB0b][(pp[1]-min1)/CB1];
		else return bucket3;
	}
	void addColor(const std::vector<ColorVal> &pixel) {
		for (unsigned int p=0; p < pixel.size(); p++) {
				findBucket(p, pixel).addColor(pixel[p],max_per_colorbucket[p]);
		}
	}

	bool exists(const int p, const prevPlanes &pp) const {
		if (p>0 && (pp[0] < min0 || pp[0] > ranges->max(0))) return false;
		if (p>1 && (pp[1] < min1 || pp[1] > ranges->max(1))) return false;

		ColorVal rmin, rmax;
		ColorVal v=pp[p];
		ranges->snap(p,pp,rmin,rmax,v);
		if (v != pp[p]) return false;   // bucket empty because of original range constraints

		const ColorBucket b = findBucket(p,pp);
		//if (b.min > b.max) return false;
		if (b.snapColor_slow(pp[p]) != pp[p]) return false;
		return true;
	}
	bool exists(const int p, const prevPlanes &lower, const prevPlanes &upper) const {
		prevPlanes pixel=lower;
		if (p==0) {
		   for (pixel[0]=lower[0]; pixel[0] <= upper[0]; pixel[0]++)
				if (exists(p,pixel)) return true;
		}
		if (p==1) {
		   for (pixel[0]=lower[0]; pixel[0] <= upper[0]; pixel[0]++) {
			 for (pixel[1]=lower[1]; pixel[1] <= upper[1]; pixel[1]++) {
				if (exists(p,pixel)) return true;
			 }
		   }
		}
		return false;
	}
	void print() {
		printf("Y buckets:\n");
		bucket0.print();
		printf("\nI buckets:\n");
		for (auto b : bucket1) b.print();
		printf("\nQ buckets:\n  ");
		for (auto bs : bucket2) { for (auto b : bs) b.print(); printf("\n  ");}
		if (ranges->numPlanes() > 3) {
		  printf("Alpha buckets:\n");
		  bucket3.print();
		}
	}
};

class ColorRangesCB final : public ColorRanges {
protected:
	const ColorRanges *ranges;
	const ColorBuckets *buckets;
	const ColorBucket& bucket(const int p, const prevPlanes &pp) const { return buckets->findBucket(p,pp); }
public:
	ColorRangesCB(const ColorRanges *rangesIn, ColorBuckets *cbIn) :  ranges(rangesIn), buckets(cbIn) {} //print();}
	~ColorRangesCB() {
		delete buckets;
	}
	bool isStatic() const { return false; }
	int numPlanes() const { return ranges->numPlanes(); }
	ColorVal min(int p) const { return ranges->min(p); }
	ColorVal max(int p) const { return ranges->max(p); }
	void snap(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv, ColorVal &v) const {
		const ColorBucket& b = bucket(p,pp);
		minv=b.min;
		maxv=b.max;
		if (b.min > b.max) { e_printf("Corruption detected!\n"); minv=v=min(p); maxv=max(p); return; } // this should only happen on malicious input files
		v=b.snapColor(v);
	}
	void minmax(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv) const {
		const ColorBucket& b = bucket(p,pp);
		minv=b.min;
		maxv=b.max;
		if (b.min > b.max) { e_printf("Corruption detected!\n"); minv=min(p); maxv=max(p); } // this should only happen on malicious input files
	}
/*    void print() {
		buckets->print();
	}
*/
};

template <typename IO>
class TransformCB : public Transform<IO> {
protected:
	ColorBuckets *cb;
	bool really_used;

	~TransformCB() {if (!really_used) delete cb;}
	bool undo_redo_during_decode() { return false; }

	const ColorRanges* meta(Images&, const ColorRanges *srcRanges) {
//        cb->print();
		really_used = true;

		// in the I buckets, some discrete buckets may have become continuous to keep the colorbucket info small
		// this means some Q buckets are empty, which means that some values from the I buckets can be eliminated
		if (srcRanges->min(2) < srcRanges->max(2)) {  // only do this if the Q buckets are actually in use
		  prevPlanes pixelL,pixelU;
		  pixelL.push_back(cb->min0);
		  pixelU.push_back(cb->min0+CB0b-1);
		  pixelL.push_back(cb->min1);
		  pixelU.push_back(cb->min1+CB1-1);
		  for (auto bv : cb->bucket2) {
				pixelL[1] = cb->min1;
				pixelU[1] = cb->min1+CB1-1;
				for (auto b : bv) {
						if (b.empty()) {
								for (ColorVal c=pixelL[1]; c<=pixelU[1]; c++) {
								  cb->findBucket(1,pixelL).removeColor(c);
								  cb->findBucket(1,pixelU).removeColor(c);
								}
						}
						pixelL[1] += CB1; pixelU[1] += CB1;
				}
				pixelL[0] += CB0b; pixelU[0] += CB0b;
		  }
		}
		cb->bucket0.prepare_snapvalues();
		cb->bucket3.prepare_snapvalues();
		for (auto& b : cb->bucket1) b.prepare_snapvalues();
		for (auto& bv : cb->bucket2) for (auto& b : bv) b.prepare_snapvalues();

		return new ColorRangesCB(srcRanges, cb);
	}
	bool init(const ColorRanges *srcRanges) {
		cb = NULL;
		really_used = false;
		if(srcRanges->numPlanes() < 3) return false;
		if (srcRanges->min(1) == srcRanges->max(1) && srcRanges->min(2) == srcRanges->max(2)) return false; // monochrome image
		if (srcRanges->min(0) == 0 && srcRanges->max(0) == 0 && srcRanges->min(2) == 0 && srcRanges->max(2) == 0) return false; // probably palette image
		if (srcRanges->min(0) == srcRanges->max(0) &&
			srcRanges->min(1) == srcRanges->max(1) &&
			srcRanges->min(2) == srcRanges->max(2)) return false; // only alpha plane contains information
//        if (srcRanges->max(0) > 255) return false; // do not attempt this on high bit depth images (TODO: generalize color bucket quantization!)
		if (srcRanges->max(0)-srcRanges->min(0) > 4096) return false; // do not attempt this on high bit depth images (TODO: generalize color bucket quantization!)
		if (srcRanges->max(1)-srcRanges->min(1) > 4096) return false;
		if (srcRanges->min(1) == srcRanges->max(1)) return false; // middle channel not used, buckets are not going to help
//        if (srcRanges->min(2) == srcRanges->max(2)) return false;
		cb = new ColorBuckets(srcRanges);
		return true;
	}

	void minmax(const ColorRanges *srcRanges, const int p, const prevPlanes &lower, const prevPlanes &upper, ColorVal &smin, ColorVal &smax) const {
		ColorVal rmin, rmax;
		smin=10000;
		smax=-10000;
		prevPlanes pixel=lower;
		if (p==0) {
				srcRanges->minmax(p,pixel,smin,smax);
		} else if (p==1) {
		   for (pixel[0]=lower[0]; pixel[0] <= upper[0]; pixel[0]++) {
				srcRanges->minmax(p,pixel,rmin,rmax);
				if (rmin<smin) smin=rmin;
				if (rmax>smax) smax=rmax;
		   }
		} else if (p==2) {
		   for (pixel[0]=lower[0]; pixel[0] <= upper[0]; pixel[0]++) {
			 for (pixel[1]=lower[1]; pixel[1] <= upper[1]; pixel[1]++) {
				srcRanges->minmax(p,pixel,rmin,rmax);
				if (rmin<smin) smin=rmin;
				if (rmax>smax) smax=rmax;
			 }
		   }
		} else if (p==3) {
				srcRanges->minmax(p,pixel,smin,smax);
		}
	}

	const ColorBucket load_bucket(SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> &coder, const ColorRanges *srcRanges, const int plane, const prevPlanes &pixelL, const prevPlanes &pixelU) const {
		ColorBucket b;
		if (plane<3)
		for (int p=0; p<plane; p++) {
				if (!cb->exists(p,pixelL,pixelU)) return b;
		}
//        SimpleBitCoder<FLIFBitChanceMeta, RacIn> bcoder(rac);

		ColorVal smin,smax;
		minmax(srcRanges,plane,pixelL,pixelU,smin,smax);

		int exists = coder.read_int(0, 1);
		if (exists == 0) {
		   return b; // empty bucket
		}
		if (smin == smax) {b.min = b.max = smin; b.discrete=false; return b;}
		b.min = coder.read_int(smin, smax);
		b.max = coder.read_int(b.min, smax);
		if (b.min == b.max) { b.discrete=false; return b; }
		if (b.min + 1 == b.max) { b.discrete=false; return b; }
		b.discrete = coder.read_int(0,1);
		if (b.discrete) {
		   int nb = coder.read_int(2, std::min((int)max_per_colorbucket[plane],b.max-b.min));
		   b.values.push_back(b.min);
		   ColorVal v=b.min;
			 for (int p=1; p < nb-1; p++) {
			   b.values.push_back(coder.read_int(v+1, b.max+1-nb+p));
			   v = b.values[p];
			 }
		   if (b.min < b.max) b.values.push_back(b.max);
		}
		return b;
	}
	bool load(const ColorRanges *srcRanges, RacIn<IO> &rac) {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coder(rac);
		prevPlanes pixelL, pixelU;
		cb->bucket0 = load_bucket(coder, srcRanges, 0, pixelL, pixelU);
		pixelL.push_back(cb->min0);
		pixelU.push_back(cb->min0+CB0a-1);
		for (ColorBucket& b : cb->bucket1) {b=load_bucket(coder, srcRanges, 1, pixelL, pixelU); pixelL[0] += CB0a; pixelU[0] += CB0a; }
		if (srcRanges->min(2) < srcRanges->max(2)) {
		  pixelL[0] = cb->min0;
		  pixelU[0] = cb->min0+CB0b-1;
		  pixelL.push_back(cb->min1);
		  pixelU.push_back(cb->min1+CB1-1);
		  for (auto& bv : cb->bucket2) {
				pixelL[1] = cb->min1;
				pixelU[1] = cb->min1+CB1-1;
				for (ColorBucket& b : bv) {
						b=load_bucket(coder, srcRanges, 2, pixelL, pixelU);
						pixelL[1] += CB1; pixelU[1] += CB1;
				}
				pixelL[0] += CB0b; pixelU[0] += CB0b;
		  }
		}
		if (srcRanges->numPlanes() > 3) cb->bucket3 = load_bucket(coder, srcRanges, 3, pixelL, pixelU);
		return true;
	}

#ifdef HAS_ENCODER
	void save_bucket(const ColorBucket &b, SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> &coder, const ColorRanges *srcRanges, const int plane, const prevPlanes &pixelL, const prevPlanes &pixelU) const {
		if (plane<3)
		for (int p=0; p<plane; p++) {
				if (!cb->exists(p,pixelL,pixelU)) {
						if (!b.empty()) {printf("\nBucket does not exist but is not empty!\n"); assert(false);}
						return;
				}
		}
		ColorVal smin,smax;
		minmax(srcRanges,plane,pixelL,pixelU,smin,smax);

		if (b.min > b.max) {
				coder.write_int(0, 1, 0);  // empty bucket
				return;
		} else coder.write_int(0, 1, 1);  // non-empty bucket
		if (smin==smax) { return;}

		coder.write_int(smin, smax, b.min);
		coder.write_int(b.min, smax, b.max);
		if (b.min == b.max) return;  // singleton bucket
		if (b.min + 1  == b.max) return; // bucket contains two consecutive values
		coder.write_int(0, 1, b.discrete);
		if (b.discrete) {
		   assert((int)b.values.size() < b.max-b.min+1); // no discrete buckets that are completely full
		   coder.write_int(2, std::min((int)max_per_colorbucket[plane],b.max-b.min), b.values.size());
		   ColorVal v=b.min;
		   int nb = b.values.size();
		   for (int p=1; p < nb - 1; p++) {
			   coder.write_int(v+1, b.max+1-nb+p, b.values[p]);
			   v = b.values[p];
		   }
		}
	}
	void save(const ColorRanges *srcRanges, RacOut<IO> &rac) const {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coder(rac);
//        printf("Saving Y Color Bucket: ");
		prevPlanes pixelL, pixelU;
		save_bucket(cb->bucket0, coder, srcRanges, 0, pixelL, pixelU);
//        printf("\nSaving I Color Buckets\n  ");
		pixelL.push_back(cb->min0);
		pixelU.push_back(cb->min0+CB0a-1);
		for (auto& b : cb->bucket1) { save_bucket(b, coder, srcRanges, 1, pixelL, pixelU); pixelL[0] += CB0a; pixelU[0] += CB0a; }
//        printf("\nSaving Q Color Buckets\n  ");
		if (srcRanges->min(2) < srcRanges->max(2)) {
		  pixelL[0] = cb->min0;
		  pixelU[0] = cb->min0+CB0b-1;
		  pixelL.push_back(cb->min1);
		  pixelU.push_back(cb->min1+CB1-1);
		  for (auto& bv : cb->bucket2) {
				pixelL[1] = cb->min1;
				pixelU[1] = cb->min1+CB1-1;
				for (auto& b : bv) {
						save_bucket(b, coder, srcRanges, 2, pixelL, pixelU);
						pixelL[1] += CB1; pixelU[1] += CB1;
				}
				pixelL[0] += CB0b; pixelU[0] += CB0b;
		  }
		}
//        printf("\n");
		if (srcRanges->numPlanes() > 3) {
//          printf("Saving Alpha Color Bucket: ");
		  save_bucket(cb->bucket3, coder, srcRanges, 3, pixelL, pixelU);
//          printf("\n");
		}
	}

	bool process(const ColorRanges *srcRanges, const Images &images) {
			std::vector<ColorVal> pixel(images[0].numPlanes());
			// fill buckets
			for (const Image& image : images)
			for (uint32_t r=0; r<image.rows(); r++) {
				for (uint32_t c=0; c<image.cols(); c++) {
				  int p;
				  for (p=0; p<image.numPlanes(); p++) {
					ColorVal v = image(p,r,c);
					pixel[p] = v;
				  }
				  if (image.alpha_zero_special && p>3 && pixel[3]==0) { cb->findBucket(3, pixel).addColor(0,max_per_colorbucket[3]); continue;}
				  cb->addColor(pixel);
				}
			}

			cb->bucket0.simplify_lossless();
			cb->bucket3.simplify_lossless();
			for (auto& b : cb->bucket1) b.simplify_lossless();
			for (auto& bv : cb->bucket2) for (auto& b : bv) b.simplify_lossless();

		// TODO: IMPROVE THESE HEURISTICS!
		// TAKE IMAGE SIZE INTO ACCOUNT!
		// CONSIDER RELATIVE AREA OF BUCKETS / BOUNDS!

//            printf("Filled color buckets with %i discrete colors + %i continous buckets\n",totaldiscretecolors,totalcontinuousbuckets);

			int64_t total_pixels = (int64_t) images.size() * images[0].rows() * images[0].cols();
			v_printf(7,", [D=%i,C=%i,P=%i]",totaldiscretecolors,totalcontinuousbuckets,(int) (total_pixels/100));
			if (totaldiscretecolors < total_pixels/200 && totalcontinuousbuckets < total_pixels/50) return true;
			if (totaldiscretecolors < total_pixels/100 && totalcontinuousbuckets < total_pixels/200) return true;
			if (totaldiscretecolors < total_pixels/40 && totalcontinuousbuckets < total_pixels/500) return true;

			// simplify buckets
			for (int factor = 95; factor >= 35; factor -= 10) {
				for (auto& b : cb->bucket1) b.simplify(factor);
				for (auto& bv : cb->bucket2) for (auto& b : bv) b.simplify(factor-20);
				v_printf(8,"->[D=%i,C=%i]",totaldiscretecolors,totalcontinuousbuckets);
				if (totaldiscretecolors < total_pixels/200 && totalcontinuousbuckets < total_pixels/100) return true;
			}
			return false;
	}
#endif
};

#endif


//#line 1 "palette.hpp"
#ifndef FLIF_PALETTE_HPP
#define FLIF_PALETTE_HPP

#include <tuple>
#ifdef HAS_ENCODER
#include <set>
#endif

#define MAX_PALETTE_SIZE 30000

class ColorRangesPalette final : public ColorRanges {
protected:
	const ColorRanges *ranges;
	int nb_colors;
public:
	ColorRangesPalette(const ColorRanges *rangesIn, const int nb) : ranges(rangesIn), nb_colors(nb) { }
	bool isStatic() const { return false; }
	int numPlanes() const { return ranges->numPlanes(); }

	ColorVal min(int p) const { if (p<3) return 0; else return ranges->min(p); }
	ColorVal max(int p) const { switch(p) {
										case 0: return 0;
										case 1: return nb_colors-1;
										case 2: return 0;
										default: return ranges->max(p);
										 };
							  }
	void minmax(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv) const {
		 if (p==1) { minv=0; maxv=nb_colors-1; return;}
		 else if (p<3) { minv=0; maxv=0; return;}
		 else ranges->minmax(p,pp,minv,maxv);
	}

};

template <typename IO>
class TransformPalette : public Transform<IO> {
protected:
	typedef std::tuple<ColorVal,ColorVal,ColorVal> Color;
	std::vector<Color> Palette_vector;
	unsigned int max_palette_size;
	bool ordered_palette;

public:
	void configure(const int setting) {
		if (setting>0) { ordered_palette=true; max_palette_size = setting;}
		else {ordered_palette=false; max_palette_size = -setting;}
	}
	bool init(const ColorRanges *srcRanges) {
		if (srcRanges->numPlanes() < 3) return false;
		if (srcRanges->max(0) == 0 && srcRanges->max(2) == 0 &&
			srcRanges->numPlanes() > 3 && srcRanges->min(3) == 1 && srcRanges->max(3) == 1) return false; // already did PLA!
//        if (srcRanges->min(0) < 0 || srcRanges->min(1) < 0 || srcRanges->min(2) < 0) return false;
		if (srcRanges->min(1) == srcRanges->max(1)
		 && srcRanges->min(2) == srcRanges->max(2)) return false;  // probably grayscale/monochrome, better not use palette then
		return true;
	}

	const ColorRanges *meta(Images& images, const ColorRanges *srcRanges) {
		for (Image& image : images) image.palette=true;
		return new ColorRangesPalette(srcRanges, Palette_vector.size());
	}
	void invData(Images& images) const {
		for (Image& image : images) {
		  image.undo_make_constant_plane(0);
		  image.undo_make_constant_plane(1); // only needed when there is only one palette color, so plane 1 is also constant
		  image.undo_make_constant_plane(2);
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				int P=image(1,r,c);
				image.set(0,r,c, std::get<0>(Palette_vector[P]));
				image.set(1,r,c, std::get<1>(Palette_vector[P]));
				image.set(2,r,c, std::get<2>(Palette_vector[P]));
			}
		  }
		  image.palette=false;
		}
	}

#ifdef HAS_ENCODER
	bool process(const ColorRanges *, const Images &images) {
		if (ordered_palette) {
		  std::set<Color> Palette;
		  for (const Image& image : images)
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				int Y=image(0,r,c), I=image(1,r,c), Q=image(2,r,c);
				if (image.alpha_zero_special && image.numPlanes()>3 && image(3,r,c)==0) continue;
				Palette.insert(Color(Y,I,Q));
				if (Palette.size() > max_palette_size) return false;
			}
		  }
		  for (Color c : Palette) Palette_vector.push_back(c);
		} else {
		  for (const Image& image : images)
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				int Y=image(0,r,c), I=image(1,r,c), Q=image(2,r,c);
				if (image.alpha_zero_special && image.numPlanes()>3 && image(3,r,c)==0) continue;
				Color C(Y,I,Q);
				bool found=false;
				for (Color c : Palette_vector) if (c==C) {found=true; break;}
				if (!found) {
					Palette_vector.push_back(C);
					if (Palette_vector.size() > max_palette_size) return false;
				}
			}
		  }
		}
//        printf("Palette size: %lu\n",Palette.size());
		return true;
	}
	void data(Images& images) const {
//        printf("TransformPalette::data\n");
		for (Image& image : images) {
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				Color C(image(0,r,c), image(1,r,c), image(2,r,c));
				ColorVal P=0;
				for (Color c : Palette_vector) {if (c==C) break; else P++;}
//                image.set(0,r,c, 0);
				image.set(1,r,c, P);
//                image.set(2,r,c, 0);
			}
		  }
		  image.make_constant_plane(0,0);
		  image.make_constant_plane(2,0);
		}
	}
	void save(const ColorRanges *srcRanges, RacOut<IO> &rac) const {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coder(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coderY(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coderI(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coderQ(rac);
		coder.write_int(1, MAX_PALETTE_SIZE, Palette_vector.size());
//        printf("Saving %lu colors: ", Palette_vector.size());
		prevPlanes pp(2);
		int sorted=(ordered_palette? 1 : 0);
		coder.write_int(0, 1, sorted);
		if (sorted) {
			Color min(srcRanges->min(0), srcRanges->min(1), srcRanges->min(2));
			Color max(srcRanges->max(0), srcRanges->max(1), srcRanges->max(2));
			Color prev(-1,-1,-1);
			for (Color c : Palette_vector) {
				ColorVal Y=std::get<0>(c);
				coderY.write_int(std::get<0>(min), std::get<0>(max), Y);
				pp[0]=Y; srcRanges->minmax(1,pp,std::get<1>(min), std::get<1>(max));
				ColorVal I=std::get<1>(c);
				coderI.write_int((std::get<0>(prev) == Y ? std::get<1>(prev): std::get<1>(min)), std::get<1>(max), I);
				pp[1]=I; srcRanges->minmax(2,pp,std::get<2>(min), std::get<2>(max));
				coderQ.write_int(std::get<2>(min), std::get<2>(max), std::get<2>(c));
				std::get<0>(min) = std::get<0>(c);
				prev = c;
			}
		} else {
			ColorVal min, max;
			for (Color c : Palette_vector) {
				ColorVal Y=std::get<0>(c);
				srcRanges->minmax(0,pp,min,max);
				coderY.write_int(min,max,Y);
				pp[0]=Y; srcRanges->minmax(1,pp,min,max);
				ColorVal I=std::get<1>(c);
				coderI.write_int(min, max, I);
				pp[1]=I; srcRanges->minmax(2,pp,min,max);
				coderQ.write_int(min, max, std::get<2>(c));
//                printf("YIQ(%i,%i,%i)\t", std::get<0>(c), std::get<1>(c), std::get<2>(c));
			}
		}
//        printf("\nSaved palette of size: %lu\n",Palette_vector.size());
		v_printf(5,"[%lu]",Palette_vector.size());
		if (!ordered_palette) v_printf(5,"Unsorted");
	}
#endif
	bool load(const ColorRanges *srcRanges, RacIn<IO> &rac) {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coder(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coderY(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coderI(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coderQ(rac);
		long unsigned size = coder.read_int(1, MAX_PALETTE_SIZE);
//        printf("Loading %lu colors: ", size);
		prevPlanes pp(2);
		int sorted = coder.read_int(0,1);
		if (sorted) {
			Color min(srcRanges->min(0), srcRanges->min(1), srcRanges->min(2));
			Color max(srcRanges->max(0), srcRanges->max(1), srcRanges->max(2));
			Color prev(-1,-1,-1);
			for (unsigned int p=0; p<size; p++) {
				ColorVal Y=coderY.read_int(std::get<0>(min), std::get<0>(max));
				pp[0]=Y; srcRanges->minmax(1,pp,std::get<1>(min), std::get<1>(max));
				ColorVal I=coderI.read_int((std::get<0>(prev) == Y ? std::get<1>(prev): std::get<1>(min)), std::get<1>(max));
				pp[1]=I; srcRanges->minmax(2,pp,std::get<2>(min), std::get<2>(max));
				ColorVal Q=coderQ.read_int(std::get<2>(min), std::get<2>(max));
				Color c(Y,I,Q);
				Palette_vector.push_back(c);
				std::get<0>(min) = std::get<0>(c);
				prev = c;
			}
		} else {
			ColorVal min, max;
			for (unsigned int p=0; p<size; p++) {
				srcRanges->minmax(0,pp,min,max);
				ColorVal Y=coderY.read_int(min,max);
				pp[0]=Y; srcRanges->minmax(1,pp,min,max);
				ColorVal I=coderI.read_int(min,max);
				pp[1]=I; srcRanges->minmax(2,pp,min,max);
				ColorVal Q=coderQ.read_int(min,max);
				Color c(Y,I,Q);
				Palette_vector.push_back(c);
//                printf("YIQ(%i,%i,%i)\t", std::get<0>(c), std::get<1>(c), std::get<2>(c));
			}
		}
//        printf("\nLoaded palette of size: %lu\n",Palette_vector.size());
		v_printf(5,"[%lu]",Palette_vector.size());
		return true;
	}
};

#endif


//#line 1 "palette_A.hpp"
#ifndef FLIF_PALETTE_A_HPP
#define FLIF_PALETTE_A_HPP

#include <tuple>
#include <set>

#define MAX_PALETTE_SIZE 30000

class ColorRangesPaletteA final : public ColorRanges {
protected:
	const ColorRanges *ranges;
	int nb_colors;
public:
	ColorRangesPaletteA(const ColorRanges *rangesIn, const int nb) : ranges(rangesIn), nb_colors(nb) { }
	bool isStatic() const { return false; }
	int numPlanes() const { return ranges->numPlanes(); }

	ColorVal min(int p) const { if (p<3) return 0; else if (p==3) return 1; else return ranges->min(p); }
	ColorVal max(int p) const { switch(p) {
										case 0: return 0;
										case 1: return nb_colors-1;
										case 2: return 0;
										case 3: return 1;
										default: return ranges->max(p);
										 };
							  }
	void minmax(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv) const {
		 if (p==1) { minv=0; maxv=nb_colors-1; return;}
		 else if (p<3) { minv=0; maxv=0; return;}
		 else if (p==3) { minv=1; maxv=1; return;}
		 else ranges->minmax(p,pp,minv,maxv);
	}

};

template <typename IO>
class TransformPaletteA : public Transform<IO> {
protected:
	typedef std::tuple<ColorVal,ColorVal,ColorVal,ColorVal> Color;
	std::vector<Color> Palette_vector;
	unsigned int max_palette_size;
	bool alpha_zero_special;
	bool ordered_palette;

public:
	// dirty hack: max_palette_size is ignored at decode time, alpha_zero_special will be set at encode time
	void configure(const int setting) {
		alpha_zero_special = setting;
		if (setting>0) { ordered_palette=true; max_palette_size = setting;}
		else {ordered_palette=false; max_palette_size = -setting;}
	}
	bool init(const ColorRanges *srcRanges) {
		if (srcRanges->numPlanes() < 4) return false;
		if (srcRanges->min(3) == srcRanges->max(3)) return false; // don't try this if the alpha plane is not actually used
		return true;
	}

	const ColorRanges *meta(Images& images, const ColorRanges *srcRanges) {
		for (Image& image : images) image.palette=true;
		return new ColorRangesPaletteA(srcRanges, Palette_vector.size());
	}

	void invData(Images& images) const {
		for (Image& image : images) {
		  image.undo_make_constant_plane(0);
		  image.undo_make_constant_plane(1);
		  image.undo_make_constant_plane(2);
		  image.undo_make_constant_plane(3);
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				int P=image(1,r,c);
				image.set(0,r,c, std::get<1>(Palette_vector[P]));
				image.set(1,r,c, std::get<2>(Palette_vector[P]));
				image.set(2,r,c, std::get<3>(Palette_vector[P]));
				image.set(3,r,c, std::get<0>(Palette_vector[P]));
			}
		  }
		  image.palette=false;
		}
	}

#if HAS_ENCODER
	bool process(const ColorRanges *srcRanges, const Images &images) {
		if (images[0].alpha_zero_special) alpha_zero_special = true; else alpha_zero_special = false;
		if (ordered_palette) {
		  std::set<Color> Palette;
		  for (const Image& image : images)
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				int Y=image(0,r,c), I=image(1,r,c), Q=image(2,r,c), A=image(3,r,c);
				if (alpha_zero_special && A==0) { Y=I=Q=0; }
				Palette.insert(Color(A,Y,I,Q));  // alpha first so sorting makes more sense (?)
				if (Palette.size() > max_palette_size) return false;
			}
		  }
		  for (Color c : Palette) Palette_vector.push_back(c);
		} else {
		  for (const Image& image : images)
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				int Y=image(0,r,c), I=image(1,r,c), Q=image(2,r,c), A=image(3,r,c);
				if (alpha_zero_special && A==0) { Y=I=Q=0; }
				Color C(A,Y,I,Q);
				bool found=false;
				for (Color c : Palette_vector) if (c==C) {found=true; break;}
				if (!found) {
					Palette_vector.push_back(C);
					if (Palette_vector.size() > max_palette_size) return false;
				}
			}
		  }
		}
		uint64_t max_nb_colors = 1;
		for (int p=0; p<4; p++) max_nb_colors *= 1+srcRanges->max(p)-srcRanges->min(p);
		if (Palette_vector.size() == max_nb_colors) return false; // don't make a trivial palette
//        printf("Palette size: %lu\n",Palette.size());
		return true;
	}
	void data(Images& images) const {
//        printf("TransformPalette::data\n");
		for (Image& image : images) {
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				Color C(image(3,r,c), image(0,r,c), image(1,r,c), image(2,r,c));
				if (alpha_zero_special && std::get<0>(C) == 0) { std::get<1>(C) = std::get<2>(C) = std::get<3>(C) = 0; }
				ColorVal P=0;
				for (Color c : Palette_vector) {if (c==C) break; else P++;}
//                image.set(0,r,c, 0);
				image.set(1,r,c, P);
//                image.set(2,r,c, 0);
				image.set(3,r,c, 1);
			}
		  }
		  image.make_constant_plane(0,0);
		  image.make_constant_plane(2,0);
		  image.make_constant_plane(3,1);
		}
	}
	void save(const ColorRanges *srcRanges, RacOut<IO> &rac) const {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coder(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coderY(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coderI(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coderQ(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coderA(rac);
		coder.write_int(1, MAX_PALETTE_SIZE, Palette_vector.size());
		prevPlanes pp(2);
		int sorted=1;
		coder.write_int(0, 1, sorted);
		if (sorted) {
			Color min(srcRanges->min(3), srcRanges->min(0), srcRanges->min(1), srcRanges->min(2));
			Color max(srcRanges->max(3), srcRanges->max(0), srcRanges->max(1), srcRanges->max(2));
			Color prev(-1,-1,-1,-1);
			for (Color c : Palette_vector) {
				ColorVal A=std::get<0>(c);
				coderA.write_int(std::get<0>(min), std::get<0>(max), A);
				if (alpha_zero_special && std::get<0>(c) == 0) continue;
				ColorVal Y=std::get<1>(c);
				coderY.write_int((std::get<0>(prev) == A ? std::get<1>(prev) : std::get<1>(min)), std::get<1>(max), Y);
				pp[0]=Y; srcRanges->minmax(1,pp,std::get<2>(min), std::get<2>(max));
				ColorVal I=std::get<2>(c);
				coderI.write_int(std::get<2>(min), std::get<2>(max), I);
				pp[1]=I; srcRanges->minmax(2,pp,std::get<3>(min), std::get<3>(max));
				coderQ.write_int(std::get<3>(min), std::get<3>(max), std::get<3>(c));

				std::get<0>(min) = std::get<0>(c);
				prev = c;
			}
		} else {
			ColorVal min, max;
			for (Color c : Palette_vector) {
				ColorVal A=std::get<0>(c);
				coderA.write_int(srcRanges->min(3),srcRanges->max(3), A);
				if (alpha_zero_special && std::get<0>(c) == 0) continue;
				srcRanges->minmax(0,pp,min,max);
				ColorVal Y=std::get<1>(c);
				coderY.write_int(min,max,Y);
				pp[0]=Y; srcRanges->minmax(1,pp,min,max);
				ColorVal I=std::get<2>(c);
				coderI.write_int(min, max, I);
				pp[1]=I; srcRanges->minmax(2,pp,min,max);
				coderQ.write_int(min, max, std::get<3>(c));
//                printf("YIQ(%i,%i,%i)\t", std::get<0>(c), std::get<1>(c), std::get<2>(c));
			}
		}
//        printf("\nSaved palette of size: %lu\n",Palette_vector.size());
		v_printf(5,"[%lu]",Palette_vector.size());
	}
#endif
	bool load(const ColorRanges *srcRanges, RacIn<IO> &rac) {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coder(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coderY(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coderI(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coderQ(rac);
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coderA(rac);
		long unsigned size = coder.read_int(1, MAX_PALETTE_SIZE);
//        printf("Loading %lu colors: ", size);
		prevPlanes pp(2);
		int sorted = coder.read_int(0,1);
		if (sorted) {
			Color min(srcRanges->min(3), srcRanges->min(0), srcRanges->min(1), srcRanges->min(2));
			Color max(srcRanges->max(3), srcRanges->max(0), srcRanges->max(1), srcRanges->max(2));
			Color prev(-1,-1,-1,-1);
			for (unsigned int p=0; p<size; p++) {
				ColorVal A=coderA.read_int(std::get<0>(min), std::get<0>(max));
				if (alpha_zero_special && A == 0) { Palette_vector.push_back(Color(0,0,0,0)); continue; }
				ColorVal Y=coderY.read_int((std::get<0>(prev) == A ? std::get<1>(prev) : std::get<1>(min)), std::get<1>(max));
				pp[0]=Y; srcRanges->minmax(1,pp,std::get<2>(min), std::get<2>(max));
				ColorVal I=coderI.read_int(std::get<2>(min), std::get<2>(max));
				pp[1]=I; srcRanges->minmax(2,pp,std::get<3>(min), std::get<3>(max));
				ColorVal Q=coderQ.read_int(std::get<3>(min), std::get<3>(max));
				Color c(A,Y,I,Q);
				Palette_vector.push_back(c);
				std::get<0>(min) = std::get<0>(c);
				prev = c;
			}
		} else {
			ColorVal min, max;
			for (unsigned int p=0; p<size; p++) {
				ColorVal A=coderA.read_int(srcRanges->min(3),srcRanges->max(3));
				if (alpha_zero_special && A == 0) { Palette_vector.push_back(Color(0,0,0,0)); continue; }
				srcRanges->minmax(0,pp,min,max);
				ColorVal Y=coderY.read_int(min,max);
				pp[0]=Y; srcRanges->minmax(1,pp,min,max);
				ColorVal I=coderI.read_int(min,max);
				pp[1]=I; srcRanges->minmax(2,pp,min,max);
				ColorVal Q=coderQ.read_int(min,max);
				Color c(A,Y,I,Q);
				Palette_vector.push_back(c);
//                printf("YIQ(%i,%i,%i)\t", std::get<0>(c), std::get<1>(c), std::get<2>(c));
			}
		}
//        printf("\nLoaded palette of size: %lu\n",Palette_vector.size());
		v_printf(5,"[%lu]",Palette_vector.size());
		return true;
	}
};

#endif


//#line 1 "palette_C.hpp"
#ifndef FLIF_PALETTE_C_HPP
#define FLIF_PALETTE_C_HPP

#include <tuple>
#include <set>

class ColorRangesPaletteC final : public ColorRanges {
protected:
	const ColorRanges *ranges;
	int nb_colors[4];
public:
	ColorRangesPaletteC(const ColorRanges *rangesIn, const int nb[4]) : ranges(rangesIn) { for (int i=0; i<4; i++) nb_colors[i] = nb[i]; }
	bool isStatic() const { return true; }
	int numPlanes() const { return ranges->numPlanes(); }

	ColorVal min(int p) const { return 0; }
	ColorVal max(int p) const { return nb_colors[p]; }
	void minmax(const int p, const prevPlanes &pp, ColorVal &minv, ColorVal &maxv) const {
		 minv=0; maxv=nb_colors[p];
	}

};

template <typename IO>
class TransformPaletteC : public Transform<IO> {
protected:
	std::vector<ColorVal> CPalette_vector[4];
	std::vector<ColorVal> CPalette_inv_vector[4];

public:
	bool init(const ColorRanges *) {
		return true;
	}

	const ColorRanges *meta(Images& images, const ColorRanges *srcRanges) {
		int nb[4] = {};
		v_printf(4,"[");
		for (int i=0; i<srcRanges->numPlanes(); i++) {
			nb[i] = CPalette_vector[i].size()-1;
			if (i>0) v_printf(4,",");
			v_printf(4,"%i",nb[i]);
//            if (nb[i] < 64) nb[i] <<= 2;
		}
		v_printf(4,"]");
		return new ColorRangesPaletteC(srcRanges, nb);
	}

	void invData(Images& images) const {
		for (Image& image : images) {
		 for (int p=0; p<image.numPlanes(); p++) {
//          const int stretch = (CPalette_vector[p].size()>64 ? 0 : 2);
		  image.undo_make_constant_plane(p);
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
//                image.set(p,r,c, CPalette_vector[p][image(p,r,c) >> stretch]);
				image.set(p,r,c, CPalette_vector[p][image(p,r,c)]);
			}
		  }
		 }
		}
	}

#if HAS_ENCODER
	bool process(const ColorRanges *srcRanges, const Images &images) {
		std::set<ColorVal> CPalette;
		bool nontrivial=false;
		for (int p=0; p<srcRanges->numPlanes(); p++) {
		 if (p==3) CPalette.insert(0); // ensure that A=0 is still A=0 even if image does not contain zero-alpha pixels
		 for (const Image& image : images) {
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				CPalette.insert(image(p,r,c));
			}
		  }
		 }
		 if ((int)CPalette.size() <= srcRanges->max(p)-srcRanges->min(p)) nontrivial = true;
		 if (CPalette.size() < 10) {
		   // add up to 10 shades of gray
		   ColorVal prev=0;
		   for (ColorVal c : CPalette) {
			 if (c > prev+1) CPalette_vector[p].push_back((c+prev)/2);
			 CPalette_vector[p].push_back(c);
			 prev=c;
			 nontrivial=true;
		   }
		 } else {
		   for (ColorVal c : CPalette) CPalette_vector[p].push_back(c);
		 }
		 CPalette.clear();
		 CPalette_inv_vector[p].resize(srcRanges->max(p)+1);
		 for (unsigned int i=0; i<CPalette_vector[p].size(); i++) CPalette_inv_vector[p][CPalette_vector[p][i]]=i;
		}
		return nontrivial;
	}
	void data(Images& images) const {
		for (Image& image : images) {
		 for (int p=0; p<image.numPlanes(); p++) {
//          const int stretch = (CPalette_vector[p].size()>64 ? 0 : 2);
		  for (uint32_t r=0; r<image.rows(); r++) {
			for (uint32_t c=0; c<image.cols(); c++) {
				ColorVal P = CPalette_inv_vector[p][image(p,r,c)];
//                for (ColorVal x : CPalette_vector[p]) {if (x==image(p,r,c)) break; else P++;}
//                image.set(p,r,c, P << stretch);
				image.set(p,r,c, P);
			}
		  }
		 }
		}
	}
	void save(const ColorRanges *srcRanges, RacOut<IO> &rac) const {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coder(rac);
		for (int p=0; p<srcRanges->numPlanes(); p++) {
		  coder.write_int(0, srcRanges->max(p)-srcRanges->min(p), CPalette_vector[p].size()-1);
		  ColorVal min=srcRanges->min(p);
		  int remaining=CPalette_vector[p].size()-1;
		  for (unsigned int i=0; i<CPalette_vector[p].size(); i++) {
			coder.write_int(0, srcRanges->max(p)-min-remaining, CPalette_vector[p][i]-min);
			min = CPalette_vector[p][i]+1;
			remaining--;
		  }
		}
	}
#endif
	bool load(const ColorRanges *srcRanges, RacIn<IO> &rac) {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coder(rac);
		for (int p=0; p<srcRanges->numPlanes(); p++) {
		  unsigned int nb = coder.read_int(0, srcRanges->max(p)-srcRanges->min(p)) + 1;
		  ColorVal min=srcRanges->min(p);
		  int remaining = nb-1;
		  for (unsigned int i=0; i<nb; i++) {
			CPalette_vector[p].push_back(min + coder.read_int(0, srcRanges->max(p)-min-remaining));
			min = CPalette_vector[p][i]+1;
			remaining--;
		  }
		}
		return true;
	}
};

#endif


//#line 1 "frameshape.hpp"
#ifndef FLIF_FRAMESHAPE_HPP
#define FLIF_FRAMESHAPE_HPP

#include <vector>

template <typename IO>
class TransformFrameShape final : public Transform<IO> {
protected:
	std::vector<uint32_t> b;
	std::vector<uint32_t> e;
	uint32_t cols;
	uint32_t nb;

	bool undo_redo_during_decode() { return false; }

	const ColorRanges *meta(Images& images, const ColorRanges *srcRanges) {
		uint32_t pos=0;
		for (unsigned int fr=1; fr<images.size(); fr++) {
			Image& image = images[fr];
			if (image.seen_before >= 0) continue;
			for (uint32_t r=0; r<image.rows(); r++) {
			   assert(pos<nb);
			   image.col_begin[r] = b[pos];
			   image.col_end[r] = e[pos];
			   pos++;
			}
		}
		return new DupColorRanges(srcRanges);
	}

	void configure(const int setting) { if (nb==0) nb=setting; else cols=setting; } // ok this is dirty

	bool load(const ColorRanges *, RacIn<IO> &rac) {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coder(rac);
		for (unsigned int i=0; i<nb; i+=1) {b.push_back(coder.read_int(0,cols));}
		for (unsigned int i=0; i<nb; i+=1) {
			e.push_back(cols-coder.read_int(0,cols-b[i]));
			if (e[i] > cols || e[i] < b[i] || e[i] <= 0) {
				e_printf("\nError: FRS transform: invalid end column\n");
				return false;
			}
		}
		return true;
	}

#if HAS_ENCODER
	void save(const ColorRanges *, RacOut<IO> &rac) const {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coder(rac);
		assert(nb == b.size());
		assert(nb == e.size());
		for (unsigned int i=0; i<nb; i+=1) { coder.write_int(0,cols,b[i]); }
		for (unsigned int i=0; i<nb; i+=1) { coder.write_int(0,cols-b[i],cols-e[i]); }
	}

	bool process(const ColorRanges *srcRanges, const Images &images) {
		if (images.size()<2) return false;
		int np=srcRanges->numPlanes();
		nb = 0;
		cols = images[0].cols();
		for (unsigned int fr=1; fr<images.size(); fr++) {
			const Image& image = images[fr];
			if (image.seen_before >= 0) continue;
			nb += image.rows();
			for (uint32_t r=0; r<image.rows(); r++) {
				bool beginfound=false;
				for (uint32_t c=0; c<image.cols(); c++) {
					if (image.alpha_zero_special && np>3 && image(3,r,c) == 0 && images[fr-1](3,r,c)==0) continue;
					for (int p=0; p<np; p++) {
					   if(image(p,r,c) != images[fr-1](p,r,c)) { beginfound=true; break;}
					}
					if (beginfound) {b.push_back(c); break;}
				}
				if (!beginfound) {b.push_back(image.cols()); e.push_back(image.cols()); continue;}
				bool endfound=false;
				for (uint32_t c=image.cols()-1; c >= b.back(); c--) {
					if (image.alpha_zero_special && np>3 && image(3,r,c) == 0 && images[fr-1](3,r,c)==0) continue;
					for (int p=0; p<np; p++) {
					   if(image(p,r,c) != images[fr-1](p,r,c)) { endfound=true; break;}
					}
					if (endfound) {e.push_back(c+1); break;}
				}
				if (!endfound) {e.push_back(0); continue;} //shouldn't happen, right?
			}
		}
		/* does not seem to do much good at all
		if (nb&1) {b.push_back(b[nb-1]); e.push_back(e[nb-1]);}
		for (unsigned int i=0; i<nb; i+=2) { b[i]=b[i+1]=std::min(b[i],b[i+1]); }
		for (unsigned int i=0; i<nb; i+=2) { e[i]=e[i+1]=std::max(e[i],e[i+1]); }
		*/
		return true;
	}
#endif
};

#endif


//#line 1 "framedup.hpp"
#ifndef FLIF_FRAMEDUP_HPP
#define FLIF_FRAMEDUP_HPP

#include <vector>

template <typename IO>
class TransformFrameDup final : public Transform<IO> {
protected:
	std::vector<int> seen_before;
	uint32_t nb;

	bool undo_redo_during_decode() { return false; }
	const ColorRanges *meta(Images& images, const ColorRanges *srcRanges) {
		for (unsigned int fr=0; fr<images.size(); fr++) {
			Image& image = images[fr];
			image.seen_before = seen_before[fr];
		}
		return new DupColorRanges(srcRanges);
	}

	void configure(const int setting) { nb=setting; }

	bool load(const ColorRanges *, RacIn<IO> &rac) {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacIn<IO>, 18> coder(rac);
		seen_before.clear();
		seen_before.push_back(-1);
		for (unsigned int i=1; i<nb; i++) seen_before.push_back(coder.read_int(-1,i-1));
		int count=0; for(int i : seen_before) { if(i>=0) count++; } v_printf(5,"[%i]",count);
		return true;
	}

#ifdef HAS_ENCODER
	void save(const ColorRanges *, RacOut<IO> &rac) const {
		SimpleSymbolCoder<FLIFBitChanceMeta, RacOut<IO>, 18> coder(rac);
		assert(nb == seen_before.size());
		for (unsigned int i=1; i<seen_before.size(); i++) coder.write_int(-1,i-1,seen_before[i]);
		int count=0; for(int i : seen_before) { if(i>=0) count++; } v_printf(5,"[%i]",count);
	}

	bool process(const ColorRanges *srcRanges, const Images &images) {
		int np=srcRanges->numPlanes();
		nb = images.size();
		seen_before.clear();
		seen_before.resize(nb,-1);
		bool dupes_found=false;
		for (unsigned int fr=1; fr<images.size(); fr++) {
			const Image& image = images[fr];
			for (unsigned int ofr=0; ofr<fr; ofr++) {
			  const Image& oimage = images[ofr];
			  bool identical=true;
			  for (uint32_t r=0; r<image.rows(); r++) {
				for (uint32_t c=0; c<image.cols(); c++) {
					for (int p=0; p<np; p++) {
					   if(image(p,r,c) != oimage(p,r,c)) { identical=false; break;}
					}
					if (!identical) {break;}
				}
				if (!identical) {break;}
			  }
			  if (identical) {seen_before[fr] = ofr; dupes_found=true; break;}
			}
		}
		return dupes_found;
	}
#endif
};

#endif


//#line 1 "framecombine.hpp"
#ifndef FLIF_FRAMECOMBINE_HPP
#define FLIF_FRAMECOMBINE_HPP

#include <vector>

class ColorRangesFC final : public ColorRanges {
protected:
	ColorVal numPrevFrames;
	ColorVal alpha_min;
	ColorVal alpha_max;
	const ColorRanges *ranges;
public:
	ColorRangesFC(const ColorVal pf, const ColorVal amin, const ColorVal amax, const ColorRanges *rangesIn) : numPrevFrames(pf), alpha_min(amin), alpha_max(amax), ranges(rangesIn) {}
	bool isStatic() const { return false; }
	int numPlanes() const { return 5; }
	ColorVal min(int p) const { if (p<3) return ranges->min(p); else if (p==3) return alpha_min; else return 0; }
	ColorVal max(int p) const { if (p<3) return ranges->max(p); else if (p==3) return alpha_max; else return numPrevFrames; }
	void minmax(const int p, const prevPlanes &pp, ColorVal &mi, ColorVal &ma) const {
		if (p >= 3) { mi=min(p); ma=max(p); }
		else ranges->minmax(p, pp, mi, ma);
	}
};

template <typename IO>
class TransformFrameCombine : public Transform<IO> {
protected:
	bool was_flat;
	bool was_grayscale;
	int max_lookback;
	int user_max_lookback;
	int nb_frames;

	bool undo_redo_during_decode() { return true; }

	const ColorRanges *meta(Images& images, const ColorRanges *srcRanges) {
//        if (max_lookback >= (int)images.size()) { e_printf("Bad value for FRA lookback\n"); exit(4);}
		assert(max_lookback < (int)images.size());
		was_grayscale = srcRanges->numPlanes() < 2;
		was_flat = srcRanges->numPlanes() < 4;
		for (unsigned int fr=0; fr<images.size(); fr++) {
			Image& image = images[fr];
			image.ensure_frame_lookbacks();
		}
		int lookback = (int)images.size()-1;
		if (lookback > max_lookback) lookback=max_lookback;
		return new ColorRangesFC(lookback, (srcRanges->numPlanes() == 4 ? srcRanges->min(3) : 255), (srcRanges->numPlanes() == 4 ? srcRanges->max(3) : 255), srcRanges);
	}

	bool load(const ColorRanges *, RacIn<IO> &rac) {
		SimpleSymbolCoder<SimpleBitChance, RacIn<IO>, 18> coder(rac);
		max_lookback = coder.read_int(1, nb_frames-1);
		v_printf(5,"[%i]",max_lookback);
		return true;
	}

#ifdef HAS_ENCODER
	void save(const ColorRanges *, RacOut<IO> &rac) const {
		SimpleSymbolCoder<SimpleBitChance, RacOut<IO>, 18> coder(rac);
		coder.write_int(1,nb_frames-1,max_lookback);
	}

// a heuristic to figure out if this is going to help (it won't help if we introduce more entropy than what is eliminated)
	bool process(const ColorRanges *srcRanges, const Images &images) {
		if (images.size() < 2) return false;
		int nump=images[0].numPlanes();
		nb_frames = images.size();
		int64_t pixel_cost = 1;
		for (int p=0; p<nump; p++) pixel_cost *= (1 + srcRanges->max(p) - srcRanges->min(p));
		// pixel_cost is roughly the cost per pixel (number of different values a pixel can take)
		if (pixel_cost < 16) {v_printf(7,", no_FRA[pixels_too_cheap:%i]", pixel_cost); return false;} // pixels are too cheap, no point in trying to save stuff
		std::vector<uint64_t> found_pixels(images.size(), 0);
		uint64_t new_pixels=0;
		max_lookback=1;
		if (user_max_lookback == -1) user_max_lookback = images.size()-1;
		for (int fr=1; fr < (int)images.size(); fr++) {
			const Image& image = images[fr];
			for (uint32_t r=0; r<image.rows(); r++) {
				for (uint32_t c=image.col_begin[r]; c<image.col_end[r]; c++) {
					new_pixels++;
					for (int prev=1; prev <= fr; prev++) {
						if (prev>user_max_lookback) break;
						bool identical=true;
						if (image.alpha_zero_special && nump>3 && image(3,r,c) == 0 && images[fr-prev](3,r,c) == 0) identical=true;
						else
						for (int p=0; p<nump; p++) {
						  if(image(p,r,c) != images[fr-prev](p,r,c)) { identical=false; break;}
						}
						if (identical) { found_pixels[prev]++; new_pixels--; if (prev>max_lookback) max_lookback=prev; break;}
					}
				}
			}
		}
		if (images.size() > 2) v_printf(7,", trying_FRA(at -1: %llu, at -2: %llu, new: %llu)",(long long unsigned) found_pixels[1],(long long unsigned) found_pixels[2], (long long unsigned) new_pixels);
		if (max_lookback>256) max_lookback=256;
		for(int i=1; i <= max_lookback; i++) {
			v_printf(8,"at lookback %i: %llu pixels\n",-i, found_pixels[i]);
			if (found_pixels[i] <= new_pixels/200 || i>pixel_cost) {max_lookback=i-1; break;}
			found_pixels[0] += found_pixels[i];
		}
		for(int i=max_lookback+1; i<(int)images.size(); i++) {
			if (found_pixels[i] > new_pixels/200 && i<pixel_cost) {max_lookback=i; found_pixels[0] += found_pixels[i];}
			else new_pixels += found_pixels[i];
		}

		return (found_pixels[0] * pixel_cost > new_pixels * (2 + max_lookback));
	};
	void data(Images &images) const {
		for (int fr=1; fr < (int)images.size(); fr++) {
			uint32_t ipixels=0;
			Image& image = images[fr];
			for (uint32_t r=0; r<image.rows(); r++) {
				for (uint32_t c=image.col_begin[r]; c<image.col_end[r]; c++) {
					for (int prev=1; prev <= fr; prev++) {
						if (prev>max_lookback) break;
						bool identical=true;
						if (image.alpha_zero_special && image(3,r,c) == 0 && images[fr-prev](3,r,c) == 0) identical=true;
						else
						for (int p=0; p<4; p++) {
						  if(image(p,r,c) != images[fr-prev](p,r,c)) { identical=false; break;}
						}
						if (identical) {image.set(4,r,c, prev); ipixels++; break;}
					}
				}
			}
//            printf("frame %i: found %u pixels from previous frames\n", fr, ipixels);
		}
	}
#endif

	void configure(int setting) { user_max_lookback=nb_frames=setting; }
	void invData(Images &images) const {
		// most work has to be done on the fly in the decoder, this is just some cleaning up
		for (Image& image : images) image.drop_frame_lookbacks();
		if (was_flat) for (Image& image : images) image.drop_alpha();
		if (was_grayscale) for (Image& image : images) image.drop_color();
	}
};

#endif

template <typename IO>
Transform<IO> *create_transform(std::string desc) {
	if (desc == "YCoCg")
		return new TransformYCoCg<IO>();
// use this if you just want to quickly try YC1C2
//        return new TransformYCC<IO>();
	if (desc == "Bounds")
		return new TransformBounds<IO>();
	if (desc == "Color_Buckets")
		return new TransformCB<IO>();
	if (desc == "Palette")
		return new TransformPalette<IO>();
	if (desc == "Palette_Alpha")
		return new TransformPaletteA<IO>();
	if (desc == "Channel_Compact")
		return new TransformPaletteC<IO>();
	if (desc == "Frame_Shape")
		return new TransformFrameShape<IO>();
	if (desc == "Duplicate_Frame")
		return new TransformFrameDup<IO>();
	if (desc == "Frame_Lookback")
		return new TransformFrameCombine<IO>();
	return NULL;
}

template Transform<FileIO> *create_transform(std::string desc);
template Transform<BlobReader> *create_transform(std::string desc);
template Transform<BlobIO> *create_transform(std::string desc);

// portable endianness stuff. rlyeh, public domain {
#include <stdint.h>
#if __STDC_VERSION__ >= 199901L
#define IS_BIG_ENDIAN (!*(unsigned char *)&(uint16_t){1})
#else
#define IS_BIG_ENDIAN (*(uint16_t *)"\0\xff" < 0x100)
#endif
uint16_t swap16( uint16_t x ) {
	return ( x << 8 ) | ( x >> 8 );
}
uint32_t swap32( uint32_t x ) {
	return ( x << 24 ) | (( x << 8 ) & 0xff0000) | (( x >> 8 ) & 0xff00) | ( x >> 24 );
}
uint16_t tobe16( uint16_t x ) {
	return IS_BIG_ENDIAN ? x : swap16(x);
}
uint32_t tobe32( uint32_t x ) {
	return IS_BIG_ENDIAN ? x : swap32(x);
}
uint16_t tole16( uint16_t x ) {
	return IS_BIG_ENDIAN ? swap16(x) : x;
}
uint32_t tole32( uint32_t x ) {
	return IS_BIG_ENDIAN ? swap32(x) : x;
}
#define  hton16(x) ( IS_BIG_ENDIAN ? (x) : swap16(x) )
#define  hton32(x) ( IS_BIG_ENDIAN ? (x) : swap32(x) )
#define  ntoh16(x) ( IS_BIG_ENDIAN ? (x) : swap16(x) )
#define  ntoh32(x) ( IS_BIG_ENDIAN ? (x) : swap32(x) )
// }

namespace spot {
int write_dds( char const *filename, int w, int h, int comp, const void *data ) {
   return save_image_as_DDS( filename, w, h, comp, (const unsigned char *const) data );
}
int write_bmp( char const *filename, int w, int h, int comp, const void *data ) {
   return stbi_write_bmp( filename, w, h, comp, data );
}
int write_tga( char const *filename, int w, int h, int comp, const void *data ) {
   return stbi_write_tga( filename, w, h, comp, data );
}
}

extern "C"
int WebPGetInfo(const uint8_t* data, size_t data_size, int* width, int* height);

extern "C"
uint8_t* WebPDecodeRGBA(const uint8_t* data, size_t data_size, int* width, int* height);

extern "C"
size_t WebPEncodeRGBA(const unsigned char* rgba, int width, int height, int stride, float quality_factor, unsigned char** output);

// Callback function: converts (partially) decoded image/animation to a/several SDL_Texture(s),
//                    resizes the viewer window if needed, and calls draw_image()
// Input arguments are: quality (0..10000), current position in the .flif file
// Output is the desired minimal quality before doing the next callback
#pragma pack(push,1)
typedef struct flif_RGBA { uint8_t r,g,b,a; } flif_RGBA;
#pragma pack(pop)

// we're ready at this point...

namespace spot {

bool devel = false;

/*
#define STBI_ASSERT assert
#define stbi__errpuc(...) 0
#define stbi__malloc malloc
#define STBI_FREE free
#define stbi_uc unsigned char */
static stbi_uc stbi__compute_y(int r, int g, int b) {
   return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);
}
static stbi_uc *stbi__convert_format(unsigned char *data, int bpp_src, int bpp_dst, unsigned int x, unsigned int y) {
   int i,j;
   stbi_uc *good;

   if (bpp_dst == bpp_src) return data;
   STBI_ASSERT(bpp_dst >= 1 && bpp_dst <= 4);

   good = (stbi_uc *) stbi__malloc(bpp_dst * x * y);
   if (good == NULL) {
	  STBI_FREE(data);
	  return stbi__errpuc("outofmem", "Out of memory");
   }

   for (j=0; j < (int) y; ++j) {
	  stbi_uc *src  = data + j * x * bpp_src   ;
	  stbi_uc *dest = good + j * x * bpp_dst;

	  #define COMBO(a,b)  ((a)*8+(b))
	  #define CASE(a,b)   case COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
	  // convert source image with bpp_src components to one with bpp_dst components;
	  // avoid switch per pixel, so use switch per scanline and massive macros
	  switch (COMBO(bpp_src, bpp_dst)) {
		 CASE(1,2) dest[0]=src[0], dest[1]=255; break;
		 CASE(1,3) dest[0]=dest[1]=dest[2]=src[0]; break;
		 CASE(1,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=255; break;
		 CASE(2,1) dest[0]=src[0]; break;
		 CASE(2,3) dest[0]=dest[1]=dest[2]=src[0]; break;
		 CASE(2,4) dest[0]=dest[1]=dest[2]=src[0], dest[3]=src[1]; break;
		 CASE(3,4) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2],dest[3]=255; break;
		 CASE(3,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
		 CASE(3,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = 255; break;
		 CASE(4,1) dest[0]=stbi__compute_y(src[0],src[1],src[2]); break;
		 CASE(4,2) dest[0]=stbi__compute_y(src[0],src[1],src[2]), dest[1] = src[3]; break;
		 CASE(4,3) dest[0]=src[0],dest[1]=src[1],dest[2]=src[2]; break;
		 default: STBI_ASSERT(0);
	  }
	  #undef CASE
   }

   STBI_FREE(data);
   return good;
}
/*
	if( (req_comp <= 4) && (req_comp >= 1) ) {
		//  user has some requirements, meet them
		if( req_comp != img_n ) {
			pkm_res_data = stbi__convert_format( pkm_res_data, img_n, req_comp, img_x, img_y );
		}
	}
*/

static stbi_uc *decode_etc1_stream(const void *stream, int len, int width, int height, unsigned int *zlen)
{
	int img_x = width, img_y = height, img_n = 3;

	unsigned int align = 0;
	unsigned int stride = ((width * 3) + align) & ~align;
	unsigned int size = stride * height;

	stbi_uc *unpacked = (stbi_uc *)malloc(size);
	if( unpacked ) {
		// pixelSize 2 is an GL_UNSIGNED_SHORT_5_6_5 image, 3 is a GL_BYTE RGB image.
		if( 0 == etc1_decode_image((const etc1_byte*)stream, (etc1_byte*)unpacked, width, height, 3, stride) ) {
			if( zlen ) *zlen = size;
			return (stbi_uc *)unpacked;
		}
		free( unpacked );
	}

	return NULL;
}

static stbi_uc *decode_pvrtc_stream(const void *stream, int len, int width, int height, int px_type, unsigned int *zlen)
{
	int img_x = width, img_y = height, img_n = 3;
	int bitmode = 0;

	switch( px_type ) {
		default: return 0;
		case pvr3::table1::PVRTC_2BPP_RGB:
		case pvr3::table1::PVRTC_2BPP_RGBA: bitmode = 1; img_n = 4; break;
		case pvr3::table1::PVRTC_4BPP_RGB:
		case pvr3::table1::PVRTC_4BPP_RGBA: img_n = 4; break;
	}

	// Load only the first mip map level
	unsigned int bytes = img_x * img_y * 4;
	stbi_uc *unpacked = (stbi_uc *)malloc( bytes );
	if( unpacked ) {
		Decompress( (AMTC_BLOCK_STRUCT*)stream, bitmode, img_x, img_y, 1, (unsigned char*)unpacked );
		if( zlen ) *zlen = bytes;
		return unpacked;
	}

	return 0;
}

bool stream::is_valid() const {
	return w && h && error.empty(); // && data && len
}

bool stream::is_etc1() const {
	return is_valid() && 0 == w % 4 && 0 == h % 4 && fmt == pvr3::table1::ETC1;
}

bool stream::is_compressed() const {
	return is_valid() && w * h * ( d >= 1 ? d : 1 ) * comp / 4 < len;
}

template<typename T>
void endianness( T &self ) {
}
template<>
void endianness( pkm::header &hd ) {
	hd.width = ntoh16(hd.width);
	hd.height = ntoh16(hd.height);
	hd.width_src = ntoh16(hd.width_src);
	hd.height_src = ntoh16(hd.height_src);
 }

template<typename T>
bool preload( T &self, const void *ptr, size_t len ) {
	if( sizeof( typename T::header ) < len ) {
		memcpy( &self.hd, ptr, sizeof( typename T::header ) );
		endianness( self.hd );
		return self.is_currently_supported();
	}
	memset( &self, 0, sizeof( typename T::header ) );
	return false;
}

/*
bool load( std::string &data, const std::string &name, uint32_t reserved = 0 ) {
	std::stringstream ss;
	std::ifstream ifs( name.c_str(), std::ios::binary );
	if( ifs.good() && ss << ifs.rdbuf() ) {
		return data = std::string( reserved, 0 ) + ss.str(), true;
	}
	return data = std::string( reserved, 0 ), false;
}
*/

stream encode_as_rgba( const void *rgba, int w, int h, int bpp = 32, int quality = 0, unsigned reserved = 0 ) {
	stream out = {};
	if( bpp >= 24 ) {
		out.w = w;
		out.h = h;
		out.d = 1;
		out.fmt = bpp ==32 ? pvr3::table1::SPOT_RGBA8888 : pvr3::table1::SPOT_RGB888;
		out.len = w * h * (bpp/8);
		out.out = new uint8_t [ reserved + out.len ];
		memcpy( ((uint8_t*)(out.out)) + reserved, rgba, out.len );
	}
	return out;
}

stream encode_as_pvrtc( const void *bgra, int w, int h, int bpp = 32, int quality = 0, unsigned reserved = 0 ) {
	stream out = {};

	/*
	auto is_power_of_two = []( unsigned x ) {
		return ((x & (x - 1)) == 0);
	};
	if( !is_power_of_two(w) ) return out;
	if( !is_power_of_two(h) ) return out;
	*/
	bool is_4bpp = true; //quality >= 50;
	if( w % 4 ) return out;
	if( h % 4 ) return out;

	// @todo check is %4
	// Alloc mem
	int len = ( is_4bpp ? w * h / 2 : w * h / 4 ) + 4;
	uint8_t *dst = new uint8_t [ reserved + len ];
	if( !dst ) return out;
	uint8_t *pvrtc = &dst[ reserved ];

	// init
	out.w = w;
	out.h = h;
	out.d = 1;
	out.out = dst;
	out.len = len;
	out.comp = bpp == 24 ? 3 : 4;

	/****/ if( bpp == 24 ) {
		Javelin::RgbBitmap bitmap( w, h );
		memcpy( bitmap.GetData(), bgra, w * h * 3 );
		//if( is_4bpp ) {
			out.fmt = pvr3::table1::PVRTC_4BPP_RGB;
			PvrTcEncoder::EncodeRgb4Bpp(pvrtc, bitmap);
		/*} else {
			out.fmt = pvr3::table1::PVRTC_2BPP_RGB;
			PvrTcEncoder::EncodeRgb2Bpp(pvrtc, bitmap);
		}*/
	} else if( bpp == 32 ) {
		Javelin::RgbaBitmap bitmap( w, h );
		memcpy( bitmap.GetData(), bgra, w * h * 4 );
		//if( is_4bpp ) {
			out.fmt = pvr3::table1::PVRTC_4BPP_RGBA;
			PvrTcEncoder::EncodeRgba4Bpp(pvrtc, bitmap);
		/*} else {
			out.fmt = pvr3::table1::PVRTC_2BPP_RGBA;
			PvrTcEncoder::EncodeRgba2Bpp(pvrtc, bitmap);
		}*/
	}

	return out;
}

stream encode_as_etc1_etcpak( const void *rgba, int w, int h, int bpp = 32, int quality = 0, unsigned reserved = 0 ) {
	stream out = {};

	bool alpha = false;
	bool mipmap = false;
	bool dither = quality >= 50;
	/*int*/ quality = 0;

	{
		auto bmp = std::make_shared<Bitmap>( (const uint32_t *)rgba, w * h * (bpp/8), w, h, (std::numeric_limits<uint>::max)() );

		auto bd = std::make_shared<BlockData>( bmp->Size(), false );
		auto block = std::make_shared<BlockBitmap>( bmp, Channels::RGB );
		if( dither ) block->Dither();
		bd->Process( block->Data(), bmp->Size().x * bmp->Size().y / 16, 0, quality, Channels::RGB );
		bd->Finish();

		BlockDataPtr bda;
		if( alpha && bpp == 32 ) {
			bda = std::make_shared<BlockData>( bmp->Size(), false );
			auto blocka = std::make_shared<BlockBitmap>( bmp, Channels::Alpha );
			// do not dither alpha
			bda->Process( blocka->Data(), bmp->Size().x * bmp->Size().y / 16, 0, quality, Channels::RGB );
			bda->Finish();
		}

		if( bd ) {
			out.w = bd->m_size.x;
			out.h = bd->m_size.y;
			out.d = 1;
			out.fmt = pvr3::table1::ETC1;
			out.len = out.w * out.h / 2;
			out.out = new unsigned char [ out.len ];
			memcpy( out.out, (const char *)&bd->m_data[ bd->m_dataOffset ], out.len );
		}
		if( bda ) {
			// to be done
		}

		bd.reset();
		bda.reset();
	}

	return out;
}
stream encode_as_etc1( const void *rgba, int w, int h, int bpp = 32, int quality = 0, unsigned reserved = 0 ) {

	if( quality < 50 ) return encode_as_etc1_etcpak( rgba, w, h, bpp, quality * 2, reserved );
	else quality = (quality - 50) * 2;

	stream out = {};

	/* Check for power of 2 {
	auto is_power_of_two = []( unsigned x ) {
		return ((x & (x - 1)) == 0);
	};
	if( !is_power_of_two(w) ) return out;
	if( !is_power_of_two(h) ) return out;
	// } */

	// Alloc mem
	unsigned pitch = w * (bpp / 8);
	unsigned blockw = w/4;
	unsigned blockh = h/4;
	size_t len = blockw * blockh * 8;
	uint8_t *dst = new uint8_t [ reserved + len ];
	if( !dst ) return out;
	uint8_t *data = &dst[ reserved ];

	// init
	rg_etc1::pack_etc1_block_init();
	rg_etc1::etc1_pack_params params;

	int step = 100/6;
	/**/ if( quality >= 100 - step * 1 ) params.m_quality = rg_etc1::cHighQuality,   params.m_dithering = true;
	else if( quality >= 100 - step * 2 ) params.m_quality = rg_etc1::cHighQuality,   params.m_dithering = false;
	else if( quality >= 100 - step * 3 ) params.m_quality = rg_etc1::cMediumQuality, params.m_dithering = true;
	else if( quality >= 100 - step * 4 ) params.m_quality = rg_etc1::cMediumQuality, params.m_dithering = false;
	else if( quality >= 100 - step * 5 ) params.m_quality = rg_etc1::cLowQuality,    params.m_dithering = true;
	else                                 params.m_quality = rg_etc1::cLowQuality,    params.m_dithering = false;

	// RGBA to ETC1
#pragma omp parallel for
	for( unsigned y = 0; y < blockh; y++ ) {
		for( unsigned x = 0; x < blockw; x++ ) {
			uint32_t block[16];
			for( unsigned iy = 0; iy < 4; iy++ ) {
				memcpy(block + 4 * iy, (uint8_t*)rgba + ((y * 4 + iy) * (pitch/4) + x * 4) * 4, 16);
			}
			rg_etc1::pack_etc1_block((data) + (blockw * y + x) * 8, block, params);
		}
	}

	out.w = blockw*4;
	out.h = blockh*4;
	out.d = 1;
	out.fmt = pvr3::table1::ETC1;
	out.out = dst;
	out.len = len;
	return out;
}

bool save_pkm_etc1( std::string &out, const stream &sm, unsigned reserved ) {
	if( sm.is_valid() && sm.is_etc1() ) {
		pkm p;
		p.hd.id = hton32('PKM ');
		p.hd.version = hton16('10');
		p.hd.type = hton16(0);
		p.hd.width = hton16(sm.w - sm.w % 4);
		p.hd.height = hton16(sm.h - sm.h % 4);
		p.hd.width_src = hton16(sm.w);
		p.hd.height_src = hton16(sm.h);
		if( devel ) p.debug(std::cout);

		out.resize( sizeof(p.hd) + reserved );
		memcpy( &out[0], &p.hd, sizeof(p.hd) );
		return true;
	}
	return out.clear(), false;
}

bool save_pvr3( std::string &out, const stream &sm, unsigned reserved = 0 ) {
	if( sm.is_valid() /* && sm.is_etc1() */ ) {
		pvr3 pvr;
		pvr.hd.version = tole32(0x50565203);     // 0x03525650, if endianess does not match ; 0x50565203, if endianess does match
		pvr.hd.flags = tole32(0);                // 0x02, colour values within the texture have been pre-multiplied by the alpha values
		pvr.hd.pixel_format_1 = tole32(sm.fmt);  // see table1 above
		pvr.hd.pixel_format_2 = tole32(0);       // 0
		pvr.hd.color_space = tole32(0);          // 0 linear rgb, 1 standard rgb
		pvr.hd.channel_type = tole32(0);         // see table2 above
		pvr.hd.height = tole32(sm.h);            // 1d texture
		pvr.hd.width = tole32(sm.w);             // 2d texture; >= 1
		pvr.hd.depth = tole32(1);                // 3d texture; >= 1
		pvr.hd.num_surfaces = tole32(1);         // num surfaces in texture array; >= 1
		pvr.hd.num_faces = tole32(1);            // num faces in cubemap; >= 1
		pvr.hd.num_mipmaps = tole32(1);          // num levels of mipmaps; >= 1
		pvr.hd.metadata_size = tole32(0);        // length of following header
		if( devel ) pvr.debug(std::cout);

		out.resize( sizeof(pvr3::header) + reserved );
		memcpy( &out[0], &pvr.hd, sizeof(pvr.hd) );
		return true;
	}
	return out.clear(), false;
}

template<int version>
bool save_pvr( std::string &out, const stream &sm, unsigned reserved = 0 ) {
	if( sm.is_valid() /* && sm.is_etc1() */ ) {
		pvr2 pvr = {};

		int32_t sizeofheader = version <= 1 ? 44 : 52, bpp = sm.comp * 8;
		pvr.hd.version = tole32(sizeofheader);          // 44 for v1, 52 for v2
		pvr.hd.height = tole32(sm.h);                   // 1d texture
		pvr.hd.width = tole32(sm.w);                    // 2d texture; >= 1

		pvr.hd.num_mipmaps = tole32(0);                 // num levels of mipmaps, excluding the top level (mipmap flag should be set if >= 1)
		pvr.hd.pixel_format = sm.fmt;                   // see pvr2::table1 above // OGL_PVRTC4;
		switch( pvr.hd.pixel_format ) {                 // convert pvr3 to pvr1/2 pixel format
		  default:
		  break; case pvr3::table1::SPOT_RGB888:     bpp = 24, pvr.hd.pixel_format = OGL_RGB_888;
		  break; case pvr3::table1::SPOT_RGBA8888:   bpp = 32, pvr.hd.pixel_format = OGL_RGBA_8888;
		  break; case pvr3::table1::PVRTC_2BPP_RGB:  bpp = 2, pvr.hd.pixel_format = OGL_PVRTC2; // MGLPT_PVRTC2;
		  break; case pvr3::table1::PVRTC_2BPP_RGBA: bpp = 2, pvr.hd.pixel_format = OGL_PVRTC2; // MGLPT_PVRTC2;
		  break; case pvr3::table1::PVRTC_4BPP_RGB:  bpp = 4, pvr.hd.pixel_format = OGL_PVRTC4; // MGLPT_PVRTC4;
		  break; case pvr3::table1::PVRTC_4BPP_RGBA: bpp = 4, pvr.hd.pixel_format = OGL_PVRTC4; // MGLPT_PVRTC4;
		  //break; case pvr3::table1::PVRTC_II_2BPP: pvr.hd.pixel_format = MGLPT_PVRTC2_2;
		  //break; case pvr3::table1::PVRTC_II_4BPP: pvr.hd.pixel_format = MGLPT_PVRTC2_4;
		}
		pvr.hd.flags[0] = sm.comp > 3 ? 0x80 : 0x00;    // alpha channel present
		pvr.hd.flags[1] = 0x00;
		pvr.hd.flags[2] = 0x00;

		pvr.hd.surface_size = tole32(sm.w*sm.h*(bpp+7)/8);// in bytes
		pvr.hd.bpp = tole32(bpp);                       // 32 bpp

		pvr.hd.r_mask = tole32(0x00000000);             // for<=32bpp: 0xff00000 in Red Mask would indicate that the last 8 bits in each pixel are used as red.
		pvr.hd.g_mask = tole32(0x00000000);             // for<=32bpp: 0xff00000 in Green Mask would indicate that the last 8 bits in each pixel are used as green.
		pvr.hd.b_mask = tole32(0x00000000);             // for<=32bpp: 0x00000ff in Blue Mask would indicate that the first 8 bits in each pixel are used as blue.
		pvr.hd.a_mask = tole32(0x00000000);             // for<=32bpp: 0x00000ff in Alpha Mask would indicate that the first 8 bits in each pixel are used as alpha.

		pvr.hd.magic = tole32(0x21525650);              // "PVR!"
		pvr.hd.num_surfaces = tole32(1);                // num surfaces in texture array; >= 1
		if( devel ) pvr.debug(std::cout);

		out.resize( sizeofheader + reserved );
		memcpy( &out[0], &pvr.hd, sizeofheader );
		return true;
	}
	return out.clear(), false;
}

bool save_ktx( std::string &out, const stream &sm, unsigned reserved = 0 ) {
	if( sm.is_valid() ) {
		ktx k;
		auto &hd = k.hd;
		hd.identifier0 = tole32(0x58544bab);
		hd.identifier1 = tole32(0xbb313120);
		hd.identifier2 = tole32(0xa1a0a0d);
		hd.endianness = tole32(0x4030201);
		hd.glType = tole32(0x0); // table 8.2 of opengl 4.4 spec; UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5, etc.)
		hd.glTypeSize = tole32(0x1); // 1 for compressed data
		hd.glFormat = tole32(0x0); // table 8.3 of opengl 4.4 spec; RGB, RGBA, BGRA...
		// glInternalFormat:     table 8.14 of opengl 4.4 spec; ETC1_RGB8_OES (0x8D64)
		// glBaseInternalFormat: table 8.11 of opengl 4.4 spec; GL_RGB (0x1907), RGBA, ALPHA...
		/**/ if( sm.fmt == pvr3::table1::ETC1 )            { hd.glInternalFormat = tole32(0x8d64), hd.glBaseInternalFormat = tole32(0x1907); }
		else if( sm.fmt == pvr3::table1::PVRTC_2BPP_RGB )  { hd.glInternalFormat = tole32(0x8c01), hd.glBaseInternalFormat = tole32(0x1907); }
		else if( sm.fmt == pvr3::table1::PVRTC_2BPP_RGBA ) { hd.glInternalFormat = tole32(0x8c03), hd.glBaseInternalFormat = tole32(0x1908); }
		else if( sm.fmt == pvr3::table1::PVRTC_4BPP_RGB )  { hd.glInternalFormat = tole32(0x8c00), hd.glBaseInternalFormat = tole32(0x1907); }
		else if( sm.fmt == pvr3::table1::PVRTC_4BPP_RGBA ) { hd.glInternalFormat = tole32(0x8c02), hd.glBaseInternalFormat = tole32(0x1908); }
		else return false;
		hd.pixelWidth = tole32(sm.w);
		hd.pixelHeight = tole32(sm.h);
		hd.pixelDepth = tole32(0);
		hd.numberOfArrayElements = tole32(0);
		hd.numberOfFaces = tole32(1);
		hd.numberOfMipmapLevels = tole32(1);
		hd.bytesOfKeyValueData = tole32(0);
		if( devel ) k.debug(std::cout);

		out.resize( sizeof(ktx::header) + reserved );
		memcpy( &out[0], &k.hd, sizeof(ktx::header) );
		return true;
	}
	return out.clear(), false;
}

std::string save_pvr3( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_pvr3( out, sm, reserved ) ? out : std::string();
}
std::string save_pvr2( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_pvr<2>( out, sm, reserved ) ? out : std::string();
}
std::string save_pvr1( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_pvr<1>( out, sm, reserved ) ? out : std::string();
}
std::string save_ktx( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_ktx( out, sm, reserved ) ? out : std::string();
}
std::string save_pkm_etc1( const stream &sm, unsigned reserved = 0 ) {
	std::string out;
	return save_pkm_etc1( out, sm, reserved ) ? out : std::string();
}

}

/*
@todo:
.pvr3
	for each MIP-Map Level in MIP-Map Count {
		for each Surface in Num. Surfaces {
			for each Face in Num. Faces {
				for each Slice in Depth {
					for each Row in Height {
						for each Pixel in Width {
							Byte data[Size_Based_On_PixelFormat]
	}}}}}

.ktx
	[header]

	for each keyValuePair that fits in bytesOfKeyValueData
		uint32_t   keyAndValueByteSize
		uint8_t    keyAndValue[keyAndValueByteSize]
		uint8_t    valuePadding[3 - ((keyAndValueByteSize + 3) % 4)]
	end

	for each mipmap_level in numberOfMipmapLevels* {
		uint32_t imageSize;
		for each array_element in numberOfArrayElements* {
		   for each face in numberOfFaces {
			   for each z_slice in pixelDepth* {
				   for each row or row_of_blocks in pixelHeight* {
					   for each pixel or block_of_pixels in pixelWidth {
						   uint8_t data[format-specific-number-of-bytes]**
					   }
				   }
			   }
			   uint8_t cubePadding[0-3]
		   }
		}
		uint8_t mipPadding[3 - ((imageSize + 3) % 4)]
	}

	* Replace with 1 if this field is 0.
	** Uncompressed texture data matches a GL_UNPACK_ALIGNMENT of 4.
*/

namespace spot
{
	namespace internals {

		std::string encode_png( unsigned w, unsigned h, const void *data, unsigned stride ) {
			if( w && h && data && stride ) {
				auto mode = LCT_RGBA;
				/**/ if( stride == 3 ) mode = LCT_RGB;
				else if( stride == 2 ) mode = LCT_GREY_ALPHA;
				else if( stride == 1 ) mode = LCT_GREY;
				unsigned char* png;
				size_t pngsize;
				unsigned bpp = 8;
				unsigned error = lodepng_encode_memory_std( &png, &pngsize, (const unsigned char *)data, w, h, mode, bpp );
				if( !error && pngsize ) {
					std::string buf;
					buf.resize(pngsize);
					memcpy(&buf[0],png,pngsize);
					free(png);
					return buf;
				}
			}
			return std::string();
		}

		std::string encode_jpg( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				std::string buf( 1024 + w * h * 3, '\0' );
				jpge::params p;
				p.m_quality = (int)quality;
				p.m_two_pass_flag = true; // slower but slighty smaller
				int buf_size = (int)buf.size();
				if( jpge::compress_image_to_jpeg_file_in_memory(&buf[0], buf_size, w, h, 4, (const jpge::uint8 *)data, p) ) {
					if( buf_size > 0 ) {
						buf.resize((unsigned)(buf_size));
						return buf;
					}
				}
			}
			return std::string();
		}

		std::string encode_wbp( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				unsigned char *buf = 0;
				size_t buflen = WebPEncodeRGBA( (const unsigned char *)data, w, h, w * 4, quality, &buf );
				if( buflen && buf ) {
					std::string s;
					s.resize(buflen);
					memcpy(&s[0],buf,buflen);
					free(buf);
					return s;
				}
			}
			return std::string();
		}

		std::string encode_pug( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				// encode color as jpg
				std::string jpg = encode_jpg( w, h, data, quality );
				// encode alpha as png (gray, lum8)
				std::vector<unsigned char> alpha( w * h );
				unsigned char *ptr = ((unsigned char *)data) + 3;
				for( unsigned x = 0; x < w * h; ++x, ptr += 4 ) alpha[ x ] = *ptr;
				std::string png = encode_png( w, h, alpha.data(), 1 );
				// glue and footer
				int32_t size24 = hton32( int32_t(jpg.size()) );
				int32_t size08 = hton32( int32_t(png.size()) );
				if( size24 && size08 ) {
					std::stringstream ss;
					ss.write( &jpg[0], size24 );
					ss.write( &png[0], size08 );
					ss.write( (const char *)&size24, 4 );
					ss.write( (const char *)&size08, 4 );
					ss.write( "pug1", 4 );
					if( ss.good() ) {
						return ss.str();
					}
				}
			}
			return std::string();
		}

		std::string encode_ktx( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				stream sm = encode_as_etc1( data, w, h, 32, quality );
				std::stringstream ss;
				ss << save_ktx(sm);
				uint32_t len32( sm.len );
				ss.write( (const char *)&len32, 4 );
				ss.write( (const char *)sm.in, sm.len );
				delete [] ((uint8_t *)sm.out);
				return ss.str();
			}
			return std::string();
		}

		std::string encode_pvr3( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				//stream sm = encode_as_etc1( data, w, h, 32, quality );
				stream sm = encode_as_pvrtc( data, w, h, 32, quality );
				std::stringstream ss;
				ss << save_pvr3(sm);
				ss.write( (const char *)sm.in, sm.len );
				delete [] ((uint8_t *)sm.out);
				return ss.str();
			}
			return std::string();
		}

		std::string encode_pvr2(unsigned w, unsigned h, const void *data, unsigned quality) {
			if (w && h && data && quality) {
				stream sm = /*quality < 100 ? */ encode_as_pvrtc( data, w, h, 32, quality )
				  /*: encode_as_rgba( data, w, h, 32, quality )*/;
				std::stringstream ss;
				ss << save_pvr2(sm);
				ss.write((const char *)sm.in, sm.len);
				delete [] ((uint8_t *)sm.out);
				return ss.str();
			}
			return std::string();
		}

		std::string encode_pvr( unsigned w, unsigned h, const void *data, unsigned quality ) {
			return encode_pvr3( w, h, data, quality );
		}

		std::string encode_ccz( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				std::string pvr2 = encode_pvr2(w, h, data, quality);
				if( pvr2.empty() ) {
					return std::string();
				}

				using namespace miniz; // from tinyexr
				std::vector<unsigned char> buf( mz_compressBound(pvr2.size()) );
				mz_ulong zlen = (mz_ulong)( buf.size() );
				if( MZ_OK != mz_compress2( (unsigned char *)&buf[0], &zlen, (const unsigned char *)&pvr2[0], (mz_ulong)pvr2.size(), 9 ) ) {
					return std::string();
				}

				std::stringstream ss;
				int16_t typ = hton16(0), ver = hton16(2);
				int32_t pad = 0, len = hton32( (uint32_t)pvr2.size() );
				ss.write("CCZ!", 4);
				ss.write((const char *) &typ, 2); // compression type (0=zlib)
				ss.write((const char *) &ver, 2); // version
				ss.write((const char *) &pad, 4); // reserved
				ss.write((const char *) &len, 4); // original stream size
				ss.write((const char *) &buf[0], zlen); // compressed stream

				return ss.str();
			}
			return std::string();
		}

		std::string encode_pkm( unsigned w, unsigned h, const void *data, unsigned quality ) {
			if( w && h && data && quality ) {
				stream sm = encode_as_etc1( data, w, h, 32, quality );
				std::stringstream ss;
				ss << save_pkm_etc1(sm);
				ss.write( (const char *)sm.in, sm.len );
				delete [] ((uint8_t *)sm.out);
				return ss.str();
			}
			return std::string();
		}

		/*
			transcoding
			===========

			std::cout << "fast: " << bench([&]{ encode_as_etc1( img.rgba32().data(), img.w, img.h, 32, SPOT_ETC1_LOW );} ) << std::endl;
			std::cout << "medium: " << bench([&]{ encode_as_etc1( img.rgba32().data(), img.w, img.h, 32, SPOT_ETC1_MEDIUM );} ) << std::endl;
			//std::cout << "high: " << bench([&]{ encode_as_etc1( img.rgba32().data(), img.w, img.h, 32, SPOT_ETC1_HIGH );} ) << std::endl;

			if( k.is_currently_supported() ) {
				auto header = save_pkm_etc1( stream { k.hd.pixelWidth, k.hd.pixelHeight, pvr3::table1::ETC1 } );
				buffer = buffer + sizeof(k.hd) + 4 - header.size();
				uint32_t len = tole32( uint32_t( header.size() ) );
				memcpy( &data[buffer - 4], &len, 4 );
				memcpy( &data[buffer], &header[0], header.size() );

				preload(pk, &data[buffer], data.size() - buffer );
				pk.debug( std::cout );
			}
			if( p.is_currently_supported() ) {
				auto header = save_pkm_etc1( stream { p.hd.width, p.hd.height, pvr3::table1::ETC1 } );
				buffer = buffer + sizeof(p.hd) - header.size();
				memcpy( &data[buffer], &header[0], header.size() );

				preload(pk, &data[buffer], data.size() - buffer );
				pk.debug( std::cout );
			}
			if( pk.is_currently_supported() ) {
				const stbi_uc *rgba = decode_etc1_stream( &data[buffer+sizeof(pkm::header)], data.size(), pk.hd.width, pk.hd.height, 3, &zlen);
				spot::texture tx( rgba, zlen, pk.hd.width, pk.hd.height );
				spot::image img = tx;
				display( img );
			}
		}
		*/

		bool writefile( const std::string &filename, const std::string &data ) {
			if( !data.empty() ) {
				std::ofstream ofs( filename.c_str(), std::ios::binary );
				ofs.write( &data[0], data.size() );
				return ofs.good();
			}
			return false;
		}
	}

	void hsl2rgb( const float *hsl, float *rgb )
	{
		// Given H,S,L in range of 0-1
		// Returns a Color (RGB struct) in range of 0-1

		const float &h = hsl[0];
		const float &s = hsl[1];
		const float &l = hsl[2];

		float &r = rgb[0];
		float &g = rgb[1];
		float &b = rgb[2];

		float v;

		r = l;   // default to gray
		g = l;
		b = l;
		v = (l <= 0.5f) ? (l * (1.f + s)) : (l + s - l * s);

		if (v > 0)
		{
			  float m = l + l - v;
			  float sv = (v - m ) / v;
			  float h6 = h * 6.f;
			  int sextant = (int)h6;
			  float fract = h6 - sextant;
			  float vsf = v * sv * fract;
			  float mid1 = m + vsf;
			  float mid2 = v - vsf;

			  switch (sextant)
			  {
					default:
					case 0:
						  r = v;
						  g = mid1;
						  b = m;
						  break;
					case 1:
						  r = mid2;
						  g = v;
						  b = m;
						  break;
					case 2:
						  r = m;
						  g = v;
						  b = mid1;
						  break;
					case 3:
						  r = m;
						  g = mid2;
						  b = v;
						  break;
					case 4:
						  r = mid1;
						  g = m;
						  b = v;
						  break;
					case 5:
						  r = v;
						  g = m;
						  b = mid2;
						  break;
			  }
		}
	}

	template<bool rgba, bool hsla>
	void rgb2hsl( const float *rgb, float *hsl, int pixels )
	{
		// Given a Color (RGB Struct) in range of 0-1
		// Return H,S,L in range of 0-1

		while( --pixels >= 0 ) {
			const float &r = *rgb++;
			const float &g = *rgb++;
			const float &b = *rgb++;
			float v;
			float m;
			float vm;
			float r2, g2, b2;

			float h = 0; // default to black
			float s = 0;
			float l;
			v = ( r > g ? r : g );
			v = ( v > b ? v : b );
			m = ( r < g ? r : g );
			m = ( m < b ? m : b );
			l = (m + v) / 2.f;
			if (l > 0.f) {
				vm = v - m;
				s = vm;
				if (s > 0.f) {
					s /= (l <= 0.5f) ? (v + m ) : (2.f - v - m) ;
					r2 = (v - r) / vm;
					g2 = (v - g) / vm;
					b2 = (v - b) / vm;
					/**/ if (r == v) {
						h = (g == m ? 5.f + b2 : 1.f - g2);
					}
					else if (g == v) {
						h = (b == m ? 1.f + r2 : 3.f - b2);
					}
					else {
						h = (r == m ? 3.f + g2 : 5.f - r2);
					}
					h /= 6.f;
				}
			}
			*hsl++ = h;
			*hsl++ = s;
			*hsl++ = l;
			if( hsla ) {
				if( rgba ) {
					*hsl++ = *rgb++;
				} else {
					*hsl++ = 1;
				}
			} else {
				if( rgba ) {
					rgb++;
				}
			}
		}
	}

	void rgb2hsl( const float *rgb, float *hsl ) {
		rgb2hsl<0,0>( rgb, hsl, 1 );
	}

	std::vector<std::string> list_supported_inputs() {
		const char *str[] = { "bmp", "dds", "gif", "hdr", "jpg", "pic", "pkm", "png", "psd", "pvr", "ccz", "svg", "tga", "webp", "pnm", "pug", "crn", "exr", "flif", 0 };
		std::vector<std::string> list;
		for( int i = 0; str[i]; ++i ) {
			list.push_back( str[i] );
		}
		return list;
	}
	std::vector<std::string> list_supported_outputs() {
		const char *str[] = { "bmp", "dds", "jpg", "png", "tga", "webp", "pug", "ktx", "pvr", "ccz", "pkm", 0 };
		std::vector<std::string> list;
		for( int i = 0; str[i]; ++i ) {
			list.push_back( str[i] );
		}
		return list;
	}

	enum { NO_DELETER, STBI_DELETER, FREE_DELETER, NEW_DELETER, NEW_ARRAY_DELETER, FLIF_DELETER };
	enum { UNK, IS_STBI, IS_CRN, IS_WEBP, IS_SVG, IS_KTX, IS_PVR3, IS_CCZ, IS_PKM, IS_EXR, IS_FLIF };

	bool info( stream &sm, const void *src, size_t len ) {
		stream blank = {};
		sm = blank;
		sm.in = src;
		sm.len = len;

		if( !src ) return false;
		if( !len ) return false;

		const char *src8 = (const char *)src;

		// flif?
		bool is_flif = len > 4 && (src8[0] == 'F' && src8[1] == 'L' && src8[2] == 'I' && src8[3] == 'F');
		if( is_flif ) {
			sm.w = (( src8[0x6] << 8) | src8[0x7] );
			sm.h = (( src8[0x8] << 8) | src8[0x9] );
			sm.comp = 4;
			sm.hint = IS_FLIF;
			sm.deleter = FLIF_DELETER;
			return true;
		}

		// crn?
		bool is_crn = len > 2 && (src8[0] == 'H' && src8[1] == 'x');
		if( is_crn ) {
			sm.w = (( src8[0xC] << 8) | src8[0xD] );
			sm.h = (( src8[0xE] << 8) | src8[0xF] );
			sm.comp = 4;
			sm.hint = IS_CRN;
			sm.deleter = STBI_DELETER;
			return true;
		}

		// ccz?
		bool is_ccz = len > 4 && (src8[0] == 'C' && src8[1] == 'C' && src8[2] == 'Z' && src8[3] == '!');
		if( is_ccz ) {
			uint32_t len = (uint32_t)ntoh32( *(uint32_t *)(&src8[16-4]) );
			sm.h = 1;
			sm.w = len * 4; // assumes pvrt4, give a rough estimation :(
			sm.fmt = -1;
			sm.comp = 4;
			sm.hint = IS_CCZ;
			return true;
		}

		// pkm? (etc1)
		{
			pkm f;
			preload( f, src, len );
			if( devel ) f.debug( std::cout );
			if( f.is_currently_supported() ) {
				sm.w = int(f.hd.width);
				sm.h = int(f.hd.height);
				sm.fmt = f.get_spot_fmt();
				sm.comp = 3;
				sm.hint = IS_PKM;
				return true;
			}
		}

		// ktx? (etc1)
		{
			ktx f;
			preload( f, src, len );
			if( devel ) f.debug( std::cout );
			if( f.is_currently_supported() ) {
				sm.w = int(f.hd.pixelWidth);
				sm.h = int(f.hd.pixelHeight);
				sm.fmt = f.get_spot_fmt();
				sm.comp = 3;
				sm.hint = IS_KTX;
				return true;
			}
		}

		// pvr3? (etc1)
		{
			pvr3 f;
			preload( f, src, len );
			if( devel ) f.debug( std::cout );
			if( f.is_currently_supported() ) {
				sm.w = int(f.hd.width);
				sm.h = int(f.hd.height);
				sm.fmt = f.get_spot_fmt();
				sm.comp = 3;
				sm.hint = IS_PVR3;
				return true;
			}
		}

		// pvr2 ?
		int iscompressed = false;
		int ok = stbi__pvr_info_from_memory( (stbi_uc const *)src, int(len), &sm.w, &sm.h, &sm.comp, &iscompressed );
		if( ok ) {
			return sm.hint = IS_STBI, sm.deleter = STBI_DELETER, true;
		}

		// dds ?
		ok = stbi__dds_info_from_memory( (stbi_uc const *)src, int(len), &sm.w, &sm.h, &sm.comp, &iscompressed );
		if( ok ) {
			return sm.hint = IS_STBI, sm.deleter = STBI_DELETER, true;
		}

		// try most
		ok = stbi_info_from_memory( (stbi_uc const *)src, int(len), &sm.w, &sm.h, &sm.comp );
		if( ok ) {
			// pug?
			const char *magic = (const char *)src + len - 4;
			if( magic[0] == 'p' && magic[1] == 'u' && magic[2] == 'g' && magic[3] == '1' ) sm.comp = 4;

			return sm.hint = IS_STBI, sm.deleter = STBI_DELETER, true;
		}

		// webp ?
		ok = 0 != WebPGetInfo( (const uint8_t *)src, len, &sm.w, &sm.h );
		if( ok ) return sm.hint = IS_WEBP, sm.deleter = FREE_DELETER, sm.comp = 4, true;

		// svg ?
		if( src8[0] == '<' || src8[0] == ' ' || src8[0] == '\t' ) {
			// Load SVG, parse and rasterize
			std::vector<char> str( len + 1 );
			memcpy( &str[0], src, len );
			str[ len ] = '\0';

			NSVGimage *image = nsvgParse( &str[0], "px" /*units*/, 96.f /* dpi */ );
			if( image ) {
				double scale = 1.0;
				sm.hint = IS_SVG;
				sm.w = int(image->width * scale);
				sm.h = int(image->height * scale);
				sm.comp = 4;

				nsvgDelete(image);
				return sm.deleter = FREE_DELETER, true;
			}
		}

		return false;
	}

	bool infof( stream &sm, const void *src, size_t len ) {
		stream blank = {};
		sm = blank;
		sm.in = src;
		sm.len = len;

		if( !src ) return false;
		if( !len ) return false;

		const char *src8 = (const char *)src;

		// exr?
		if( 1 ) {
			EXRImage exrImage;
			InitEXRImage(&exrImage);
			const char *err = 0;

			int ret = ParseMultiChannelEXRHeaderFromMemory(&exrImage, (const unsigned char *)src8, &err);
			if (ret == 0) {
				sm.w = exrImage.width;
				sm.h = exrImage.height;
				sm.comp = exrImage.num_channels;
				sm.hint = IS_EXR;
				sm.deleter = STBI_DELETER;
				FreeEXRImage(&exrImage);
				return true;
			}

			FreeEXRImage(&exrImage);
		}

		return false;
	}

	bool decode( stream &dst, const stream &src )
	{
		if( !src.in || !dst.out ) {
			dst.error = "Error: invalid pointer provided";
			return false;
		}

		if( !src.len || !dst.len ) {
			dst.error = "Error: invalid size provided";
			return false;
		}

		// decode
		int imageWidth = 0, imageHeight = 0, imageComp = 0, imageHint = 0;
		int deleter = NO_DELETER;
		int copier = 1;

		if( !src.hint ) {
			if( !info( dst, src.in, src.len ) ) {
				return false;
			}
		}

		imageWidth = src.w;
		imageHeight = src.h;
		imageComp = src.comp;
		imageHint = src.hint;

		stbi_uc *imageuc = 0;

		switch( imageHint ) {
		default:
		break;
		case IS_FLIF: {
			int64_t bytes_read = -1;
			int32_t quality = 100;
			const char *ptr = (const char *) src.in;
			size_t len = src.len;

			FLIF_DECODER* d = NULL;
			d = flif_create_decoder();
			if (d) {
				// set the quality to 100% (a lower value will decode a lower-quality preview)
				flif_decoder_set_quality(d, 100);             // this is the default, so can be omitted
				// set the scale-down factor to 1 (a higher value will decode a downsampled preview)
				flif_decoder_set_scale(d, 1);                 // this is the default, so can be omitted
				// set the maximum size to twice the screen resolution; if an image is larger, a downsampled preview will be decoded
				//flif_decoder_set_resize(d, 100, 200);   // the default is to not have a maximum size
				if (flif_decoder_decode_memory(d, ptr, len)) {
					// no callback was set, so we manually call our callback function to render the final image/frames
					//printf("%lli bytes read, rendering at quality=%.2f%%\n",(long long int) bytes_read, 0.01*quality);

					FLIF_IMAGE* image = flif_decoder_get_image(d, 0);
					if (image) {
						uint32_t nb_frames = flif_decoder_num_images(d);
						uint32_t w = flif_image_get_width(image);
						uint32_t h = flif_image_get_height(image);
						uint32_t bpp = flif_image_get_nb_channels(image);

						imageuc = (unsigned char *)malloc( imageWidth * imageHeight * imageComp );
						if(imageuc) {
							unsigned char *out = imageuc;

							// Produce a texture
							for (int f = 0; f < nb_frames; f++) {
								FLIF_IMAGE* image = flif_decoder_get_image(d, f);
								if (image) {
									uint32_t w = flif_image_get_width(image);
									uint32_t h = flif_image_get_height(image);
									uint32_t bpp = flif_image_get_nb_channels(image);
									int frame_delay = flif_image_get_frame_delay(image);

									// Copy the decoded pixels into texture
									flif_RGBA *row = new flif_RGBA [w];
									for (uint32_t r=0; r<h; r++) {
										flif_image_read_row_RGBA8(image, r, row, w * sizeof(flif_RGBA));
										for(uint32_t x=0; x<w; ++x) {
											auto &px = row[x];
											*out++ = px.r;
											*out++ = px.g;
											*out++ = px.b;
											*out++ = px.a;
										}
									}
									delete [] row;
								}
							}
						}
					}
				}
				flif_destroy_decoder(d);
			}
		}
		break;
		case IS_CRN :{
			std::string dds;
			if( crn2dds( dds, src.in, src.len ) ) {
				imageuc = stbi_load_from_memory( (const unsigned char *)&dds[0], dds.size(), &imageWidth, &imageHeight, &imageComp, 4 );
				deleter = STBI_DELETER;
				imageComp = 4;
			}
		}
		break;
		case IS_PKM :{
			unsigned int zlen;
			const stbi_uc *data = (const stbi_uc *)src.in;
			size_t offset = sizeof(pkm::header);
			imageuc = decode_etc1_stream( &data[offset], src.len - offset, imageWidth, imageHeight, &zlen);
			deleter = FREE_DELETER;
			imageComp = 3;
		}
		break;
		case IS_KTX :{
			unsigned int zlen;
			const stbi_uc *data = (const stbi_uc *)src.in;
			size_t offset = sizeof(ktx::header) + ((ktx::header *)src.in)->bytesOfKeyValueData + 4;
			/****/ if( src.fmt == pvr3::table1::ETC1 ) {
				imageuc = decode_etc1_stream( &data[offset], src.len - offset, imageWidth, imageHeight, &zlen);
				imageComp = 3;
			} else if( src.fmt <= pvr3::table1::PVRTC_4BPP_RGBA ) {
				imageuc = decode_pvrtc_stream( &data[offset], src.len - offset, imageWidth, imageHeight, src.fmt, &zlen);
				imageComp = (src.fmt == pvr3::table1::PVRTC_2BPP_RGBA || pvr3::table1::PVRTC_4BPP_RGBA) ? 4 : 3;
			}
			deleter = FREE_DELETER;
		}
		break;
		case IS_PVR3: {
			unsigned int zlen;
			const stbi_uc *data = (const stbi_uc *)src.in;
			size_t offset = sizeof(pvr3::header) + ((pvr3::header *)src.in)->metadata_size;
			/****/ if( src.fmt == pvr3::table1::ETC1 ) {
				imageuc = decode_etc1_stream( &data[offset], src.len - offset, imageWidth, imageHeight, &zlen);
				imageComp = 3;
			} else if( src.fmt <= pvr3::table1::PVRTC_4BPP_RGBA ) {
				imageuc = decode_pvrtc_stream( &data[offset], src.len - offset, imageWidth, imageHeight, src.fmt, &zlen);
				imageComp = (src.fmt == pvr3::table1::PVRTC_2BPP_RGBA || pvr3::table1::PVRTC_4BPP_RGBA) ? 4 : 3;
			}
			deleter = FREE_DELETER;
		}
		break;
		case IS_CCZ: {
			using namespace miniz;
			const unsigned char *src8 = (const unsigned char *)src.in;
			mz_ulong len = (mz_ulong)ntoh32( *(uint32_t *)(&src8[16-4]) );
			std::vector<unsigned char> ptr( len );
			if( MZ_OK == mz_uncompress( &ptr[0], &len, &src8[16], src.len - 16 ) ) {
				stream in2 = {};
				if( info( in2, &ptr[0], len ) ) {
					if( in2.is_valid() ) {
						return decode( dst, (const stream &)in2 );
					}
				}
			}
			return false;
		}
		break;
		case IS_STBI: {
			imageuc = stbi_load_from_memory( (const stbi_uc *)src.in, src.len, &imageWidth, &imageHeight, &imageComp, src.comp < 3 ? 3 : src.comp );
			imageComp = src.comp < 3 ? 3 : src.comp;

			deleter = STBI_DELETER;
			// if it is a .pug file, then decode alpha
			const char *magic = (const char *)src.in + src.len - 4;
			if( magic[0] == 'p' && magic[1] == 'u' && magic[2] == 'g' && magic[3] == '1' ) {
				imageComp = 4;
				const int32_t color_size = ntoh32( *(const int32_t *)((const char *)src.in + src.len - 12) );
				const int32_t alpha_size = ntoh32( *(const int32_t *)((const char *)src.in + src.len - 8) );
				int w2 = 0, h2 = 0, bpp2 = 0;
				stbi_uc *alpha = stbi_load_from_memory( (const unsigned char *)src.in + color_size, alpha_size, &w2, &h2, &bpp2, 1 );
				if( alpha ) {
					stbi_uc *data8 = &alpha[ 0 ], *end8 = &alpha[ w2*h2 ], *dst8 = &imageuc[ 3 ];
					while( data8 < end8 ) {
						*dst8 = *data8++;
						dst8 += 4;
					}
					stbi_image_free( alpha );
				}
			}
		}
		break;
		case IS_WEBP: {
			imageuc = (stbi_uc *) WebPDecodeRGBA( (const uint8_t *)src.in, src.len, &imageWidth, &imageHeight );
			deleter = FREE_DELETER;
			imageComp = 4;
		}
		break;
		case IS_SVG :{
			// Load SVG, parse and rasterize
			std::vector<char> str( src.len + 1 );
			memcpy( &str[0], src.in, src.len );
			str[ src.len ] = '\0';

			NSVGimage *image = nsvgParse( &str[0], "px" /*units*/, 96.f /* dpi */ );
			if( image ) {
				// Create rasterizer (can be used to render multiple images).
				static struct install {
					NSVGrasterizer *rasterizer;
					 install() { rasterizer = nsvgCreateRasterizer(); }
					~install() { if( rasterizer ) nsvgDeleteRasterizer( rasterizer ); rasterizer = 0; }
				} local;
				// Allocate memory for image
				int w = image->width;
				int h = image->height;

				imageuc = (stbi_uc *)malloc(w*h*4); //imageWidth*imageHeight*4
				deleter = FREE_DELETER;
				if( imageuc ) {
					// Rasterizes SVG image, returns RGBA image (non-premultiplied alpha)
					//   r - pointer to rasterizer context
					//   image - pointer to image to rasterize
					//   tx,ty - image offset (applied after scaling)
					//   scale - image scale
					//   dst - pointer to destination image data, 4 bytes per pixel (RGBA)
					//   w - width of the image to render
					//   h - height of the image to render
					//   stride - number of bytes per scaleline in the destination buffer
					double scale = 1.0;
					nsvgRasterize( local.rasterizer, image, 0,0,scale, imageuc, w, h, w*scale*4 );
				}
				nsvgDelete(image);
			}
		}
		};

		if( !imageuc )
		{
			// assert( false );
			// return yellow/black texture instead?
			dst.error = "Error! unable to decode image";
			return false;
		}

		if( copier ) {
			memcpy( dst.out, imageuc, imageWidth * imageHeight * imageComp ); //dst.len );
		}

		/****/ if( deleter == STBI_DELETER ) {
			stbi_image_free( imageuc );
		} else if( deleter == FREE_DELETER ) {
			free(imageuc);
		} else if( deleter == NEW_DELETER ) {
			delete imageuc;
		} else if( deleter == NEW_ARRAY_DELETER ) {
			delete [] (imageuc);
		}
		imageuc = 0;

		dst.w = imageWidth;
		dst.h = imageHeight;
		dst.d = 1;
		dst.comp = imageComp;
		dst.fmt = RGBA_8888;

		return true;
	}

	bool decodef( stream &dst, const stream &src )
	{
		if( !src.in || !dst.out ) {
			dst.error = "Error: invalid pointer provided";
			return false;
		}

		if( !src.len || !dst.len ) {
			dst.error = "Error: invalid size provided";
			return false;
		}

		// decode
		int imageWidth = 0, imageHeight = 0, imageComp = 0, imageHint = 0;
		int deleter = NO_DELETER;
		int copier = 1;

		if( !src.hint ) {
			if( !infof( dst, src.in, src.len ) ) {
				return false;
			}
		}

		imageWidth = src.w;
		imageHeight = src.h;
		imageComp = src.comp;
		imageHint = src.hint;

		float *imageuc = 0;

		switch( imageHint ) {
		default:
		break;
		case IS_EXR: {

				EXRImage exrImage;
				InitEXRImage(&exrImage);
				const char *err = 0;

				{
					int ret = ParseMultiChannelEXRHeaderFromMemory(&exrImage, (const unsigned char *)src.in, &err);
					if (ret != 0) {
						if( err ) dst.error = err;
					  break;
					}
				}

				// Read HALF channel as FLOAT.
				for (int i = 0; i < exrImage.num_channels; i++) {
					if (exrImage.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) {
						exrImage.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT;
					}
				}

				{
					int ret = LoadMultiChannelEXRFromMemory(&exrImage, (const unsigned char *)src.in, &err);
					if (ret != 0) {
						if( err ) dst.error = err;
						break;
					}
				}

				// RGBA
				int idxR = -1;
				int idxG = -1;
				int idxB = -1;
				int idxA = -1;
				for (int c = 0; c < exrImage.num_channels; c++) {
					/**/ if ('R' == exrImage.channel_names[c][0]) idxR = c;
					else if ('G' == exrImage.channel_names[c][0]) idxG = c;
					else if ('B' == exrImage.channel_names[c][0]) idxB = c;
					else if ('A' == exrImage.channel_names[c][0]) idxA = c;
				}

				if (idxR == -1) {
					dst.error = "R channel not found\n";
					// @todo { free exrImage }
					break;
				}

				if (idxG == -1) {
					dst.error = "G channel not found\n";
					// @todo { free exrImage }
					break;
				}

				if (idxB == -1) {
					dst.error = "B channel not found\n";
					// @todo { free exrImage }
					break;
				}

				imageuc = (float *)1;
				copier = 0;
				deleter = NO_DELETER;

				float *ptr = (float *)dst.out;
				bool do_rgba = (src.comp < 3 ? 3 : src.comp) > 3;
				float *ch_r = reinterpret_cast<float **>(exrImage.images)[idxR];
				float *ch_g = reinterpret_cast<float **>(exrImage.images)[idxG];
				float *ch_b = reinterpret_cast<float **>(exrImage.images)[idxB];
				float *ch_a = reinterpret_cast<float **>(exrImage.images)[idxA != -1 ? idxA : idxR];
				if( do_rgba ) {
					if (idxA != -1) {
						for (int i = 0; i < exrImage.width * exrImage.height; i++) {
							*ptr++ = ch_r[i];
							*ptr++ = ch_g[i];
							*ptr++ = ch_b[i];
							*ptr++ = ch_a[i];
						}
						rgb2hsl<1,1>( (const float *)dst.out, (float *)dst.out, exrImage.width * exrImage.height );
					} else {
						for (int i = 0; i < exrImage.width * exrImage.height; i++) {
							*ptr++ = ch_r[i];
							*ptr++ = ch_g[i];
							*ptr++ = ch_b[i];
						}
						rgb2hsl<1,0>( (const float *)dst.out, (float *)dst.out, exrImage.width * exrImage.height );
					}
				} else {
						for (int i = 0; i < exrImage.width * exrImage.height; i++) {
							*ptr++ = ch_r[i];
							*ptr++ = ch_g[i];
							*ptr++ = ch_b[i];
						}
						rgb2hsl<0,0>( (const float *)dst.out, (float *)dst.out, exrImage.width * exrImage.height );
				}

				imageWidth = exrImage.width;
				imageHeight = exrImage.height;

				// @todo { free exrImage }
			}

			break;
		};

		if( !imageuc )
		{
			// assert( false );
			// return yellow/black texture instead?
			dst.error = "Error! unable to decode image";
			return false;
		}

		if( copier ) {
			memcpy( dst.out, imageuc, imageWidth * imageHeight * imageComp * sizeof(float) );
		}

		/****/ if( deleter == STBI_DELETER ) {
			stbi_image_free( imageuc );
		} else if( deleter == FREE_DELETER ) {
			free(imageuc);
		} else if( deleter == NEW_DELETER ) {
			delete imageuc;
		} else if( deleter == NEW_ARRAY_DELETER ) {
			delete [] (imageuc);
		}
		imageuc = 0;

		dst.w = imageWidth;
		dst.h = imageHeight;
		dst.d = 1;
		dst.comp = imageComp;
		dst.fmt = imageComp > 3 ? RGBA_8888F : RGB_888F;

		return true;
	}

	std::vector<unsigned char> decode8( const void *src, size_t size, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		stream in = {};
		stream out = {};
		if( info( in, src, size ) ) {
			if( in.is_valid() ) {
				std::vector<unsigned char> dst( in.w * in.h * 4 /*srccomp*/ );
				out.out = &dst[0];
				out.len = int(dst.size());
				out.fmt = RGBA_8888;
				if( decode( out, in ) ) {
					if( w     ) *w = size_t(out.w);
					if( h     ) *h = size_t(out.h);
					if( comp  ) *comp = size_t(out.comp);
					if( error ) *error = out.error;
					return dst;
				}
			}
		}
		return std::vector<unsigned char>();
	}

	std::vector<unsigned char> decode8( const std::string &filename, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		std::ifstream ifs( filename.c_str(), std::ios::binary );
		std::vector<char> buffer( (std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
		return decode8( (const unsigned char *)buffer.data(), buffer.size(), w, h, comp, error );
	}

	std::vector<unsigned int> decode32( const void *ptr, size_t size, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		std::vector<unsigned char> decoded = decode8( ptr, size, w, h, comp, error );
		std::vector<unsigned int> out;
		if( !decoded.empty() ) {
			out.reserve( decoded.size() / 4 );
			if( comp && *comp == 3 )
			for( unsigned char *data8 = &decoded[0], *end8 = data8 + decoded.size(); data8 != end8; ) {
				pixel p;
				p.r = *data8++;
				p.g = *data8++;
				p.b = *data8++;
				p.a = 255;
				out.push_back( p.rgba );
			}
			if( comp && *comp == 4 )
			for( unsigned char *data8 = &decoded[0], *end8 = data8 + decoded.size(); data8 != end8; ) {
				pixel p;
				p.r = *data8++;
				p.g = *data8++;
				p.b = *data8++;
				p.a = *data8++;
				out.push_back( p.rgba );
			}
			return out;
		}
		return out;
	}

	std::vector<unsigned int> decode32( const std::string &filename, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		std::ifstream ifs( filename.c_str(), std::ios::binary );
		std::vector<char> buffer( (std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
		return decode32( (const unsigned char *)buffer.data(), buffer.size(), w, h, comp, error );
	}

	std::vector<float> decodef( const void *src, size_t size, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		stream in = {};
		stream out = {};
		if( infof( in, src, size ) ) {
			if( in.is_valid() ) {
				std::vector<float> dst( in.w * in.h * 4 /*srccomp*/ );
				out.out = &dst[0];
				out.len = int(dst.size());
				out.fmt = RGBA_8888F;
				if( decodef( out, in ) ) {
					if( w     ) *w = size_t(out.w);
					if( h     ) *h = size_t(out.h);
					if( comp  ) *comp = size_t(out.comp);
					if( error ) *error = out.error;
					return dst;
				}
			}
		}
		return std::vector<float>();
	}

	std::vector<float> decodef( const std::string &filename, size_t *w, size_t *h, size_t *comp, std::string *error ) {
		std::ifstream ifs( filename.c_str(), std::ios::binary );
		std::vector<char> buffer( (std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
		return decodef( (const float *)buffer.data(), buffer.size(), w, h, comp, error );
	}

	pixel::operator color() const {
		const float inv = 1.f / 255.f;
		pixel c = this->clamp().to_hsla();
		return spot::color(c.r * inv, c.g * inv, c.b * inv, c.a * inv);
	}

	static pixel rgba8888( unsigned char r, unsigned char g, unsigned char b, unsigned char a ) {
		return pixel(r,g,b,a);
	}
	static color rgba8888_alt( unsigned char r, unsigned char g, unsigned char b, unsigned char a ) {
		return pixel(r,g,b,a);
	}

	void texture::print( int x, int y, const char *utf8 ) {
		unifont<pixel> f( &(this->operator[](0)), this->w, &rgba8888 );
		f.render_string( x, y, 0|2, utf8 );
	}
	void image::print( int x, int y, const char *utf8 ) {
		unifont<color> f( &(this->operator[](0)), this->w, &rgba8888_alt );
		f.render_string( x, y, 0|2, utf8 );
	}
}

